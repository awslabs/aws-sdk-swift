// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.ActivateReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A read set activation job filter.
    public struct ActivateReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The filter's status.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A read set activation job.
    public struct ActivateReadSetJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobStatus?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ActivateReadSetSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct ActivateReadSetSourceItem: Swift.Equatable {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetActivationJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?

        public init (
            readSetId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetActivationJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension OmicsClientTypes {
    /// Details about an imported annotation item.
    public struct AnnotationImportItemDetail: Swift.Equatable {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init (
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension OmicsClientTypes {
    /// A source for an annotation import job.
    public struct AnnotationImportItemSource: Swift.Equatable {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init (
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.AnnotationImportJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destinationName
        case id
        case roleArn
        case runLeftNormalization
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if runLeftNormalization != false {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
    }
}

extension OmicsClientTypes {
    /// An annotation import job.
    public struct AnnotationImportJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination annotation store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.AnnotationStoreItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeFormat
        case storeSizeBytes
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storeArn = self.storeArn {
            try encodeContainer.encode(storeArn, forKey: .storeArn)
        }
        if let storeFormat = self.storeFormat {
            try encodeContainer.encode(storeFormat.rawValue, forKey: .storeFormat)
        }
        if let storeSizeBytes = self.storeSizeBytes {
            try encodeContainer.encode(storeSizeBytes, forKey: .storeSizeBytes)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension OmicsClientTypes {
    /// An annotation store.
    public struct AnnotationStoreItem: Swift.Equatable {
        /// The store's creation time.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's file format.
        /// This member is required.
        public var storeFormat: OmicsClientTypes.StoreFormat?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeFormat: OmicsClientTypes.StoreFormat? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeFormat = storeFormat
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {
    public enum AnnotationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Contains contig and 1-base position
        case chrPos
        /// Contains contig, 1-base position, ref and alt allele information
        case chrPosRefAlt
        /// Contains contig, start, and end positions. Coordinates are 1-based
        case chrStartEndOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 1-based
        case chrStartEndRefAltOneBase
        /// Contains contig, start, end, ref and alt allele information. Coordinates are 0-based
        case chrStartEndRefAltZeroBase
        /// Contains contig, start, and end positions. Coordinates are 0-based
        case chrStartEndZeroBase
        /// Generic text file. No genomic information
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [AnnotationType] {
            return [
                .chrPos,
                .chrPosRefAlt,
                .chrStartEndOneBase,
                .chrStartEndRefAltOneBase,
                .chrStartEndRefAltZeroBase,
                .chrStartEndZeroBase,
                .generic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .chrPos: return "CHR_POS"
            case .chrPosRefAlt: return "CHR_POS_REF_ALT"
            case .chrStartEndOneBase: return "CHR_START_END_ONE_BASE"
            case .chrStartEndRefAltOneBase: return "CHR_START_END_REF_ALT_ONE_BASE"
            case .chrStartEndRefAltZeroBase: return "CHR_START_END_REF_ALT_ZERO_BASE"
            case .chrStartEndZeroBase: return "CHR_START_END_ZERO_BASE"
            case .generic: return "GENERIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnnotationType(rawValue: rawValue) ?? AnnotationType.sdkUnknown(rawValue)
        }
    }
}

extension BatchDeleteReadSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for readsetid0 in ids {
                try idsContainer.encode(readsetid0)
            }
        }
    }
}

extension BatchDeleteReadSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/batch/delete"
    }
}

public struct BatchDeleteReadSetInput: Swift.Equatable {
    /// The read sets' IDs.
    /// This member is required.
    public var ids: [Swift.String]?
    /// The read sets' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        ids: [Swift.String]? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.ids = ids
        self.sequenceStoreId = sequenceStoreId
    }
}

struct BatchDeleteReadSetInputBody: Swift.Equatable {
    let ids: [Swift.String]?
}

extension BatchDeleteReadSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
    }
}

extension BatchDeleteReadSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteReadSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDeleteReadSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteReadSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDeleteReadSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteReadSetOutputResponse: Swift.Equatable {
    /// Errors returned by individual delete operations.
    public var errors: [OmicsClientTypes.ReadSetBatchError]?

    public init (
        errors: [OmicsClientTypes.ReadSetBatchError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteReadSetOutputResponseBody: Swift.Equatable {
    let errors: [OmicsClientTypes.ReadSetBatchError]?
}

extension BatchDeleteReadSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReadSetBatchError?].self, forKey: .errors)
        var errorsDecoded0:[OmicsClientTypes.ReadSetBatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [OmicsClientTypes.ReadSetBatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension CancelAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelAnnotationImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelAnnotationImportJobInputBody: Swift.Equatable {
}

extension CancelAnnotationImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelAnnotationImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelAnnotationImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelAnnotationImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelAnnotationImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelAnnotationImportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/cancel"
    }
}

public struct CancelRunInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct CancelRunInputBody: Swift.Equatable {
}

extension CancelRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelRunOutputResponse: Swift.Equatable {

    public init () { }
}

extension CancelVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct CancelVariantImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelVariantImportJobInputBody: Swift.Equatable {
}

extension CancelVariantImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CancelVariantImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelVariantImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelVariantImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelVariantImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelVariantImportJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request cannot be applied to the target resource in its current state.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAnnotationStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case storeFormat
        case storeOptions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let storeFormat = self.storeFormat {
            try encodeContainer.encode(storeFormat.rawValue, forKey: .storeFormat)
        }
        if let storeOptions = self.storeOptions {
            try encodeContainer.encode(storeOptions, forKey: .storeOptions)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/annotationStore"
    }
}

public struct CreateAnnotationStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's annotations.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The annotation file format of the store.
    /// This member is required.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// File parsing options for the annotation store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.tags = tags
    }
}

struct CreateAnnotationStoreInputBody: Swift.Equatable {
    let reference: OmicsClientTypes.ReferenceItem?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let sseConfig: OmicsClientTypes.SseConfig?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let storeOptions: OmicsClientTypes.StoreOptions?
}

extension CreateAnnotationStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case storeFormat
        case storeOptions
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
    }
}

extension CreateAnnotationStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnnotationStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAnnotationStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnnotationStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAnnotationStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
        } else {
            self.creationTime = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.storeFormat = nil
            self.storeOptions = nil
        }
    }
}

public struct CreateAnnotationStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's file parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
    }
}

struct CreateAnnotationStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateAnnotationStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case name
        case reference
        case status
        case storeFormat
        case storeOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateReferenceStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/referencestore"
    }
}

public struct CreateReferenceStoreInput: Swift.Equatable {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateReferenceStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateReferenceStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateReferenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReferenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReferenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReferenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReferenceStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct CreateReferenceStoreOutputResponse: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct CreateReferenceStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension CreateReferenceStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateRunGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxRuns
        case name
        case requestId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/runGroup"
    }
}

public struct CreateRunGroupInput: Swift.Equatable {
    /// The maximum number of CPUs to use in the group.
    public var maxCpus: Swift.Int?
    /// A max duration for the group.
    public var maxDuration: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?
    /// A request ID for the group.
    /// This member is required.
    public var requestId: Swift.String?
    /// Tags for the group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        requestId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxRuns = maxRuns
        self.name = name
        self.requestId = requestId
        self.tags = tags
    }
}

struct CreateRunGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
}

extension CreateRunGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxRuns
        case name
        case requestId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateRunGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRunGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRunGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRunGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRunGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct CreateRunGroupOutputResponse: Swift.Equatable {
    /// The group's ARN.
    public var arn: Swift.String?
    /// The group's ID.
    public var id: Swift.String?
    /// Tags for the run group.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.tags = tags
    }
}

struct CreateRunGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateRunGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSequenceStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sequencestore"
    }
}

public struct CreateSequenceStoreInput: Swift.Equatable {
    /// To ensure that requests don't run multiple times, specify a unique token for each request.
    public var clientToken: Swift.String?
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateSequenceStoreInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateSequenceStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case sseConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateSequenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSequenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSequenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSequenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSequenceStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct CreateSequenceStoreOutputResponse: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's SSE settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct CreateSequenceStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension CreateSequenceStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateVariantStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/variantStore"
    }
}

public struct CreateVariantStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    public var name: Swift.String?
    /// The genome reference for the store's variants.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// Server-side encryption (SSE) settings for the store.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// Tags for the store.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.tags = tags
    }
}

struct CreateVariantStoreInputBody: Swift.Equatable {
    let reference: OmicsClientTypes.ReferenceItem?
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let sseConfig: OmicsClientTypes.SseConfig?
}

extension CreateVariantStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case reference
        case sseConfig
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
    }
}

extension CreateVariantStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVariantStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateVariantStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVariantStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateVariantStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
        }
    }
}

public struct CreateVariantStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
    }
}

struct CreateVariantStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let creationTime: ClientRuntime.Date?
}

extension CreateVariantStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case name
        case reference
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitionUri
        case definitionZip
        case description
        case engine
        case main
        case name
        case parameterTemplate
        case requestId
        case storageCapacity
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definitionUri = self.definitionUri {
            try encodeContainer.encode(definitionUri, forKey: .definitionUri)
        }
        if let definitionZip = self.definitionZip {
            try encodeContainer.encode(definitionZip.base64EncodedString(), forKey: .definitionZip)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine.rawValue, forKey: .engine)
        }
        if let main = self.main {
            try encodeContainer.encode(main, forKey: .main)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameterTemplate = parameterTemplate {
            var parameterTemplateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameterTemplate)
            for (dictKey0, workflowParameterTemplate0) in parameterTemplate {
                try parameterTemplateContainer.encode(workflowParameterTemplate0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflow"
    }
}

public struct CreateWorkflowInput: Swift.Equatable {
    /// The URI of a definition for the workflow.
    public var definitionUri: Swift.String?
    /// A ZIP archive for the workflow.
    public var definitionZip: ClientRuntime.Data?
    /// A description for the workflow.
    public var description: Swift.String?
    /// An engine for the workflow.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?
    /// A parameter template for the workflow.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// A request ID for the workflow.
    /// This member is required.
    public var requestId: Swift.String?
    /// A storage capacity for the workflow.
    public var storageCapacity: Swift.Int?
    /// Tags for the workflow.
    public var tags: [Swift.String:Swift.String]?

    public init (
        definitionUri: Swift.String? = nil,
        definitionZip: ClientRuntime.Data? = nil,
        description: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        main: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        requestId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.definitionUri = definitionUri
        self.definitionZip = definitionZip
        self.description = description
        self.engine = engine
        self.main = main
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.requestId = requestId
        self.storageCapacity = storageCapacity
        self.tags = tags
    }
}

struct CreateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let engine: OmicsClientTypes.WorkflowEngine?
    let definitionZip: ClientRuntime.Data?
    let definitionUri: Swift.String?
    let main: Swift.String?
    let parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    let storageCapacity: Swift.Int?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
}

extension CreateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitionUri
        case definitionZip
        case description
        case engine
        case main
        case name
        case parameterTemplate
        case requestId
        case storageCapacity
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowEngine.self, forKey: .engine)
        engine = engineDecoded
        let definitionZipDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .definitionZip)
        definitionZip = definitionZipDecoded
        let definitionUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definitionUri)
        definitionUri = definitionUriDecoded
        let mainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .main)
        main = mainDecoded
        let parameterTemplateContainer = try containerValues.decodeIfPresent([Swift.String: OmicsClientTypes.WorkflowParameter?].self, forKey: .parameterTemplate)
        var parameterTemplateDecoded0: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil
        if let parameterTemplateContainer = parameterTemplateContainer {
            parameterTemplateDecoded0 = [Swift.String:OmicsClientTypes.WorkflowParameter]()
            for (key0, workflowparameter0) in parameterTemplateContainer {
                if let workflowparameter0 = workflowparameter0 {
                    parameterTemplateDecoded0?[key0] = workflowparameter0
                }
            }
        }
        parameterTemplate = parameterTemplateDecoded0
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension CreateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct CreateWorkflowOutputResponse: Swift.Equatable {
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
        self.tags = tags
    }
}

struct CreateWorkflowOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.WorkflowStatus?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DeleteAnnotationStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteAnnotationStoreInput: Swift.Equatable {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

struct DeleteAnnotationStoreInputBody: Swift.Equatable {
}

extension DeleteAnnotationStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnnotationStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnnotationStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAnnotationStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnnotationStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAnnotationStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteAnnotationStoreOutputResponse: Swift.Equatable {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init (
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteAnnotationStoreOutputResponseBody: Swift.Equatable {
    let status: OmicsClientTypes.StoreStatus?
}

extension DeleteAnnotationStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteReferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceInput: Swift.Equatable {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct DeleteReferenceInputBody: Swift.Equatable {
}

extension DeleteReferenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReferenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReferenceOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteReferenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteReferenceStoreInputBody: Swift.Equatable {
}

extension DeleteReferenceStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteReferenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReferenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReferenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReferenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReferenceStoreOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunGroupInput: Swift.Equatable {
    /// The run group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteRunGroupInputBody: Swift.Equatable {
}

extension DeleteRunGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRunGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRunGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRunGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRunGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRunGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct DeleteRunInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteRunInputBody: Swift.Equatable {
}

extension DeleteRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRunOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct DeleteSequenceStoreInput: Swift.Equatable {
    /// The sequence store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteSequenceStoreInputBody: Swift.Equatable {
}

extension DeleteSequenceStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSequenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSequenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSequenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSequenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSequenceStoreOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVariantStoreInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let force = force {
                let forceQueryItem = ClientRuntime.URLQueryItem(name: "force".urlPercentEncoding(), value: Swift.String(force).urlPercentEncoding())
                items.append(forceQueryItem)
            }
            return items
        }
    }
}

extension DeleteVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct DeleteVariantStoreInput: Swift.Equatable {
    /// Whether to force deletion.
    public var force: Swift.Bool?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        force: Swift.Bool? = nil,
        name: Swift.String? = nil
    )
    {
        self.force = force
        self.name = name
    }
}

struct DeleteVariantStoreInputBody: Swift.Equatable {
}

extension DeleteVariantStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteVariantStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVariantStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVariantStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVariantStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteVariantStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeleteVariantStoreOutputResponse: Swift.Equatable {
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?

    public init (
        status: OmicsClientTypes.StoreStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeleteVariantStoreOutputResponseBody: Swift.Equatable {
    let status: OmicsClientTypes.StoreStatus?
}

extension DeleteVariantStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct DeleteWorkflowInput: Swift.Equatable {
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWorkflowInputBody: Swift.Equatable {
}

extension DeleteWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWorkflowOutputResponse: Swift.Equatable {

    public init () { }
}

extension OmicsClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// KMS
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ExportReadSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ExportReadSet: Swift.Equatable {
        /// The set's ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init (
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension OmicsClientTypes.ExportReadSetDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a read set.
    public struct ExportReadSetDetail: Swift.Equatable {
        /// The set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobItemStatus?
        /// The set's status message.
        public var statusMessage: Swift.String?

        public init (
            id: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.id = id
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension OmicsClientTypes.ExportReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// An read set export job filter.
    public struct ExportReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ExportReadSetJobDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destination
        case id
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a read set export job.
    public struct ExportReadSetJobDetail: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination in Amazon S3.
        /// This member is required.
        public var destination: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetExportJobStatus?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destination: Swift.String? = nil,
            id: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetExportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destination = destination
            self.id = id
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.FileInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentLength
        case partSize
        case totalParts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentLength = self.contentLength {
            try encodeContainer.encode(contentLength, forKey: .contentLength)
        }
        if let partSize = self.partSize {
            try encodeContainer.encode(partSize, forKey: .partSize)
        }
        if let totalParts = self.totalParts {
            try encodeContainer.encode(totalParts, forKey: .totalParts)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalPartsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalParts)
        totalParts = totalPartsDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
        let contentLengthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .contentLength)
        contentLength = contentLengthDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a file.
    public struct FileInformation: Swift.Equatable {
        /// The file's content length.
        public var contentLength: Swift.Int?
        /// The file's part size.
        public var partSize: Swift.Int?
        /// The file's total parts.
        public var totalParts: Swift.Int?

        public init (
            contentLength: Swift.Int? = nil,
            partSize: Swift.Int? = nil,
            totalParts: Swift.Int? = nil
        )
        {
            self.contentLength = contentLength
            self.partSize = partSize
            self.totalParts = totalParts
        }
    }

}

extension OmicsClientTypes {
    public enum FileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bam
        case cram
        case fastq
        case sdkUnknown(Swift.String)

        public static var allCases: [FileType] {
            return [
                .bam,
                .cram,
                .fastq,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bam: return "BAM"
            case .cram: return "CRAM"
            case .fastq: return "FASTQ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FileType(rawValue: rawValue) ?? FileType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.FormatOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tsvoptions = "tsvOptions"
        case vcfoptions = "vcfOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tsvoptions(tsvoptions):
                try container.encode(tsvoptions, forKey: .tsvoptions)
            case let .vcfoptions(vcfoptions):
                try container.encode(vcfoptions, forKey: .vcfoptions)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tsvoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.TsvOptions.self, forKey: .tsvoptions)
        if let tsvoptions = tsvoptionsDecoded {
            self = .tsvoptions(tsvoptions)
            return
        }
        let vcfoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.VcfOptions.self, forKey: .vcfoptions)
        if let vcfoptions = vcfoptionsDecoded {
            self = .vcfoptions(vcfoptions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// Formatting options for a file.
    public enum FormatOptions: Swift.Equatable {
        /// Options for a TSV file.
        case tsvoptions(OmicsClientTypes.TsvOptions)
        /// Options for a VCF file.
        case vcfoptions(OmicsClientTypes.VcfOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {
    public enum FormatToHeaderKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alt
        case chr
        case end
        case pos
        case ref
        case start
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatToHeaderKey] {
            return [
                .alt,
                .chr,
                .end,
                .pos,
                .ref,
                .start,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alt: return "ALT"
            case .chr: return "CHR"
            case .end: return "END"
            case .pos: return "POS"
            case .ref: return "REF"
            case .start: return "START"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatToHeaderKey(rawValue: rawValue) ?? FormatToHeaderKey.sdkUnknown(rawValue)
        }
    }
}

extension GetAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/annotation/\(jobId.urlPercentEncoding())"
    }
}

public struct GetAnnotationImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetAnnotationImportJobInputBody: Swift.Equatable {
}

extension GetAnnotationImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnnotationImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnnotationImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAnnotationImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnnotationImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAnnotationImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destinationName = output.destinationName
            self.formatOptions = output.formatOptions
            self.id = output.id
            self.items = output.items
            self.roleArn = output.roleArn
            self.runLeftNormalization = output.runLeftNormalization
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.updateTime = output.updateTime
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.destinationName = nil
            self.formatOptions = nil
            self.id = nil
            self.items = nil
            self.roleArn = nil
            self.runLeftNormalization = false
            self.status = nil
            self.statusMessage = nil
            self.updateTime = nil
        }
    }
}

public struct GetAnnotationImportJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    /// This member is required.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination annotation store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for a file.
    /// This member is required.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's imported items.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.AnnotationImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
    }
}

struct GetAnnotationImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.JobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let items: [OmicsClientTypes.AnnotationImportItemDetail]?
    let runLeftNormalization: Swift.Bool
    let formatOptions: OmicsClientTypes.FormatOptions?
}

extension GetAnnotationImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destinationName
        case formatOptions
        case id
        case items
        case roleArn
        case runLeftNormalization
        case status
        case statusMessage
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportItemDetail?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.AnnotationImportItemDetail]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.AnnotationImportItemDetail]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
        let formatOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
    }
}

extension GetAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct GetAnnotationStoreInput: Swift.Equatable {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetAnnotationStoreInputBody: Swift.Equatable {
}

extension GetAnnotationStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAnnotationStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnnotationStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAnnotationStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnnotationStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAnnotationStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.sseConfig = output.sseConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storeArn = output.storeArn
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
            self.storeSizeBytes = output.storeSizeBytes
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.sseConfig = nil
            self.status = nil
            self.statusMessage = nil
            self.storeArn = nil
            self.storeFormat = nil
            self.storeOptions = nil
            self.storeSizeBytes = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetAnnotationStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// A status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's annotation file format.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// The store's parsing options.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetAnnotationStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let storeArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let storeFormat: OmicsClientTypes.StoreFormat?
    let statusMessage: Swift.String?
    let storeSizeBytes: Swift.Int?
}

extension GetAnnotationStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeFormat
        case storeOptions
        case storeSizeBytes
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension GetReadSetActivationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetActivationJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetActivationJobInputBody: Swift.Equatable {
}

extension GetReadSetActivationJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetActivationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadSetActivationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadSetActivationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadSetActivationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadSetActivationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetActivationJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's sources.
    public var sources: [OmicsClientTypes.ActivateReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ActivateReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetActivationJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let status: OmicsClientTypes.ReadSetActivationJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ActivateReadSetSourceItem]?
}

extension GetReadSetActivationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case sequenceStoreId
        case sources
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ActivateReadSetSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ActivateReadSetSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ActivateReadSetSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension GetReadSetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetExportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetExportJobInputBody: Swift.Equatable {
}

extension GetReadSetExportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadSetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadSetExportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadSetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadSetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.id = output.id
            self.readSets = output.readSets
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.destination = nil
            self.id = nil
            self.readSets = nil
            self.sequenceStoreId = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetExportJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's read sets.
    public var readSets: [OmicsClientTypes.ExportReadSetDetail]?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        readSets: [OmicsClientTypes.ExportReadSetDetail]? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.readSets = readSets
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetExportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let destination: Swift.String?
    let status: OmicsClientTypes.ReadSetExportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let readSets: [OmicsClientTypes.ExportReadSetDetail]?
}

extension GetReadSetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destination
        case id
        case readSets
        case sequenceStoreId
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let readSetsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSetDetail?].self, forKey: .readSets)
        var readSetsDecoded0:[OmicsClientTypes.ExportReadSetDetail]? = nil
        if let readSetsContainer = readSetsContainer {
            readSetsDecoded0 = [OmicsClientTypes.ExportReadSetDetail]()
            for structure0 in readSetsContainer {
                if let structure0 = structure0 {
                    readSetsDecoded0?.append(structure0)
                }
            }
        }
        readSets = readSetsDecoded0
    }
}

extension GetReadSetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetImportJobInputBody: Swift.Equatable {
}

extension GetReadSetImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadSetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadSetImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadSetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadSetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.roleArn = output.roleArn
            self.sequenceStoreId = output.sequenceStoreId
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.roleArn = nil
            self.sequenceStoreId = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReadSetImportJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's sources.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReadSetSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReadSetSourceItem]? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReadSetImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReadSetImportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ImportReadSetSourceItem]?
}

extension GetReadSetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case sources
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReadSetSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ImportReadSetSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ImportReadSetSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension GetReadSetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let file = file {
                let fileQueryItem = ClientRuntime.URLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
                items.append(fileQueryItem)
            }
            guard let partNumber = partNumber else {
                let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
            return items
        }
    }
}

extension GetReadSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())"
    }
}

public struct GetReadSetInput: Swift.Equatable {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReadSetFile?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        file: OmicsClientTypes.ReadSetFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetInputBody: Swift.Equatable {
}

extension GetReadSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readset/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReadSetMetadataInput: Swift.Equatable {
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.sequenceStoreId = sequenceStoreId
    }
}

struct GetReadSetMetadataInputBody: Swift.Equatable {
}

extension GetReadSetMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReadSetMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadSetMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadSetMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadSetMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReadSetMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.fileType = output.fileType
            self.files = output.files
            self.id = output.id
            self.name = output.name
            self.referenceArn = output.referenceArn
            self.sampleId = output.sampleId
            self.sequenceInformation = output.sequenceInformation
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
            self.subjectId = output.subjectId
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.fileType = nil
            self.files = nil
            self.id = nil
            self.name = nil
            self.referenceArn = nil
            self.sampleId = nil
            self.sequenceInformation = nil
            self.sequenceStoreId = nil
            self.status = nil
            self.subjectId = nil
        }
    }
}

public struct GetReadSetMetadataOutputResponse: Swift.Equatable {
    /// The read set's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the read set was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The read set's description.
    public var description: Swift.String?
    /// The read set's file type.
    /// This member is required.
    public var fileType: OmicsClientTypes.FileType?
    /// The read set's files.
    public var files: OmicsClientTypes.ReadSetFiles?
    /// The read set's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's name.
    public var name: Swift.String?
    /// The read set's genome reference ARN.
    public var referenceArn: Swift.String?
    /// The read set's sample ID.
    public var sampleId: Swift.String?
    /// The read set's sequence information.
    public var sequenceInformation: OmicsClientTypes.SequenceInformation?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The read set's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetStatus?
    /// The read set's subject ID.
    public var subjectId: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        fileType: OmicsClientTypes.FileType? = nil,
        files: OmicsClientTypes.ReadSetFiles? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceArn: Swift.String? = nil,
        sampleId: Swift.String? = nil,
        sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetStatus? = nil,
        subjectId: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.fileType = fileType
        self.files = files
        self.id = id
        self.name = name
        self.referenceArn = referenceArn
        self.sampleId = sampleId
        self.sequenceInformation = sequenceInformation
        self.sequenceStoreId = sequenceStoreId
        self.status = status
        self.subjectId = subjectId
    }
}

struct GetReadSetMetadataOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let sequenceStoreId: Swift.String?
    let subjectId: Swift.String?
    let sampleId: Swift.String?
    let status: OmicsClientTypes.ReadSetStatus?
    let name: Swift.String?
    let description: Swift.String?
    let fileType: OmicsClientTypes.FileType?
    let creationTime: ClientRuntime.Date?
    let sequenceInformation: OmicsClientTypes.SequenceInformation?
    let referenceArn: Swift.String?
    let files: OmicsClientTypes.ReadSetFiles?
}

extension GetReadSetMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case fileType
        case files
        case id
        case name
        case referenceArn
        case sampleId
        case sequenceInformation
        case sequenceStoreId
        case status
        case subjectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let sequenceInformationDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceInformation.self, forKey: .sequenceInformation)
        sequenceInformation = sequenceInformationDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let filesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetFiles.self, forKey: .files)
        files = filesDecoded
    }
}

extension GetReadSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReadSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RangeNotSatisfiableException" : self = .rangeNotSatisfiableException(try RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReadSetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case rangeNotSatisfiableException(RangeNotSatisfiableException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReadSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.payload = ByteStream.from(data: data)
        } else {
            self.payload = nil
        }
    }
}

public struct GetReadSetOutputResponse: Swift.Equatable {
    /// The read set file payload.
    public var payload: ClientRuntime.ByteStream?

    public init (
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

struct GetReadSetOutputResponseBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension GetReadSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension GetReferenceImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceImportJobInputBody: Swift.Equatable {
}

extension GetReferenceImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReferenceImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReferenceImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReferenceImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReferenceImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.id = output.id
            self.referenceStoreId = output.referenceStoreId
            self.roleArn = output.roleArn
            self.sources = output.sources
            self.status = output.status
            self.statusMessage = output.statusMessage
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.id = nil
            self.referenceStoreId = nil
            self.roleArn = nil
            self.sources = nil
            self.status = nil
            self.statusMessage = nil
        }
    }
}

public struct GetReferenceImportJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's sources.
    /// This member is required.
    public var sources: [OmicsClientTypes.ImportReferenceSourceItem]?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?
    /// The job's status message.
    public var statusMessage: Swift.String?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.ImportReferenceSourceItem]? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil,
        statusMessage: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
        self.status = status
        self.statusMessage = statusMessage
    }
}

struct GetReferenceImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let referenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReferenceImportJobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let sources: [OmicsClientTypes.ImportReferenceSourceItem]?
}

extension GetReferenceImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case sources
        case status
        case statusMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReferenceSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ImportReferenceSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ImportReferenceSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension GetReferenceInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let range = range {
            items.add(Header(name: "Range", value: Swift.String(range)))
        }
        return items
    }
}

extension GetReferenceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let file = file {
                let fileQueryItem = ClientRuntime.URLQueryItem(name: "file".urlPercentEncoding(), value: Swift.String(file.rawValue).urlPercentEncoding())
                items.append(fileQueryItem)
            }
            guard let partNumber = partNumber else {
                let message = "Creating a URL Query Item failed. partNumber is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let partNumberQueryItem = ClientRuntime.URLQueryItem(name: "partNumber".urlPercentEncoding(), value: Swift.String(partNumber).urlPercentEncoding())
            items.append(partNumberQueryItem)
            return items
        }
    }
}

extension GetReferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceInput: Swift.Equatable {
    /// The file to retrieve.
    public var file: OmicsClientTypes.ReferenceFile?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The part number to retrieve.
    /// This member is required.
    public var partNumber: Swift.Int?
    /// The range to retrieve.
    public var range: Swift.String?
    /// The reference's store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        file: OmicsClientTypes.ReferenceFile? = nil,
        id: Swift.String? = nil,
        partNumber: Swift.Int? = nil,
        range: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.file = file
        self.id = id
        self.partNumber = partNumber
        self.range = range
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceInputBody: Swift.Equatable {
}

extension GetReferenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/reference/\(id.urlPercentEncoding())/metadata"
    }
}

public struct GetReferenceMetadataInput: Swift.Equatable {
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.id = id
        self.referenceStoreId = referenceStoreId
    }
}

struct GetReferenceMetadataInputBody: Swift.Equatable {
}

extension GetReferenceMetadataInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReferenceMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReferenceMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReferenceMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReferenceMetadataOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.files = output.files
            self.id = output.id
            self.md5 = output.md5
            self.name = output.name
            self.referenceStoreId = output.referenceStoreId
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.files = nil
            self.id = nil
            self.md5 = nil
            self.name = nil
            self.referenceStoreId = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct GetReferenceMetadataOutputResponse: Swift.Equatable {
    /// The reference's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the reference was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The reference's description.
    public var description: Swift.String?
    /// The reference's files.
    public var files: OmicsClientTypes.ReferenceFiles?
    /// The reference's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The reference's MD5 checksum.
    /// This member is required.
    public var md5: Swift.String?
    /// The reference's name.
    public var name: Swift.String?
    /// The reference's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The reference's status.
    public var status: OmicsClientTypes.ReferenceStatus?
    /// When the reference was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        files: OmicsClientTypes.ReferenceFiles? = nil,
        id: Swift.String? = nil,
        md5: Swift.String? = nil,
        name: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.files = files
        self.id = id
        self.md5 = md5
        self.name = name
        self.referenceStoreId = referenceStoreId
        self.status = status
        self.updateTime = updateTime
    }
}

struct GetReferenceMetadataOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let referenceStoreId: Swift.String?
    let md5: Swift.String?
    let status: OmicsClientTypes.ReferenceStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let files: OmicsClientTypes.ReferenceFiles?
}

extension GetReferenceMetadataOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case files
        case id
        case md5
        case name
        case referenceStoreId
        case status
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let filesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceFiles.self, forKey: .files)
        files = filesDecoded
    }
}

extension GetReferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RangeNotSatisfiableException" : self = .rangeNotSatisfiableException(try RangeNotSatisfiableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReferenceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case rangeNotSatisfiableException(RangeNotSatisfiableException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let data = httpResponse.body.toBytes()?.getData() {
            self.payload = ByteStream.from(data: data)
        } else {
            self.payload = nil
        }
    }
}

public struct GetReferenceOutputResponse: Swift.Equatable {
    /// The reference file payload.
    public var payload: ClientRuntime.ByteStream?

    public init (
        payload: ClientRuntime.ByteStream? = nil
    )
    {
        self.payload = payload
    }
}

struct GetReferenceOutputResponseBody: Swift.Equatable {
    let payload: ClientRuntime.ByteStream?
}

extension GetReferenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case payload
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension GetReferenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/referencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetReferenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetReferenceStoreInputBody: Swift.Equatable {
}

extension GetReferenceStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetReferenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReferenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReferenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReferenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReferenceStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct GetReferenceStoreOutputResponse: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct GetReferenceStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension GetReferenceStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension GetRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct GetRunGroupInput: Swift.Equatable {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetRunGroupInputBody: Swift.Equatable {
}

extension GetRunGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRunGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRunGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRunGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.id = output.id
            self.maxCpus = output.maxCpus
            self.maxDuration = output.maxDuration
            self.maxRuns = output.maxRuns
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTime = nil
            self.id = nil
            self.maxCpus = nil
            self.maxDuration = nil
            self.maxRuns = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetRunGroupOutputResponse: Swift.Equatable {
    /// The group's ARN.
    public var arn: Swift.String?
    /// When the group was created.
    public var creationTime: ClientRuntime.Date?
    /// The group's ID.
    public var id: Swift.String?
    /// The group's maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// The group's maximum run duration.
    public var maxDuration: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// The group's name.
    public var name: Swift.String?
    /// The group's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxRuns = maxRuns
        self.name = name
        self.tags = tags
    }
}

struct GetRunGroupOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetRunGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case maxCpus
        case maxDuration
        case maxRuns
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRunInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let export = export {
                export.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())"
    }
}

public struct GetRunInput: Swift.Equatable {
    /// The run's export format.
    public var export: [OmicsClientTypes.RunExport]?
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        export: [OmicsClientTypes.RunExport]? = nil,
        id: Swift.String? = nil
    )
    {
        self.export = export
        self.id = id
    }
}

struct GetRunInputBody: Swift.Equatable {
}

extension GetRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.definition = output.definition
            self.digest = output.digest
            self.id = output.id
            self.logLevel = output.logLevel
            self.name = output.name
            self.outputUri = output.outputUri
            self.parameters = output.parameters
            self.priority = output.priority
            self.resourceDigests = output.resourceDigests
            self.roleArn = output.roleArn
            self.runGroupId = output.runGroupId
            self.runId = output.runId
            self.startTime = output.startTime
            self.startedBy = output.startedBy
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stopTime = output.stopTime
            self.storageCapacity = output.storageCapacity
            self.tags = output.tags
            self.workflowId = output.workflowId
            self.workflowType = output.workflowType
        } else {
            self.arn = nil
            self.creationTime = nil
            self.definition = nil
            self.digest = nil
            self.id = nil
            self.logLevel = nil
            self.name = nil
            self.outputUri = nil
            self.parameters = nil
            self.priority = nil
            self.resourceDigests = nil
            self.roleArn = nil
            self.runGroupId = nil
            self.runId = nil
            self.startTime = nil
            self.startedBy = nil
            self.status = nil
            self.statusMessage = nil
            self.stopTime = nil
            self.storageCapacity = nil
            self.tags = nil
            self.workflowId = nil
            self.workflowType = nil
        }
    }
}

public struct GetRunOutputResponse: Swift.Equatable {
    /// The run's ARN.
    public var arn: Swift.String?
    /// When the run was created.
    public var creationTime: ClientRuntime.Date?
    /// The run's definition.
    public var definition: Swift.String?
    /// The run's digest.
    public var digest: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The run's log level.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// The run's name.
    public var name: Swift.String?
    /// The run's output URI.
    public var outputUri: Swift.String?
    /// The run's parameters.
    public var parameters: ClientRuntime.Document?
    /// The run's priority.
    public var priority: Swift.Int?
    /// The run's resource digests.
    public var resourceDigests: [Swift.String:Swift.String]?
    /// The run's service role ARN.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The run's ID.
    public var runId: Swift.String?
    /// When the run started.
    public var startTime: ClientRuntime.Date?
    /// Who started the run.
    public var startedBy: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's status message.
    public var statusMessage: Swift.String?
    /// The run's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The run's storage capacity.
    public var storageCapacity: Swift.Int?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The run's workflow type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        digest: Swift.String? = nil,
        id: Swift.String? = nil,
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: ClientRuntime.Document? = nil,
        priority: Swift.Int? = nil,
        resourceDigests: [Swift.String:Swift.String]? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        startedBy: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.digest = digest
        self.id = id
        self.logLevel = logLevel
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.resourceDigests = resourceDigests
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.startTime = startTime
        self.startedBy = startedBy
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct GetRunOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.RunStatus?
    let workflowId: Swift.String?
    let workflowType: OmicsClientTypes.WorkflowType?
    let runId: Swift.String?
    let roleArn: Swift.String?
    let name: Swift.String?
    let runGroupId: Swift.String?
    let priority: Swift.Int?
    let definition: Swift.String?
    let digest: Swift.String?
    let parameters: ClientRuntime.Document?
    let storageCapacity: Swift.Int?
    let outputUri: Swift.String?
    let logLevel: OmicsClientTypes.RunLogLevel?
    let resourceDigests: [Swift.String:Swift.String]?
    let startedBy: Swift.String?
    let creationTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case definition
        case digest
        case id
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case resourceDigests
        case roleArn
        case runGroupId
        case runId
        case startTime
        case startedBy
        case status
        case statusMessage
        case stopTime
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let runGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runGroupId)
        runGroupId = runGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .parameters)
        parameters = parametersDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunLogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let resourceDigestsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceDigests)
        var resourceDigestsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceDigestsContainer = resourceDigestsContainer {
            resourceDigestsDecoded0 = [Swift.String:Swift.String]()
            for (key0, runresourcedigest0) in resourceDigestsContainer {
                if let runresourcedigest0 = runresourcedigest0 {
                    resourceDigestsDecoded0?[key0] = runresourcedigest0
                }
            }
        }
        resourceDigests = resourceDigestsDecoded0
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetRunTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        guard let taskId = taskId else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task/\(taskId.urlPercentEncoding())"
    }
}

public struct GetRunTaskInput: Swift.Equatable {
    /// The task's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The task's ID.
    /// This member is required.
    public var taskId: Swift.String?

    public init (
        id: Swift.String? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.id = id
        self.taskId = taskId
    }
}

struct GetRunTaskInputBody: Swift.Equatable {
}

extension GetRunTaskInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRunTaskOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRunTaskOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRunTaskOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRunTaskOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRunTaskOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cpus = output.cpus
            self.creationTime = output.creationTime
            self.logStream = output.logStream
            self.memory = output.memory
            self.name = output.name
            self.startTime = output.startTime
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.stopTime = output.stopTime
            self.taskId = output.taskId
        } else {
            self.cpus = nil
            self.creationTime = nil
            self.logStream = nil
            self.memory = nil
            self.name = nil
            self.startTime = nil
            self.status = nil
            self.statusMessage = nil
            self.stopTime = nil
            self.taskId = nil
        }
    }
}

public struct GetRunTaskOutputResponse: Swift.Equatable {
    /// The task's CPU usage.
    public var cpus: Swift.Int?
    /// When the task was created.
    public var creationTime: ClientRuntime.Date?
    /// The task's log stream.
    public var logStream: Swift.String?
    /// The task's memory setting.
    public var memory: Swift.Int?
    /// The task's name.
    public var name: Swift.String?
    /// The task's start time.
    public var startTime: ClientRuntime.Date?
    /// The task's status.
    public var status: OmicsClientTypes.TaskStatus?
    /// The task's status message.
    public var statusMessage: Swift.String?
    /// The task's stop time.
    public var stopTime: ClientRuntime.Date?
    /// The task's ID.
    public var taskId: Swift.String?

    public init (
        cpus: Swift.Int? = nil,
        creationTime: ClientRuntime.Date? = nil,
        logStream: Swift.String? = nil,
        memory: Swift.Int? = nil,
        name: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: OmicsClientTypes.TaskStatus? = nil,
        statusMessage: Swift.String? = nil,
        stopTime: ClientRuntime.Date? = nil,
        taskId: Swift.String? = nil
    )
    {
        self.cpus = cpus
        self.creationTime = creationTime
        self.logStream = logStream
        self.memory = memory
        self.name = name
        self.startTime = startTime
        self.status = status
        self.statusMessage = statusMessage
        self.stopTime = stopTime
        self.taskId = taskId
    }
}

struct GetRunTaskOutputResponseBody: Swift.Equatable {
    let taskId: Swift.String?
    let status: OmicsClientTypes.TaskStatus?
    let name: Swift.String?
    let cpus: Swift.Int?
    let memory: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let logStream: Swift.String?
}

extension GetRunTaskOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case creationTime
        case logStream
        case memory
        case name
        case startTime
        case status
        case statusMessage
        case stopTime
        case taskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let cpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpus)
        cpus = cpusDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let logStreamDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logStream)
        logStream = logStreamDecoded
    }
}

extension GetSequenceStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/sequencestore/\(id.urlPercentEncoding())"
    }
}

public struct GetSequenceStoreInput: Swift.Equatable {
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSequenceStoreInputBody: Swift.Equatable {
}

extension GetSequenceStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSequenceStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSequenceStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSequenceStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSequenceStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSequenceStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.sseConfig = output.sseConfig
        } else {
            self.arn = nil
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.sseConfig = nil
        }
    }
}

public struct GetSequenceStoreOutputResponse: Swift.Equatable {
    /// The store's ARN.
    /// This member is required.
    public var arn: Swift.String?
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    public var name: Swift.String?
    /// The store's server-side encryption (SSE) settings.
    public var sseConfig: OmicsClientTypes.SseConfig?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.sseConfig = sseConfig
    }
}

struct GetSequenceStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
}

extension GetSequenceStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension GetVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/import/variant/\(jobId.urlPercentEncoding())"
    }
}

public struct GetVariantImportJobInput: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetVariantImportJobInputBody: Swift.Equatable {
}

extension GetVariantImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVariantImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVariantImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVariantImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVariantImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVariantImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.creationTime = output.creationTime
            self.destinationName = output.destinationName
            self.id = output.id
            self.items = output.items
            self.roleArn = output.roleArn
            self.runLeftNormalization = output.runLeftNormalization
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.updateTime = output.updateTime
        } else {
            self.completionTime = nil
            self.creationTime = nil
            self.destinationName = nil
            self.id = nil
            self.items = nil
            self.roleArn = nil
            self.runLeftNormalization = false
            self.status = nil
            self.statusMessage = nil
            self.updateTime = nil
        }
    }
}

public struct GetVariantImportJobOutputResponse: Swift.Equatable {
    /// When the job completed.
    public var completionTime: ClientRuntime.Date?
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's destination variant store.
    /// This member is required.
    public var destinationName: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's items.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemDetail]?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    /// This member is required.
    public var runLeftNormalization: Swift.Bool
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.JobStatus?
    /// The job's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// When the job was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        completionTime: ClientRuntime.Date? = nil,
        creationTime: ClientRuntime.Date? = nil,
        destinationName: Swift.String? = nil,
        id: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemDetail]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool = false,
        status: OmicsClientTypes.JobStatus? = nil,
        statusMessage: Swift.String? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.completionTime = completionTime
        self.creationTime = creationTime
        self.destinationName = destinationName
        self.id = id
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
        self.status = status
        self.statusMessage = statusMessage
        self.updateTime = updateTime
    }
}

struct GetVariantImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.JobStatus?
    let statusMessage: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let completionTime: ClientRuntime.Date?
    let items: [OmicsClientTypes.VariantImportItemDetail]?
    let runLeftNormalization: Swift.Bool
}

extension GetVariantImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destinationName
        case id
        case items
        case roleArn
        case runLeftNormalization
        case status
        case statusMessage
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportItemDetail?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.VariantImportItemDetail]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.VariantImportItemDetail]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
    }
}

extension GetVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct GetVariantStoreInput: Swift.Equatable {
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetVariantStoreInputBody: Swift.Equatable {
}

extension GetVariantStoreInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetVariantStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVariantStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetVariantStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVariantStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetVariantStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.sseConfig = output.sseConfig
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storeArn = output.storeArn
            self.storeSizeBytes = output.storeSizeBytes
            self.tags = output.tags
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.sseConfig = nil
            self.status = nil
            self.statusMessage = nil
            self.storeArn = nil
            self.storeSizeBytes = nil
            self.tags = nil
            self.updateTime = nil
        }
    }
}

public struct GetVariantStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's server-side encryption (SSE) settings.
    /// This member is required.
    public var sseConfig: OmicsClientTypes.SseConfig?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The store's status message.
    /// This member is required.
    public var statusMessage: Swift.String?
    /// The store's ARN.
    /// This member is required.
    public var storeArn: Swift.String?
    /// The store's size in bytes.
    /// This member is required.
    public var storeSizeBytes: Swift.Int?
    /// The store's tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        sseConfig: OmicsClientTypes.SseConfig? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        statusMessage: Swift.String? = nil,
        storeArn: Swift.String? = nil,
        storeSizeBytes: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.sseConfig = sseConfig
        self.status = status
        self.statusMessage = statusMessage
        self.storeArn = storeArn
        self.storeSizeBytes = storeSizeBytes
        self.tags = tags
        self.updateTime = updateTime
    }
}

struct GetVariantStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let storeArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let sseConfig: OmicsClientTypes.SseConfig?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
    let statusMessage: Swift.String?
    let storeSizeBytes: Swift.Int?
}

extension GetVariantStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeSizeBytes
        case tags
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension GetWorkflowInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let export = export {
                export.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "export".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            return items
        }
    }
}

extension GetWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct GetWorkflowInput: Swift.Equatable {
    /// The export format for the workflow.
    public var export: [OmicsClientTypes.WorkflowExport]?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?

    public init (
        export: [OmicsClientTypes.WorkflowExport]? = nil,
        id: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.export = export
        self.id = id
        self.type = type
    }
}

struct GetWorkflowInputBody: Swift.Equatable {
}

extension GetWorkflowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkflowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTime = output.creationTime
            self.definition = output.definition
            self.description = output.description
            self.digest = output.digest
            self.engine = output.engine
            self.id = output.id
            self.main = output.main
            self.name = output.name
            self.parameterTemplate = output.parameterTemplate
            self.status = output.status
            self.statusMessage = output.statusMessage
            self.storageCapacity = output.storageCapacity
            self.tags = output.tags
            self.type = output.type
        } else {
            self.arn = nil
            self.creationTime = nil
            self.definition = nil
            self.description = nil
            self.digest = nil
            self.engine = nil
            self.id = nil
            self.main = nil
            self.name = nil
            self.parameterTemplate = nil
            self.status = nil
            self.statusMessage = nil
            self.storageCapacity = nil
            self.tags = nil
            self.type = nil
        }
    }
}

public struct GetWorkflowOutputResponse: Swift.Equatable {
    /// The workflow's ARN.
    public var arn: Swift.String?
    /// When the workflow was created.
    public var creationTime: ClientRuntime.Date?
    /// The workflow's definition.
    public var definition: Swift.String?
    /// The workflow's description.
    public var description: Swift.String?
    /// The workflow's digest.
    public var digest: Swift.String?
    /// The workflow's engine.
    public var engine: OmicsClientTypes.WorkflowEngine?
    /// The workflow's ID.
    public var id: Swift.String?
    /// The path of the main definition file for the workflow.
    public var main: Swift.String?
    /// The workflow's name.
    public var name: Swift.String?
    /// The workflow's parameter template.
    public var parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    /// The workflow's status.
    public var status: OmicsClientTypes.WorkflowStatus?
    /// The workflow's status message.
    public var statusMessage: Swift.String?
    /// The workflow's storage capacity.
    public var storageCapacity: Swift.Int?
    /// The workflow's tags.
    public var tags: [Swift.String:Swift.String]?
    /// The workflow's type.
    public var type: OmicsClientTypes.WorkflowType?

    public init (
        arn: Swift.String? = nil,
        creationTime: ClientRuntime.Date? = nil,
        definition: Swift.String? = nil,
        description: Swift.String? = nil,
        digest: Swift.String? = nil,
        engine: OmicsClientTypes.WorkflowEngine? = nil,
        id: Swift.String? = nil,
        main: Swift.String? = nil,
        name: Swift.String? = nil,
        parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil,
        status: OmicsClientTypes.WorkflowStatus? = nil,
        statusMessage: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.definition = definition
        self.description = description
        self.digest = digest
        self.engine = engine
        self.id = id
        self.main = main
        self.name = name
        self.parameterTemplate = parameterTemplate
        self.status = status
        self.statusMessage = statusMessage
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.type = type
    }
}

struct GetWorkflowOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.WorkflowStatus?
    let type: OmicsClientTypes.WorkflowType?
    let name: Swift.String?
    let description: Swift.String?
    let engine: OmicsClientTypes.WorkflowEngine?
    let definition: Swift.String?
    let main: Swift.String?
    let digest: Swift.String?
    let parameterTemplate: [Swift.String:OmicsClientTypes.WorkflowParameter]?
    let storageCapacity: Swift.Int?
    let creationTime: ClientRuntime.Date?
    let statusMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetWorkflowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case definition
        case description
        case digest
        case engine
        case id
        case main
        case name
        case parameterTemplate
        case status
        case statusMessage
        case storageCapacity
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowEngine.self, forKey: .engine)
        engine = engineDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definition)
        definition = definitionDecoded
        let mainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .main)
        main = mainDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let parameterTemplateContainer = try containerValues.decodeIfPresent([Swift.String: OmicsClientTypes.WorkflowParameter?].self, forKey: .parameterTemplate)
        var parameterTemplateDecoded0: [Swift.String:OmicsClientTypes.WorkflowParameter]? = nil
        if let parameterTemplateContainer = parameterTemplateContainer {
            parameterTemplateDecoded0 = [Swift.String:OmicsClientTypes.WorkflowParameter]()
            for (key0, workflowparameter0) in parameterTemplateContainer {
                if let workflowparameter0 = workflowparameter0 {
                    parameterTemplateDecoded0?[key0] = workflowparameter0
                }
            }
        }
        parameterTemplate = parameterTemplateDecoded0
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes.ImportReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for import read set jobs.
    public struct ImportReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// An import read set job.
    public struct ImportReadSetJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobStatus?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.roleArn = roleArn
            self.sequenceStoreId = sequenceStoreId
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReadSetSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case sourceFiles
        case status
        case statusMessage
        case subjectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let sourceFiles = self.sourceFiles {
            try encodeContainer.encode(sourceFiles, forKey: .sourceFiles)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFilesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SourceFiles.self, forKey: .sourceFiles)
        sourceFiles = sourceFilesDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for an import read set job.
    public struct ImportReadSetSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            status: OmicsClientTypes.ReadSetImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.status = status
            self.statusMessage = statusMessage
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension OmicsClientTypes.ImportReferenceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for import references.
    public struct ImportReferenceFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let referenceStoreId = self.referenceStoreId {
            try encodeContainer.encode(referenceStoreId, forKey: .referenceStoreId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
    }
}

extension OmicsClientTypes {
    /// An import reference job.
    public struct ImportReferenceJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's reference store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobStatus?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobStatus? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.id = id
            self.referenceStoreId = referenceStoreId
            self.roleArn = roleArn
            self.status = status
        }
    }

}

extension OmicsClientTypes.ImportReferenceSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sourceFile
        case status
        case statusMessage
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobItemStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// An genome reference source.
    public struct ImportReferenceSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        public var sourceFile: Swift.String?
        /// The source's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReferenceImportJobItemStatus?
        /// The source's status message.
        public var statusMessage: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceImportJobItemStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred. Try the request again.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The Job was cancelled
        case cancelled
        /// The Job has completed
        case completed
        /// The Job failed
        case failed
        /// The Job is executing
        case inProgress
        /// The Job has been submitted to run
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ListAnnotationImportJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case storeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storeName = self.storeName {
            try encodeContainer.encode(storeName, forKey: .storeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let storeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeName)
        storeName = storeNameDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for annotation import jobs.
    public struct ListAnnotationImportJobsFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init (
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListAnnotationImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListAnnotationImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAnnotationImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/annotations"
    }
}

public struct ListAnnotationImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationImportJobsFilter?
    /// IDs of annotation import jobs to retrieve.
    public var ids: [Swift.String]?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.ListAnnotationImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnnotationImportJobsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListAnnotationImportJobsFilter?
}

extension ListAnnotationImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListAnnotationImportJobsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAnnotationImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnnotationImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnnotationImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnnotationImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnnotationImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.annotationImportJobs = output.annotationImportJobs
            self.nextToken = output.nextToken
        } else {
            self.annotationImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnnotationImportJobsOutputResponse: Swift.Equatable {
    /// A list of jobs.
    public var annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationImportJobs = annotationImportJobs
        self.nextToken = nextToken
    }
}

struct ListAnnotationImportJobsOutputResponseBody: Swift.Equatable {
    let annotationImportJobs: [OmicsClientTypes.AnnotationImportJobItem]?
    let nextToken: Swift.String?
}

extension ListAnnotationImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationImportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationImportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportJobItem?].self, forKey: .annotationImportJobs)
        var annotationImportJobsDecoded0:[OmicsClientTypes.AnnotationImportJobItem]? = nil
        if let annotationImportJobsContainer = annotationImportJobsContainer {
            annotationImportJobsDecoded0 = [OmicsClientTypes.AnnotationImportJobItem]()
            for structure0 in annotationImportJobsContainer {
                if let structure0 = structure0 {
                    annotationImportJobsDecoded0?.append(structure0)
                }
            }
        }
        annotationImportJobs = annotationImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OmicsClientTypes.ListAnnotationStoresFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for annotation stores.
    public struct ListAnnotationStoresFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init (
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListAnnotationStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListAnnotationStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListAnnotationStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/annotationStores"
    }
}

public struct ListAnnotationStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListAnnotationStoresFilter?
    /// IDs of stores to list.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.ListAnnotationStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoresInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListAnnotationStoresFilter?
}

extension ListAnnotationStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListAnnotationStoresFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAnnotationStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnnotationStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAnnotationStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnnotationStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAnnotationStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.annotationStores = output.annotationStores
            self.nextToken = output.nextToken
        } else {
            self.annotationStores = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnnotationStoresOutputResponse: Swift.Equatable {
    /// A list of stores.
    public var annotationStores: [OmicsClientTypes.AnnotationStoreItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        annotationStores: [OmicsClientTypes.AnnotationStoreItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.annotationStores = annotationStores
        self.nextToken = nextToken
    }
}

struct ListAnnotationStoresOutputResponseBody: Swift.Equatable {
    let annotationStores: [OmicsClientTypes.AnnotationStoreItem]?
    let nextToken: Swift.String?
}

extension ListAnnotationStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationStores
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationStoreItem?].self, forKey: .annotationStores)
        var annotationStoresDecoded0:[OmicsClientTypes.AnnotationStoreItem]? = nil
        if let annotationStoresContainer = annotationStoresContainer {
            annotationStoresDecoded0 = [OmicsClientTypes.AnnotationStoreItem]()
            for structure0 in annotationStoresContainer {
                if let structure0 = structure0 {
                    annotationStoresDecoded0?.append(structure0)
                }
            }
        }
        annotationStores = annotationStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReadSetActivationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetActivationJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetActivationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjobs"
    }
}

public struct ListReadSetActivationJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ActivateReadSetFilter?
    /// The maximum number of read set activation jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ActivateReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetActivationJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ActivateReadSetFilter?
}

extension ListReadSetActivationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ActivateReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetActivationJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadSetActivationJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReadSetActivationJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadSetActivationJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReadSetActivationJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activationJobs = output.activationJobs
            self.nextToken = output.nextToken
        } else {
            self.activationJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetActivationJobsOutputResponse: Swift.Equatable {
    /// A list of jobs.
    public var activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.activationJobs = activationJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetActivationJobsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let activationJobs: [OmicsClientTypes.ActivateReadSetJobItem]?
}

extension ListReadSetActivationJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let activationJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ActivateReadSetJobItem?].self, forKey: .activationJobs)
        var activationJobsDecoded0:[OmicsClientTypes.ActivateReadSetJobItem]? = nil
        if let activationJobsContainer = activationJobsContainer {
            activationJobsDecoded0 = [OmicsClientTypes.ActivateReadSetJobItem]()
            for structure0 in activationJobsContainer {
                if let structure0 = structure0 {
                    activationJobsDecoded0?.append(structure0)
                }
            }
        }
        activationJobs = activationJobsDecoded0
    }
}

extension ListReadSetExportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetExportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetExportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjobs"
    }
}

public struct ListReadSetExportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ExportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ExportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetExportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ExportReadSetFilter?
}

extension ListReadSetExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ExportReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadSetExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReadSetExportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadSetExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReadSetExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.exportJobs = output.exportJobs
            self.nextToken = output.nextToken
        } else {
            self.exportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetExportJobsOutputResponse: Swift.Equatable {
    /// A list of jobs.
    public var exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.exportJobs = exportJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetExportJobsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let exportJobs: [OmicsClientTypes.ExportReadSetJobDetail]?
}

extension ListReadSetExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let exportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSetJobDetail?].self, forKey: .exportJobs)
        var exportJobsDecoded0:[OmicsClientTypes.ExportReadSetJobDetail]? = nil
        if let exportJobsContainer = exportJobsContainer {
            exportJobsDecoded0 = [OmicsClientTypes.ExportReadSetJobDetail]()
            for structure0 in exportJobsContainer {
                if let structure0 = structure0 {
                    exportJobsDecoded0?.append(structure0)
                }
            }
        }
        exportJobs = exportJobsDecoded0
    }
}

extension ListReadSetImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjobs"
    }
}

public struct ListReadSetImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReadSetFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ImportReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetImportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ImportReadSetFilter?
}

extension ListReadSetImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ImportReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadSetImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReadSetImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadSetImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReadSetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobs = output.importJobs
            self.nextToken = output.nextToken
        } else {
            self.importJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReadSetImportJobsOutputResponse: Swift.Equatable {
    /// A list of jobs.
    public var importJobs: [OmicsClientTypes.ImportReadSetJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        importJobs: [OmicsClientTypes.ImportReadSetJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

struct ListReadSetImportJobsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let importJobs: [OmicsClientTypes.ImportReadSetJobItem]?
}

extension ListReadSetImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let importJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReadSetJobItem?].self, forKey: .importJobs)
        var importJobsDecoded0:[OmicsClientTypes.ImportReadSetJobItem]? = nil
        if let importJobsContainer = importJobsContainer {
            importJobsDecoded0 = [OmicsClientTypes.ImportReadSetJobItem]()
            for structure0 in importJobsContainer {
                if let structure0 = structure0 {
                    importJobsDecoded0?.append(structure0)
                }
            }
        }
        importJobs = importJobsDecoded0
    }
}

extension ListReadSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReadSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReadSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/readsets"
    }
}

public struct ListReadSetsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReadSetFilter?
    /// The maximum number of read sets to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The jobs' sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ReadSetFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sequenceStoreId = sequenceStoreId
    }
}

struct ListReadSetsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReadSetFilter?
}

extension ListReadSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReadSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReadSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReadSetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReadSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReadSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.readSets = output.readSets
        } else {
            self.nextToken = nil
            self.readSets = nil
        }
    }
}

public struct ListReadSetsOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of read sets.
    /// This member is required.
    public var readSets: [OmicsClientTypes.ReadSetListItem]?

    public init (
        nextToken: Swift.String? = nil,
        readSets: [OmicsClientTypes.ReadSetListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.readSets = readSets
    }
}

struct ListReadSetsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let readSets: [OmicsClientTypes.ReadSetListItem]?
}

extension ListReadSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case readSets
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let readSetsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReadSetListItem?].self, forKey: .readSets)
        var readSetsDecoded0:[OmicsClientTypes.ReadSetListItem]? = nil
        if let readSetsContainer = readSetsContainer {
            readSetsDecoded0 = [OmicsClientTypes.ReadSetListItem]()
            for structure0 in readSetsContainer {
                if let structure0 = structure0 {
                    readSetsDecoded0?.append(structure0)
                }
            }
        }
        readSets = readSetsDecoded0
    }
}

extension ListReferenceImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferenceImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferenceImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjobs"
    }
}

public struct ListReferenceImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ImportReferenceFilter?
    /// The maximum number of jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ImportReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

struct ListReferenceImportJobsInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ImportReferenceFilter?
}

extension ListReferenceImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ImportReferenceFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferenceImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReferenceImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReferenceImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReferenceImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReferenceImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.importJobs = output.importJobs
            self.nextToken = output.nextToken
        } else {
            self.importJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListReferenceImportJobsOutputResponse: Swift.Equatable {
    /// A lis of jobs.
    public var importJobs: [OmicsClientTypes.ImportReferenceJobItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        importJobs: [OmicsClientTypes.ImportReferenceJobItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.importJobs = importJobs
        self.nextToken = nextToken
    }
}

struct ListReferenceImportJobsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let importJobs: [OmicsClientTypes.ImportReferenceJobItem]?
}

extension ListReferenceImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case importJobs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let importJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ImportReferenceJobItem?].self, forKey: .importJobs)
        var importJobsDecoded0:[OmicsClientTypes.ImportReferenceJobItem]? = nil
        if let importJobsContainer = importJobsContainer {
            importJobsDecoded0 = [OmicsClientTypes.ImportReferenceJobItem]()
            for structure0 in importJobsContainer {
                if let structure0 = structure0 {
                    importJobsDecoded0?.append(structure0)
                }
            }
        }
        importJobs = importJobsDecoded0
    }
}

extension ListReferenceStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferenceStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferenceStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/referencestores"
    }
}

public struct ListReferenceStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.ReferenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReferenceStoresInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReferenceStoreFilter?
}

extension ListReferenceStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStoreFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferenceStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReferenceStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReferenceStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReferenceStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReferenceStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.referenceStores = output.referenceStores
        } else {
            self.nextToken = nil
            self.referenceStores = nil
        }
    }
}

public struct ListReferenceStoresOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of reference stores.
    /// This member is required.
    public var referenceStores: [OmicsClientTypes.ReferenceStoreDetail]?

    public init (
        nextToken: Swift.String? = nil,
        referenceStores: [OmicsClientTypes.ReferenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.referenceStores = referenceStores
    }
}

struct ListReferenceStoresOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let referenceStores: [OmicsClientTypes.ReferenceStoreDetail]?
}

extension ListReferenceStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case referenceStores
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let referenceStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReferenceStoreDetail?].self, forKey: .referenceStores)
        var referenceStoresDecoded0:[OmicsClientTypes.ReferenceStoreDetail]? = nil
        if let referenceStoresContainer = referenceStoresContainer {
            referenceStoresDecoded0 = [OmicsClientTypes.ReferenceStoreDetail]()
            for structure0 in referenceStoresContainer {
                if let structure0 = structure0 {
                    referenceStoresDecoded0?.append(structure0)
                }
            }
        }
        referenceStores = referenceStoresDecoded0
    }
}

extension ListReferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListReferencesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListReferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/references"
    }
}

public struct ListReferencesInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ReferenceFilter?
    /// The maximum number of references to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The references' reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?

    public init (
        filter: OmicsClientTypes.ReferenceFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.referenceStoreId = referenceStoreId
    }
}

struct ListReferencesInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.ReferenceFilter?
}

extension ListReferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListReferencesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReferencesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListReferencesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReferencesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListReferencesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.references = output.references
        } else {
            self.nextToken = nil
            self.references = nil
        }
    }
}

public struct ListReferencesOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of references.
    /// This member is required.
    public var references: [OmicsClientTypes.ReferenceListItem]?

    public init (
        nextToken: Swift.String? = nil,
        references: [OmicsClientTypes.ReferenceListItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.references = references
    }
}

struct ListReferencesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let references: [OmicsClientTypes.ReferenceListItem]?
}

extension ListReferencesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case references
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let referencesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ReferenceListItem?].self, forKey: .references)
        var referencesDecoded0:[OmicsClientTypes.ReferenceListItem]? = nil
        if let referencesContainer = referencesContainer {
            referencesDecoded0 = [OmicsClientTypes.ReferenceListItem]()
            for structure0 in referencesContainer {
                if let structure0 = structure0 {
                    referencesDecoded0?.append(structure0)
                }
            }
        }
        references = referencesDecoded0
    }
}

extension ListRunGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            return items
        }
    }
}

extension ListRunGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/runGroup"
    }
}

public struct ListRunGroupsInput: Swift.Equatable {
    /// The maximum number of run groups to return in one page of results.
    public var maxResults: Swift.Int?
    /// The run groups' name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
    }
}

struct ListRunGroupsInputBody: Swift.Equatable {
}

extension ListRunGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRunGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRunGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRunGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunGroupsOutputResponse: Swift.Equatable {
    /// A list of groups.
    public var items: [OmicsClientTypes.RunGroupListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        items: [OmicsClientTypes.RunGroupListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunGroupsOutputResponseBody: Swift.Equatable {
    let items: [OmicsClientTypes.RunGroupListItem]?
    let nextToken: Swift.String?
}

extension ListRunGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.RunGroupListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.RunGroupListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.RunGroupListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunTasksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListRunTasksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/run/\(id.urlPercentEncoding())/task"
    }
}

public struct ListRunTasksInput: Swift.Equatable {
    /// The run's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of run tasks to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// Filter the list by status.
    public var status: OmicsClientTypes.TaskStatus?

    public init (
        id: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        startingToken: Swift.String? = nil,
        status: OmicsClientTypes.TaskStatus? = nil
    )
    {
        self.id = id
        self.maxResults = maxResults
        self.startingToken = startingToken
        self.status = status
    }
}

struct ListRunTasksInputBody: Swift.Equatable {
}

extension ListRunTasksInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRunTasksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunTasksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRunTasksOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunTasksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRunTasksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunTasksOutputResponse: Swift.Equatable {
    /// A list of tasks.
    public var items: [OmicsClientTypes.TaskListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        items: [OmicsClientTypes.TaskListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunTasksOutputResponseBody: Swift.Equatable {
    let items: [OmicsClientTypes.TaskListItem]?
    let nextToken: Swift.String?
}

extension ListRunTasksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.TaskListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.TaskListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.TaskListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let runGroupId = runGroupId {
                let runGroupIdQueryItem = ClientRuntime.URLQueryItem(name: "runGroupId".urlPercentEncoding(), value: Swift.String(runGroupId).urlPercentEncoding())
                items.append(runGroupIdQueryItem)
            }
            return items
        }
    }
}

extension ListRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/run"
    }
}

public struct ListRunsInput: Swift.Equatable {
    /// The maximum number of runs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Filter the list by run name.
    public var name: Swift.String?
    /// Filter the list by run group ID.
    public var runGroupId: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        startingToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.runGroupId = runGroupId
        self.startingToken = startingToken
    }
}

struct ListRunsInputBody: Swift.Equatable {
}

extension ListRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRunsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRunsOutputResponse: Swift.Equatable {
    /// A list of runs.
    public var items: [OmicsClientTypes.RunListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        items: [OmicsClientTypes.RunListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRunsOutputResponseBody: Swift.Equatable {
    let items: [OmicsClientTypes.RunListItem]?
    let nextToken: Swift.String?
}

extension ListRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.RunListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.RunListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.RunListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSequenceStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }
}

extension ListSequenceStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSequenceStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/sequencestores"
    }
}

public struct ListSequenceStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.SequenceStoreFilter?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.SequenceStoreFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSequenceStoresInputBody: Swift.Equatable {
    let filter: OmicsClientTypes.SequenceStoreFilter?
}

extension ListSequenceStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceStoreFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListSequenceStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSequenceStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSequenceStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSequenceStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSequenceStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sequenceStores = output.sequenceStores
        } else {
            self.nextToken = nil
            self.sequenceStores = nil
        }
    }
}

public struct ListSequenceStoresOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of sequence stores.
    /// This member is required.
    public var sequenceStores: [OmicsClientTypes.SequenceStoreDetail]?

    public init (
        nextToken: Swift.String? = nil,
        sequenceStores: [OmicsClientTypes.SequenceStoreDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.sequenceStores = sequenceStores
    }
}

struct ListSequenceStoresOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let sequenceStores: [OmicsClientTypes.SequenceStoreDetail]?
}

extension ListSequenceStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case sequenceStores
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sequenceStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.SequenceStoreDetail?].self, forKey: .sequenceStores)
        var sequenceStoresDecoded0:[OmicsClientTypes.SequenceStoreDetail]? = nil
        if let sequenceStoresContainer = sequenceStoresContainer {
            sequenceStoresDecoded0 = [OmicsClientTypes.SequenceStoreDetail]()
            for structure0 in sequenceStoresContainer {
                if let structure0 = structure0 {
                    sequenceStoresDecoded0?.append(structure0)
                }
            }
        }
        sequenceStores = sequenceStoresDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes.ListVariantImportJobsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case storeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let storeName = self.storeName {
            try encodeContainer.encode(storeName, forKey: .storeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let storeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeName)
        storeName = storeNameDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for variant import jobs.
    public struct ListVariantImportJobsFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.JobStatus?
        /// A store name to filter on.
        public var storeName: Swift.String?

        public init (
            status: OmicsClientTypes.JobStatus? = nil,
            storeName: Swift.String? = nil
        )
        {
            self.status = status
            self.storeName = storeName
        }
    }

}

extension ListVariantImportJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListVariantImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListVariantImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/variants"
    }
}

public struct ListVariantImportJobsInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantImportJobsFilter?
    /// A list of job IDs.
    public var ids: [Swift.String]?
    /// The maximum number of import jobs to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.ListVariantImportJobsFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVariantImportJobsInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListVariantImportJobsFilter?
}

extension ListVariantImportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListVariantImportJobsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListVariantImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVariantImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVariantImportJobsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVariantImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVariantImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variantImportJobs = output.variantImportJobs
        } else {
            self.nextToken = nil
            self.variantImportJobs = nil
        }
    }
}

public struct ListVariantImportJobsOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of jobs.
    public var variantImportJobs: [OmicsClientTypes.VariantImportJobItem]?

    public init (
        nextToken: Swift.String? = nil,
        variantImportJobs: [OmicsClientTypes.VariantImportJobItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantImportJobs = variantImportJobs
    }
}

struct ListVariantImportJobsOutputResponseBody: Swift.Equatable {
    let variantImportJobs: [OmicsClientTypes.VariantImportJobItem]?
    let nextToken: Swift.String?
}

extension ListVariantImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variantImportJobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantImportJobsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportJobItem?].self, forKey: .variantImportJobs)
        var variantImportJobsDecoded0:[OmicsClientTypes.VariantImportJobItem]? = nil
        if let variantImportJobsContainer = variantImportJobsContainer {
            variantImportJobsDecoded0 = [OmicsClientTypes.VariantImportJobItem]()
            for structure0 in variantImportJobsContainer {
                if let structure0 = structure0 {
                    variantImportJobsDecoded0?.append(structure0)
                }
            }
        }
        variantImportJobs = variantImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OmicsClientTypes.ListVariantStoresFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for variant stores.
    public struct ListVariantStoresFilter: Swift.Equatable {
        /// A status to filter on.
        public var status: OmicsClientTypes.StoreStatus?

        public init (
            status: OmicsClientTypes.StoreStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension ListVariantStoresInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for resourceidentifier0 in ids {
                try idsContainer.encode(resourceidentifier0)
            }
        }
    }
}

extension ListVariantStoresInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListVariantStoresInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/variantStores"
    }
}

public struct ListVariantStoresInput: Swift.Equatable {
    /// A filter to apply to the list.
    public var filter: OmicsClientTypes.ListVariantStoresFilter?
    /// A list of store IDs.
    public var ids: [Swift.String]?
    /// The maximum number of stores to return in one page of results.
    public var maxResults: Swift.Int?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        filter: OmicsClientTypes.ListVariantStoresFilter? = nil,
        ids: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.ids = ids
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListVariantStoresInputBody: Swift.Equatable {
    let ids: [Swift.String]?
    let filter: OmicsClientTypes.ListVariantStoresFilter?
}

extension ListVariantStoresInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case ids
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ids)
        var idsDecoded0:[Swift.String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [Swift.String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ListVariantStoresFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListVariantStoresOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVariantStoresOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListVariantStoresOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVariantStoresOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListVariantStoresOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.variantStores = output.variantStores
        } else {
            self.nextToken = nil
            self.variantStores = nil
        }
    }
}

public struct ListVariantStoresOutputResponse: Swift.Equatable {
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?
    /// A list of variant stores.
    public var variantStores: [OmicsClientTypes.VariantStoreItem]?

    public init (
        nextToken: Swift.String? = nil,
        variantStores: [OmicsClientTypes.VariantStoreItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.variantStores = variantStores
    }
}

struct ListVariantStoresOutputResponseBody: Swift.Equatable {
    let variantStores: [OmicsClientTypes.VariantStoreItem]?
    let nextToken: Swift.String?
}

extension ListVariantStoresOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case variantStores
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantStoresContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantStoreItem?].self, forKey: .variantStores)
        var variantStoresDecoded0:[OmicsClientTypes.VariantStoreItem]? = nil
        if let variantStoresContainer = variantStoresContainer {
            variantStoresDecoded0 = [OmicsClientTypes.VariantStoreItem]()
            for structure0 in variantStoresContainer {
                if let structure0 = structure0 {
                    variantStoresDecoded0?.append(structure0)
                }
            }
        }
        variantStores = variantStoresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWorkflowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startingToken = startingToken {
                let startingTokenQueryItem = ClientRuntime.URLQueryItem(name: "startingToken".urlPercentEncoding(), value: Swift.String(startingToken).urlPercentEncoding())
                items.append(startingTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let name = name {
                let nameQueryItem = ClientRuntime.URLQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
                items.append(nameQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            return items
        }
    }
}

extension ListWorkflowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workflow"
    }
}

public struct ListWorkflowsInput: Swift.Equatable {
    /// The maximum number of workflows to return in one page of results.
    public var maxResults: Swift.Int?
    /// The workflows' name.
    public var name: Swift.String?
    /// Specify the pagination token from a previous request to retrieve the next page of results.
    public var startingToken: Swift.String?
    /// The workflows' type.
    public var type: OmicsClientTypes.WorkflowType?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        startingToken: Swift.String? = nil,
        type: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.startingToken = startingToken
        self.type = type
    }
}

struct ListWorkflowsInputBody: Swift.Equatable {
}

extension ListWorkflowsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListWorkflowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWorkflowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWorkflowsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWorkflowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWorkflowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWorkflowsOutputResponse: Swift.Equatable {
    /// The workflows' items.
    public var items: [OmicsClientTypes.WorkflowListItem]?
    /// A pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        items: [OmicsClientTypes.WorkflowListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWorkflowsOutputResponseBody: Swift.Equatable {
    let items: [OmicsClientTypes.WorkflowListItem]?
    let nextToken: Swift.String?
}

extension ListWorkflowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.WorkflowListItem?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.WorkflowListItem]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.WorkflowListItem]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension RangeNotSatisfiableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RangeNotSatisfiableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ranges specified in the request are not valid.
public struct RangeNotSatisfiableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RangeNotSatisfiableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RangeNotSatisfiableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.ReadOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comment
        case encoding
        case escape
        case escapeQuotes
        case header
        case lineSep
        case quote
        case quoteAll
        case sep
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = self.comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let encoding = self.encoding {
            try encodeContainer.encode(encoding, forKey: .encoding)
        }
        if let escape = self.escape {
            try encodeContainer.encode(escape, forKey: .escape)
        }
        if escapeQuotes != false {
            try encodeContainer.encode(escapeQuotes, forKey: .escapeQuotes)
        }
        if header != false {
            try encodeContainer.encode(header, forKey: .header)
        }
        if let lineSep = self.lineSep {
            try encodeContainer.encode(lineSep, forKey: .lineSep)
        }
        if let quote = self.quote {
            try encodeContainer.encode(quote, forKey: .quote)
        }
        if quoteAll != false {
            try encodeContainer.encode(quoteAll, forKey: .quoteAll)
        }
        if let sep = self.sep {
            try encodeContainer.encode(sep, forKey: .sep)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sep)
        sep = sepDecoded
        let encodingDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoding)
        encoding = encodingDecoded
        let quoteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quote)
        quote = quoteDecoded
        let quoteAllDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .quoteAll) ?? false
        quoteAll = quoteAllDecoded
        let escapeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .escape)
        escape = escapeDecoded
        let escapeQuotesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .escapeQuotes) ?? false
        escapeQuotes = escapeQuotesDecoded
        let commentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comment)
        comment = commentDecoded
        let headerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .header) ?? false
        header = headerDecoded
        let lineSepDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lineSep)
        lineSep = lineSepDecoded
    }
}

extension OmicsClientTypes {
    /// Read options for an annotation import job.
    public struct ReadOptions: Swift.Equatable {
        /// The file's comment character.
        public var comment: Swift.String?
        /// The file's encoding.
        public var encoding: Swift.String?
        /// A character for escaping quotes in the file.
        public var escape: Swift.String?
        /// Whether quotes need to be escaped in the file.
        public var escapeQuotes: Swift.Bool
        /// Whether the file has a header row.
        public var header: Swift.Bool
        /// A line separator for the file.
        public var lineSep: Swift.String?
        /// The file's quote character.
        public var quote: Swift.String?
        /// Whether all values need to be quoted, or just those that contain quotes.
        public var quoteAll: Swift.Bool
        /// The file's field separator.
        public var sep: Swift.String?

        public init (
            comment: Swift.String? = nil,
            encoding: Swift.String? = nil,
            escape: Swift.String? = nil,
            escapeQuotes: Swift.Bool = false,
            header: Swift.Bool = false,
            lineSep: Swift.String? = nil,
            quote: Swift.String? = nil,
            quoteAll: Swift.Bool = false,
            sep: Swift.String? = nil
        )
        {
            self.comment = comment
            self.encoding = encoding
            self.escape = escape
            self.escapeQuotes = escapeQuotes
            self.header = header
            self.lineSep = lineSep
            self.quote = quote
            self.quoteAll = quoteAll
            self.sep = sep
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetActivationJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetActivationJobItemStatus(rawValue: rawValue) ?? ReadSetActivationJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetActivationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetActivationJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetActivationJobStatus(rawValue: rawValue) ?? ReadSetActivationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetBatchError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case id
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    /// An error from a batch read set operation.
    public struct ReadSetBatchError: Swift.Equatable {
        /// The error's code.
        /// This member is required.
        public var code: Swift.String?
        /// The error's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The error's message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: Swift.String? = nil,
            id: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.id = id
            self.message = message
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetExportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetExportJobItemStatus(rawValue: rawValue) ?? ReadSetExportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetExportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetExportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetExportJobStatus(rawValue: rawValue) ?? ReadSetExportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case source1
        case source2
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetFile] {
            return [
                .index,
                .source1,
                .source2,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source1: return "SOURCE1"
            case .source2: return "SOURCE2"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetFile(rawValue: rawValue) ?? ReadSetFile.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case source1
        case source2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let source1 = self.source1 {
            try encodeContainer.encode(source1, forKey: .source1)
        }
        if let source2 = self.source2 {
            try encodeContainer.encode(source2, forKey: .source2)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let source1Decoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source1)
        source1 = source1Decoded
        let source2Decoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source2)
        source2 = source2Decoded
        let indexDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .index)
        index = indexDecoded
    }
}

extension OmicsClientTypes {
    /// Files in a read set.
    public struct ReadSetFiles: Swift.Equatable {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The location of the first file in Amazon S3.
        public var source1: OmicsClientTypes.FileInformation?
        /// The location of the second file in Amazon S3.
        public var source2: OmicsClientTypes.FileInformation?

        public init (
            index: OmicsClientTypes.FileInformation? = nil,
            source1: OmicsClientTypes.FileInformation? = nil,
            source2: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.ReadSetFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case name
        case referenceArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for read sets.
    public struct ReadSetFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A name to filter on.
        public var name: Swift.String?
        /// A genome reference ARN to filter on.
        public var referenceArn: Swift.String?
        /// A status to filter on.
        public var status: OmicsClientTypes.ReadSetStatus?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
            self.referenceArn = referenceArn
            self.status = status
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetImportJobItemStatus(rawValue: rawValue) ?? ReadSetImportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReadSetImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetImportJobStatus(rawValue: rawValue) ?? ReadSetImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReadSetListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case fileType
        case id
        case name
        case referenceArn
        case sampleId
        case sequenceInformation
        case sequenceStoreId
        case status
        case subjectId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fileType = self.fileType {
            try encodeContainer.encode(fileType.rawValue, forKey: .fileType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sequenceInformation = self.sequenceInformation {
            try encodeContainer.encode(sequenceInformation, forKey: .sequenceInformation)
        }
        if let sequenceStoreId = self.sequenceStoreId {
            try encodeContainer.encode(sequenceStoreId, forKey: .sequenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let fileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .fileType)
        fileType = fileTypeDecoded
        let sequenceInformationDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SequenceInformation.self, forKey: .sequenceInformation)
        sequenceInformation = sequenceInformationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A read set.
    public struct ReadSetListItem: Swift.Equatable {
        /// The read set's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the read set was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The read set's description.
        public var description: Swift.String?
        /// The read set's file type.
        /// This member is required.
        public var fileType: OmicsClientTypes.FileType?
        /// The read set's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The read set's name.
        public var name: Swift.String?
        /// The read set's genome reference ARN.
        public var referenceArn: Swift.String?
        /// The read set's sample ID.
        public var sampleId: Swift.String?
        /// Details about a sequence.
        public var sequenceInformation: OmicsClientTypes.SequenceInformation?
        /// The read set's sequence store ID.
        /// This member is required.
        public var sequenceStoreId: Swift.String?
        /// The read set's status.
        /// This member is required.
        public var status: OmicsClientTypes.ReadSetStatus?
        /// The read set's subject ID.
        public var subjectId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            fileType: OmicsClientTypes.FileType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sequenceInformation: OmicsClientTypes.SequenceInformation? = nil,
            sequenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReadSetStatus? = nil,
            subjectId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.fileType = fileType
            self.id = id
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sequenceInformation = sequenceInformation
            self.sequenceStoreId = sequenceStoreId
            self.status = status
            self.subjectId = subjectId
        }
    }

}

extension OmicsClientTypes {
    public enum ReadSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case archived
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReadSetStatus] {
            return [
                .activating,
                .active,
                .archived,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .archived: return "ARCHIVED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReadSetStatus(rawValue: rawValue) ?? ReadSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReferenceFile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case index
        case source
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceFile] {
            return [
                .index,
                .source,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .index: return "INDEX"
            case .source: return "SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceFile(rawValue: rawValue) ?? ReferenceFile.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case index
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let index = self.index {
            try encodeContainer.encode(index, forKey: .index)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .source)
        source = sourceDecoded
        let indexDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileInformation.self, forKey: .index)
        index = indexDecoded
    }
}

extension OmicsClientTypes {
    /// A set of genome reference files.
    public struct ReferenceFiles: Swift.Equatable {
        /// The files' index.
        public var index: OmicsClientTypes.FileInformation?
        /// The source file's location in Amazon S3.
        public var source: OmicsClientTypes.FileInformation?

        public init (
            index: OmicsClientTypes.FileInformation? = nil,
            source: OmicsClientTypes.FileInformation? = nil
        )
        {
            self.index = index
            self.source = source
        }
    }

}

extension OmicsClientTypes.ReferenceFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case md5
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let md5 = self.md5 {
            try encodeContainer.encode(md5, forKey: .md5)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for references.
    public struct ReferenceFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// An MD5 checksum to filter on.
        public var md5: Swift.String?
        /// A name to filter on.
        public var name: Swift.String?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.md5 = md5
            self.name = name
        }
    }

}

extension OmicsClientTypes {
    public enum ReferenceImportJobItemStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case finished
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobItemStatus] {
            return [
                .failed,
                .finished,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .finished: return "FINISHED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceImportJobItemStatus(rawValue: rawValue) ?? ReferenceImportJobItemStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum ReferenceImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case completed
        case completedWithFailures
        case failed
        case inProgress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceImportJobStatus] {
            return [
                .cancelled,
                .cancelling,
                .completed,
                .completedWithFailures,
                .failed,
                .inProgress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceImportJobStatus(rawValue: rawValue) ?? ReferenceImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referencearn = "referenceArn"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .referencearn(referencearn):
                try container.encode(referencearn, forKey: .referencearn)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let referencearnDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .referencearn)
        if let referencearn = referencearnDecoded {
            self = .referencearn(referencearn)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public enum ReferenceItem: Swift.Equatable, Swift.Hashable {
        /// The reference's ARN.
        case referencearn(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes.ReferenceListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case md5
        case name
        case referenceStoreId
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let md5 = self.md5 {
            try encodeContainer.encode(md5, forKey: .md5)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceStoreId = self.referenceStoreId {
            try encodeContainer.encode(referenceStoreId, forKey: .referenceStoreId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let md5Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .md5)
        md5 = md5Decoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A genome reference.
    public struct ReferenceListItem: Swift.Equatable {
        /// The reference's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the reference was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The reference's description.
        public var description: Swift.String?
        /// The reference's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The reference's MD5 checksum.
        /// This member is required.
        public var md5: Swift.String?
        /// The reference's name.
        public var name: Swift.String?
        /// The reference's store ID.
        /// This member is required.
        public var referenceStoreId: Swift.String?
        /// The reference's status.
        public var status: OmicsClientTypes.ReferenceStatus?
        /// When the reference was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            md5: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceStoreId: Swift.String? = nil,
            status: OmicsClientTypes.ReferenceStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.md5 = md5
            self.name = name
            self.referenceStoreId = referenceStoreId
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes {
    public enum ReferenceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [ReferenceStatus] {
            return [
                .active,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReferenceStatus(rawValue: rawValue) ?? ReferenceStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.ReferenceStoreDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a reference store.
    public struct ReferenceStoreDetail: Swift.Equatable {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.ReferenceStoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for reference stores.
    public struct ReferenceStoreFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// The name to filter on.
        public var name: Swift.String?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension RequestTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request timed out.
public struct RequestTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The target resource was not found in the current Region.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes {
    public enum RunExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [RunExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunExport(rawValue: rawValue) ?? RunExport.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.RunGroupListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case maxCpus
        case maxDuration
        case maxRuns
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A run group.
    public struct RunGroupListItem: Swift.Equatable {
        /// The group's ARN.
        public var arn: Swift.String?
        /// When the group was created.
        public var creationTime: ClientRuntime.Date?
        /// The group's ID.
        public var id: Swift.String?
        /// The group's maximum CPU count setting.
        public var maxCpus: Swift.Int?
        /// The group's maximum duration setting.
        public var maxDuration: Swift.Int?
        /// The group's maximum concurrent run setting.
        public var maxRuns: Swift.Int?
        /// The group's name.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            maxCpus: Swift.Int? = nil,
            maxDuration: Swift.Int? = nil,
            maxRuns: Swift.Int? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.maxCpus = maxCpus
            self.maxDuration = maxDuration
            self.maxRuns = maxRuns
            self.name = name
        }
    }

}

extension OmicsClientTypes.RunListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case id
        case name
        case priority
        case startTime
        case status
        case stopTime
        case storageCapacity
        case workflowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .dateTime, forKey: .stopTime)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow run.
    public struct RunListItem: Swift.Equatable {
        /// The run's ARN.
        public var arn: Swift.String?
        /// When the run was created.
        public var creationTime: ClientRuntime.Date?
        /// The run's ID.
        public var id: Swift.String?
        /// The run's name.
        public var name: Swift.String?
        /// The run's priority.
        public var priority: Swift.Int?
        /// When the run started.
        public var startTime: ClientRuntime.Date?
        /// The run's status.
        public var status: OmicsClientTypes.RunStatus?
        /// When the run stopped.
        public var stopTime: ClientRuntime.Date?
        /// The run's storage capacity.
        public var storageCapacity: Swift.Int?
        /// The run's workflow ID.
        public var workflowId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            priority: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.RunStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            storageCapacity: Swift.Int? = nil,
            workflowId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.id = id
            self.name = name
            self.priority = priority
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.storageCapacity = storageCapacity
            self.workflowId = workflowId
        }
    }

}

extension OmicsClientTypes {
    public enum RunLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case error
        case fatal
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [RunLogLevel] {
            return [
                .all,
                .error,
                .fatal,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunLogLevel(rawValue: rawValue) ?? RunLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum RunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case deleted
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [RunStatus] {
            return [
                .cancelled,
                .completed,
                .deleted,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunStatus(rawValue: rawValue) ?? RunStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum SchemaValueType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// BOOLEAN type
        case boolean
        /// DOUBLE type
        case double
        /// FLOAT type
        case float
        /// INT type
        case int
        /// LONG type
        case long
        /// STRING type
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaValueType] {
            return [
                .boolean,
                .double,
                .float,
                .int,
                .long,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .int: return "INT"
            case .long: return "LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaValueType(rawValue: rawValue) ?? SchemaValueType.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.SequenceInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alignment
        case generatedFrom
        case totalBaseCount
        case totalReadCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alignment = self.alignment {
            try encodeContainer.encode(alignment, forKey: .alignment)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let totalBaseCount = self.totalBaseCount {
            try encodeContainer.encode(totalBaseCount, forKey: .totalBaseCount)
        }
        if let totalReadCount = self.totalReadCount {
            try encodeContainer.encode(totalReadCount, forKey: .totalReadCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalReadCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalReadCount)
        totalReadCount = totalReadCountDecoded
        let totalBaseCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBaseCount)
        totalBaseCount = totalBaseCountDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let alignmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alignment)
        alignment = alignmentDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a sequence.
    public struct SequenceInformation: Swift.Equatable {
        /// The sequence's alignment setting.
        public var alignment: Swift.String?
        /// Where the sequence originated.
        public var generatedFrom: Swift.String?
        /// The sequence's total base count.
        public var totalBaseCount: Swift.Int?
        /// The sequence's total read count.
        public var totalReadCount: Swift.Int?

        public init (
            alignment: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            totalBaseCount: Swift.Int? = nil,
            totalReadCount: Swift.Int? = nil
        )
        {
            self.alignment = alignment
            self.generatedFrom = generatedFrom
            self.totalBaseCount = totalBaseCount
            self.totalReadCount = totalReadCount
        }
    }

}

extension OmicsClientTypes.SequenceStoreDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case description
        case id
        case name
        case sseConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// Details about a sequence store.
    public struct SequenceStoreDetail: Swift.Equatable {
        /// The store's ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        public var name: Swift.String?
        /// The store's server-side encryption (SSE) settings.
        public var sseConfig: OmicsClientTypes.SseConfig?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.sseConfig = sseConfig
        }
    }

}

extension OmicsClientTypes.SequenceStoreFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAfter
        case createdBefore
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAfter = self.createdAfter {
            try encodeContainer.encodeTimestamp(createdAfter, format: .dateTime, forKey: .createdAfter)
        }
        if let createdBefore = self.createdBefore {
            try encodeContainer.encodeTimestamp(createdBefore, format: .dateTime, forKey: .createdBefore)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAfterDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAfter)
        createdAfter = createdAfterDecoded
        let createdBeforeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdBefore)
        createdBefore = createdBeforeDecoded
    }
}

extension OmicsClientTypes {
    /// A filter for a sequence store.
    public struct SequenceStoreFilter: Swift.Equatable {
        /// The filter's start date.
        public var createdAfter: ClientRuntime.Date?
        /// The filter's end date.
        public var createdBefore: ClientRuntime.Date?
        /// A name to filter on.
        public var name: Swift.String?

        public init (
            createdAfter: ClientRuntime.Date? = nil,
            createdBefore: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdAfter = createdAfter
            self.createdBefore = createdBefore
            self.name = name
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds a service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.SourceFiles: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source1
        case source2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source1 = self.source1 {
            try encodeContainer.encode(source1, forKey: .source1)
        }
        if let source2 = self.source2 {
            try encodeContainer.encode(source2, forKey: .source2)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let source1Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source1)
        source1 = source1Decoded
        let source2Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source2)
        source2 = source2Decoded
    }
}

extension OmicsClientTypes {
    /// Source files for a sequence.
    public struct SourceFiles: Swift.Equatable {
        /// The location of the first file in Amazon S3.
        /// This member is required.
        public var source1: Swift.String?
        /// The location of the second file in Amazon S3.
        public var source2: Swift.String?

        public init (
            source1: Swift.String? = nil,
            source2: Swift.String? = nil
        )
        {
            self.source1 = source1
            self.source2 = source2
        }
    }

}

extension OmicsClientTypes.SseConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyArn = self.keyArn {
            try encodeContainer.encode(keyArn, forKey: .keyArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.EncryptionType.self, forKey: .type)
        type = typeDecoded
        let keyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyArn)
        keyArn = keyArnDecoded
    }
}

extension OmicsClientTypes {
    /// Server-side encryption (SSE) settings for a store.
    public struct SseConfig: Swift.Equatable {
        /// An encryption key ARN.
        public var keyArn: Swift.String?
        /// The encryption type.
        /// This member is required.
        public var type: OmicsClientTypes.EncryptionType?

        public init (
            keyArn: Swift.String? = nil,
            type: OmicsClientTypes.EncryptionType? = nil
        )
        {
            self.keyArn = keyArn
            self.type = type
        }
    }

}

extension StartAnnotationImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName
        case formatOptions
        case items
        case roleArn
        case runLeftNormalization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let formatOptions = self.formatOptions {
            try encodeContainer.encode(formatOptions, forKey: .formatOptions)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for annotationimportitemsource0 in items {
                try itemsContainer.encode(annotationimportitemsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runLeftNormalization = self.runLeftNormalization {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
    }
}

extension StartAnnotationImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/annotation"
    }
}

public struct StartAnnotationImportJobInput: Swift.Equatable {
    /// A destination annotation store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Formatting options for the annotation file.
    public var formatOptions: OmicsClientTypes.FormatOptions?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.AnnotationImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?

    public init (
        destinationName: Swift.String? = nil,
        formatOptions: OmicsClientTypes.FormatOptions? = nil,
        items: [OmicsClientTypes.AnnotationImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil
    )
    {
        self.destinationName = destinationName
        self.formatOptions = formatOptions
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
    }
}

struct StartAnnotationImportJobInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let items: [OmicsClientTypes.AnnotationImportItemSource]?
    let formatOptions: OmicsClientTypes.FormatOptions?
    let runLeftNormalization: Swift.Bool?
}

extension StartAnnotationImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName
        case formatOptions
        case items
        case roleArn
        case runLeftNormalization
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.AnnotationImportItemSource?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.AnnotationImportItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.AnnotationImportItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let formatOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FormatOptions.self, forKey: .formatOptions)
        formatOptions = formatOptionsDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization)
        runLeftNormalization = runLeftNormalizationDecoded
    }
}

extension StartAnnotationImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAnnotationImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAnnotationImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAnnotationImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartAnnotationImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartAnnotationImportJobOutputResponse: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartAnnotationImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartAnnotationImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension StartReadSetActivationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreadsetactivationjobsourceitem0 in sources {
                try sourcesContainer.encode(startreadsetactivationjobsourceitem0)
            }
        }
    }
}

extension StartReadSetActivationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/activationjob"
    }
}

public struct StartReadSetActivationJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's sources.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]?

    public init (
        clientToken: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetActivationJobInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReadSetActivationJobSourceItem]?
}

extension StartReadSetActivationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReadSetActivationJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReadSetActivationJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReadSetActivationJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetActivationJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReadSetActivationJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReadSetActivationJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReadSetActivationJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReadSetActivationJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetActivationJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetActivationJobStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetActivationJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetActivationJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let status: OmicsClientTypes.ReadSetActivationJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetActivationJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case sequenceStoreId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetActivationJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes.StartReadSetActivationJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readSetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readSetId = self.readSetId {
            try encodeContainer.encode(readSetId, forKey: .readSetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readSetId)
        readSetId = readSetIdDecoded
    }
}

extension OmicsClientTypes {
    /// A source for a read set activation job.
    public struct StartReadSetActivationJobSourceItem: Swift.Equatable {
        /// The source's read set ID.
        /// This member is required.
        public var readSetId: Swift.String?

        public init (
            readSetId: Swift.String? = nil
        )
        {
            self.readSetId = readSetId
        }
    }

}

extension StartReadSetExportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destination
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destination = self.destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for exportreadset0 in sources {
                try sourcesContainer.encode(exportreadset0)
            }
        }
    }
}

extension StartReadSetExportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/exportjob"
    }
}

public struct StartReadSetExportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A location for exported files in Amazon S3.
    /// This member is required.
    public var destination: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// Sources for the job.
    /// This member is required.
    public var sources: [OmicsClientTypes.ExportReadSet]?

    public init (
        clientToken: Swift.String? = nil,
        destination: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.ExportReadSet]? = nil
    )
    {
        self.clientToken = clientToken
        self.destination = destination
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetExportJobInputBody: Swift.Equatable {
    let destination: Swift.String?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.ExportReadSet]?
}

extension StartReadSetExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case destination
        case roleArn
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.ExportReadSet?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.ExportReadSet]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.ExportReadSet]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReadSetExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReadSetExportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReadSetExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReadSetExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.id = output.id
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.id = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetExportJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's output location.
    /// This member is required.
    public var destination: Swift.String?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetExportJobStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        destination: Swift.String? = nil,
        id: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetExportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.id = id
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetExportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let destination: Swift.String?
    let status: OmicsClientTypes.ReadSetExportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case destination
        case id
        case sequenceStoreId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetExportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension StartReadSetImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreadsetimportjobsourceitem0 in sources {
                try sourcesContainer.encode(startreadsetimportjobsourceitem0)
            }
        }
    }
}

extension StartReadSetImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let sequenceStoreId = sequenceStoreId else {
            return nil
        }
        return "/sequencestore/\(sequenceStoreId.urlPercentEncoding())/importjob"
    }
}

public struct StartReadSetImportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// Source files to import.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]?

    public init (
        clientToken: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.sources = sources
    }
}

struct StartReadSetImportJobInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReadSetImportJobSourceItem]?
}

extension StartReadSetImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReadSetImportJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReadSetImportJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReadSetImportJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReadSetImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReadSetImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReadSetImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReadSetImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReadSetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.roleArn = output.roleArn
            self.sequenceStoreId = output.sequenceStoreId
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.roleArn = nil
            self.sequenceStoreId = nil
            self.status = nil
        }
    }
}

public struct StartReadSetImportJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The read set's sequence store ID.
    /// This member is required.
    public var sequenceStoreId: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReadSetImportJobStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sequenceStoreId: Swift.String? = nil,
        status: OmicsClientTypes.ReadSetImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.sequenceStoreId = sequenceStoreId
        self.status = status
    }
}

struct StartReadSetImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let sequenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReadSetImportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReadSetImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case roleArn
        case sequenceStoreId
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sequenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sequenceStoreId)
        sequenceStoreId = sequenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadSetImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes.StartReadSetImportJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case generatedFrom
        case name
        case referenceArn
        case sampleId
        case sourceFileType
        case sourceFiles
        case subjectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let generatedFrom = self.generatedFrom {
            try encodeContainer.encode(generatedFrom, forKey: .generatedFrom)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let referenceArn = self.referenceArn {
            try encodeContainer.encode(referenceArn, forKey: .referenceArn)
        }
        if let sampleId = self.sampleId {
            try encodeContainer.encode(sampleId, forKey: .sampleId)
        }
        if let sourceFileType = self.sourceFileType {
            try encodeContainer.encode(sourceFileType.rawValue, forKey: .sourceFileType)
        }
        if let sourceFiles = self.sourceFiles {
            try encodeContainer.encode(sourceFiles, forKey: .sourceFiles)
        }
        if let subjectId = self.subjectId {
            try encodeContainer.encode(subjectId, forKey: .subjectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFilesDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SourceFiles.self, forKey: .sourceFiles)
        sourceFiles = sourceFilesDecoded
        let sourceFileTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.FileType.self, forKey: .sourceFileType)
        sourceFileType = sourceFileTypeDecoded
        let subjectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subjectId)
        subjectId = subjectIdDecoded
        let sampleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sampleId)
        sampleId = sampleIdDecoded
        let generatedFromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .generatedFrom)
        generatedFrom = generatedFromDecoded
        let referenceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceArn)
        referenceArn = referenceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for a read set import job.
    public struct StartReadSetImportJobSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// Where the source originated.
        public var generatedFrom: Swift.String?
        /// The source's name.
        public var name: Swift.String?
        /// The source's reference ARN.
        /// This member is required.
        public var referenceArn: Swift.String?
        /// The source's sample ID.
        /// This member is required.
        public var sampleId: Swift.String?
        /// The source's file type.
        /// This member is required.
        public var sourceFileType: OmicsClientTypes.FileType?
        /// The source files' location in Amazon S3.
        /// This member is required.
        public var sourceFiles: OmicsClientTypes.SourceFiles?
        /// The source's subject ID.
        /// This member is required.
        public var subjectId: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            generatedFrom: Swift.String? = nil,
            name: Swift.String? = nil,
            referenceArn: Swift.String? = nil,
            sampleId: Swift.String? = nil,
            sourceFileType: OmicsClientTypes.FileType? = nil,
            sourceFiles: OmicsClientTypes.SourceFiles? = nil,
            subjectId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.generatedFrom = generatedFrom
            self.name = name
            self.referenceArn = referenceArn
            self.sampleId = sampleId
            self.sourceFileType = sourceFileType
            self.sourceFiles = sourceFiles
            self.subjectId = subjectId
            self.tags = tags
        }
    }

}

extension StartReferenceImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for startreferenceimportjobsourceitem0 in sources {
                try sourcesContainer.encode(startreferenceimportjobsourceitem0)
            }
        }
    }
}

extension StartReferenceImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let referenceStoreId = referenceStoreId else {
            return nil
        }
        return "/referencestore/\(referenceStoreId.urlPercentEncoding())/importjob"
    }
}

public struct StartReferenceImportJobInput: Swift.Equatable {
    /// To ensure that jobs don't run multiple times, specify a unique token for each job.
    public var clientToken: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// Sources for the job.
    /// This member is required.
    public var sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]?

    public init (
        clientToken: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]? = nil
    )
    {
        self.clientToken = clientToken
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.sources = sources
    }
}

struct StartReferenceImportJobInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let sources: [OmicsClientTypes.StartReferenceImportJobSourceItem]?
}

extension StartReferenceImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case roleArn
        case sources
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([OmicsClientTypes.StartReferenceImportJobSourceItem?].self, forKey: .sources)
        var sourcesDecoded0:[OmicsClientTypes.StartReferenceImportJobSourceItem]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [OmicsClientTypes.StartReferenceImportJobSourceItem]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension StartReferenceImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReferenceImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReferenceImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReferenceImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReferenceImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.id = output.id
            self.referenceStoreId = output.referenceStoreId
            self.roleArn = output.roleArn
            self.status = output.status
        } else {
            self.creationTime = nil
            self.id = nil
            self.referenceStoreId = nil
            self.roleArn = nil
            self.status = nil
        }
    }
}

public struct StartReferenceImportJobOutputResponse: Swift.Equatable {
    /// When the job was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The job's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The job's reference store ID.
    /// This member is required.
    public var referenceStoreId: Swift.String?
    /// The job's service role ARN.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's status.
    /// This member is required.
    public var status: OmicsClientTypes.ReferenceImportJobStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        referenceStoreId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        status: OmicsClientTypes.ReferenceImportJobStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.id = id
        self.referenceStoreId = referenceStoreId
        self.roleArn = roleArn
        self.status = status
    }
}

struct StartReferenceImportJobOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let referenceStoreId: Swift.String?
    let roleArn: Swift.String?
    let status: OmicsClientTypes.ReferenceImportJobStatus?
    let creationTime: ClientRuntime.Date?
}

extension StartReferenceImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case id
        case referenceStoreId
        case roleArn
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .referenceStoreId)
        referenceStoreId = referenceStoreIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceImportJobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes.StartReferenceImportJobSourceItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case sourceFile
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceFile = self.sourceFile {
            try encodeContainer.encode(sourceFile, forKey: .sourceFile)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceFile)
        sourceFile = sourceFileDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension OmicsClientTypes {
    /// A source for a reference import job.
    public struct StartReferenceImportJobSourceItem: Swift.Equatable {
        /// The source's description.
        public var description: Swift.String?
        /// The source's name.
        /// This member is required.
        public var name: Swift.String?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var sourceFile: Swift.String?
        /// The source's tags.
        public var tags: [Swift.String:Swift.String]?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceFile: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.description = description
            self.name = name
            self.sourceFile = sourceFile
            self.tags = tags
        }
    }

}

extension StartRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case requestId
        case roleArn
        case runGroupId
        case runId
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = self.logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputUri = self.outputUri {
            try encodeContainer.encode(outputUri, forKey: .outputUri)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let priority = self.priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runGroupId = self.runGroupId {
            try encodeContainer.encode(runGroupId, forKey: .runGroupId)
        }
        if let runId = self.runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let storageCapacity = self.storageCapacity {
            try encodeContainer.encode(storageCapacity, forKey: .storageCapacity)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workflowId = self.workflowId {
            try encodeContainer.encode(workflowId, forKey: .workflowId)
        }
        if let workflowType = self.workflowType {
            try encodeContainer.encode(workflowType.rawValue, forKey: .workflowType)
        }
    }
}

extension StartRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/run"
    }
}

public struct StartRunInput: Swift.Equatable {
    /// A log level for the run.
    public var logLevel: OmicsClientTypes.RunLogLevel?
    /// A name for the run.
    public var name: Swift.String?
    /// An output URI for the run.
    public var outputUri: Swift.String?
    /// Parameters for the run.
    public var parameters: ClientRuntime.Document?
    /// A priority for the run.
    public var priority: Swift.Int?
    /// A request ID for the run.
    /// This member is required.
    public var requestId: Swift.String?
    /// A service role for the run.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The run's group ID.
    public var runGroupId: Swift.String?
    /// The run's ID.
    public var runId: Swift.String?
    /// A storage capacity for the run.
    public var storageCapacity: Swift.Int?
    /// Tags for the run.
    public var tags: [Swift.String:Swift.String]?
    /// The run's workflow ID.
    public var workflowId: Swift.String?
    /// The run's workflows type.
    public var workflowType: OmicsClientTypes.WorkflowType?

    public init (
        logLevel: OmicsClientTypes.RunLogLevel? = nil,
        name: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        parameters: ClientRuntime.Document? = nil,
        priority: Swift.Int? = nil,
        requestId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        runGroupId: Swift.String? = nil,
        runId: Swift.String? = nil,
        storageCapacity: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workflowId: Swift.String? = nil,
        workflowType: OmicsClientTypes.WorkflowType? = nil
    )
    {
        self.logLevel = logLevel
        self.name = name
        self.outputUri = outputUri
        self.parameters = parameters
        self.priority = priority
        self.requestId = requestId
        self.roleArn = roleArn
        self.runGroupId = runGroupId
        self.runId = runId
        self.storageCapacity = storageCapacity
        self.tags = tags
        self.workflowId = workflowId
        self.workflowType = workflowType
    }
}

struct StartRunInputBody: Swift.Equatable {
    let workflowId: Swift.String?
    let workflowType: OmicsClientTypes.WorkflowType?
    let runId: Swift.String?
    let roleArn: Swift.String?
    let name: Swift.String?
    let runGroupId: Swift.String?
    let priority: Swift.Int?
    let parameters: ClientRuntime.Document?
    let storageCapacity: Swift.Int?
    let outputUri: Swift.String?
    let logLevel: OmicsClientTypes.RunLogLevel?
    let tags: [Swift.String:Swift.String]?
    let requestId: Swift.String?
}

extension StartRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logLevel
        case name
        case outputUri
        case parameters
        case priority
        case requestId
        case roleArn
        case runGroupId
        case runId
        case storageCapacity
        case tags
        case workflowId
        case workflowType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workflowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workflowId)
        workflowId = workflowIdDecoded
        let workflowTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .workflowType)
        workflowType = workflowTypeDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let runGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runGroupId)
        runGroupId = runGroupIdDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .priority)
        priority = priorityDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .parameters)
        parameters = parametersDecoded
        let storageCapacityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storageCapacity)
        storageCapacity = storageCapacityDecoded
        let outputUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputUri)
        outputUri = outputUriDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunLogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
    }
}

extension StartRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartRunOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.id = output.id
            self.status = output.status
            self.tags = output.tags
        } else {
            self.arn = nil
            self.id = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct StartRunOutputResponse: Swift.Equatable {
    /// The run's ARN.
    public var arn: Swift.String?
    /// The run's ID.
    public var id: Swift.String?
    /// The run's status.
    public var status: OmicsClientTypes.RunStatus?
    /// The run's tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        status: OmicsClientTypes.RunStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.status = status
        self.tags = tags
    }
}

struct StartRunOutputResponseBody: Swift.Equatable {
    let arn: Swift.String?
    let id: Swift.String?
    let status: OmicsClientTypes.RunStatus?
    let tags: [Swift.String:Swift.String]?
}

extension StartRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.RunStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartVariantImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName
        case items
        case roleArn
        case runLeftNormalization
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let items = items {
            var itemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .items)
            for variantimportitemsource0 in items {
                try itemsContainer.encode(variantimportitemsource0)
            }
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runLeftNormalization = self.runLeftNormalization {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
    }
}

extension StartVariantImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/import/variant"
    }
}

public struct StartVariantImportJobInput: Swift.Equatable {
    /// The destination variant store for the job.
    /// This member is required.
    public var destinationName: Swift.String?
    /// Items to import.
    /// This member is required.
    public var items: [OmicsClientTypes.VariantImportItemSource]?
    /// A service role for the job.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The job's left normalization setting.
    public var runLeftNormalization: Swift.Bool?

    public init (
        destinationName: Swift.String? = nil,
        items: [OmicsClientTypes.VariantImportItemSource]? = nil,
        roleArn: Swift.String? = nil,
        runLeftNormalization: Swift.Bool? = nil
    )
    {
        self.destinationName = destinationName
        self.items = items
        self.roleArn = roleArn
        self.runLeftNormalization = runLeftNormalization
    }
}

struct StartVariantImportJobInputBody: Swift.Equatable {
    let destinationName: Swift.String?
    let roleArn: Swift.String?
    let items: [OmicsClientTypes.VariantImportItemSource]?
    let runLeftNormalization: Swift.Bool?
}

extension StartVariantImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationName
        case items
        case roleArn
        case runLeftNormalization
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let itemsContainer = try containerValues.decodeIfPresent([OmicsClientTypes.VariantImportItemSource?].self, forKey: .items)
        var itemsDecoded0:[OmicsClientTypes.VariantImportItemSource]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [OmicsClientTypes.VariantImportItemSource]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization)
        runLeftNormalization = runLeftNormalizationDecoded
    }
}

extension StartVariantImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartVariantImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartVariantImportJobOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartVariantImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartVariantImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartVariantImportJobOutputResponse: Swift.Equatable {
    /// The job's ID.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartVariantImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension StartVariantImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension OmicsClientTypes {
    public enum StoreFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// GFF3 Format
        case gff
        /// TSV Format
        case tsv
        /// VCF Format
        case vcf
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreFormat] {
            return [
                .gff,
                .tsv,
                .vcf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gff: return "GFF"
            case .tsv: return "TSV"
            case .vcf: return "VCF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StoreFormat(rawValue: rawValue) ?? StoreFormat.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.StoreOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case tsvstoreoptions = "tsvStoreOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .tsvstoreoptions(tsvstoreoptions):
                try container.encode(tsvstoreoptions, forKey: .tsvstoreoptions)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tsvstoreoptionsDecoded = try values.decodeIfPresent(OmicsClientTypes.TsvStoreOptions.self, forKey: .tsvstoreoptions)
        if let tsvstoreoptions = tsvstoreoptionsDecoded {
            self = .tsvstoreoptions(tsvstoreoptions)
            return
        }
        self = .sdkUnknown("")
    }
}

extension OmicsClientTypes {
    /// Settings for a store.
    public enum StoreOptions: Swift.Equatable {
        /// File settings for a TSV store.
        case tsvstoreoptions(OmicsClientTypes.TsvStoreOptions)
        case sdkUnknown(Swift.String)
    }

}

extension OmicsClientTypes {
    public enum StoreStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The Store is active
        case active
        /// The Store is being created
        case creating
        /// The Store is deleting
        case deleting
        /// The Store creation failed
        case failed
        /// The Store is updating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [StoreStatus] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StoreStatus(rawValue: rawValue) ?? StoreStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tags for the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension OmicsClientTypes.TaskListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case creationTime
        case memory
        case name
        case startTime
        case status
        case stopTime
        case taskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = self.cpus {
            try encodeContainer.encode(cpus, forKey: .cpus)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let memory = self.memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .dateTime, forKey: .stopTime)
        }
        if let taskId = self.taskId {
            try encodeContainer.encode(taskId, forKey: .taskId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .taskId)
        taskId = taskIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.TaskStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let cpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cpus)
        cpus = cpusDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memory)
        memory = memoryDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow run task.
    public struct TaskListItem: Swift.Equatable {
        /// The task's CPU count.
        public var cpus: Swift.Int?
        /// When the task was created.
        public var creationTime: ClientRuntime.Date?
        /// The task's memory.
        public var memory: Swift.Int?
        /// The task's name.
        public var name: Swift.String?
        /// When the task started.
        public var startTime: ClientRuntime.Date?
        /// The task's status.
        public var status: OmicsClientTypes.TaskStatus?
        /// When the task stopped.
        public var stopTime: ClientRuntime.Date?
        /// The task's ID.
        public var taskId: Swift.String?

        public init (
            cpus: Swift.Int? = nil,
            creationTime: ClientRuntime.Date? = nil,
            memory: Swift.Int? = nil,
            name: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: OmicsClientTypes.TaskStatus? = nil,
            stopTime: ClientRuntime.Date? = nil,
            taskId: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.creationTime = creationTime
            self.memory = memory
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stopTime = stopTime
            self.taskId = taskId
        }
    }

}

extension OmicsClientTypes {
    public enum TaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case pending
        case running
        case starting
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .pending,
                .running,
                .starting,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TaskStatus(rawValue: rawValue) ?? TaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = true
    public var _isThrottling: Swift.Bool = true
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.TsvOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case readOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let readOptions = self.readOptions {
            try encodeContainer.encode(readOptions, forKey: .readOptions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReadOptions.self, forKey: .readOptions)
        readOptions = readOptionsDecoded
    }
}

extension OmicsClientTypes {
    /// Formatting options for a TSV file.
    public struct TsvOptions: Swift.Equatable {
        /// The file's read options.
        public var readOptions: OmicsClientTypes.ReadOptions?

        public init (
            readOptions: OmicsClientTypes.ReadOptions? = nil
        )
        {
            self.readOptions = readOptions
        }
    }

}

extension OmicsClientTypes.TsvStoreOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case annotationType
        case formatToHeader
        case schema
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationType = self.annotationType {
            try encodeContainer.encode(annotationType.rawValue, forKey: .annotationType)
        }
        if let formatToHeader = formatToHeader {
            var formatToHeaderContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatToHeader)
            for (dictKey0, formatToHeader0) in formatToHeader {
                try formatToHeaderContainer.encode(formatToHeader0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let schema = schema {
            var schemaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .schema)
            for schemaitem0 in schema {
                var schemaitem0Container = schemaContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, schemaItem1) in schemaitem0 {
                    try schemaitem0Container.encode(schemaItem1.rawValue, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let annotationTypeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.AnnotationType.self, forKey: .annotationType)
        annotationType = annotationTypeDecoded
        let formatToHeaderContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatToHeader)
        var formatToHeaderDecoded0: [Swift.String:Swift.String]? = nil
        if let formatToHeaderContainer = formatToHeaderContainer {
            formatToHeaderDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in formatToHeaderContainer {
                if let string0 = string0 {
                    formatToHeaderDecoded0?[key0] = string0
                }
            }
        }
        formatToHeader = formatToHeaderDecoded0
        let schemaContainer = try containerValues.decodeIfPresent([[Swift.String: OmicsClientTypes.SchemaValueType?]?].self, forKey: .schema)
        var schemaDecoded0:[[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        if let schemaContainer = schemaContainer {
            schemaDecoded0 = [[Swift.String:OmicsClientTypes.SchemaValueType]]()
            for map0 in schemaContainer {
                var schemaContainerDecoded0: [Swift.String: OmicsClientTypes.SchemaValueType]? = nil
                if let map0 = map0 {
                    schemaContainerDecoded0 = [Swift.String: OmicsClientTypes.SchemaValueType]()
                    for (key1, schemavaluetype1) in map0 {
                        if let schemavaluetype1 = schemavaluetype1 {
                            schemaContainerDecoded0?[key1] = schemavaluetype1
                        }
                    }
                }
                if let schemaContainerDecoded0 = schemaContainerDecoded0 {
                    schemaDecoded0?.append(schemaContainerDecoded0)
                }
            }
        }
        schema = schemaDecoded0
    }
}

extension OmicsClientTypes {
    /// File settings for a TSV store.
    public struct TsvStoreOptions: Swift.Equatable {
        /// The store's annotation type.
        public var annotationType: OmicsClientTypes.AnnotationType?
        /// The store's header key to column name mapping.
        public var formatToHeader: [Swift.String:Swift.String]?
        /// The store's schema.
        public var schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]?

        public init (
            annotationType: OmicsClientTypes.AnnotationType? = nil,
            formatToHeader: [Swift.String:Swift.String]? = nil,
            schema: [[Swift.String:OmicsClientTypes.SchemaValueType]]? = nil
        )
        {
            self.annotationType = annotationType
            self.formatToHeader = formatToHeader
            self.schema = schema
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys of tags to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAnnotationStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateAnnotationStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/annotationStore/\(name.urlPercentEncoding())"
    }
}

public struct UpdateAnnotationStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateAnnotationStoreInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateAnnotationStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAnnotationStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnnotationStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAnnotationStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnnotationStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAnnotationStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.storeFormat = output.storeFormat
            self.storeOptions = output.storeOptions
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.storeFormat = nil
            self.storeOptions = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateAnnotationStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// The annotation file format of the store.
    public var storeFormat: OmicsClientTypes.StoreFormat?
    /// Parsing options for the store.
    public var storeOptions: OmicsClientTypes.StoreOptions?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        storeFormat: OmicsClientTypes.StoreFormat? = nil,
        storeOptions: OmicsClientTypes.StoreOptions? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.storeFormat = storeFormat
        self.storeOptions = storeOptions
        self.updateTime = updateTime
    }
}

struct UpdateAnnotationStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
    let storeOptions: OmicsClientTypes.StoreOptions?
    let storeFormat: OmicsClientTypes.StoreFormat?
}

extension UpdateAnnotationStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case status
        case storeFormat
        case storeOptions
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let storeOptionsDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreOptions.self, forKey: .storeOptions)
        storeOptions = storeOptionsDecoded
        let storeFormatDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreFormat.self, forKey: .storeFormat)
        storeFormat = storeFormatDecoded
    }
}

extension UpdateRunGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxRuns
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCpus = self.maxCpus {
            try encodeContainer.encode(maxCpus, forKey: .maxCpus)
        }
        if let maxDuration = self.maxDuration {
            try encodeContainer.encode(maxDuration, forKey: .maxDuration)
        }
        if let maxRuns = self.maxRuns {
            try encodeContainer.encode(maxRuns, forKey: .maxRuns)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateRunGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/runGroup/\(id.urlPercentEncoding())"
    }
}

public struct UpdateRunGroupInput: Swift.Equatable {
    /// The group's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of CPUs to use.
    public var maxCpus: Swift.Int?
    /// The maximum amount of time to run.
    public var maxDuration: Swift.Int?
    /// The maximum number of concurrent runs for the group.
    public var maxRuns: Swift.Int?
    /// A name for the group.
    public var name: Swift.String?

    public init (
        id: Swift.String? = nil,
        maxCpus: Swift.Int? = nil,
        maxDuration: Swift.Int? = nil,
        maxRuns: Swift.Int? = nil,
        name: Swift.String? = nil
    )
    {
        self.id = id
        self.maxCpus = maxCpus
        self.maxDuration = maxDuration
        self.maxRuns = maxRuns
        self.name = name
    }
}

struct UpdateRunGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxCpus: Swift.Int?
    let maxRuns: Swift.Int?
    let maxDuration: Swift.Int?
}

extension UpdateRunGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCpus
        case maxDuration
        case maxRuns
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxCpusDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCpus)
        maxCpus = maxCpusDecoded
        let maxRunsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxRuns)
        maxRuns = maxRunsDecoded
        let maxDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxDuration)
        maxDuration = maxDurationDecoded
    }
}

extension UpdateRunGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRunGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateRunGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRunGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRunGroupOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateVariantStoreInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateVariantStoreInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/variantStore/\(name.urlPercentEncoding())"
    }
}

public struct UpdateVariantStoreInput: Swift.Equatable {
    /// A description for the store.
    public var description: Swift.String?
    /// A name for the store.
    /// This member is required.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
    }
}

struct UpdateVariantStoreInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateVariantStoreInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateVariantStoreOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVariantStoreOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateVariantStoreOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVariantStoreOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateVariantStoreOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.description = output.description
            self.id = output.id
            self.name = output.name
            self.reference = output.reference
            self.status = output.status
            self.updateTime = output.updateTime
        } else {
            self.creationTime = nil
            self.description = nil
            self.id = nil
            self.name = nil
            self.reference = nil
            self.status = nil
            self.updateTime = nil
        }
    }
}

public struct UpdateVariantStoreOutputResponse: Swift.Equatable {
    /// When the store was created.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// The store's description.
    /// This member is required.
    public var description: Swift.String?
    /// The store's ID.
    /// This member is required.
    public var id: Swift.String?
    /// The store's name.
    /// This member is required.
    public var name: Swift.String?
    /// The store's genome reference.
    /// This member is required.
    public var reference: OmicsClientTypes.ReferenceItem?
    /// The store's status.
    /// This member is required.
    public var status: OmicsClientTypes.StoreStatus?
    /// When the store was updated.
    /// This member is required.
    public var updateTime: ClientRuntime.Date?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        reference: OmicsClientTypes.ReferenceItem? = nil,
        status: OmicsClientTypes.StoreStatus? = nil,
        updateTime: ClientRuntime.Date? = nil
    )
    {
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.reference = reference
        self.status = status
        self.updateTime = updateTime
    }
}

struct UpdateVariantStoreOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let reference: OmicsClientTypes.ReferenceItem?
    let status: OmicsClientTypes.StoreStatus?
    let name: Swift.String?
    let description: Swift.String?
    let creationTime: ClientRuntime.Date?
    let updateTime: ClientRuntime.Date?
}

extension UpdateVariantStoreOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case status
        case updateTime
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension UpdateWorkflowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateWorkflowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/workflow/\(id.urlPercentEncoding())"
    }
}

public struct UpdateWorkflowInput: Swift.Equatable {
    /// A description for the workflow.
    public var description: Swift.String?
    /// The workflow's ID.
    /// This member is required.
    public var id: Swift.String?
    /// A name for the workflow.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateWorkflowInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateWorkflowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWorkflowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWorkflowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWorkflowOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWorkflowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWorkflowOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OmicsClientTypes.VariantImportItemDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatus
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatus = self.jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension OmicsClientTypes {
    /// Details about an imported variant item.
    public struct VariantImportItemDetail: Swift.Equatable {
        /// The item's job status.
        /// This member is required.
        public var jobStatus: OmicsClientTypes.JobStatus?
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init (
            jobStatus: OmicsClientTypes.JobStatus? = nil,
            source: Swift.String? = nil
        )
        {
            self.jobStatus = jobStatus
            self.source = source
        }
    }

}

extension OmicsClientTypes.VariantImportItemSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension OmicsClientTypes {
    /// A imported variant item's source.
    public struct VariantImportItemSource: Swift.Equatable {
        /// The source file's location in Amazon S3.
        /// This member is required.
        public var source: Swift.String?

        public init (
            source: Swift.String? = nil
        )
        {
            self.source = source
        }
    }

}

extension OmicsClientTypes.VariantImportJobItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case creationTime
        case destinationName
        case id
        case roleArn
        case runLeftNormalization
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .dateTime, forKey: .completionTime)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let destinationName = self.destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if runLeftNormalization != false {
            try encodeContainer.encode(runLeftNormalization, forKey: .runLeftNormalization)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let runLeftNormalizationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runLeftNormalization) ?? false
        runLeftNormalization = runLeftNormalizationDecoded
    }
}

extension OmicsClientTypes {
    /// A variant import job.
    public struct VariantImportJobItem: Swift.Equatable {
        /// When the job completed.
        public var completionTime: ClientRuntime.Date?
        /// When the job was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The job's destination variant store.
        /// This member is required.
        public var destinationName: Swift.String?
        /// The job's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The job's service role ARN.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The job's left normalization setting.
        public var runLeftNormalization: Swift.Bool
        /// The job's status.
        /// This member is required.
        public var status: OmicsClientTypes.JobStatus?
        /// When the job was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            completionTime: ClientRuntime.Date? = nil,
            creationTime: ClientRuntime.Date? = nil,
            destinationName: Swift.String? = nil,
            id: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runLeftNormalization: Swift.Bool = false,
            status: OmicsClientTypes.JobStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.completionTime = completionTime
            self.creationTime = creationTime
            self.destinationName = destinationName
            self.id = id
            self.roleArn = roleArn
            self.runLeftNormalization = runLeftNormalization
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VariantStoreItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime
        case description
        case id
        case name
        case reference
        case sseConfig
        case status
        case statusMessage
        case storeArn
        case storeSizeBytes
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let reference = self.reference {
            try encodeContainer.encode(reference, forKey: .reference)
        }
        if let sseConfig = self.sseConfig {
            try encodeContainer.encode(sseConfig, forKey: .sseConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let storeArn = self.storeArn {
            try encodeContainer.encode(storeArn, forKey: .storeArn)
        }
        if let storeSizeBytes = self.storeSizeBytes {
            try encodeContainer.encode(storeSizeBytes, forKey: .storeSizeBytes)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .dateTime, forKey: .updateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let referenceDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.ReferenceItem.self, forKey: .reference)
        reference = referenceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.StoreStatus.self, forKey: .status)
        status = statusDecoded
        let storeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .storeArn)
        storeArn = storeArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sseConfigDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.SseConfig.self, forKey: .sseConfig)
        sseConfig = sseConfigDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let storeSizeBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .storeSizeBytes)
        storeSizeBytes = storeSizeBytesDecoded
    }
}

extension OmicsClientTypes {
    /// A variant store.
    public struct VariantStoreItem: Swift.Equatable {
        /// When the store was created.
        /// This member is required.
        public var creationTime: ClientRuntime.Date?
        /// The store's description.
        /// This member is required.
        public var description: Swift.String?
        /// The store's ID.
        /// This member is required.
        public var id: Swift.String?
        /// The store's name.
        /// This member is required.
        public var name: Swift.String?
        /// The store's genome reference.
        /// This member is required.
        public var reference: OmicsClientTypes.ReferenceItem?
        /// The store's server-side encryption (SSE) settings.
        /// This member is required.
        public var sseConfig: OmicsClientTypes.SseConfig?
        /// The store's status.
        /// This member is required.
        public var status: OmicsClientTypes.StoreStatus?
        /// The store's status message.
        /// This member is required.
        public var statusMessage: Swift.String?
        /// The store's ARN.
        /// This member is required.
        public var storeArn: Swift.String?
        /// The store's size in bytes.
        /// This member is required.
        public var storeSizeBytes: Swift.Int?
        /// When the store was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            reference: OmicsClientTypes.ReferenceItem? = nil,
            sseConfig: OmicsClientTypes.SseConfig? = nil,
            status: OmicsClientTypes.StoreStatus? = nil,
            statusMessage: Swift.String? = nil,
            storeArn: Swift.String? = nil,
            storeSizeBytes: Swift.Int? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.creationTime = creationTime
            self.description = description
            self.id = id
            self.name = name
            self.reference = reference
            self.sseConfig = sseConfig
            self.status = status
            self.statusMessage = statusMessage
            self.storeArn = storeArn
            self.storeSizeBytes = storeSizeBytes
            self.updateTime = updateTime
        }
    }

}

extension OmicsClientTypes.VcfOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ignoreFilterField
        case ignoreQualField
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignoreFilterField = self.ignoreFilterField {
            try encodeContainer.encode(ignoreFilterField, forKey: .ignoreFilterField)
        }
        if let ignoreQualField = self.ignoreQualField {
            try encodeContainer.encode(ignoreQualField, forKey: .ignoreQualField)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignoreQualFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreQualField)
        ignoreQualField = ignoreQualFieldDecoded
        let ignoreFilterFieldDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreFilterField)
        ignoreFilterField = ignoreFilterFieldDecoded
    }
}

extension OmicsClientTypes {
    /// Formatting options for a VCF file.
    public struct VcfOptions: Swift.Equatable {
        /// The file's ignore filter field setting.
        public var ignoreFilterField: Swift.Bool?
        /// The file's ignore qual field setting.
        public var ignoreQualField: Swift.Bool?

        public init (
            ignoreFilterField: Swift.Bool? = nil,
            ignoreQualField: Swift.Bool? = nil
        )
        {
            self.ignoreFilterField = ignoreFilterField
            self.ignoreQualField = ignoreQualField
        }
    }

}

extension OmicsClientTypes {
    public enum WorkflowEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nextflow
        case wdl
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowEngine] {
            return [
                .nextflow,
                .wdl,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nextflow: return "NEXTFLOW"
            case .wdl: return "WDL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowEngine(rawValue: rawValue) ?? WorkflowEngine.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum WorkflowExport: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case definition
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowExport] {
            return [
                .definition,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .definition: return "DEFINITION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowExport(rawValue: rawValue) ?? WorkflowExport.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes.WorkflowListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationTime
        case digest
        case id
        case name
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .dateTime, forKey: .creationTime)
        }
        if let digest = self.digest {
            try encodeContainer.encode(digest, forKey: .digest)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowStatus.self, forKey: .status)
        status = statusDecoded
        let typeDecoded = try containerValues.decodeIfPresent(OmicsClientTypes.WorkflowType.self, forKey: .type)
        type = typeDecoded
        let digestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .digest)
        digest = digestDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow.
    public struct WorkflowListItem: Swift.Equatable {
        /// The workflow's ARN.
        public var arn: Swift.String?
        /// When the workflow was created.
        public var creationTime: ClientRuntime.Date?
        /// The workflow's digest.
        public var digest: Swift.String?
        /// The workflow's ID.
        public var id: Swift.String?
        /// The workflow's name.
        public var name: Swift.String?
        /// The workflow's status.
        public var status: OmicsClientTypes.WorkflowStatus?
        /// The workflow's type.
        public var type: OmicsClientTypes.WorkflowType?

        public init (
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            digest: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: OmicsClientTypes.WorkflowStatus? = nil,
            type: OmicsClientTypes.WorkflowType? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.digest = digest
            self.id = id
            self.name = name
            self.status = status
            self.type = type
        }
    }

}

extension OmicsClientTypes.WorkflowParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case `optional` = "optional"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let `optional` = self.`optional` {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
    }
}

extension OmicsClientTypes {
    /// A workflow parameter.
    public struct WorkflowParameter: Swift.Equatable {
        /// The parameter's description.
        public var description: Swift.String?
        /// Whether the parameter is optional.
        public var `optional`: Swift.Bool?

        public init (
            description: Swift.String? = nil,
            `optional`: Swift.Bool? = nil
        )
        {
            self.description = description
            self.`optional` = `optional`
        }
    }

}

extension OmicsClientTypes {
    public enum WorkflowStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowStatus] {
            return [
                .active,
                .creating,
                .deleted,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowStatus(rawValue: rawValue) ?? WorkflowStatus.sdkUnknown(rawValue)
        }
    }
}

extension OmicsClientTypes {
    public enum WorkflowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowType] {
            return [
                .private,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WorkflowType(rawValue: rawValue) ?? WorkflowType.sdkUnknown(rawValue)
        }
    }
}
