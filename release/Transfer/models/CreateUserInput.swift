// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct CreateUserInput: Equatable {
    /// <p>The landing directory (folder) for a user when they log in to the server using the
    ///       client.</p>
    ///
    ///          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    public let homeDirectory: String?
    /// <p>Logical directory mappings that specify what Amazon S3 or EFS paths and keys should be visible to
    ///       your user and how you want to make them visible. You will need to specify the
    ///         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or EFS path. If you only specify a
    ///       target, it will be displayed as is. You will need to also make sure that your IAM role
    ///       provides access to paths in <code>Target</code>. This value can only be set when
    ///         <code>HomeDirectoryType</code> is set to <code>LOGICAL</code>.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target":
    ///         "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock your user
    ///       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for
    ///         <code>chroot</code>.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry will
    ///         be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
    ///         holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
    ///         <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
    ///         following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
    ///         sure that the end of the key name ends in a <code>/</code> for it to be considered a
    ///         folder.</p>
    ///          </note>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) you want your users' home directory to be when
    ///       they log into the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 paths visible to your
    ///       users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>A scope-down policy for your user so you can use the same IAM role across multiple users.
    ///       This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you
    ///       can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///
    ///          <note>
    ///             <p>This only applies when domain of ServerId is S3. EFS does not use scope down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead
    ///         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
    ///         it in the <code>Policy</code> argument.</p>
    ///
    ///
    ///
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example scope-down
    ///         policy</a>.</p>
    ///
    ///
    ///
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS
    ///           Security Token Service API Reference</i>.</p>
    ///          </note>
    public let policy: String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in Amazon EFS determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies
    ///       attached to this role will determine the level of access you want to provide your users when
    ///       transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also
    ///
    ///       contain a trust relationship that allows the server to access your resources when servicing
    ///       your users' transfer requests.</p>
    public let role: String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server
    ///       that you added your user to.</p>
    public let serverId: String?
    /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
    ///       server.</p>
    public let sshPublicKeyBody: String?
    /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
    ///       to users for any purpose.</p>
    public let tags: [Tag]?
    /// <p>A unique string that identifies a user and is associated with a as specified by the
    ///         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
    ///       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
    ///       '-', period '.', and at sign '@'. The user name can't start
    ///       with a hyphen, period, or at sign.</p>
    public let userName: String?

    public init (
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        serverId: String? = nil,
        sshPublicKeyBody: String? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), serverId: \(String(describing: serverId)), sshPublicKeyBody: \(String(describing: sshPublicKeyBody)), tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}
