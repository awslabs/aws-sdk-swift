// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the <code>UpdatServer</code> is called for a file transfer
///       protocol-enabled server that has VPC as the endpoint type and the server's
///         <code>VpcEndpointID</code> is not in the available state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAccessInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessInput>
    public typealias MOutput = OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessOutputError>
}

extension CreateAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessInput(externalId: \(String(describing: externalId)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), serverId: \(String(describing: serverId)))"}
}

extension CreateAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct CreateAccessInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessInput>
    public typealias MOutput = OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessOutputError>
}

public struct CreateAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessInput>
    public typealias MOutput = OperationOutput<CreateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessOutputError>
}

public struct CreateAccessInput: Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    ///          <p>A <code>HomeDirectory</code> example is <code>/directory_name/home/mydirectory</code>.</p>
    public let homeDirectory: String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    ///       be visible to your user and how you want to make them visible. You must specify the
    ///         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    ///       only specify a target, it will be displayed as is. You also must ensure that your AWS Identity
    ///       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    ///       can only be set when <code>HomeDirectoryType</code> is set to
    ///       <i>LOGICAL</i>.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
    ///         <code>HomeDirectory</code> parameter value.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or Amazon EFS, the
    ///         entry will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create
    ///         0-byte objects as place holders for your directory. If using the AWS CLI, use the
    ///           <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code> or
    ///           <code>efs</code> so you can use the <code>put-object</code> operation. For example, you
    ///         can use the following.</p>
    ///             <p>
    ///                <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>
    ///             </p>
    ///             <p>The end of the key name must end in a <code>/</code> for it to be considered a
    ///         folder.</p>
    ///          </note>
    ///          <p>Required: No</p>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>A scope-down policy for your user so that you can use the same IAM role across multiple
    ///       users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables
    ///       that you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>This only applies when domain of <code>ServerId</code> is S3. Amazon EFS does not use scope
    ///         down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
    ///           scope-down policy</a>.</p>
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS Security Token Service API
    ///           Reference</i>.</p>
    ///          </note>
    public let policy: String?
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    ///       file system. The policies attached to this role determine the level of access that you want to
    ///       provide your users when transferring files into and out of your Amazon S3 bucket or EFS file
    ///       system. The IAM role should also contain a trust relationship that allows the server to access
    ///       your resources when servicing your users' transfer requests.</p>
    public let role: String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct CreateAccessInputBody: Equatable {
    public let homeDirectory: String?
    public let homeDirectoryType: HomeDirectoryType?
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    public let policy: String?
    public let posixProfile: PosixProfile?
    public let role: String?
    public let serverId: String?
    public let externalId: String?
}

extension CreateAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension CreateAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessOutputResponse(externalId: \(String(describing: externalId)), serverId: \(String(describing: serverId)))"}
}

extension CreateAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct CreateAccessOutputResponse: Equatable {
    /// <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family.</p>
    public let externalId: String?
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct CreateAccessOutputResponseBody: Equatable {
    public let serverId: String?
    public let externalId: String?
}

extension CreateAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

public struct CreateServerInputBodyMiddleware: Middleware {
    public let id: String = "CreateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

extension CreateServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServerInput(certificate: \(String(describing: certificate)), domain: \(String(describing: domain)), endpointDetails: \(String(describing: endpointDetails)), endpointType: \(String(describing: endpointType)), hostKey: \(String(describing: hostKey)), identityProviderDetails: \(String(describing: identityProviderDetails)), identityProviderType: \(String(describing: identityProviderType)), loggingRole: \(String(describing: loggingRole)), protocols: \(String(describing: protocols)), securityPolicyName: \(String(describing: securityPolicyName)), tags: \(String(describing: tags)))"}
}

extension CreateServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateServerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

public struct CreateServerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

public struct CreateServerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. Required
    ///       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    ///
    ///          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
    ///         private certificate</a> in the <i> AWS Certificate Manager User
    ///       Guide</i>.</p>
    ///
    ///          <p>Certificates with the following cryptographic algorithms and key sizes are
    ///       supported:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>2048-bit RSA (RSA_2048)</p>
    ///             </li>
    ///             <li>
    ///                <p>4096-bit RSA (RSA_4096)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
    ///         address specified and information about the issuer.</p>
    ///          </note>
    public let certificate: String?
    /// <p>The domain of the storage system that is used for file transfers. There are two domains
    ///       available: Amazon Simple Storage Service (Amazon S3) and Amazon Elastic File System (Amazon EFS). The
    ///       default value is S3.</p>
    ///
    ///          <note>
    ///             <p>After the server is created, the domain cannot be changed.</p>
    ///          </note>
    public let domain: Domain?
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
    ///       When you host your endpoint within your VPC, you can make it accessible only to resources
    ///       within your VPC, or you can attach Elastic IP addresses and make it accessible to clients over
    ///       the internet. Your VPC's default security groups are automatically assigned to your
    ///       endpoint.</p>
    public let endpointDetails: EndpointDetails?
    /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
    ///       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
    ///       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
    ///          <note>
    ///             <p> After March 31, 2021, you won't be able to create a server using
    ///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
    ///       done so before March 31, 2021. If you have already created servers with
    ///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
    ///         you will not be affected. After this date, use
    ///         <code>EndpointType</code>=<code>VPC</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
    ///         this endpoint type, you have the option to directly associate up to three Elastic IPv4
    ///         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
    ///         restrict traffic by the client's public IP address. This is not possible with
    ///           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
    ///          </note>
    public let endpointType: EndpointType?
    /// <p>The RSA private key as generated by the <code>ssh-keygen -N "" -m PEM -f
    ///         my-new-server-key</code> command.</p>
    ///
    ///          <important>
    ///             <p>If you aren't planning to migrate existing users from an existing SFTP-enabled
    ///         server to a new server, don't update the host key. Accidentally changing a
    ///         server's host key can be disruptive.</p>
    ///          </important>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>AWS Transfer
    ///         Family User Guide</i>.</p>
    public let hostKey: String?
    /// <p>Required when <code>IdentityProviderType</code> is set to
    ///         <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>. Accepts an array containing
    ///       all of the information required to use a directory in <code>AWS_DIRECTORY_SERVICE</code> or
    ///       invoke a customer-supplied authentication API, including the API Gateway URL. Not required
    ///       when <code>IdentityProviderType</code> is set to <code>SERVICE_MANAGED</code>.</p>
    public let identityProviderDetails: IdentityProviderDetails?
    /// <p>Specifies the mode of authentication for a server. The default value is
    ///         <code>SERVICE_MANAGED</code>, which allows you to store and access user credentials within
    ///       the AWS Transfer Family service. Use <code>AWS_DIRECTORY_SERVICE</code> to provide access to
    ///       Active Directory groups in AWS Managed Active Directory or Microsoft Active Directory in your
    ///       on-premises environment or in AWS using AD Connectors. This option also requires you to
    ///       provide a Directory ID using the <code>IdentityProviderDetails</code> parameter. Use the
    ///         <code>API_GATEWAY</code> value to integrate with an identity provider of your choosing. The
    ///         <code>API_GATEWAY</code> setting requires you to provide an API Gateway endpoint URL to call
    ///       for authentication using the <code>IdentityProviderDetails</code> parameter.</p>
    public let identityProviderType: IdentityProviderType?
    /// <p>Allows the service to write your users' activity to your Amazon CloudWatch logs for
    ///       monitoring and auditing purposes.</p>
    public let loggingRole: String?
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    ///       client can connect to your server's endpoint. The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
    ///           SSH</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
    ///           encryption</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>If you select <code>FTPS</code>, you must choose a certificate stored in AWS Certificate
    ///         Manager (ACM) which will be used to identify your server when clients connect to it over
    ///         FTPS.</p>
    ///
    ///             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
    ///           <code>EndpointType</code> must be <code>VPC</code> and the
    ///           <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
    ///
    ///             <p>If <code>Protocol</code> includes <code>FTP</code>, then
    ///           <code>AddressAllocationIds</code> cannot be associated.</p>
    ///
    ///             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
    ///         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
    ///           <code>SERVICE_MANAGED</code>.</p>
    ///          </note>
    public let protocols: [`Protocol`]?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: String?
    /// <p>Key-value pairs that can be used to group and search for servers.</p>
    public let tags: [Tag]?

    public init (
        certificate: String? = nil,
        domain: Domain? = nil,
        endpointDetails: EndpointDetails? = nil,
        endpointType: EndpointType? = nil,
        hostKey: String? = nil,
        identityProviderDetails: IdentityProviderDetails? = nil,
        identityProviderType: IdentityProviderType? = nil,
        loggingRole: String? = nil,
        protocols: [`Protocol`]? = nil,
        securityPolicyName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.tags = tags
    }
}

struct CreateServerInputBody: Equatable {
    public let certificate: String?
    public let domain: Domain?
    public let endpointDetails: EndpointDetails?
    public let endpointType: EndpointType?
    public let hostKey: String?
    public let identityProviderDetails: IdentityProviderDetails?
    public let identityProviderType: IdentityProviderType?
    public let loggingRole: String?
    public let protocols: [`Protocol`]?
    public let securityPolicyName: String?
    public let tags: [Tag]?
}

extension CreateServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServerOutputResponse(serverId: \(String(describing: serverId)))"}
}

extension CreateServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct CreateServerOutputResponse: Equatable {
    /// <p>The service-assigned ID of the server that is created.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct CreateServerOutputResponseBody: Equatable {
    public let serverId: String?
}

extension CreateServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), serverId: \(String(describing: serverId)), sshPublicKeyBody: \(String(describing: sshPublicKeyBody)), tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>The landing directory (folder) for a user when they log in to the server using the
    ///       client.</p>
    ///
    ///          <p>A <code>HomeDirectory</code> example is <code>/bucket_name/home/mydirectory</code>.</p>
    public let homeDirectory: String?
    /// <p>Logical directory mappings that specify what Amazon S3 or EFS paths and keys should be visible to
    ///       your user and how you want to make them visible. You will need to specify the
    ///         <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or EFS path. If you only specify a
    ///       target, it will be displayed as is. You will need to also make sure that your IAM role
    ///       provides access to paths in <code>Target</code>. This value can only be set when
    ///         <code>HomeDirectoryType</code> is set to <code>LOGICAL</code>.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target":
    ///         "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock your user
    ///       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    ///
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for
    ///         <code>chroot</code>.</p>
    ///
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry will
    ///         be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0 byte objects as place
    ///         holders for your directory. If using the CLI, use the <code>s3api</code> or <code>efsapi</code> call instead of
    ///         <code>s3</code> or <code>efs</code> so you can use the put-object operation. For example, you use the
    ///         following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
    ///         sure that the end of the key name ends in a <code>/</code> for it to be considered a
    ///         folder.</p>
    ///          </note>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) you want your users' home directory to be when
    ///       they log into the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 paths visible to your
    ///       users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>A scope-down policy for your user so you can use the same IAM role across multiple users.
    ///       This policy scopes down user access to portions of their Amazon S3 bucket. Variables that you
    ///       can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///
    ///          <note>
    ///             <p>This only applies when domain of ServerId is S3. EFS does not use scope down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead
    ///         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
    ///         it in the <code>Policy</code> argument.</p>
    ///
    ///
    ///
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example scope-down
    ///         policy</a>.</p>
    ///
    ///
    ///
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS
    ///           Security Token Service API Reference</i>.</p>
    ///          </note>
    public let policy: String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in Amazon EFS determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS file system. The policies
    ///       attached to this role will determine the level of access you want to provide your users when
    ///       transferring files into and out of your Amazon S3 bucket or EFS file system. The IAM role should also
    ///
    ///       contain a trust relationship that allows the server to access your resources when servicing
    ///       your users' transfer requests.</p>
    public let role: String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server
    ///       that you added your user to.</p>
    public let serverId: String?
    /// <p>The public portion of the Secure Shell (SSH) key used to authenticate the user to the
    ///       server.</p>
    public let sshPublicKeyBody: String?
    /// <p>Key-value pairs that can be used to group and search for users. Tags are metadata attached
    ///       to users for any purpose.</p>
    public let tags: [Tag]?
    /// <p>A unique string that identifies a user and is associated with a as specified by the
    ///         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
    ///       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
    ///       '-', period '.', and at sign '@'. The user name can't start
    ///       with a hyphen, period, or at sign.</p>
    public let userName: String?

    public init (
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        serverId: String? = nil,
        sshPublicKeyBody: String? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.tags = tags
        self.userName = userName
    }
}

struct CreateUserInputBody: Equatable {
    public let homeDirectory: String?
    public let homeDirectoryType: HomeDirectoryType?
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    public let policy: String?
    public let posixProfile: PosixProfile?
    public let role: String?
    public let serverId: String?
    public let sshPublicKeyBody: String?
    public let tags: [Tag]?
    public let userName: String?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case tags = "Tags"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(serverId: \(String(describing: serverId)), userName: \(String(describing: userName)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

public struct CreateUserOutputResponse: Equatable {
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: String?
    /// <p>A unique string that identifies a user account associated with a server.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let serverId: String?
    public let userName: String?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

public struct DeleteAccessInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessOutputError>
}

extension DeleteAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessInput(externalId: \(String(describing: externalId)), serverId: \(String(describing: serverId)))"}
}

extension DeleteAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DeleteAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessOutputError>
}

public struct DeleteAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessInput>
    public typealias MOutput = OperationOutput<DeleteAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessOutputError>
}

public struct DeleteAccessInput: Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DeleteAccessInputBody: Equatable {
    public let serverId: String?
    public let externalId: String?
}

extension DeleteAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DeleteAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessOutputResponse()"}
}

extension DeleteAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessOutputResponseBody: Equatable {
}

extension DeleteAccessOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

extension DeleteServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerInput(serverId: \(String(describing: serverId)))"}
}

extension DeleteServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DeleteServerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

public struct DeleteServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

public struct DeleteServerInput: Equatable {
    /// <p>A unique system-assigned identifier for a server instance.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DeleteServerInputBody: Equatable {
    public let serverId: String?
}

extension DeleteServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DeleteServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerOutputResponse()"}
}

extension DeleteServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Equatable {

    public init() {}
}

struct DeleteServerOutputResponseBody: Equatable {
}

extension DeleteServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteSshPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSshPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSshPublicKeyOutputError>
}

extension DeleteSshPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSshPublicKeyInput(serverId: \(String(describing: serverId)), sshPublicKeyId: \(String(describing: sshPublicKeyId)), userName: \(String(describing: userName)))"}
}

extension DeleteSshPublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteSshPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSshPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSshPublicKeyOutputError>
}

public struct DeleteSshPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSshPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSshPublicKeyInput>
    public typealias MOutput = OperationOutput<DeleteSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSshPublicKeyOutputError>
}

public struct DeleteSshPublicKeyInput: Equatable {
    /// <p>A system-assigned unique identifier for a file transfer protocol-enabled server instance
    ///       that has the user assigned to it.</p>
    public let serverId: String?
    /// <p>A unique identifier used to reference your user's specific SSH key.</p>
    public let sshPublicKeyId: String?
    /// <p>A unique string that identifies a user whose public key is being deleted.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        sshPublicKeyId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct DeleteSshPublicKeyInputBody: Equatable {
    public let serverId: String?
    public let sshPublicKeyId: String?
    public let userName: String?
}

extension DeleteSshPublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteSshPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSshPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSshPublicKeyOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSshPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSshPublicKeyOutputResponse()"}
}

extension DeleteSshPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSshPublicKeyOutputResponse: Equatable {

    public init() {}
}

struct DeleteSshPublicKeyOutputResponseBody: Equatable {
}

extension DeleteSshPublicKeyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(serverId: \(String(describing: serverId)), userName: \(String(describing: userName)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>A system-assigned unique identifier for a server instance that has the user assigned to
    ///       it.</p>
    public let serverId: String?
    /// <p>A unique string that identifies a user that is being deleted from a server.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DeleteUserInputBody: Equatable {
    public let serverId: String?
    public let userName: String?
}

extension DeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccessInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessOutputError>
}

extension DescribeAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessInput(externalId: \(String(describing: externalId)), serverId: \(String(describing: serverId)))"}
}

extension DescribeAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DescribeAccessInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessOutputError>
}

public struct DescribeAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccessInput>
    public typealias MOutput = OperationOutput<DescribeAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccessOutputError>
}

public struct DescribeAccessInput: Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group you associate have access to your Amazon S3 or Amazon EFS resources
    ///       over the enabled protocols using AWS Transfer Family. If you know the group name, you can view
    ///       the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct DescribeAccessInputBody: Equatable {
    public let serverId: String?
    public let externalId: String?
}

extension DescribeAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribeAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccessOutputResponse(access: \(String(describing: access)), serverId: \(String(describing: serverId)))"}
}

extension DescribeAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.access = output.access
            self.serverId = output.serverId
        } else {
            self.access = nil
            self.serverId = nil
        }
    }
}

public struct DescribeAccessOutputResponse: Equatable {
    /// <p>The external ID of the server that the access is attached to.</p>
    public let access: DescribedAccess?
    /// <p>A system-assigned unique identifier for a server that has this access assigned.</p>
    public let serverId: String?

    public init (
        access: DescribedAccess? = nil,
        serverId: String? = nil
    )
    {
        self.access = access
        self.serverId = serverId
    }
}

struct DescribeAccessOutputResponseBody: Equatable {
    public let serverId: String?
    public let access: DescribedAccess?
}

extension DescribeAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case access = "Access"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessDecoded = try containerValues.decodeIfPresent(DescribedAccess.self, forKey: .access)
        access = accessDecoded
    }
}

public struct DescribeSecurityPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSecurityPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecurityPolicyOutputError>
}

extension DescribeSecurityPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecurityPolicyInput(securityPolicyName: \(String(describing: securityPolicyName)))"}
}

extension DescribeSecurityPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
    }
}

public struct DescribeSecurityPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSecurityPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecurityPolicyOutputError>
}

public struct DescribeSecurityPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSecurityPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSecurityPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSecurityPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSecurityPolicyInput>
    public typealias MOutput = OperationOutput<DescribeSecurityPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSecurityPolicyOutputError>
}

public struct DescribeSecurityPolicyInput: Equatable {
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: String?

    public init (
        securityPolicyName: String? = nil
    )
    {
        self.securityPolicyName = securityPolicyName
    }
}

struct DescribeSecurityPolicyInputBody: Equatable {
    public let securityPolicyName: String?
}

extension DescribeSecurityPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityPolicyName = "SecurityPolicyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
    }
}

extension DescribeSecurityPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSecurityPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSecurityPolicyOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSecurityPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSecurityPolicyOutputResponse(securityPolicy: \(String(describing: securityPolicy)))"}
}

extension DescribeSecurityPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSecurityPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityPolicy = output.securityPolicy
        } else {
            self.securityPolicy = nil
        }
    }
}

public struct DescribeSecurityPolicyOutputResponse: Equatable {
    /// <p>An array containing the properties of the security policy.</p>
    public let securityPolicy: DescribedSecurityPolicy?

    public init (
        securityPolicy: DescribedSecurityPolicy? = nil
    )
    {
        self.securityPolicy = securityPolicy
    }
}

struct DescribeSecurityPolicyOutputResponseBody: Equatable {
    public let securityPolicy: DescribedSecurityPolicy?
}

extension DescribeSecurityPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityPolicy = "SecurityPolicy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityPolicyDecoded = try containerValues.decodeIfPresent(DescribedSecurityPolicy.self, forKey: .securityPolicy)
        securityPolicy = securityPolicyDecoded
    }
}

public struct DescribeServerInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServerInput>
    public typealias MOutput = OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServerOutputError>
}

extension DescribeServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServerInput(serverId: \(String(describing: serverId)))"}
}

extension DescribeServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct DescribeServerInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServerInput>
    public typealias MOutput = OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServerOutputError>
}

public struct DescribeServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServerInput>
    public typealias MOutput = OperationOutput<DescribeServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServerOutputError>
}

public struct DescribeServerInput: Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct DescribeServerInputBody: Equatable {
    public let serverId: String?
}

extension DescribeServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension DescribeServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServerOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServerOutputResponse(server: \(String(describing: server)))"}
}

extension DescribeServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct DescribeServerOutputResponse: Equatable {
    /// <p>An array containing the properties of a server with the <code>ServerID</code> you
    ///       specified.</p>
    public let server: DescribedServer?

    public init (
        server: DescribedServer? = nil
    )
    {
        self.server = server
    }
}

struct DescribeServerOutputResponseBody: Equatable {
    public let server: DescribedServer?
}

extension DescribeServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(DescribedServer.self, forKey: .server)
        server = serverDecoded
    }
}

public struct DescribeUserInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

extension DescribeUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserInput(serverId: \(String(describing: serverId)), userName: \(String(describing: userName)))"}
}

extension DescribeUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct DescribeUserInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Equatable {
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: String?
    /// <p>The name of the user assigned to one or more servers. User names are part of the sign-in
    ///       credentials to use the AWS Transfer Family service and perform file transfer tasks.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct DescribeUserInputBody: Equatable {
    public let serverId: String?
    public let userName: String?
}

extension DescribeUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribeUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserOutputResponse(serverId: \(String(describing: serverId)), user: \(String(describing: user)))"}
}

extension DescribeUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
            self.user = output.user
        } else {
            self.serverId = nil
            self.user = nil
        }
    }
}

public struct DescribeUserOutputResponse: Equatable {
    /// <p>A system-assigned unique identifier for a server that has this user assigned.</p>
    public let serverId: String?
    /// <p>An array containing the properties of the user account for the <code>ServerID</code> value
    ///       that you specified.</p>
    public let user: DescribedUser?

    public init (
        serverId: String? = nil,
        user: DescribedUser? = nil
    )
    {
        self.serverId = serverId
        self.user = user
    }
}

struct DescribeUserOutputResponseBody: Equatable {
    public let serverId: String?
    public let user: DescribedUser?
}

extension DescribeUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case user = "User"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(DescribedUser.self, forKey: .user)
        user = userDecoded
    }
}

extension DescribedAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension DescribedAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribedAccess(externalId: \(String(describing: externalId)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)))"}
}

/// <p>Describes the properties of the access that was specified.</p>
public struct DescribedAccess: Equatable {
    /// <p>A unique identifier that might be required when you assume a role in another account.
    ///       Think of the <code>ExternalID</code> as a group membership mechanism that uses a unique
    ///       identifier (often a SID, but could be a group name or something else) as a basis. If the
    ///       administrator of the account to which the role belongs provided you with an external ID, then
    ///       provide that value in the <code>ExternalId</code> parameter. A cross-account role is usually
    ///       set up to trust everyone in an account. Therefore, the administrator of the trusting account
    ///       might send an external ID to the administrator of the trusted account. That way, only someone
    ///       with the ID can assume the role, rather than everyone in the account.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>Specifies the landing directory (or folder), which is the location that files are written
    ///       to or read from in an Amazon S3 bucket, for the described access.</p>
    public let homeDirectory: String?
    /// <p>Specifies the logical directory mappings that specify what Amazon S3 or Amazon EFS paths
    ///       and keys should be visible to the associated access and how you want to make them visible. You
    ///       must specify the "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code>
    ///       shows how the path is made visible and <code>Target</code> is the actual Amazon S3 or EFS
    ///       path. If you only specify a target, it will be displayed as is. You also must ensure that your
    ///       AWS Identity and Access Management (IAM) role provides access to paths in
    ///       <code>Target</code>.</p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down the
    ///       associated access to the designated home directory ("<code>chroot</code>"). To do this, you
    ///       can set <code>Entry</code> to '/' and set <code>Target</code> to the
    ///         <code>HomeDirectory</code> parameter value.</p>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it to
    ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>A scope-down policy for your user so that you can use the same AWS Identity and Access
    ///       Management (IAM) role across multiple users. This policy scopes down user access to portions
    ///       of their Amazon S3 bucket. Variables that you can use inside this policy include
    ///         <code>${Transfer:UserName}</code>, <code>${Transfer:HomeDirectory}</code>, and
    ///         <code>${Transfer:HomeBucket}</code>.</p>
    public let policy: String?
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>The IAM role that controls access to your Amazon S3 bucket from the specified associated
    ///       access. The policies attached to this role will determine the level of access that you want to
    ///       provide the associated access when transferring files into and out of your Amazon S3 bucket or
    ///       buckets. The IAM role should also contain a trust relationship that allows a server to access
    ///       your resources when servicing transfer requests for the associated access.</p>
    public let role: String?

    public init (
        externalId: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
    }
}

extension DescribedSecurityPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fips = "Fips"
        case securityPolicyName = "SecurityPolicyName"
        case sshCiphers = "SshCiphers"
        case sshKexs = "SshKexs"
        case sshMacs = "SshMacs"
        case tlsCiphers = "TlsCiphers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fips = fips {
            try encodeContainer.encode(fips, forKey: .fips)
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let sshCiphers = sshCiphers {
            var sshCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshCiphers)
            for securitypolicyoptions0 in sshCiphers {
                try sshCiphersContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshKexs = sshKexs {
            var sshKexsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshKexs)
            for securitypolicyoptions0 in sshKexs {
                try sshKexsContainer.encode(securitypolicyoptions0)
            }
        }
        if let sshMacs = sshMacs {
            var sshMacsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshMacs)
            for securitypolicyoptions0 in sshMacs {
                try sshMacsContainer.encode(securitypolicyoptions0)
            }
        }
        if let tlsCiphers = tlsCiphers {
            var tlsCiphersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tlsCiphers)
            for securitypolicyoptions0 in tlsCiphers {
                try tlsCiphersContainer.encode(securitypolicyoptions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fipsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .fips)
        fips = fipsDecoded
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let sshCiphersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sshCiphers)
        var sshCiphersDecoded0:[String]? = nil
        if let sshCiphersContainer = sshCiphersContainer {
            sshCiphersDecoded0 = [String]()
            for string0 in sshCiphersContainer {
                if let string0 = string0 {
                    sshCiphersDecoded0?.append(string0)
                }
            }
        }
        sshCiphers = sshCiphersDecoded0
        let sshKexsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sshKexs)
        var sshKexsDecoded0:[String]? = nil
        if let sshKexsContainer = sshKexsContainer {
            sshKexsDecoded0 = [String]()
            for string0 in sshKexsContainer {
                if let string0 = string0 {
                    sshKexsDecoded0?.append(string0)
                }
            }
        }
        sshKexs = sshKexsDecoded0
        let sshMacsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sshMacs)
        var sshMacsDecoded0:[String]? = nil
        if let sshMacsContainer = sshMacsContainer {
            sshMacsDecoded0 = [String]()
            for string0 in sshMacsContainer {
                if let string0 = string0 {
                    sshMacsDecoded0?.append(string0)
                }
            }
        }
        sshMacs = sshMacsDecoded0
        let tlsCiphersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tlsCiphers)
        var tlsCiphersDecoded0:[String]? = nil
        if let tlsCiphersContainer = tlsCiphersContainer {
            tlsCiphersDecoded0 = [String]()
            for string0 in tlsCiphersContainer {
                if let string0 = string0 {
                    tlsCiphersDecoded0?.append(string0)
                }
            }
        }
        tlsCiphers = tlsCiphersDecoded0
    }
}

extension DescribedSecurityPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribedSecurityPolicy(fips: \(String(describing: fips)), securityPolicyName: \(String(describing: securityPolicyName)), sshCiphers: \(String(describing: sshCiphers)), sshKexs: \(String(describing: sshKexs)), sshMacs: \(String(describing: sshMacs)), tlsCiphers: \(String(describing: tlsCiphers)))"}
}

/// <p>Describes the properties of a security policy that was specified. For more information
///       about security policies, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/security-policies.html">Working with security
///         policies</a>.</p>
public struct DescribedSecurityPolicy: Equatable {
    /// <p>Specifies whether this policy enables Federal Information Processing Standards
    ///       (FIPS).</p>
    public let fips: Bool?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: String?
    /// <p>Specifies the enabled Secure Shell (SSH) cipher encryption algorithms in the security
    ///       policy that is attached to the server.</p>
    public let sshCiphers: [String]?
    /// <p>Specifies the enabled SSH key exchange (KEX) encryption algorithms in the security policy
    ///       that is attached to the server.</p>
    public let sshKexs: [String]?
    /// <p>Specifies the enabled SSH message authentication code (MAC) encryption algorithms in the
    ///       security policy that is attached to the server.</p>
    public let sshMacs: [String]?
    /// <p>Specifies the enabled Transport Layer Security (TLS) cipher encryption algorithms in the
    ///       security policy that is attached to the server.</p>
    public let tlsCiphers: [String]?

    public init (
        fips: Bool? = nil,
        securityPolicyName: String? = nil,
        sshCiphers: [String]? = nil,
        sshKexs: [String]? = nil,
        sshMacs: [String]? = nil,
        tlsCiphers: [String]? = nil
    )
    {
        self.fips = fips
        self.securityPolicyName = securityPolicyName
        self.sshCiphers = sshCiphers
        self.sshKexs = sshKexs
        self.sshMacs = sshMacs
        self.tlsCiphers = tlsCiphers
    }
}

extension DescribedServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case certificate = "Certificate"
        case domain = "Domain"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKeyFingerprint = "HostKeyFingerprint"
        case identityProviderDetails = "IdentityProviderDetails"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
        case state = "State"
        case tags = "Tags"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKeyFingerprint = hostKeyFingerprint {
            try encodeContainer.encode(hostKeyFingerprint, forKey: .hostKeyFingerprint)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyFingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostKeyFingerprint)
        hostKeyFingerprint = hostKeyFingerprintDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension DescribedServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribedServer(arn: \(String(describing: arn)), certificate: \(String(describing: certificate)), domain: \(String(describing: domain)), endpointDetails: \(String(describing: endpointDetails)), endpointType: \(String(describing: endpointType)), hostKeyFingerprint: \(String(describing: hostKeyFingerprint)), identityProviderDetails: \(String(describing: identityProviderDetails)), identityProviderType: \(String(describing: identityProviderType)), loggingRole: \(String(describing: loggingRole)), protocols: \(String(describing: protocols)), securityPolicyName: \(String(describing: securityPolicyName)), serverId: \(String(describing: serverId)), state: \(String(describing: state)), tags: \(String(describing: tags)), userCount: \(String(describing: userCount)))"}
}

/// <p>Describes the properties of a file transfer protocol-enabled server that was
///       specified.</p>
public struct DescribedServer: Equatable {
    /// <p>Specifies the unique Amazon Resource Name (ARN) of the server.</p>
    public let arn: String?
    /// <p>Specifies the ARN of the AWS Certificate Manager (ACM) certificate. Required when
    ///         <code>Protocols</code> is set to <code>FTPS</code>.</p>
    public let certificate: String?
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    public let domain: Domain?
    /// <p>Specifies the virtual private cloud (VPC) endpoint settings that you configured for your
    ///       server.</p>
    public let endpointDetails: EndpointDetails?
    /// <p>Defines the type of endpoint that your server is connected to. If your server is connected
    ///       to a VPC endpoint, your server isn't accessible over the public internet.</p>
    public let endpointType: EndpointType?
    /// <p>Specifies the Base64-encoded SHA256 fingerprint of the server's host key. This value
    ///       is equivalent to the output of the <code>ssh-keygen -l -f my-new-server-key</code>
    ///       command.</p>
    public let hostKeyFingerprint: String?
    /// <p>Specifies information to call a customer-supplied authentication API. This field is not
    ///       populated when the <code>IdentityProviderType</code> of a server is
    ///       <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>.</p>
    public let identityProviderDetails: IdentityProviderDetails?
    /// <p>Specifies the mode of authentication method enabled for this service. A value of
    ///         <code>AWS_DIRECTORY_SERVICE</code> means that you are providing access to Active Directory
    ///       groups in AWS Managed Active Directory or Microsoft Active Directory in your on-premises
    ///       environment or in AWS using AD Connectors. A value of <code>SERVICE_MANAGED</code> means that
    ///       you are using this server to store and access user credentials within the service. A value of
    ///         <code>API_GATEWAY</code> indicates that you have integrated an API Gateway endpoint that
    ///       will be invoked for authenticating your user into the service.</p>
    public let identityProviderType: IdentityProviderType?
    /// <p>Specifies the AWS Identity and Access Management (IAM) role that allows a server to turn
    ///       on Amazon CloudWatch logging for Amazon S3 or Amazon EFS events. When set, user activity can be viewed in
    ///       your CloudWatch logs.</p>
    public let loggingRole: String?
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    ///       client can connect to your server's endpoint. The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SFTP</code> (Secure Shell (SSH) File Transfer Protocol): File transfer over
    ///           SSH</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTPS</code> (File Transfer Protocol Secure): File transfer with TLS
    ///           encryption</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FTP</code> (File Transfer Protocol): Unencrypted file transfer</p>
    ///             </li>
    ///          </ul>
    public let protocols: [`Protocol`]?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: String?
    /// <p>Specifies the unique system-assigned identifier for a server that you instantiate.</p>
    public let serverId: String?
    /// <p>Specifies the condition of a server for the server that was described. A value of
    ///         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
    ///         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
    ///       transfer operations.</p>
    ///
    ///          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
    ///       in an intermediate state, either not fully able to respond, or not fully offline. The values
    ///       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
    ///       condition.</p>
    public let state: State?
    /// <p>Specifies the key-value pairs that you can use to search for and group servers that were
    ///       assigned to the server that was described.</p>
    public let tags: [Tag]?
    /// <p>Specifies the number of users that are assigned to a server you specified with the
    ///         <code>ServerId</code>.</p>
    public let userCount: Int?

    public init (
        arn: String? = nil,
        certificate: String? = nil,
        domain: Domain? = nil,
        endpointDetails: EndpointDetails? = nil,
        endpointType: EndpointType? = nil,
        hostKeyFingerprint: String? = nil,
        identityProviderDetails: IdentityProviderDetails? = nil,
        identityProviderType: IdentityProviderType? = nil,
        loggingRole: String? = nil,
        protocols: [`Protocol`]? = nil,
        securityPolicyName: String? = nil,
        serverId: String? = nil,
        state: State? = nil,
        tags: [Tag]? = nil,
        userCount: Int? = nil
    )
    {
        self.arn = arn
        self.certificate = certificate
        self.domain = domain
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKeyFingerprint = hostKeyFingerprint
        self.identityProviderDetails = identityProviderDetails
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
        self.state = state
        self.tags = tags
        self.userCount = userCount
    }
}

extension DescribedUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case sshPublicKeys = "SshPublicKeys"
        case tags = "Tags"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeys = sshPublicKeys {
            var sshPublicKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sshPublicKeys)
            for sshpublickeys0 in sshPublicKeys {
                try sshPublicKeysContainer.encode(sshpublickeys0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeysContainer = try containerValues.decodeIfPresent([SshPublicKey?].self, forKey: .sshPublicKeys)
        var sshPublicKeysDecoded0:[SshPublicKey]? = nil
        if let sshPublicKeysContainer = sshPublicKeysContainer {
            sshPublicKeysDecoded0 = [SshPublicKey]()
            for structure0 in sshPublicKeysContainer {
                if let structure0 = structure0 {
                    sshPublicKeysDecoded0?.append(structure0)
                }
            }
        }
        sshPublicKeys = sshPublicKeysDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension DescribedUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribedUser(arn: \(String(describing: arn)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), sshPublicKeys: \(String(describing: sshPublicKeys)), tags: \(String(describing: tags)), userName: \(String(describing: userName)))"}
}

/// <p>Describes the properties of a user that was specified.</p>
public struct DescribedUser: Equatable {
    /// <p>Specifies the unique Amazon Resource Name (ARN) for the user that was requested to be
    ///       described.</p>
    public let arn: String?
    /// <p>Specifies the landing directory (or folder), which is the location that files are written
    ///       to or read from in an Amazon S3 bucket, for the described user. An example is
    ///           <i>
    ///                <code>your-Amazon-S3-bucket-name>/home/username</code>
    ///             </i>.</p>
    public let homeDirectory: String?
    /// <p>Specifies the logical directory mappings that specify what Amazon S3 or EFS paths and keys should
    ///       be visible to your user and how you want to make them visible. You will need to specify the
    ///         "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code> shows how the
    ///       path is made visible and <code>Target</code> is the actual Amazon S3 or EFS path. If you only specify
    ///       a target, it will be displayed as is. You will need to also make sure that your AWS Identity
    ///       and Access Management (IAM) role provides access to paths in <code>Target</code>.</p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock your user
    ///       down to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>Specifies the type of landing directory (folder) you mapped for your users to see when
    ///       they log into the file transfer protocol-enabled server. If you set it to <code>PATH</code>,
    ///       the user will see the absolute Amazon S3 bucket or EFS paths as is in their file transfer protocol
    ///       clients. If you set it <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or EFS paths visible to your
    ///       users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>Specifies the name of the policy in use for the described user.</p>
    public let policy: String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon Elastic File System (Amazon EFS) file systems. The POSIX
    ///       permissions that are set on files and directories in your file system determine the level of
    ///       access your users get when transferring files into and out of your Amazon EFS file
    ///       systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket. The
    ///       policies attached to this role will determine the level of access you want to provide your
    ///       users when transferring files into and out of your Amazon S3 bucket or buckets. The IAM role
    ///       should also contain a trust relationship that allows a server to access your resources when
    ///       servicing your users' transfer requests.</p>
    public let role: String?
    /// <p>Specifies the public key portion of the Secure Shell (SSH) keys stored for the described
    ///       user.</p>
    public let sshPublicKeys: [SshPublicKey]?
    /// <p>Specifies the key-value pairs for the user requested. Tag can be used to search for and
    ///       group users for a variety of purposes.</p>
    public let tags: [Tag]?
    /// <p>Specifies the name of the user that was requested to be described. User names are used for
    ///       authentication purposes. This is the string that will be used by your user when they log in to
    ///       your server.</p>
    public let userName: String?

    public init (
        arn: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        sshPublicKeys: [SshPublicKey]? = nil,
        tags: [Tag]? = nil,
        userName: String? = nil
    )
    {
        self.arn = arn
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.sshPublicKeys = sshPublicKeys
        self.tags = tags
        self.userName = userName
    }
}

public enum Domain {
    case efs
    case s3
    case sdkUnknown(String)
}

extension Domain : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Domain] {
        return [
            .efs,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .efs: return "EFS"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
    }
}

extension EndpointDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressAllocationIds = "AddressAllocationIds"
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcEndpointId = "VpcEndpointId"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressAllocationIds = addressAllocationIds {
            var addressAllocationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addressAllocationIds)
            for addressallocationids0 in addressAllocationIds {
                try addressAllocationIdsContainer.encode(addressallocationids0)
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcEndpointId = vpcEndpointId {
            try encodeContainer.encode(vpcEndpointId, forKey: .vpcEndpointId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressAllocationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .addressAllocationIds)
        var addressAllocationIdsDecoded0:[String]? = nil
        if let addressAllocationIdsContainer = addressAllocationIdsContainer {
            addressAllocationIdsDecoded0 = [String]()
            for string0 in addressAllocationIdsContainer {
                if let string0 = string0 {
                    addressAllocationIdsDecoded0?.append(string0)
                }
            }
        }
        addressAllocationIds = addressAllocationIdsDecoded0
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcEndpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcEndpointId)
        vpcEndpointId = vpcEndpointIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension EndpointDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointDetails(addressAllocationIds: \(String(describing: addressAllocationIds)), securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcEndpointId: \(String(describing: vpcEndpointId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The virtual private cloud (VPC) endpoint settings that are configured for your file
///       transfer protocol-enabled server. With a VPC endpoint, you can restrict access to your server
///       and resources only within your VPC. To control incoming internet traffic, invoke the
///         <code>UpdateServer</code> API and attach an Elastic IP address to your server's
///       endpoint.</p>
///          <note>
///             <p> After March 31, 2021, you won't be able to create a server using
///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
///       done so before March 31, 2021. If you have already created servers with
///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
///         you will not be affected. After this date, use
///         <code>EndpointType</code>=<code>VPC</code>.</p>
///
///             <p>For more information, see
///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
///          </note>
public struct EndpointDetails: Equatable {
    /// <p>A list of address allocation IDs that are required to attach an Elastic IP address to your
    ///       server's endpoint.</p>
    ///
    ///          <note>
    ///
    ///             <p>This property can only be set when <code>EndpointType</code> is set to <code>VPC</code>
    ///         and it is only valid in the <code>UpdateServer</code> API.</p>
    ///          </note>
    public let addressAllocationIds: [String]?
    /// <p>A list of security groups IDs that are available to attach to your server's
    ///       endpoint.</p>
    ///
    ///          <note>
    ///             <p>This property can only be set when <code>EndpointType</code> is set to
    ///         <code>VPC</code>.</p>
    ///
    ///             <p>You can edit the <code>SecurityGroupIds</code> property in the <a href="https://docs.aws.amazon.com/transfer/latest/userguide/API_UpdateServer.html">UpdateServer</a> API only if you are changing the <code>EndpointType</code> from
    ///           <code>PUBLIC</code> or <code>VPC_ENDPOINT</code> to <code>VPC</code>. To change security
    ///         groups associated with your server's VPC endpoint after creation, use the Amazon EC2
    ///           <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyVpcEndpoint.html">ModifyVpcEndpoint</a> API.</p>
    ///          </note>
    public let securityGroupIds: [String]?
    /// <p>A list of subnet IDs that are required to host your server endpoint in your VPC.</p>
    ///
    ///          <note>
    ///             <p>This property can only be set when <code>EndpointType</code> is set to
    ///         <code>VPC</code>.</p>
    ///          </note>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC endpoint.</p>
    ///
    ///          <note>
    ///             <p>This property can only be set when <code>EndpointType</code> is set to
    ///           <code>VPC_ENDPOINT</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///          </note>
    public let vpcEndpointId: String?
    /// <p>The VPC ID of the VPC in which a server's endpoint will be hosted.</p>
    ///
    ///          <note>
    ///             <p>This property can only be set when <code>EndpointType</code> is set to
    ///         <code>VPC</code>.</p>
    ///          </note>
    public let vpcId: String?

    public init (
        addressAllocationIds: [String]? = nil,
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcEndpointId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.addressAllocationIds = addressAllocationIds
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcEndpointId = vpcEndpointId
        self.vpcId = vpcId
    }
}

public enum EndpointType {
    case `public`
    case vpc
    case vpcEndpoint
    case sdkUnknown(String)
}

extension EndpointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndpointType] {
        return [
            .public,
            .vpc,
            .vpcEndpoint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .public: return "PUBLIC"
        case .vpc: return "VPC"
        case .vpcEndpoint: return "VPC_ENDPOINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndpointType(rawValue: rawValue) ?? EndpointType.sdkUnknown(rawValue)
    }
}

extension HomeDirectoryMapEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entry = "Entry"
        case target = "Target"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entry = entry {
            try encodeContainer.encode(entry, forKey: .entry)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entry)
        entry = entryDecoded
        let targetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .target)
        target = targetDecoded
    }
}

extension HomeDirectoryMapEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HomeDirectoryMapEntry(entry: \(String(describing: entry)), target: \(String(describing: target)))"}
}

/// <p>Represents an object that contains entries and targets for
///         <code>HomeDirectoryMappings</code>.</p>
public struct HomeDirectoryMapEntry: Equatable {
    /// <p>Represents an entry and a target for <code>HomeDirectoryMappings</code>.</p>
    public let entry: String?
    /// <p>Represents the map target that is used in a <code>HomeDirectorymapEntry</code>.</p>
    public let target: String?

    public init (
        entry: String? = nil,
        target: String? = nil
    )
    {
        self.entry = entry
        self.target = target
    }
}

public enum HomeDirectoryType {
    case logical
    case path
    case sdkUnknown(String)
}

extension HomeDirectoryType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HomeDirectoryType] {
        return [
            .logical,
            .path,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .logical: return "LOGICAL"
        case .path: return "PATH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HomeDirectoryType(rawValue: rawValue) ?? HomeDirectoryType.sdkUnknown(rawValue)
    }
}

extension IdentityProviderDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case directoryId = "DirectoryId"
        case invocationRole = "InvocationRole"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let invocationRole = invocationRole {
            try encodeContainer.encode(invocationRole, forKey: .invocationRole)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let invocationRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationRole)
        invocationRole = invocationRoleDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
    }
}

extension IdentityProviderDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityProviderDetails(directoryId: \(String(describing: directoryId)), invocationRole: \(String(describing: invocationRole)), url: \(String(describing: url)))"}
}

/// <p>Returns information related to the type of user authentication that is in use for a file
///       transfer protocol-enabled server's users. A server can have only one method of
///       authentication.</p>
public struct IdentityProviderDetails: Equatable {
    /// <p>The identifier of the AWS Directory Service directory that you want to stop sharing.</p>
    public let directoryId: String?
    /// <p>Provides the type of <code>InvocationRole</code> used to authenticate the user
    ///       account.</p>
    public let invocationRole: String?
    /// <p>Provides the location of the service endpoint used to authenticate users.</p>
    public let url: String?

    public init (
        directoryId: String? = nil,
        invocationRole: String? = nil,
        url: String? = nil
    )
    {
        self.directoryId = directoryId
        self.invocationRole = invocationRole
        self.url = url
    }
}

/// <p>Returns information related to the type of user authentication that is in use for a file
///       transfer protocol-enabled server's users. For <code>AWS_DIRECTORY_SERVICE</code> or <code>SERVICE_MANAGED</code>
///       authentication, the Secure Shell (SSH) public keys are stored with a user on the server
///       instance. For <code>API_GATEWAY</code> authentication, your custom authentication method is
///       implemented by using an API call. The server can have only one method of
///       authentication.</p>
public enum IdentityProviderType {
    case apiGateway
    case awsDirectoryService
    case serviceManaged
    case sdkUnknown(String)
}

extension IdentityProviderType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IdentityProviderType] {
        return [
            .apiGateway,
            .awsDirectoryService,
            .serviceManaged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .apiGateway: return "API_GATEWAY"
        case .awsDirectoryService: return "AWS_DIRECTORY_SERVICE"
        case .serviceManaged: return "SERVICE_MANAGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IdentityProviderType(rawValue: rawValue) ?? IdentityProviderType.sdkUnknown(rawValue)
    }
}

public struct ImportSshPublicKeyInputBodyMiddleware: Middleware {
    public let id: String = "ImportSshPublicKeyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSshPublicKeyOutputError>
}

extension ImportSshPublicKeyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSshPublicKeyInput(serverId: \(String(describing: serverId)), sshPublicKeyBody: \(String(describing: sshPublicKeyBody)), userName: \(String(describing: userName)))"}
}

extension ImportSshPublicKeyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct ImportSshPublicKeyInputHeadersMiddleware: Middleware {
    public let id: String = "ImportSshPublicKeyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSshPublicKeyOutputError>
}

public struct ImportSshPublicKeyInputQueryItemMiddleware: Middleware {
    public let id: String = "ImportSshPublicKeyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ImportSshPublicKeyInput>,
                  next: H) -> Swift.Result<OperationOutput<ImportSshPublicKeyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ImportSshPublicKeyInput>
    public typealias MOutput = OperationOutput<ImportSshPublicKeyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ImportSshPublicKeyOutputError>
}

public struct ImportSshPublicKeyInput: Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: String?
    /// <p>The public key portion of an SSH key pair.</p>
    public let sshPublicKeyBody: String?
    /// <p>The name of the user account that is assigned to one or more servers.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        sshPublicKeyBody: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyBody = sshPublicKeyBody
        self.userName = userName
    }
}

struct ImportSshPublicKeyInputBody: Equatable {
    public let serverId: String?
    public let sshPublicKeyBody: String?
    public let userName: String?
}

extension ImportSshPublicKeyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ImportSshPublicKeyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportSshPublicKeyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportSshPublicKeyOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportSshPublicKeyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportSshPublicKeyOutputResponse(serverId: \(String(describing: serverId)), sshPublicKeyId: \(String(describing: sshPublicKeyId)), userName: \(String(describing: userName)))"}
}

extension ImportSshPublicKeyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ImportSshPublicKeyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
            self.sshPublicKeyId = output.sshPublicKeyId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.sshPublicKeyId = nil
            self.userName = nil
        }
    }
}

/// <p>Identifies the user, the server they belong to, and the identifier of the SSH public key
///       associated with that user. A user can have more than one key on each server that they are
///       associated with.</p>
public struct ImportSshPublicKeyOutputResponse: Equatable {
    /// <p>A system-assigned unique identifier for a server.</p>
    public let serverId: String?
    /// <p>The name given to a public key by the system that was imported.</p>
    public let sshPublicKeyId: String?
    /// <p>A user name assigned to the <code>ServerID</code> value that you specified.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        sshPublicKeyId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.sshPublicKeyId = sshPublicKeyId
        self.userName = userName
    }
}

struct ImportSshPublicKeyOutputResponseBody: Equatable {
    public let serverId: String?
    public let sshPublicKeyId: String?
    public let userName: String?
}

extension ImportSshPublicKeyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case sshPublicKeyId = "SshPublicKeyId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension InternalServiceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceError(message: \(String(describing: message)))"}
}

extension InternalServiceError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when an error occurs in the AWS Transfer Family service.</p>
public struct InternalServiceError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> parameter that was passed is invalid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the client submits a malformed request.</p>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccessesInputBodyMiddleware: Middleware {
    public let id: String = "ListAccessesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessesInput>
    public typealias MOutput = OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessesOutputError>
}

extension ListAccessesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serverId: \(String(describing: serverId)))"}
}

extension ListAccessesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct ListAccessesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessesInput>
    public typealias MOutput = OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessesOutputError>
}

public struct ListAccessesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessesInput>
    public typealias MOutput = OperationOutput<ListAccessesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessesOutputError>
}

public struct ListAccessesInput: Equatable {
    /// <p>Specifies the maximum number of access SIDs to return.</p>
    public let maxResults: Int?
    /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       accesses.</p>
    public let nextToken: String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serverId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let serverId: String?
}

extension ListAccessesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListAccessesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessesOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessesOutputResponse(accesses: \(String(describing: accesses)), nextToken: \(String(describing: nextToken)), serverId: \(String(describing: serverId)))"}
}

extension ListAccessesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accesses = output.accesses
            self.nextToken = output.nextToken
            self.serverId = output.serverId
        } else {
            self.accesses = nil
            self.nextToken = nil
            self.serverId = nil
        }
    }
}

public struct ListAccessesOutputResponse: Equatable {
    /// <p>Returns the accesses and their properties for the <code>ServerId</code> value that you
    ///       specify.</p>
    public let accesses: [ListedAccess]?
    /// <p>When you can get additional results from the <code>ListAccesses</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       accesses.</p>
    public let nextToken: String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: String?

    public init (
        accesses: [ListedAccess]? = nil,
        nextToken: String? = nil,
        serverId: String? = nil
    )
    {
        self.accesses = accesses
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListAccessesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let serverId: String?
    public let accesses: [ListedAccess]?
}

extension ListAccessesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accesses = "Accesses"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let accessesContainer = try containerValues.decodeIfPresent([ListedAccess?].self, forKey: .accesses)
        var accessesDecoded0:[ListedAccess]? = nil
        if let accessesContainer = accessesContainer {
            accessesDecoded0 = [ListedAccess]()
            for structure0 in accessesContainer {
                if let structure0 = structure0 {
                    accessesDecoded0?.append(structure0)
                }
            }
        }
        accesses = accessesDecoded0
    }
}

public struct ListSecurityPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListSecurityPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityPoliciesOutputError>
}

extension ListSecurityPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityPoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSecurityPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListSecurityPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListSecurityPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityPoliciesOutputError>
}

public struct ListSecurityPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSecurityPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSecurityPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSecurityPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSecurityPoliciesInput>
    public typealias MOutput = OperationOutput<ListSecurityPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSecurityPoliciesOutputError>
}

public struct ListSecurityPoliciesInput: Equatable {
    /// <p>Specifies the number of security policies to return as a response to the
    ///         <code>ListSecurityPolicies</code> query.</p>
    public let maxResults: Int?
    /// <p>When additional results are obtained from the <code>ListSecurityPolicies</code> command, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass the
    ///         <code>NextToken</code> parameter in a subsequent command to continue listing additional
    ///       security policies.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSecurityPoliciesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListSecurityPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSecurityPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSecurityPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSecurityPoliciesOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSecurityPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSecurityPoliciesOutputResponse(nextToken: \(String(describing: nextToken)), securityPolicyNames: \(String(describing: securityPolicyNames)))"}
}

extension ListSecurityPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSecurityPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.securityPolicyNames = output.securityPolicyNames
        } else {
            self.nextToken = nil
            self.securityPolicyNames = nil
        }
    }
}

public struct ListSecurityPoliciesOutputResponse: Equatable {
    /// <p>When you can get additional results from the <code>ListSecurityPolicies</code> operation,
    ///       a <code>NextToken</code> parameter is returned in the output. In a following command, you can
    ///       pass in the <code>NextToken</code> parameter to continue listing security policies.</p>
    public let nextToken: String?
    /// <p>An array of security policies that were listed.</p>
    public let securityPolicyNames: [String]?

    public init (
        nextToken: String? = nil,
        securityPolicyNames: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.securityPolicyNames = securityPolicyNames
    }
}

struct ListSecurityPoliciesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let securityPolicyNames: [String]?
}

extension ListSecurityPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case securityPolicyNames = "SecurityPolicyNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let securityPolicyNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityPolicyNames)
        var securityPolicyNamesDecoded0:[String]? = nil
        if let securityPolicyNamesContainer = securityPolicyNamesContainer {
            securityPolicyNamesDecoded0 = [String]()
            for string0 in securityPolicyNamesContainer {
                if let string0 = string0 {
                    securityPolicyNamesDecoded0?.append(string0)
                }
            }
        }
        securityPolicyNames = securityPolicyNamesDecoded0
    }
}

public struct ListServersInputBodyMiddleware: Middleware {
    public let id: String = "ListServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServersInput>
    public typealias MOutput = OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServersOutputError>
}

extension ListServersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListServersInputHeadersMiddleware: Middleware {
    public let id: String = "ListServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServersInput>
    public typealias MOutput = OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServersOutputError>
}

public struct ListServersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServersInput>
    public typealias MOutput = OperationOutput<ListServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServersOutputError>
}

public struct ListServersInput: Equatable {
    /// <p>Specifies the number of servers to return as a response to the <code>ListServers</code>
    ///       query.</p>
    public let maxResults: Int?
    /// <p>When additional results are obtained from the <code>ListServers</code> command, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass the
    ///         <code>NextToken</code> parameter in a subsequent command to continue listing additional
    ///       servers.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListServersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListServersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServersOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServersOutputResponse(nextToken: \(String(describing: nextToken)), servers: \(String(describing: servers)))"}
}

extension ListServersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct ListServersOutputResponse: Equatable {
    /// <p>When you can get additional results from the <code>ListServers</code> operation, a
    ///         <code>NextToken</code> parameter is returned in the output. In a following command, you can
    ///       pass in the <code>NextToken</code> parameter to continue listing additional servers.</p>
    public let nextToken: String?
    /// <p>An array of servers that were listed.</p>
    public let servers: [ListedServer]?

    public init (
        nextToken: String? = nil,
        servers: [ListedServer]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct ListServersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let servers: [ListedServer]?
}

extension ListServersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serversContainer = try containerValues.decodeIfPresent([ListedServer?].self, forKey: .servers)
        var serversDecoded0:[ListedServer]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [ListedServer]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(arn: \(String(describing: arn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>Requests the tags associated with a particular Amazon Resource Name (ARN). An ARN is an
    ///       identifier for a specific AWS resource, such as a server, user, or role.</p>
    public let arn: String?
    /// <p>Specifies the number of tags to return as a response to the
    ///         <code>ListTagsForResource</code> request.</p>
    public let maxResults: Int?
    /// <p>When you request additional results from the <code>ListTagsForResource</code> operation, a
    ///         <code>NextToken</code> parameter is returned in the input. You can then pass in a subsequent
    ///       command to the <code>NextToken</code> parameter to continue listing additional tags.</p>
    public let nextToken: String?

    public init (
        arn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let arn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(arn: \(String(describing: arn)), nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.arn = nil
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The ARN you specified to list the tags of.</p>
    public let arn: String?
    /// <p>When you can get additional results from the <code>ListTagsForResource</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       tags.</p>
    public let nextToken: String?
    /// <p>Key-value pairs that are assigned to a resource, usually for the purpose of grouping and
    ///       searching for items. Tags are metadata that you define.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let arn: String?
    public let nextToken: String?
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListUsersInputBodyMiddleware: Middleware {
    public let id: String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serverId: \(String(describing: serverId)))"}
}

extension ListUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// <p>Specifies the number of users to return as a response to the <code>ListUsers</code>
    ///       request.</p>
    public let maxResults: Int?
    /// <p>When you can get additional results from the <code>ListUsers</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       users.</p>
    public let nextToken: String?
    /// <p>A system-assigned unique identifier for a server that has users assigned to it.</p>
    public let serverId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serverId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct ListUsersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
    public let serverId: String?
}

extension ListUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(nextToken: \(String(describing: nextToken)), serverId: \(String(describing: serverId)), users: \(String(describing: users)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.serverId = output.serverId
            self.users = output.users
        } else {
            self.nextToken = nil
            self.serverId = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Equatable {
    /// <p>When you can get additional results from the <code>ListUsers</code> call, a
    ///         <code>NextToken</code> parameter is returned in the output. You can then pass in a
    ///       subsequent command to the <code>NextToken</code> parameter to continue listing additional
    ///       users.</p>
    public let nextToken: String?
    /// <p>A system-assigned unique identifier for a server that the users are assigned to.</p>
    public let serverId: String?
    /// <p>Returns the user accounts and their properties for the <code>ServerId</code> value that
    ///       you specify.</p>
    public let users: [ListedUser]?

    public init (
        nextToken: String? = nil,
        serverId: String? = nil,
        users: [ListedUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverId = serverId
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let serverId: String?
    public let users: [ListedUser]?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serverId = "ServerId"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([ListedUser?].self, forKey: .users)
        var usersDecoded0:[ListedUser]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [ListedUser]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension ListedAccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension ListedAccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListedAccess(externalId: \(String(describing: externalId)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryType: \(String(describing: homeDirectoryType)), role: \(String(describing: role)))"}
}

/// <p>Lists the properties for one or more specified associated accesses.</p>
public struct ListedAccess: Equatable {
    /// <p>A unique identifier that might be required when you assume a role in another account. Think
    ///       of the <code>ExternalID</code> as a group membership mechanism that uses a unique identifier
    ///       (often a SID, but could be a group name or something else) as a basis. If the administrator of
    ///       the account to which the role belongs provided you with an external ID, then provide that
    ///       value in the <code>ExternalId</code> parameter. A cross-account role is usually set up to
    ///       trust everyone in an account. Therefore, the administrator of the trusting account might send
    ///       an external ID to the administrator of the trusted account. That way, only someone with the ID
    ///       can assume the role, rather than everyone in the account.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>Specifies the landing directory (or folder), which is the location that files are written
    ///       to or read from in an Amazon S3 bucket, for the described access.</p>
    public let homeDirectory: String?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it to
    ///         <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>The AWS Identity and Access Management (IAM) role that controls access to your Amazon S3
    ///       bucket from the specified associated access. The policies attached to this role will determine
    ///       the level of access that you want to provide the associated access when transferring files
    ///       into and out of your Amazon S3 bucket or buckets. The IAM role should also contain a trust
    ///       relationship that allows a server to access your resources when servicing transfer requests
    ///       for the associated access.</p>
    public let role: String?

    public init (
        externalId: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        role: String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryType = homeDirectoryType
        self.role = role
    }
}

extension ListedServer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case domain = "Domain"
        case endpointType = "EndpointType"
        case identityProviderType = "IdentityProviderType"
        case loggingRole = "LoggingRole"
        case serverId = "ServerId"
        case state = "State"
        case userCount = "UserCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let identityProviderType = identityProviderType {
            try encodeContainer.encode(identityProviderType.rawValue, forKey: .identityProviderType)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userCount = userCount {
            try encodeContainer.encode(userCount, forKey: .userCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let identityProviderTypeDecoded = try containerValues.decodeIfPresent(IdentityProviderType.self, forKey: .identityProviderType)
        identityProviderType = identityProviderTypeDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let userCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .userCount)
        userCount = userCountDecoded
    }
}

extension ListedServer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListedServer(arn: \(String(describing: arn)), domain: \(String(describing: domain)), endpointType: \(String(describing: endpointType)), identityProviderType: \(String(describing: identityProviderType)), loggingRole: \(String(describing: loggingRole)), serverId: \(String(describing: serverId)), state: \(String(describing: state)), userCount: \(String(describing: userCount)))"}
}

/// <p>Returns properties of a file transfer protocol-enabled server that was specified.</p>
public struct ListedServer: Equatable {
    /// <p>Specifies the unique Amazon Resource Name (ARN) for a server to be listed.</p>
    public let arn: String?
    /// <p>Specifies the domain of the storage system that is used for file transfers.</p>
    public let domain: Domain?
    /// <p>Specifies the type of VPC endpoint that your server is connected to. If your server is
    ///       connected to a VPC endpoint, your server isn't accessible over the public
    ///       internet.</p>
    public let endpointType: EndpointType?
    /// <p>Specifies the authentication method used to validate a user for a server that was
    ///       specified. This can include Secure Shell (SSH), Active Directory groups, user name and
    ///       password combinations, or your own custom authentication method. </p>
    public let identityProviderType: IdentityProviderType?
    /// <p>Specifies the AWS Identity and Access Management (IAM) role that allows a server to turn
    ///       on Amazon CloudWatch logging.</p>
    public let loggingRole: String?
    /// <p>Specifies the unique system assigned identifier for the servers that were listed.</p>
    public let serverId: String?
    /// <p>Specifies the condition of a server for the server that was described. A value of
    ///         <code>ONLINE</code> indicates that the server can accept jobs and transfer files. A
    ///         <code>State</code> value of <code>OFFLINE</code> means that the server cannot perform file
    ///       transfer operations.</p>
    ///
    ///          <p>The states of <code>STARTING</code> and <code>STOPPING</code> indicate that the server is
    ///       in an intermediate state, either not fully able to respond, or not fully offline. The values
    ///       of <code>START_FAILED</code> or <code>STOP_FAILED</code> can indicate an error
    ///       condition.</p>
    public let state: State?
    /// <p>Specifies the number of users that are assigned to a server you specified with the
    ///         <code>ServerId</code>.</p>
    public let userCount: Int?

    public init (
        arn: String? = nil,
        domain: Domain? = nil,
        endpointType: EndpointType? = nil,
        identityProviderType: IdentityProviderType? = nil,
        loggingRole: String? = nil,
        serverId: String? = nil,
        state: State? = nil,
        userCount: Int? = nil
    )
    {
        self.arn = arn
        self.domain = domain
        self.endpointType = endpointType
        self.identityProviderType = identityProviderType
        self.loggingRole = loggingRole
        self.serverId = serverId
        self.state = state
        self.userCount = userCount
    }
}

extension ListedUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryType = "HomeDirectoryType"
        case role = "Role"
        case sshPublicKeyCount = "SshPublicKeyCount"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let sshPublicKeyCount = sshPublicKeyCount {
            try encodeContainer.encode(sshPublicKeyCount, forKey: .sshPublicKeyCount)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let sshPublicKeyCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sshPublicKeyCount)
        sshPublicKeyCount = sshPublicKeyCountDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension ListedUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListedUser(arn: \(String(describing: arn)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryType: \(String(describing: homeDirectoryType)), role: \(String(describing: role)), sshPublicKeyCount: \(String(describing: sshPublicKeyCount)), userName: \(String(describing: userName)))"}
}

/// <p>Returns properties of the user that you specify.</p>
public struct ListedUser: Equatable {
    /// <p>Provides the unique Amazon Resource Name (ARN) for the user that you want to learn
    ///       about.</p>
    public let arn: String?
    /// <p>Specifies the location that files are written to or read from an Amazon S3 bucket for the
    ///       user you specify by their ARN.</p>
    public let homeDirectory: String?
    /// <p>Specifies the type of landing directory (folder) you mapped for your users' home
    ///       directory. If you set it to <code>PATH</code>, the user will see the absolute Amazon S3 bucket
    ///       paths as is in their file transfer protocol clients. If you set it <code>LOGICAL</code>, you
    ///       will need to provide mappings in the <code>HomeDirectoryMappings</code> for how you want to
    ///       make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>Specifies the role that is in use by this user. A <i>role</i> is an AWS
    ///       Identity and Access Management (IAM) entity that, in this case, allows a file transfer
    ///       protocol-enabled server to act on a user's behalf. It allows the server to inherit the
    ///       trust relationship that enables that user to perform file operations to their Amazon S3
    ///       bucket.</p>
    ///          <note>
    ///
    ///             <p>The IAM role that controls your users' access to your Amazon S3 bucket for servers with <code>Domain=S3</code>, or your EFS file system for servers with <code>Domain=EFS</code>.
    ///         </p>
    ///             <p>The policies attached to this role determine the level of access you want to provide your users when
    ///         transferring files into and out of your S3 buckets or EFS file systems.</p>
    ///
    ///          </note>
    public let role: String?
    /// <p>Specifies the number of SSH public keys stored for the user you specified.</p>
    public let sshPublicKeyCount: Int?
    /// <p>Specifies the name of the user whose ARN was specified. User names are used for
    ///       authentication purposes.</p>
    public let userName: String?

    public init (
        arn: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        role: String? = nil,
        sshPublicKeyCount: Int? = nil,
        userName: String? = nil
    )
    {
        self.arn = arn
        self.homeDirectory = homeDirectory
        self.homeDirectoryType = homeDirectoryType
        self.role = role
        self.sshPublicKeyCount = sshPublicKeyCount
        self.userName = userName
    }
}

extension PosixProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gid = "Gid"
        case secondaryGids = "SecondaryGids"
        case uid = "Uid"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let secondaryGids = secondaryGids {
            var secondaryGidsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .secondaryGids)
            for secondarygids0 in secondaryGids {
                try secondaryGidsContainer.encode(secondarygids0)
            }
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uid)
        uid = uidDecoded
        let gidDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .gid)
        gid = gidDecoded
        let secondaryGidsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .secondaryGids)
        var secondaryGidsDecoded0:[Int]? = nil
        if let secondaryGidsContainer = secondaryGidsContainer {
            secondaryGidsDecoded0 = [Int]()
            for long0 in secondaryGidsContainer {
                if let long0 = long0 {
                    secondaryGidsDecoded0?.append(long0)
                }
            }
        }
        secondaryGids = secondaryGidsDecoded0
    }
}

extension PosixProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PosixProfile(gid: \(String(describing: gid)), secondaryGids: \(String(describing: secondaryGids)), uid: \(String(describing: uid)))"}
}

/// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
///       files and directories in your file system determine the level of access your users get when
///       transferring files into and out of your Amazon EFS file systems.</p>
public struct PosixProfile: Equatable {
    /// <p>The POSIX group ID used for all EFS operations by this user.</p>
    public let gid: Int?
    /// <p>The secondary POSIX group IDs used for all EFS operations by this user.</p>
    public let secondaryGids: [Int]?
    /// <p>The POSIX user ID used for all EFS operations by this user.</p>
    public let uid: Int?

    public init (
        gid: Int? = nil,
        secondaryGids: [Int]? = nil,
        uid: Int? = nil
    )
    {
        self.gid = gid
        self.secondaryGids = secondaryGids
        self.uid = uid
    }
}

public enum `Protocol` {
    case ftp
    case ftps
    case sftp
    case sdkUnknown(String)
}

extension `Protocol` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Protocol`] {
        return [
            .ftp,
            .ftps,
            .sftp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ftp: return "FTP"
        case .ftps: return "FTPS"
        case .sftp: return "SFTP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Protocol`(rawValue: rawValue) ?? `Protocol`.sdkUnknown(rawValue)
    }
}

extension ResourceExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceExistsException(message: \(String(describing: message)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist.</p>
public struct ResourceExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resource: String?
    public var resourceType: String?

    public init (
        message: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceExistsExceptionBody: Equatable {
    public let message: String?
    public let resource: String?
    public let resourceType: String?
}

extension ResourceExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resource: \(String(describing: resource)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resource = output.resource
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resource = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a resource is not found by the AWS Transfer Family
///       service.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var resource: String?
    public var resourceType: String?

    public init (
        message: String? = nil,
        resource: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resource = resource
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resource: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resource = "Resource"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed because the AWS Transfer Family service is not available.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SshPublicKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateImported = "DateImported"
        case sshPublicKeyBody = "SshPublicKeyBody"
        case sshPublicKeyId = "SshPublicKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateImported = dateImported {
            try encodeContainer.encode(dateImported.timeIntervalSince1970, forKey: .dateImported)
        }
        if let sshPublicKeyBody = sshPublicKeyBody {
            try encodeContainer.encode(sshPublicKeyBody, forKey: .sshPublicKeyBody)
        }
        if let sshPublicKeyId = sshPublicKeyId {
            try encodeContainer.encode(sshPublicKeyId, forKey: .sshPublicKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateImportedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateImported)
        dateImported = dateImportedDecoded
        let sshPublicKeyBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyBody)
        sshPublicKeyBody = sshPublicKeyBodyDecoded
        let sshPublicKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sshPublicKeyId)
        sshPublicKeyId = sshPublicKeyIdDecoded
    }
}

extension SshPublicKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SshPublicKey(dateImported: \(String(describing: dateImported)), sshPublicKeyBody: \(String(describing: sshPublicKeyBody)), sshPublicKeyId: \(String(describing: sshPublicKeyId)))"}
}

/// <p>Provides information about the public Secure Shell (SSH) key that is associated with a
///       user account for the specific file transfer protocol-enabled server (as identified by
///         <code>ServerId</code>). The information returned includes the date the key was imported, the
///       public key contents, and the public key ID. A user can store more than one SSH public key
///       associated with their user name on a specific server.</p>
public struct SshPublicKey: Equatable {
    /// <p>Specifies the date that the public key was added to the user account.</p>
    public let dateImported: Date?
    /// <p>Specifies the content of the SSH public key as specified by the
    ///       <code>PublicKeyId</code>.</p>
    public let sshPublicKeyBody: String?
    /// <p>Specifies the <code>SshPublicKeyId</code> parameter contains the identifier of the public
    ///       key.</p>
    public let sshPublicKeyId: String?

    public init (
        dateImported: Date? = nil,
        sshPublicKeyBody: String? = nil,
        sshPublicKeyId: String? = nil
    )
    {
        self.dateImported = dateImported
        self.sshPublicKeyBody = sshPublicKeyBody
        self.sshPublicKeyId = sshPublicKeyId
    }
}

public struct StartServerInputBodyMiddleware: Middleware {
    public let id: String = "StartServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartServerInput>
    public typealias MOutput = OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartServerOutputError>
}

extension StartServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartServerInput(serverId: \(String(describing: serverId)))"}
}

extension StartServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct StartServerInputHeadersMiddleware: Middleware {
    public let id: String = "StartServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartServerInput>
    public typealias MOutput = OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartServerOutputError>
}

public struct StartServerInputQueryItemMiddleware: Middleware {
    public let id: String = "StartServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StartServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartServerInput>
    public typealias MOutput = OperationOutput<StartServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartServerOutputError>
}

public struct StartServerInput: Equatable {
    /// <p>A system-assigned unique identifier for a server that you start.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StartServerInputBody: Equatable {
    public let serverId: String?
}

extension StartServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StartServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartServerOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartServerOutputResponse()"}
}

extension StartServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartServerOutputResponse: Equatable {

    public init() {}
}

struct StartServerOutputResponseBody: Equatable {
}

extension StartServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>Describes the condition of a file transfer protocol-enabled server with respect to its
///       ability to perform file operations. There are six possible states: <code>OFFLINE</code>,
///         <code>ONLINE</code>, <code>STARTING</code>, <code>STOPPING</code>,
///       <code>START_FAILED</code>, and <code>STOP_FAILED</code>.</p>
///
///          <p>
///             <code>OFFLINE</code> indicates that the server exists, but that it is not available for
///       file operations. <code>ONLINE</code> indicates that the server is available to perform file
///       operations. <code>STARTING</code> indicates that the server's was instantiated, but the
///       server is not yet available to perform file operations. Under normal conditions, it can take a
///       couple of minutes for the server to be completely operational. Both <code>START_FAILED</code>
///       and <code>STOP_FAILED</code> are error conditions.</p>
public enum State {
    case offline
    case online
    case starting
    case startFailed
    case stopping
    case stopFailed
    case sdkUnknown(String)
}

extension State : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [State] {
        return [
            .offline,
            .online,
            .starting,
            .startFailed,
            .stopping,
            .stopFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .offline: return "OFFLINE"
        case .online: return "ONLINE"
        case .starting: return "STARTING"
        case .startFailed: return "START_FAILED"
        case .stopping: return "STOPPING"
        case .stopFailed: return "STOP_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
    }
}

public struct StopServerInputBodyMiddleware: Middleware {
    public let id: String = "StopServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopServerInput>
    public typealias MOutput = OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopServerOutputError>
}

extension StopServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopServerInput(serverId: \(String(describing: serverId)))"}
}

extension StopServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct StopServerInputHeadersMiddleware: Middleware {
    public let id: String = "StopServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopServerInput>
    public typealias MOutput = OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopServerOutputError>
}

public struct StopServerInputQueryItemMiddleware: Middleware {
    public let id: String = "StopServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopServerInput>,
                  next: H) -> Swift.Result<OperationOutput<StopServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopServerInput>
    public typealias MOutput = OperationOutput<StopServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopServerOutputError>
}

public struct StopServerInput: Equatable {
    /// <p>A system-assigned unique identifier for a server that you stopped.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct StopServerInputBody: Equatable {
    public let serverId: String?
}

extension StopServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension StopServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopServerOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopServerOutputResponse()"}
}

extension StopServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopServerOutputResponse: Equatable {

    public init() {}
}

struct StopServerOutputResponseBody: Equatable {
}

extension StopServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Creates a key-value pair for a specific resource. Tags are metadata that you can use to
///       search for and group a resource for various purposes. You can apply tags to servers, users,
///       and roles. A tag key can take more than one value. For example, to group servers for
///       accounting purposes, you might create a tag called <code>Group</code> and assign the values
///         <code>Research</code> and <code>Accounting</code> to that group.</p>
public struct Tag: Equatable {
    /// <p>The name assigned to the tag that you create.</p>
    public let key: String?
    /// <p>Contains one or more values that you assigned to the key name you create.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(arn: \(String(describing: arn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>An Amazon Resource Name (ARN) for a specific AWS resource, such as a server, user, or
    ///       role.</p>
    public let arn: String?
    /// <p>Key-value pairs assigned to ARNs that you can use to group and search for resources by
    ///       type. You can attach this metadata to user accounts for any purpose.</p>
    public let tags: [Tag]?

    public init (
        arn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let arn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TestIdentityProviderInputBodyMiddleware: Middleware {
    public let id: String = "TestIdentityProviderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestIdentityProviderOutputError>
}

extension TestIdentityProviderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestIdentityProviderInput(serverId: \(String(describing: serverId)), serverProtocol: \(String(describing: serverProtocol)), sourceIp: \(String(describing: sourceIp)), userName: \(String(describing: userName)), userPassword: \(String(describing: userPassword)))"}
}

extension TestIdentityProviderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverProtocol = serverProtocol {
            try encodeContainer.encode(serverProtocol.rawValue, forKey: .serverProtocol)
        }
        if let sourceIp = sourceIp {
            try encodeContainer.encode(sourceIp, forKey: .sourceIp)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userPassword = userPassword {
            try encodeContainer.encode(userPassword, forKey: .userPassword)
        }
    }
}

public struct TestIdentityProviderInputHeadersMiddleware: Middleware {
    public let id: String = "TestIdentityProviderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestIdentityProviderOutputError>
}

public struct TestIdentityProviderInputQueryItemMiddleware: Middleware {
    public let id: String = "TestIdentityProviderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestIdentityProviderInput>,
                  next: H) -> Swift.Result<OperationOutput<TestIdentityProviderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestIdentityProviderInput>
    public typealias MOutput = OperationOutput<TestIdentityProviderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestIdentityProviderOutputError>
}

public struct TestIdentityProviderInput: Equatable {
    /// <p>A system-assigned identifier for a specific server. That server's user authentication
    ///       method is tested with a user name and password.</p>
    public let serverId: String?
    /// <p>The type of file transfer protocol to be tested.</p>
    ///
    ///          <p>The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Secure Shell (SSH) File Transfer Protocol (SFTP)</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol Secure (FTPS)</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol (FTP)</p>
    ///             </li>
    ///          </ul>
    public let serverProtocol: `Protocol`?
    /// <p>The source IP address of the user account to be tested.</p>
    public let sourceIp: String?
    /// <p>The name of the user account to be tested.</p>
    public let userName: String?
    /// <p>The password of the user account to be tested.</p>
    public let userPassword: String?

    public init (
        serverId: String? = nil,
        serverProtocol: `Protocol`? = nil,
        sourceIp: String? = nil,
        userName: String? = nil,
        userPassword: String? = nil
    )
    {
        self.serverId = serverId
        self.serverProtocol = serverProtocol
        self.sourceIp = sourceIp
        self.userName = userName
        self.userPassword = userPassword
    }
}

struct TestIdentityProviderInputBody: Equatable {
    public let serverId: String?
    public let serverProtocol: `Protocol`?
    public let sourceIp: String?
    public let userName: String?
    public let userPassword: String?
}

extension TestIdentityProviderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case serverProtocol = "ServerProtocol"
        case sourceIp = "SourceIp"
        case userName = "UserName"
        case userPassword = "UserPassword"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverProtocolDecoded = try containerValues.decodeIfPresent(`Protocol`.self, forKey: .serverProtocol)
        serverProtocol = serverProtocolDecoded
        let sourceIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIp)
        sourceIp = sourceIpDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
        let userPasswordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPassword)
        userPassword = userPasswordDecoded
    }
}

extension TestIdentityProviderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestIdentityProviderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestIdentityProviderOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestIdentityProviderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestIdentityProviderOutputResponse(message: \(String(describing: message)), response: \(String(describing: response)), statusCode: \(String(describing: statusCode)), url: \(String(describing: url)))"}
}

extension TestIdentityProviderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestIdentityProviderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.response = output.response
            self.statusCode = output.statusCode
            self.url = output.url
        } else {
            self.message = nil
            self.response = nil
            self.statusCode = 0
            self.url = nil
        }
    }
}

public struct TestIdentityProviderOutputResponse: Equatable {
    /// <p>A message that indicates whether the test was successful or not.</p>
    public let message: String?
    /// <p>The response that is returned from your API Gateway.</p>
    public let response: String?
    /// <p>The HTTP status code that is the response from your API Gateway.</p>
    public let statusCode: Int
    /// <p>The endpoint of the service used to authenticate a user.</p>
    public let url: String?

    public init (
        message: String? = nil,
        response: String? = nil,
        statusCode: Int = 0,
        url: String? = nil
    )
    {
        self.message = message
        self.response = response
        self.statusCode = statusCode
        self.url = url
    }
}

struct TestIdentityProviderOutputResponseBody: Equatable {
    public let response: String?
    public let statusCode: Int
    public let message: String?
    public let url: String?
}

extension TestIdentityProviderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case response = "Response"
        case statusCode = "StatusCode"
        case url = "Url"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .response)
        response = responseDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
///
///          <p> HTTP Status Code: 400</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var retryAfterSeconds: String?

    public init (
        retryAfterSeconds: String? = nil
    )
    {
        self.retryAfterSeconds = retryAfterSeconds
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(arn: \(String(describing: arn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The value of the resource that will have the tag removed. An Amazon Resource Name (ARN) is
    ///       an identifier for a specific AWS resource, such as a server, user, or role.</p>
    public let arn: String?
    /// <p>TagKeys are key-value pairs assigned to ARNs that can be used to group and search for
    ///       resources by type. This metadata can be attached to resources for any purpose.</p>
    public let tagKeys: [String]?

    public init (
        arn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let arn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAccessInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessOutputError>
}

extension UpdateAccessInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessInput(externalId: \(String(describing: externalId)), homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), serverId: \(String(describing: serverId)))"}
}

extension UpdateAccessInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct UpdateAccessInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessOutputError>
}

public struct UpdateAccessInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAccessInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAccessInput>
    public typealias MOutput = OperationOutput<UpdateAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAccessOutputError>
}

public struct UpdateAccessInput: Equatable {
    /// <p>A unique identifier that is required to identify specific groups within your directory.
    ///       The users of the group that you associate have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family. If you know the group name,
    ///       you can view the SID values by running the following command using Windows PowerShell.</p>
    ///          <p>
    ///             <code>Get-ADGroup -Filter {samAccountName -like "<i>YourGroupName</i>*"} -Properties * | Select SamaccountName,ObjectSid</code>
    ///          </p>
    ///          <p>In that command, replace <i>YourGroupName</i> with the name of your Active
    ///       Directory group.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of
    ///       uppercase and lowercase alphanumeric characters with no spaces. You can also include
    ///       underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>The landing directory (folder) for a user when they log in to the server using the client.</p>
    ///          <p>A <code>HomeDirectory</code> example is <code>/directory_name/home/mydirectory</code>.</p>
    public let homeDirectory: String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should
    ///       be visible to your user and how you want to make them visible. You must specify the
    ///       <code>Entry</code> and <code>Target</code> pair, where <code>Entry</code> shows how the path
    ///       is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you
    ///       only specify a target, it will be displayed as is. You also must ensure that your AWS Identity
    ///       and Access Management (IAM) role provides access to paths in <code>Target</code>. This value
    ///       can only be set when <code>HomeDirectoryType</code> is set to
    ///       <i>LOGICAL</i>.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example.</p>
    ///          <p>
    ///             <code>[ { "Entry": "your-personal-report.pdf", "Target": "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]</code>
    ///          </p>
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///         user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to <code>/</code> and set <code>Target</code> to the
    ///         <code>HomeDirectory</code> parameter value.</p>
    ///          <p>The following is an <code>Entry</code> and <code>Target</code> pair example for <code>chroot</code>.</p>
    ///          <p>
    ///             <code>[ { "Entry": "/", "Target": "/bucket_name/home/mydirectory" } ]</code>
    ///          </p>
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or Amazon EFS, the
    ///         entry will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create
    ///         0-byte objects as place holders for your directory. If using the AWS CLI, use the
    ///         <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code> or
    ///         <code>efs</code> so you can use the <code>put-object</code> operation. For example, you
    ///         can use the following.</p>
    ///             <p>
    ///                <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>
    ///             </p>
    ///             <p>The end of the key name must end in a <code>/</code> for it to be considered a
    ///           folder.</p>
    ///          </note>
    ///          <p>Required: No</p>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) that you want your users' home directory to be when
    ///       they log in to the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket paths as is in their file transfer protocol clients. If you set it
    ///       <code>LOGICAL</code>, you must provide mappings in the <code>HomeDirectoryMappings</code>
    ///       for how you want to make Amazon S3 paths visible to your users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p></p>
    ///          <p>A scope-down policy for your user so that you can use the same IAM role across multiple
    ///       users. This policy scopes down user access to portions of their Amazon S3 bucket. Variables
    ///       that you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///       <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>This only applies when domain of <code>ServerId</code> is S3. Amazon EFS does not use scope
    ///       down policy.</p>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass it in the <code>Policy</code> argument.</p>
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/scope-down-policy.html">Example
    ///         scope-down policy</a>.</p>
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS Security Token Service API
    ///           Reference</i>.</p>
    ///          </note>
    public let policy: String?
    /// <p>The full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///       (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon EFS file systems. The POSIX permissions that are set on
    ///       files and directories in your file system determine the level of access your users get when
    ///       transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>Specifies the IAM role that controls your users' access to your Amazon S3 bucket or EFS
    ///       file system. The policies attached to this role determine the level of access that you want to
    ///       provide your users when transferring files into and out of your Amazon S3 bucket or EFS file
    ///       system. The IAM role should also contain a trust relationship that allows the server to access
    ///       your resources when servicing your users' transfer requests.</p>
    public let role: String?
    /// <p>A system-assigned unique identifier for a server instance. This is the specific server that you added your user to.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
    }
}

struct UpdateAccessInputBody: Equatable {
    public let homeDirectory: String?
    public let homeDirectoryType: HomeDirectoryType?
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    public let policy: String?
    public let posixProfile: PosixProfile?
    public let role: String?
    public let serverId: String?
    public let externalId: String?
}

extension UpdateAccessInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

extension UpdateAccessOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAccessOutputResponse(externalId: \(String(describing: externalId)), serverId: \(String(describing: serverId)))"}
}

extension UpdateAccessOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAccessOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.externalId = output.externalId
            self.serverId = output.serverId
        } else {
            self.externalId = nil
            self.serverId = nil
        }
    }
}

public struct UpdateAccessOutputResponse: Equatable {
    /// <p>The external ID of the group whose users have access to your Amazon S3 or Amazon EFS
    ///       resources over the enabled protocols using AWS Transfer Family.</p>
    public let externalId: String?
    /// <p>The ID of the server that the user is attached to.</p>
    public let serverId: String?

    public init (
        externalId: String? = nil,
        serverId: String? = nil
    )
    {
        self.externalId = externalId
        self.serverId = serverId
    }
}

struct UpdateAccessOutputResponseBody: Equatable {
    public let serverId: String?
    public let externalId: String?
}

extension UpdateAccessOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case externalId = "ExternalId"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
    }
}

public struct UpdateServerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

extension UpdateServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerInput(certificate: \(String(describing: certificate)), endpointDetails: \(String(describing: endpointDetails)), endpointType: \(String(describing: endpointType)), hostKey: \(String(describing: hostKey)), identityProviderDetails: \(String(describing: identityProviderDetails)), loggingRole: \(String(describing: loggingRole)), protocols: \(String(describing: protocols)), securityPolicyName: \(String(describing: securityPolicyName)), serverId: \(String(describing: serverId)))"}
}

extension UpdateServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let endpointDetails = endpointDetails {
            try encodeContainer.encode(endpointDetails, forKey: .endpointDetails)
        }
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let hostKey = hostKey {
            try encodeContainer.encode(hostKey, forKey: .hostKey)
        }
        if let identityProviderDetails = identityProviderDetails {
            try encodeContainer.encode(identityProviderDetails, forKey: .identityProviderDetails)
        }
        if let loggingRole = loggingRole {
            try encodeContainer.encode(loggingRole, forKey: .loggingRole)
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocols0 in protocols {
                try protocolsContainer.encode(protocols0.rawValue)
            }
        }
        if let securityPolicyName = securityPolicyName {
            try encodeContainer.encode(securityPolicyName, forKey: .securityPolicyName)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

public struct UpdateServerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

public struct UpdateServerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

public struct UpdateServerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Certificate Manager (ACM) certificate. Required
    ///       when <code>Protocols</code> is set to <code>FTPS</code>.</p>
    ///
    ///          <p>To request a new public certificate, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html">Request a public certificate</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To import an existing certificate into ACM, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html">Importing certificates into ACM</a>
    ///       in the <i> AWS Certificate Manager User Guide</i>.</p>
    ///
    ///          <p>To request a private certificate to use FTPS through private IP addresses, see <a href="https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-private.html">Request a
    ///         private certificate</a> in the <i> AWS Certificate Manager User
    ///       Guide</i>.</p>
    ///
    ///          <p>Certificates with the following cryptographic algorithms and key sizes are
    ///       supported:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>2048-bit RSA (RSA_2048)</p>
    ///             </li>
    ///             <li>
    ///                <p>4096-bit RSA (RSA_4096)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 256 bit (EC_prime256v1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 384 bit (EC_secp384r1)</p>
    ///             </li>
    ///             <li>
    ///                <p>Elliptic Prime Curve 521 bit (EC_secp521r1)</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>The certificate must be a valid SSL/TLS X.509 version 3 certificate with FQDN or IP
    ///         address specified and information about the issuer.</p>
    ///          </note>
    public let certificate: String?
    /// <p>The virtual private cloud (VPC) endpoint settings that are configured for your server.
    ///       With a VPC endpoint, you can restrict access to your server to resources only within your VPC.
    ///       To control incoming internet traffic, you will need to associate one or more Elastic IP
    ///       addresses with your server's endpoint.</p>
    public let endpointDetails: EndpointDetails?
    /// <p>The type of endpoint that you want your server to use. You can choose to make your server's endpoint publicly accessible (PUBLIC)
    ///       or host it inside your VPC. With an endpoint that is hosted in a VPC, you can restrict access to your server and
    ///       resources only within your VPC or choose to make it internet facing by attaching Elastic IP addresses directly to it.</p>
    ///          <note>
    ///             <p> After March 31, 2021, you won't be able to create a server using
    ///           <code>EndpointType=VPC_ENDPOINT</code> in your AWS account if your account hasn't already
    ///       done so before March 31, 2021. If you have already created servers with
    ///       <code>EndpointType=VPC_ENDPOINT</code> in your AWS account on or before March 31, 2021,
    ///         you will not be affected. After this date, use
    ///         <code>EndpointType</code>=<code>VPC</code>.</p>
    ///
    ///             <p>For more information, see
    ///         https://docs.aws.amazon.com/transfer/latest/userguide/create-server-in-vpc.html#deprecate-vpc-endpoint.</p>
    ///             <p>It is recommended that you use <code>VPC</code> as the <code>EndpointType</code>. With
    ///         this endpoint type, you have the option to directly associate up to three Elastic IPv4
    ///         addresses (BYO IP included) with your server's endpoint and use VPC security groups to
    ///         restrict traffic by the client's public IP address. This is not possible with
    ///           <code>EndpointType</code> set to <code>VPC_ENDPOINT</code>.</p>
    ///          </note>
    public let endpointType: EndpointType?
    /// <p>The RSA private key as generated by <code>ssh-keygen -N "" -m PEM -f
    ///         my-new-server-key</code>.</p>
    ///
    ///          <important>
    ///             <p>If you aren't planning to migrate existing users from an existing server to a new
    ///         server, don't update the host key. Accidentally changing a server's host key can
    ///         be disruptive.</p>
    ///          </important>
    ///
    ///
    ///
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/edit-server-config.html#configuring-servers-change-host-key">Change the host key for your SFTP-enabled server</a> in the <i>AWS Transfer
    ///         Family User Guide</i>.</p>
    public let hostKey: String?
    /// <p>An array containing all of the information required to call a customer's
    ///       authentication API method.</p>
    public let identityProviderDetails: IdentityProviderDetails?
    /// <p>Changes the AWS Identity and Access Management (IAM) role that allows Amazon S3 or Amazon EFS events to
    ///       be logged in Amazon CloudWatch, turning logging on or off.</p>
    public let loggingRole: String?
    /// <p>Specifies the file transfer protocol or protocols over which your file transfer protocol
    ///       client can connect to your server's endpoint. The available protocols are:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>Secure Shell (SSH) File Transfer Protocol (SFTP): File transfer over SSH</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol Secure (FTPS): File transfer with TLS encryption</p>
    ///             </li>
    ///             <li>
    ///                <p>File Transfer Protocol (FTP): Unencrypted file transfer</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <note>
    ///             <p>If you select <code>FTPS</code>, you must choose a certificate stored in AWS Certificate
    ///         Manager (ACM) which will be used to identify your server when clients connect to it over
    ///         FTPS.</p>
    ///
    ///
    ///             <p>If <code>Protocol</code> includes either <code>FTP</code> or <code>FTPS</code>, then the
    ///         <code>EndpointType</code> must be <code>VPC</code> and the
    ///         <code>IdentityProviderType</code> must be <code>AWS_DIRECTORY_SERVICE</code> or <code>API_GATEWAY</code>.</p>
    ///
    ///             <p>If <code>Protocol</code> includes <code>FTP</code>, then
    ///           <code>AddressAllocationIds</code> cannot be associated.</p>
    ///
    ///             <p>If <code>Protocol</code> is set only to <code>SFTP</code>, the <code>EndpointType</code>
    ///         can be set to <code>PUBLIC</code> and the <code>IdentityProviderType</code> can be set to
    ///           <code>SERVICE_MANAGED</code>.</p>
    ///          </note>
    public let protocols: [`Protocol`]?
    /// <p>Specifies the name of the security policy that is attached to the server.</p>
    public let securityPolicyName: String?
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: String?

    public init (
        certificate: String? = nil,
        endpointDetails: EndpointDetails? = nil,
        endpointType: EndpointType? = nil,
        hostKey: String? = nil,
        identityProviderDetails: IdentityProviderDetails? = nil,
        loggingRole: String? = nil,
        protocols: [`Protocol`]? = nil,
        securityPolicyName: String? = nil,
        serverId: String? = nil
    )
    {
        self.certificate = certificate
        self.endpointDetails = endpointDetails
        self.endpointType = endpointType
        self.hostKey = hostKey
        self.identityProviderDetails = identityProviderDetails
        self.loggingRole = loggingRole
        self.protocols = protocols
        self.securityPolicyName = securityPolicyName
        self.serverId = serverId
    }
}

struct UpdateServerInputBody: Equatable {
    public let certificate: String?
    public let endpointDetails: EndpointDetails?
    public let endpointType: EndpointType?
    public let hostKey: String?
    public let identityProviderDetails: IdentityProviderDetails?
    public let loggingRole: String?
    public let protocols: [`Protocol`]?
    public let securityPolicyName: String?
    public let serverId: String?
}

extension UpdateServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificate = "Certificate"
        case endpointDetails = "EndpointDetails"
        case endpointType = "EndpointType"
        case hostKey = "HostKey"
        case identityProviderDetails = "IdentityProviderDetails"
        case loggingRole = "LoggingRole"
        case protocols = "Protocols"
        case securityPolicyName = "SecurityPolicyName"
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let endpointDetailsDecoded = try containerValues.decodeIfPresent(EndpointDetails.self, forKey: .endpointDetails)
        endpointDetails = endpointDetailsDecoded
        let endpointTypeDecoded = try containerValues.decodeIfPresent(EndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let hostKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostKey)
        hostKey = hostKeyDecoded
        let identityProviderDetailsDecoded = try containerValues.decodeIfPresent(IdentityProviderDetails.self, forKey: .identityProviderDetails)
        identityProviderDetails = identityProviderDetailsDecoded
        let loggingRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loggingRole)
        loggingRole = loggingRoleDecoded
        let protocolsContainer = try containerValues.decodeIfPresent([`Protocol`?].self, forKey: .protocols)
        var protocolsDecoded0:[`Protocol`]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [`Protocol`]()
            for string0 in protocolsContainer {
                if let string0 = string0 {
                    protocolsDecoded0?.append(string0)
                }
            }
        }
        protocols = protocolsDecoded0
        let securityPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityPolicyName)
        securityPolicyName = securityPolicyNameDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

extension UpdateServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceExistsException" : self = .resourceExistsException(try ResourceExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceExistsException(ResourceExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerOutputResponse(serverId: \(String(describing: serverId)))"}
}

extension UpdateServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
        } else {
            self.serverId = nil
        }
    }
}

public struct UpdateServerOutputResponse: Equatable {
    /// <p>A system-assigned unique identifier for a server that the user account is assigned
    ///       to.</p>
    public let serverId: String?

    public init (
        serverId: String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct UpdateServerOutputResponseBody: Equatable {
    public let serverId: String?
}

extension UpdateServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
    }
}

public struct UpdateUserInputBodyMiddleware: Middleware {
    public let id: String = "UpdateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

extension UpdateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserInput(homeDirectory: \(String(describing: homeDirectory)), homeDirectoryMappings: \(String(describing: homeDirectoryMappings)), homeDirectoryType: \(String(describing: homeDirectoryType)), policy: \(String(describing: policy)), posixProfile: \(String(describing: posixProfile)), role: \(String(describing: role)), serverId: \(String(describing: serverId)), userName: \(String(describing: userName)))"}
}

extension UpdateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeDirectory = homeDirectory {
            try encodeContainer.encode(homeDirectory, forKey: .homeDirectory)
        }
        if let homeDirectoryMappings = homeDirectoryMappings {
            var homeDirectoryMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .homeDirectoryMappings)
            for homedirectorymappings0 in homeDirectoryMappings {
                try homeDirectoryMappingsContainer.encode(homedirectorymappings0)
            }
        }
        if let homeDirectoryType = homeDirectoryType {
            try encodeContainer.encode(homeDirectoryType.rawValue, forKey: .homeDirectoryType)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let posixProfile = posixProfile {
            try encodeContainer.encode(posixProfile, forKey: .posixProfile)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let serverId = serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

public struct UpdateUserInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateUserInput>
    public typealias MOutput = OperationOutput<UpdateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateUserOutputError>
}

public struct UpdateUserInput: Equatable {
    /// <p>Specifies the landing directory (folder) for a user when they log in to the server using
    ///       their file transfer protocol client.</p>
    ///
    ///          <p>An example is <code>your-Amazon-S3-bucket-name>/home/username</code>.</p>
    public let homeDirectory: String?
    /// <p>Logical directory mappings that specify what Amazon S3 or Amazon EFS paths and keys should be visible to
    ///       your user and how you want to make them visible. You will need to specify the
    ///         "<code>Entry</code>" and "<code>Target</code>" pair, where <code>Entry</code> shows how the
    ///       path is made visible and <code>Target</code> is the actual Amazon S3 or Amazon EFS path. If you only specify
    ///       a target, it will be displayed as is. You will need to also make sure that your IAM role
    ///       provides access to paths in <code>Target</code>. The following is an example.</p>
    ///
    ///          <p>
    ///             <code>'[ "/bucket2/documentation", { "Entry": "your-personal-report.pdf", "Target":
    ///         "/bucket3/customized-reports/${transfer:UserName}.pdf" } ]'</code>
    ///          </p>
    ///
    ///          <p>In most cases, you can use this value instead of the scope-down policy to lock down your
    ///       user to the designated home directory ("<code>chroot</code>"). To do this, you can set
    ///         <code>Entry</code> to '/' and set <code>Target</code> to the HomeDirectory
    ///       parameter value.</p>
    ///
    ///          <note>
    ///             <p>If the target of a logical directory entry does not exist in Amazon S3 or EFS, the entry
    ///         will be ignored. As a workaround, you can use the Amazon S3 API or EFS API to create 0-byte
    ///         objects as place holders for your directory. If using the AWS CLI, use the
    ///           <code>s3api</code> or <code>efsapi</code> call instead of <code>s3</code>
    ///                <code>efs</code> so you can use the put-object operation. For example, you use the
    ///         following: <code>aws s3api put-object --bucket bucketname --key path/to/folder/</code>. Make
    ///         sure that the end of the key name ends in a / for it to be considered a folder.</p>
    ///          </note>
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    /// <p>The type of landing directory (folder) you want your users' home directory to be when
    ///       they log into the server. If you set it to <code>PATH</code>, the user will see the absolute
    ///       Amazon S3 bucket or EFS paths as is in their file transfer protocol clients. If you set it
    ///         <code>LOGICAL</code>, you will need to provide mappings in the
    ///         <code>HomeDirectoryMappings</code> for how you want to make Amazon S3 or EFS paths visible to your
    ///       users.</p>
    public let homeDirectoryType: HomeDirectoryType?
    /// <p>Allows you to supply a scope-down policy for your user so you can use the same IAM role
    ///       across multiple users. The policy scopes down user access to portions of your Amazon S3
    ///       bucket. Variables you can use inside this policy include <code>${Transfer:UserName}</code>,
    ///         <code>${Transfer:HomeDirectory}</code>, and <code>${Transfer:HomeBucket}</code>.</p>
    ///          <note>
    ///             <p>For scope-down policies, AWS Transfer Family stores the policy as a JSON blob, instead
    ///         of the Amazon Resource Name (ARN) of the policy. You save the policy as a JSON blob and pass
    ///         it in the <code>Policy</code> argument.</p>
    ///
    ///
    ///
    ///
    ///             <p>For an example of a scope-down policy, see <a href="https://docs.aws.amazon.com/transfer/latest/userguide/users.html#users-policies-scope-down">Creating a scope-down
    ///           policy</a>.</p>
    ///
    ///
    ///
    ///             <p>For more information, see <a href="https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html">AssumeRole</a> in the <i>AWS
    ///           Security Token Service API Reference</i>.</p>
    ///          </note>
    public let policy: String?
    /// <p>Specifies the full POSIX identity, including user ID (<code>Uid</code>), group ID
    ///         (<code>Gid</code>), and any secondary groups IDs (<code>SecondaryGids</code>), that controls
    ///       your users' access to your Amazon Elastic File Systems (Amazon EFS). The POSIX permissions
    ///       that are set on files and directories in your file system determines the level of access your
    ///       users get when transferring files into and out of your Amazon EFS file systems.</p>
    public let posixProfile: PosixProfile?
    /// <p>The IAM role that controls your users' access to your Amazon S3 bucket. The policies
    ///       attached to this role determine the level of access you want to provide your users when
    ///       transferring files into and out of your S3 bucket or buckets. The IAM role should also contain
    ///       a trust relationship that allows the server to access your resources when servicing your
    ///       users' transfer requests.</p>
    public let role: String?
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: String?
    /// <p>A unique string that identifies a user and is associated with a server as specified by the
    ///         <code>ServerId</code>. This user name must be a minimum of 3 and a maximum of 100 characters
    ///       long. The following are valid characters: a-z, A-Z, 0-9, underscore '_', hyphen
    ///       '-', period '.', and at sign '@'. The user name can't start
    ///       with a hyphen, period, or at sign.</p>
    public let userName: String?

    public init (
        homeDirectory: String? = nil,
        homeDirectoryMappings: [HomeDirectoryMapEntry]? = nil,
        homeDirectoryType: HomeDirectoryType? = nil,
        policy: String? = nil,
        posixProfile: PosixProfile? = nil,
        role: String? = nil,
        serverId: String? = nil,
        userName: String? = nil
    )
    {
        self.homeDirectory = homeDirectory
        self.homeDirectoryMappings = homeDirectoryMappings
        self.homeDirectoryType = homeDirectoryType
        self.policy = policy
        self.posixProfile = posixProfile
        self.role = role
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserInputBody: Equatable {
    public let homeDirectory: String?
    public let homeDirectoryType: HomeDirectoryType?
    public let homeDirectoryMappings: [HomeDirectoryMapEntry]?
    public let policy: String?
    public let posixProfile: PosixProfile?
    public let role: String?
    public let serverId: String?
    public let userName: String?
}

extension UpdateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case homeDirectory = "HomeDirectory"
        case homeDirectoryMappings = "HomeDirectoryMappings"
        case homeDirectoryType = "HomeDirectoryType"
        case policy = "Policy"
        case posixProfile = "PosixProfile"
        case role = "Role"
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let homeDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeDirectory)
        homeDirectory = homeDirectoryDecoded
        let homeDirectoryTypeDecoded = try containerValues.decodeIfPresent(HomeDirectoryType.self, forKey: .homeDirectoryType)
        homeDirectoryType = homeDirectoryTypeDecoded
        let homeDirectoryMappingsContainer = try containerValues.decodeIfPresent([HomeDirectoryMapEntry?].self, forKey: .homeDirectoryMappings)
        var homeDirectoryMappingsDecoded0:[HomeDirectoryMapEntry]? = nil
        if let homeDirectoryMappingsContainer = homeDirectoryMappingsContainer {
            homeDirectoryMappingsDecoded0 = [HomeDirectoryMapEntry]()
            for structure0 in homeDirectoryMappingsContainer {
                if let structure0 = structure0 {
                    homeDirectoryMappingsDecoded0?.append(structure0)
                }
            }
        }
        homeDirectoryMappings = homeDirectoryMappingsDecoded0
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let posixProfileDecoded = try containerValues.decodeIfPresent(PosixProfile.self, forKey: .posixProfile)
        posixProfile = posixProfileDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}

extension UpdateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServiceError" : self = .internalServiceError(try InternalServiceError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateUserOutputError: Equatable {
    case internalServiceError(InternalServiceError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateUserOutputResponse(serverId: \(String(describing: serverId)), userName: \(String(describing: userName)))"}
}

extension UpdateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverId = output.serverId
            self.userName = output.userName
        } else {
            self.serverId = nil
            self.userName = nil
        }
    }
}

/// <p>
///             <code>UpdateUserResponse</code> returns the user name and identifier for the request to
///       update a user's properties.</p>
public struct UpdateUserOutputResponse: Equatable {
    /// <p>A system-assigned unique identifier for a server instance that the user account is
    ///       assigned to.</p>
    public let serverId: String?
    /// <p>The unique identifier for a user that is assigned to a server instance that was specified
    ///       in the request.</p>
    public let userName: String?

    public init (
        serverId: String? = nil,
        userName: String? = nil
    )
    {
        self.serverId = serverId
        self.userName = userName
    }
}

struct UpdateUserOutputResponseBody: Equatable {
    public let serverId: String?
    public let userName: String?
}

extension UpdateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverId = "ServerId"
        case userName = "UserName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userName)
        userName = userNameDecoded
    }
}
