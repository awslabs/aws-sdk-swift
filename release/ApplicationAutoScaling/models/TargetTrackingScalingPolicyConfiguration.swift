// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Represents a target tracking scaling policy configuration to use with Application Auto Scaling.</p>
public struct TargetTrackingScalingPolicyConfiguration: Equatable {
    /// <p>A customized metric. You can specify either a predefined metric or a customized
    ///          metric.</p>
    public let customizedMetricSpecification: CustomizedMetricSpecification?
    /// <p>Indicates whether scale in by the target tracking scaling policy is disabled. If the
    ///          value is <code>true</code>, scale in is disabled and the target tracking scaling policy
    ///          won't remove capacity from the scalable target. Otherwise, scale in is enabled and the
    ///          target tracking scaling policy can remove capacity from the scalable target. The default
    ///          value is <code>false</code>.</p>
    public let disableScaleIn: Bool?
    /// <p>A predefined metric. You can specify either a predefined metric or a customized
    ///          metric.</p>
    public let predefinedMetricSpecification: PredefinedMetricSpecification?
    /// <p>The amount of time, in seconds, after a scale-in activity completes before another
    ///       scale-in activity can start.</p>
    ///          <p>With the <i>scale-in cooldown period</i>, the intention is to scale in
    ///       conservatively to protect your applicationâ€™s availability, so scale-in activities are blocked
    ///       until the cooldown period has expired. However, if another alarm triggers a scale-out activity
    ///       during the scale-in cooldown period, Application Auto Scaling scales out the target immediately. In this case,
    ///       the scale-in cooldown period stops and doesn't complete.</p>
    ///          <p>Application Auto Scaling provides a default value of 300 for the following scalable targets:</p>
    ///          <ul>
    ///             <li>
    ///                <p>ECS services</p>
    ///            </li>
    ///             <li>
    ///                <p>Spot Fleet requests</p>
    ///            </li>
    ///             <li>
    ///                <p>EMR clusters</p>
    ///            </li>
    ///             <li>
    ///                <p>AppStream 2.0 fleets</p>
    ///            </li>
    ///             <li>
    ///                <p>Aurora DB clusters</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon SageMaker endpoint variants</p>
    ///            </li>
    ///             <li>
    ///                <p>Custom resources</p>
    ///            </li>
    ///          </ul>
    ///          <p>For all other scalable targets, the default value is 0:</p>
    ///          <ul>
    ///             <li>
    ///                <p>DynamoDB tables</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB global secondary indexes</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon Comprehend document classification and entity recognizer endpoints</p>
    ///            </li>
    ///             <li>
    ///                <p>Lambda provisioned concurrency</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon Keyspaces tables</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon MSK broker storage</p>
    ///            </li>
    ///          </ul>
    public let scaleInCooldown: Int?
    /// <p>The amount of time, in seconds, to wait for a previous scale-out activity to take
    ///       effect.</p>
    ///          <p>With the <i>scale-out cooldown period</i>, the intention is to continuously
    ///       (but not excessively) scale out. After Application Auto Scaling successfully scales out using a target
    ///       tracking scaling policy, it starts to calculate the cooldown time. The scaling policy won't
    ///       increase the desired capacity again unless either a larger scale out is triggered or the
    ///       cooldown period ends. While the cooldown period is in effect, the capacity added by the
    ///       initiating scale-out activity is calculated as part of the desired capacity for the next
    ///       scale-out activity.</p>
    ///          <p>Application Auto Scaling provides a default value of 300 for the following scalable targets:</p>
    ///          <ul>
    ///             <li>
    ///                <p>ECS services</p>
    ///            </li>
    ///             <li>
    ///                <p>Spot Fleet requests</p>
    ///            </li>
    ///             <li>
    ///                <p>EMR clusters</p>
    ///            </li>
    ///             <li>
    ///                <p>AppStream 2.0 fleets</p>
    ///            </li>
    ///             <li>
    ///                <p>Aurora DB clusters</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon SageMaker endpoint variants</p>
    ///            </li>
    ///             <li>
    ///                <p>Custom resources</p>
    ///            </li>
    ///          </ul>
    ///          <p>For all other scalable targets, the default value is 0:</p>
    ///          <ul>
    ///             <li>
    ///                <p>DynamoDB tables</p>
    ///            </li>
    ///             <li>
    ///                <p>DynamoDB global secondary indexes</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon Comprehend document classification and entity recognizer endpoints</p>
    ///            </li>
    ///             <li>
    ///                <p>Lambda provisioned concurrency</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon Keyspaces tables</p>
    ///            </li>
    ///             <li>
    ///                <p>Amazon MSK broker storage</p>
    ///            </li>
    ///          </ul>
    public let scaleOutCooldown: Int?
    /// <p>The target value for the metric. Although this property accepts numbers of type Double,
    ///          it won't accept values that are either too small or too large. Values must be in the range
    ///          of -2^360 to 2^360. The value must be a valid number based on the choice of metric. For
    ///          example, if the metric is CPU utilization, then the target value is a percent value that
    ///          represents how much of the CPU can be used before scaling out. </p>
    public let targetValue: Double?

    public init (
        customizedMetricSpecification: CustomizedMetricSpecification? = nil,
        disableScaleIn: Bool? = nil,
        predefinedMetricSpecification: PredefinedMetricSpecification? = nil,
        scaleInCooldown: Int? = nil,
        scaleOutCooldown: Int? = nil,
        targetValue: Double? = nil
    )
    {
        self.customizedMetricSpecification = customizedMetricSpecification
        self.disableScaleIn = disableScaleIn
        self.predefinedMetricSpecification = predefinedMetricSpecification
        self.scaleInCooldown = scaleInCooldown
        self.scaleOutCooldown = scaleOutCooldown
        self.targetValue = targetValue
    }
}

extension TargetTrackingScalingPolicyConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetTrackingScalingPolicyConfiguration(customizedMetricSpecification: \(String(describing: customizedMetricSpecification)), disableScaleIn: \(String(describing: disableScaleIn)), predefinedMetricSpecification: \(String(describing: predefinedMetricSpecification)), scaleInCooldown: \(String(describing: scaleInCooldown)), scaleOutCooldown: \(String(describing: scaleOutCooldown)), targetValue: \(String(describing: targetValue)))"}
}
