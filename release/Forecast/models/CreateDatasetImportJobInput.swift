// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct CreateDatasetImportJobInput: Equatable {
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
    ///          <p>If encryption is used, <code>DataSource</code> must include an AWS Key Management Service (KMS) key and the
    ///       IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must
    ///       match those specified in the <code>EncryptionConfig</code> parameter of the <a>CreateDataset</a> operation.</p>
    public let dataSource: DataSource?
    /// <p>The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data
    ///       to.</p>
    public let datasetArn: String?
    /// <p>The name for the dataset import job. We recommend including the current timestamp in the
    ///       name, for example, <code>20190721DatasetImport</code>. This can help you avoid getting a
    ///         <code>ResourceAlreadyExistsException</code> exception.</p>
    public let datasetImportJobName: String?
    /// <p>The format of the geolocation attribute. The geolocation attribute can be formatted in
    ///             one of two ways:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>LAT_LONG</code> - the latitude and longitude in decimal format (Example: 47.61_-122.33).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CC_POSTALCODE</code> (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).</p>
    ///             </li>
    ///          </ul>
    public let geolocationFormat: String?
    /// <p>The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?
    /// <p>A single time zone for every item in your dataset. This option is ideal for datasets
    ///             with all timestamps within a single time zone, or if all timestamps are normalized to a
    ///             single time zone. </p>
    ///         <p>Refer to the <a href="http://joda-time.sourceforge.net/timezones.html">Joda-Time
    ///                 API</a> for a complete list of valid time zone names.</p>
    public let timeZone: String?
    /// <p>The format of timestamps in the dataset. The format that you specify depends on the
    ///         <code>DataFrequency</code> specified when the dataset was created. The following formats are
    ///       supported</p>
    ///          <ul>
    ///             <li>
    ///                <p>"yyyy-MM-dd"</p>
    ///                <p>For the following data frequencies: Y, M, W, and D</p>
    ///             </li>
    ///             <li>
    ///                <p>"yyyy-MM-dd HH:mm:ss"</p>
    ///                <p>For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y,
    ///           M, W, and D</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd
    ///       HH:mm:ss".</p>
    public let timestampFormat: String?
    /// <p>Automatically derive time zone information from the geolocation attribute. This option
    ///             is ideal for datasets that contain timestamps in multiple time zones and those
    ///             timestamps are expressed in local time.</p>
    public let useGeolocationForTimeZone: Bool

    public init (
        dataSource: DataSource? = nil,
        datasetArn: String? = nil,
        datasetImportJobName: String? = nil,
        geolocationFormat: String? = nil,
        tags: [Tag]? = nil,
        timeZone: String? = nil,
        timestampFormat: String? = nil,
        useGeolocationForTimeZone: Bool = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.geolocationFormat = geolocationFormat
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

extension CreateDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetImportJobInput(dataSource: \(String(describing: dataSource)), datasetArn: \(String(describing: datasetArn)), datasetImportJobName: \(String(describing: datasetImportJobName)), geolocationFormat: \(String(describing: geolocationFormat)), tags: \(String(describing: tags)), timeZone: \(String(describing: timeZone)), timestampFormat: \(String(describing: timestampFormat)), useGeolocationForTimeZone: \(String(describing: useGeolocationForTimeZone)))"}
}
