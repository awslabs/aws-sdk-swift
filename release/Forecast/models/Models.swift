// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AttributeType {
    case float
    case geolocation
    case integer
    case string
    case timestamp
    case sdkUnknown(String)
}

extension AttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttributeType] {
        return [
            .float,
            .geolocation,
            .integer,
            .string,
            .timestamp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .float: return "float"
        case .geolocation: return "geolocation"
        case .integer: return "integer"
        case .string: return "string"
        case .timestamp: return "timestamp"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
    }
}

public enum AutoMLOverrideStrategy {
    case latencyoptimized
    case sdkUnknown(String)
}

extension AutoMLOverrideStrategy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AutoMLOverrideStrategy] {
        return [
            .latencyoptimized,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .latencyoptimized: return "LatencyOptimized"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AutoMLOverrideStrategy(rawValue: rawValue) ?? AutoMLOverrideStrategy.sdkUnknown(rawValue)
    }
}

extension CategoricalParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension CategoricalParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CategoricalParameterRange(name: \(String(describing: name)), values: \(String(describing: values)))"}
}

/// <p>Specifies a categorical hyperparameter and it's range of tunable values.
///       This object is part of the <a>ParameterRanges</a> object.</p>
public struct CategoricalParameterRange: Equatable {
    /// <p>The name of the categorical hyperparameter to tune.</p>
    public let name: String?
    /// <p>A list of the tunable categories for the hyperparameter.</p>
    public let values: [String]?

    public init (
        name: String? = nil,
        values: [String]? = nil
    )
    {
        self.name = name
        self.values = values
    }
}

extension ContinuousParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension ContinuousParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ContinuousParameterRange(maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)), scalingType: \(String(describing: scalingType)))"}
}

/// <p>Specifies a continuous hyperparameter and it's range of tunable values.
///       This object is part of the <a>ParameterRanges</a> object.</p>
public struct ContinuousParameterRange: Equatable {
    /// <p>The maximum tunable value of the hyperparameter.</p>
    public let maxValue: Double?
    /// <p>The minimum tunable value of the hyperparameter.</p>
    public let minValue: Double?
    /// <p>The name of the hyperparameter to tune.</p>
    public let name: String?
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range.
    ///       Valid values:</p>
    ///          <dl>
    ///             <dt>Auto</dt>
    ///             <dd>
    ///                <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    ///             </dd>
    ///             <dt>Linear</dt>
    ///             <dd>
    ///                <p>Hyperparameter tuning searches the values in the hyperparameter range by using a
    ///             linear scale.</p>
    ///             </dd>
    ///             <dt>Logarithmic</dt>
    ///             <dd>
    ///                <p>Hyperparameter tuning searches the values in the hyperparameter range by using a
    ///             logarithmic scale.</p>
    ///                <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    ///             </dd>
    ///             <dt>ReverseLogarithmic</dt>
    ///             <dd>
    ///                <p>hyperparameter tuning searches the values in the hyperparameter range by using a
    ///             reverse logarithmic scale.</p>
    ///                <p>Reverse logarithmic scaling works only for ranges that are entirely within the
    ///             range 0 <= x < 1.0.</p>
    ///             </dd>
    ///          </dl>
    ///          <p>For information about choosing a hyperparameter scale, see
    ///       <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>.
    ///       One of the following values:</p>
    public let scalingType: ScalingType?

    public init (
        maxValue: Double? = nil,
        minValue: Double? = nil,
        name: String? = nil,
        scalingType: ScalingType? = nil
    )
    {
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
        self.scalingType = scalingType
    }
}

public struct CreateDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

extension CreateDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetGroupInput(datasetArns: \(String(describing: datasetArns)), datasetGroupName: \(String(describing: datasetGroupName)), domain: \(String(describing: domain)), tags: \(String(describing: tags)))"}
}

extension CreateDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetGroupInput>
    public typealias MOutput = OperationOutput<CreateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetGroupOutputError>
}

public struct CreateDatasetGroupInput: Equatable {
    /// <p>An array of Amazon Resource Names (ARNs) of the datasets that you want to include in the
    ///       dataset group.</p>
    public let datasetArns: [String]?
    /// <p>A name for the dataset group.</p>
    public let datasetGroupName: String?
    /// <p>The domain associated with the dataset group. When you add a dataset to a dataset group,
    ///       this value and the value specified for the <code>Domain</code> parameter of the <a>CreateDataset</a> operation must match.</p>
    ///          <p>The <code>Domain</code> and <code>DatasetType</code> that you choose determine the fields
    ///       that must be present in training data that you import to a dataset. For example, if you choose
    ///       the <code>RETAIL</code> domain and <code>TARGET_TIME_SERIES</code> as the
    ///         <code>DatasetType</code>, Amazon Forecast requires that <code>item_id</code>,
    ///         <code>timestamp</code>, and <code>demand</code> fields are present in your data. For more
    ///       information, see <a>howitworks-datasets-groups</a>.</p>
    public let domain: Domain?
    /// <p>The optional metadata that you apply to the dataset group to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        datasetArns: [String]? = nil,
        datasetGroupName: String? = nil,
        domain: Domain? = nil,
        tags: [Tag]? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.tags = tags
    }
}

struct CreateDatasetGroupInputBody: Equatable {
    public let datasetGroupName: String?
    public let domain: Domain?
    public let datasetArns: [String]?
    public let tags: [Tag]?
}

extension CreateDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetGroupOutputResponse(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension CreateDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetGroupArn = output.datasetGroupArn
        } else {
            self.datasetGroupArn = nil
        }
    }
}

public struct CreateDatasetGroupOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct CreateDatasetGroupOutputResponseBody: Equatable {
    public let datasetGroupArn: String?
}

extension CreateDatasetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

public struct CreateDatasetImportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

extension CreateDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetImportJobInput(dataSource: \(String(describing: dataSource)), datasetArn: \(String(describing: datasetArn)), datasetImportJobName: \(String(describing: datasetImportJobName)), geolocationFormat: \(String(describing: geolocationFormat)), tags: \(String(describing: tags)), timeZone: \(String(describing: timeZone)), timestampFormat: \(String(describing: timestampFormat)), useGeolocationForTimeZone: \(String(describing: useGeolocationForTimeZone)))"}
}

extension CreateDatasetImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let geolocationFormat = geolocationFormat {
            try encodeContainer.encode(geolocationFormat, forKey: .geolocationFormat)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let timeZone = timeZone {
            try encodeContainer.encode(timeZone, forKey: .timeZone)
        }
        if let timestampFormat = timestampFormat {
            try encodeContainer.encode(timestampFormat, forKey: .timestampFormat)
        }
        if useGeolocationForTimeZone != false {
            try encodeContainer.encode(useGeolocationForTimeZone, forKey: .useGeolocationForTimeZone)
        }
    }
}

public struct CreateDatasetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetImportJobInput>
    public typealias MOutput = OperationOutput<CreateDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetImportJobOutputError>
}

public struct CreateDatasetImportJobInput: Equatable {
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
    ///          <p>If encryption is used, <code>DataSource</code> must include an AWS Key Management Service (KMS) key and the
    ///       IAM role must allow Amazon Forecast permission to access the key. The KMS key and IAM role must
    ///       match those specified in the <code>EncryptionConfig</code> parameter of the <a>CreateDataset</a> operation.</p>
    public let dataSource: DataSource?
    /// <p>The Amazon Resource Name (ARN) of the Amazon Forecast dataset that you want to import data
    ///       to.</p>
    public let datasetArn: String?
    /// <p>The name for the dataset import job. We recommend including the current timestamp in the
    ///       name, for example, <code>20190721DatasetImport</code>. This can help you avoid getting a
    ///         <code>ResourceAlreadyExistsException</code> exception.</p>
    public let datasetImportJobName: String?
    /// <p>The format of the geolocation attribute. The geolocation attribute can be formatted in
    ///             one of two ways:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>LAT_LONG</code> - the latitude and longitude in decimal format (Example: 47.61_-122.33).</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CC_POSTALCODE</code> (US Only) - the country code (US), followed by the 5-digit ZIP code (Example: US_98121).</p>
    ///             </li>
    ///          </ul>
    public let geolocationFormat: String?
    /// <p>The optional metadata that you apply to the dataset import job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?
    /// <p>A single time zone for every item in your dataset. This option is ideal for datasets
    ///             with all timestamps within a single time zone, or if all timestamps are normalized to a
    ///             single time zone. </p>
    ///         <p>Refer to the <a href="http://joda-time.sourceforge.net/timezones.html">Joda-Time
    ///                 API</a> for a complete list of valid time zone names.</p>
    public let timeZone: String?
    /// <p>The format of timestamps in the dataset. The format that you specify depends on the
    ///         <code>DataFrequency</code> specified when the dataset was created. The following formats are
    ///       supported</p>
    ///          <ul>
    ///             <li>
    ///                <p>"yyyy-MM-dd"</p>
    ///                <p>For the following data frequencies: Y, M, W, and D</p>
    ///             </li>
    ///             <li>
    ///                <p>"yyyy-MM-dd HH:mm:ss"</p>
    ///                <p>For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y,
    ///           M, W, and D</p>
    ///             </li>
    ///          </ul>
    ///          <p>If the format isn't specified, Amazon Forecast expects the format to be "yyyy-MM-dd
    ///       HH:mm:ss".</p>
    public let timestampFormat: String?
    /// <p>Automatically derive time zone information from the geolocation attribute. This option
    ///             is ideal for datasets that contain timestamps in multiple time zones and those
    ///             timestamps are expressed in local time.</p>
    public let useGeolocationForTimeZone: Bool

    public init (
        dataSource: DataSource? = nil,
        datasetArn: String? = nil,
        datasetImportJobName: String? = nil,
        geolocationFormat: String? = nil,
        tags: [Tag]? = nil,
        timeZone: String? = nil,
        timestampFormat: String? = nil,
        useGeolocationForTimeZone: Bool = false
    )
    {
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobName = datasetImportJobName
        self.geolocationFormat = geolocationFormat
        self.tags = tags
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct CreateDatasetImportJobInputBody: Equatable {
    public let datasetImportJobName: String?
    public let datasetArn: String?
    public let dataSource: DataSource?
    public let timestampFormat: String?
    public let timeZone: String?
    public let useGeolocationForTimeZone: Bool
    public let geolocationFormat: String?
    public let tags: [Tag]?
}

extension CreateDatasetImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobName = "DatasetImportJobName"
        case geolocationFormat = "GeolocationFormat"
        case tags = "Tags"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetImportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetImportJobOutputResponse(datasetImportJobArn: \(String(describing: datasetImportJobArn)))"}
}

extension CreateDatasetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetImportJobArn = output.datasetImportJobArn
        } else {
            self.datasetImportJobArn = nil
        }
    }
}

public struct CreateDatasetImportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    public let datasetImportJobArn: String?

    public init (
        datasetImportJobArn: String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct CreateDatasetImportJobOutputResponseBody: Equatable {
    public let datasetImportJobArn: String?
}

extension CreateDatasetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(dataFrequency: \(String(describing: dataFrequency)), datasetName: \(String(describing: datasetName)), datasetType: \(String(describing: datasetType)), domain: \(String(describing: domain)), encryptionConfig: \(String(describing: encryptionConfig)), schema: \(String(describing: schema)), tags: \(String(describing: tags)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataFrequency = dataFrequency {
            try encodeContainer.encode(dataFrequency, forKey: .dataFrequency)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p>The frequency of data collection. This parameter is required for RELATED_TIME_SERIES
    ///       datasets.</p>
    ///          <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
    ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example,
    ///       "D" indicates every day and "15min" indicates every 15 minutes.</p>
    public let dataFrequency: String?
    /// <p>A name for the dataset.</p>
    public let datasetName: String?
    /// <p>The dataset type. Valid values depend on the chosen <code>Domain</code>.</p>
    public let datasetType: DatasetType?
    /// <p>The domain associated with the dataset. When you add a dataset to a dataset group, this
    ///       value and the value specified for the <code>Domain</code> parameter of the <a>CreateDatasetGroup</a> operation must match.</p>
    ///          <p>The <code>Domain</code> and <code>DatasetType</code> that you choose determine the fields
    ///       that must be present in the training data that you import to the dataset. For example, if you
    ///       choose the <code>RETAIL</code> domain and <code>TARGET_TIME_SERIES</code> as the
    ///         <code>DatasetType</code>, Amazon Forecast requires <code>item_id</code>, <code>timestamp</code>,
    ///       and <code>demand</code> fields to be present in your data. For more information, see <a>howitworks-datasets-groups</a>.</p>
    public let domain: Domain?
    /// <p>An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.</p>
    public let encryptionConfig: EncryptionConfig?
    /// <p>The schema for the dataset. The schema attributes and their order must match the fields in
    ///       your data. The dataset <code>Domain</code> and <code>DatasetType</code> that you choose
    ///       determine the minimum required fields in your training data. For information about the
    ///       required fields for a specific dataset domain and type, see <a>howitworks-domains-ds-types</a>.</p>
    public let schema: Schema?
    /// <p>The optional metadata that you apply to the dataset to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        dataFrequency: String? = nil,
        datasetName: String? = nil,
        datasetType: DatasetType? = nil,
        domain: Domain? = nil,
        encryptionConfig: EncryptionConfig? = nil,
        schema: Schema? = nil,
        tags: [Tag]? = nil
    )
    {
        self.dataFrequency = dataFrequency
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.schema = schema
        self.tags = tags
    }
}

struct CreateDatasetInputBody: Equatable {
    public let datasetName: String?
    public let domain: Domain?
    public let datasetType: DatasetType?
    public let dataFrequency: String?
    public let schema: Schema?
    public let encryptionConfig: EncryptionConfig?
    public let tags: [Tag]?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataFrequency = "DataFrequency"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case schema = "Schema"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(datasetArn: \(String(describing: datasetArn)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetArn = output.datasetArn
        } else {
            self.datasetArn = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let datasetArn: String?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

public struct CreateForecastExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastExportJobOutputError>
}

extension CreateForecastExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateForecastExportJobInput(destination: \(String(describing: destination)), forecastArn: \(String(describing: forecastArn)), forecastExportJobName: \(String(describing: forecastExportJobName)), tags: \(String(describing: tags)))"}
}

extension CreateForecastExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateForecastExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastExportJobOutputError>
}

public struct CreateForecastExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastExportJobInput>
    public typealias MOutput = OperationOutput<CreateForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastExportJobOutputError>
}

public struct CreateForecastExportJobInput: Equatable {
    /// <p>The location where you want to save the forecast and an AWS Identity and Access Management (IAM) role that
    ///       Amazon Forecast can assume to access the location. The forecast must be exported to an Amazon S3
    ///       bucket.</p>
    ///          <p>If encryption is used, <code>Destination</code> must include an AWS Key Management Service (KMS) key. The
    ///       IAM role must allow Amazon Forecast permission to access the key.</p>
    public let destination: DataDestination?
    /// <p>The Amazon Resource Name (ARN) of the forecast that you want to export.</p>
    public let forecastArn: String?
    /// <p>The name for the forecast export job.</p>
    public let forecastExportJobName: String?
    /// <p>The optional metadata that you apply to the forecast export job to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        destination: DataDestination? = nil,
        forecastArn: String? = nil,
        forecastExportJobName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobName = forecastExportJobName
        self.tags = tags
    }
}

struct CreateForecastExportJobInputBody: Equatable {
    public let forecastExportJobName: String?
    public let forecastArn: String?
    public let destination: DataDestination?
    public let tags: [Tag]?
}

extension CreateForecastExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobName = "ForecastExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateForecastExportJobOutputResponse(forecastExportJobArn: \(String(describing: forecastExportJobArn)))"}
}

extension CreateForecastExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecastExportJobArn = output.forecastExportJobArn
        } else {
            self.forecastExportJobArn = nil
        }
    }
}

public struct CreateForecastExportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the export job.</p>
    public let forecastExportJobArn: String?

    public init (
        forecastExportJobArn: String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct CreateForecastExportJobOutputResponseBody: Equatable {
    public let forecastExportJobArn: String?
}

extension CreateForecastExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

public struct CreateForecastInputBodyMiddleware: Middleware {
    public let id: String = "CreateForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastInput>
    public typealias MOutput = OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastOutputError>
}

extension CreateForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateForecastInput(forecastName: \(String(describing: forecastName)), forecastTypes: \(String(describing: forecastTypes)), predictorArn: \(String(describing: predictorArn)), tags: \(String(describing: tags)))"}
}

extension CreateForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateForecastInputHeadersMiddleware: Middleware {
    public let id: String = "CreateForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastInput>
    public typealias MOutput = OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastOutputError>
}

public struct CreateForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateForecastInput>
    public typealias MOutput = OperationOutput<CreateForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateForecastOutputError>
}

public struct CreateForecastInput: Equatable {
    /// <p>A name for the forecast.</p>
    public let forecastName: String?
    /// <p>The quantiles at which probabilistic forecasts are generated. <b>You
    ///         can currently specify up to 5 quantiles per forecast</b>. Accepted values include
    ///         <code>0.01 to 0.99</code> (increments of .01 only) and <code>mean</code>. The mean forecast
    ///       is different from the median (0.50) when the distribution is not symmetric (for example, Beta
    ///       and Negative Binomial). The default value is <code>["0.1", "0.5", "0.9"]</code>.</p>
    public let forecastTypes: [String]?
    /// <p>The Amazon Resource Name (ARN) of the predictor to use to generate the forecast.</p>
    public let predictorArn: String?
    /// <p>The optional metadata that you apply to the forecast to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        forecastName: String? = nil,
        forecastTypes: [String]? = nil,
        predictorArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.predictorArn = predictorArn
        self.tags = tags
    }
}

struct CreateForecastInputBody: Equatable {
    public let forecastName: String?
    public let predictorArn: String?
    public let forecastTypes: [String]?
    public let tags: [Tag]?
}

extension CreateForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case predictorArn = "PredictorArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateForecastOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateForecastOutputResponse(forecastArn: \(String(describing: forecastArn)))"}
}

extension CreateForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateForecastOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecastArn = output.forecastArn
        } else {
            self.forecastArn = nil
        }
    }
}

public struct CreateForecastOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the forecast.</p>
    public let forecastArn: String?

    public init (
        forecastArn: String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct CreateForecastOutputResponseBody: Equatable {
    public let forecastArn: String?
}

extension CreateForecastOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

public struct CreatePredictorBacktestExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreatePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorBacktestExportJobOutputError>
}

extension CreatePredictorBacktestExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePredictorBacktestExportJobInput(destination: \(String(describing: destination)), predictorArn: \(String(describing: predictorArn)), predictorBacktestExportJobName: \(String(describing: predictorBacktestExportJobName)), tags: \(String(describing: tags)))"}
}

extension CreatePredictorBacktestExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreatePredictorBacktestExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorBacktestExportJobOutputError>
}

public struct CreatePredictorBacktestExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<CreatePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorBacktestExportJobOutputError>
}

public struct CreatePredictorBacktestExportJobInput: Equatable {
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    public let destination: DataDestination?
    /// <p>The Amazon Resource Name (ARN) of the predictor that you want to export.</p>
    public let predictorArn: String?
    /// <p>The name for the backtest export job.</p>
    public let predictorBacktestExportJobName: String?
    /// <p>Optional metadata to help you categorize and organize your backtests. Each tag consists
    ///             of a key and an optional value, both of which you define. Tag keys and values are case
    ///             sensitive.</p>
    ///         <p>The following restrictions apply to tags:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For each resource, each tag key must be unique and each tag key must have one
    ///                     value.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum number of tags per resource: 50.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum key length: 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Maximum value length: 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Accepted characters: all letters and numbers, spaces representable in UTF-8, and +
    ///                     - = . _ : / @. If your tagging schema is used across other services and resources,
    ///                     the character restrictions of those services also apply. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Key prefixes cannot include any upper or lowercase combination of
    ///                     <code>aws:</code> or <code>AWS:</code>. Values can have this prefix. If a tag
    ///                     value has <code>aws</code> as its prefix but the key does not, Forecast considers it
    ///                     to be a user tag and will count against the limit of 50 tags. Tags with only the key
    ///                     prefix of <code>aws</code> do not count against your tags per resource limit. You
    ///                     cannot edit or delete tag keys with this prefix.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        destination: DataDestination? = nil,
        predictorArn: String? = nil,
        predictorBacktestExportJobName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.destination = destination
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.tags = tags
    }
}

struct CreatePredictorBacktestExportJobInputBody: Equatable {
    public let predictorBacktestExportJobName: String?
    public let predictorArn: String?
    public let destination: DataDestination?
    public let tags: [Tag]?
}

extension CreatePredictorBacktestExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePredictorBacktestExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorBacktestExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorBacktestExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorBacktestExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePredictorBacktestExportJobOutputResponse(predictorBacktestExportJobArn: \(String(describing: predictorBacktestExportJobArn)))"}
}

extension CreatePredictorBacktestExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
        } else {
            self.predictorBacktestExportJobArn = nil
        }
    }
}

public struct CreatePredictorBacktestExportJobOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job that you want to
    ///             export.</p>
    public let predictorBacktestExportJobArn: String?

    public init (
        predictorBacktestExportJobArn: String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct CreatePredictorBacktestExportJobOutputResponseBody: Equatable {
    public let predictorBacktestExportJobArn: String?
}

extension CreatePredictorBacktestExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

public struct CreatePredictorInputBodyMiddleware: Middleware {
    public let id: String = "CreatePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorOutputError>
}

extension CreatePredictorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePredictorInput(algorithmArn: \(String(describing: algorithmArn)), autoMLOverrideStrategy: \(String(describing: autoMLOverrideStrategy)), encryptionConfig: \(String(describing: encryptionConfig)), evaluationParameters: \(String(describing: evaluationParameters)), featurizationConfig: \(String(describing: featurizationConfig)), forecastHorizon: \(String(describing: forecastHorizon)), forecastTypes: \(String(describing: forecastTypes)), hPOConfig: \(String(describing: hPOConfig)), inputDataConfig: \(String(describing: inputDataConfig)), performAutoML: \(String(describing: performAutoML)), performHPO: \(String(describing: performHPO)), predictorName: \(String(describing: predictorName)), tags: \(String(describing: tags)), trainingParameters: \(String(describing: trainingParameters)))"}
}

extension CreatePredictorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let autoMLOverrideStrategy = autoMLOverrideStrategy {
            try encodeContainer.encode(autoMLOverrideStrategy.rawValue, forKey: .autoMLOverrideStrategy)
        }
        if let encryptionConfig = encryptionConfig {
            try encodeContainer.encode(encryptionConfig, forKey: .encryptionConfig)
        }
        if let evaluationParameters = evaluationParameters {
            try encodeContainer.encode(evaluationParameters, forKey: .evaluationParameters)
        }
        if let featurizationConfig = featurizationConfig {
            try encodeContainer.encode(featurizationConfig, forKey: .featurizationConfig)
        }
        if let forecastHorizon = forecastHorizon {
            try encodeContainer.encode(forecastHorizon, forKey: .forecastHorizon)
        }
        if let forecastTypes = forecastTypes {
            var forecastTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastTypes)
            for forecasttypes0 in forecastTypes {
                try forecastTypesContainer.encode(forecasttypes0)
            }
        }
        if let hPOConfig = hPOConfig {
            try encodeContainer.encode(hPOConfig, forKey: .hPOConfig)
        }
        if let inputDataConfig = inputDataConfig {
            try encodeContainer.encode(inputDataConfig, forKey: .inputDataConfig)
        }
        if let performAutoML = performAutoML {
            try encodeContainer.encode(performAutoML, forKey: .performAutoML)
        }
        if let performHPO = performHPO {
            try encodeContainer.encode(performHPO, forKey: .performHPO)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let trainingParameters = trainingParameters {
            var trainingParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .trainingParameters)
            for (dictKey0, trainingparameters0) in trainingParameters {
                try trainingParametersContainer.encode(trainingparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePredictorInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorOutputError>
}

public struct CreatePredictorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePredictorInput>
    public typealias MOutput = OperationOutput<CreatePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePredictorOutputError>
}

public struct CreatePredictorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm to use for model training. Required if
    ///         <code>PerformAutoML</code> is not set to <code>true</code>.</p>
    ///          <p class="title">
    ///             <b>Supported algorithms:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/ARIMA</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/CNN-QR</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/Deep_AR_Plus</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/ETS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/NPTS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>arn:aws:forecast:::algorithm/Prophet</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let algorithmArn: String?
    /// <p>Used to overide the default AutoML strategy, which is to optimize predictor accuracy.
    ///             To apply an AutoML strategy that minimizes training time, use
    ///                 <code>LatencyOptimized</code>.</p>
    ///         <p>This parameter is only valid for predictors trained using AutoML.</p>
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
    /// <p>An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.</p>
    public let encryptionConfig: EncryptionConfig?
    /// <p>Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast
    ///       evaluates a predictor by splitting a dataset into training data and testing data. The
    ///       evaluation parameters define how to perform the split and the number of iterations.</p>
    public let evaluationParameters: EvaluationParameters?
    /// <p>The featurization configuration.</p>
    public let featurizationConfig: FeaturizationConfig?
    /// <p>Specifies the number of time-steps that the model is trained to predict. The forecast
    ///       horizon is also called the prediction length.</p>
    ///          <p>For example, if you configure a dataset for daily data collection (using the
    ///         <code>DataFrequency</code> parameter of the <a>CreateDataset</a> operation) and
    ///       set the forecast horizon to 10, the model returns predictions for 10 days.</p>
    ///          <p>The maximum forecast horizon is the lesser of 500 time-steps or 1/3 of the
    ///       TARGET_TIME_SERIES dataset length.</p>
    public let forecastHorizon: Int?
    /// <p>Specifies the forecast types used to train a predictor. You can specify up to five forecast types.
    ///       Forecast types can be quantiles from 0.01 to 0.99, by increments of 0.01 or higher. You can also specify
    ///       the mean forecast with <code>mean</code>.
    ///     </p>
    ///          <p>The default value is <code>["0.10", "0.50", "0.9"]</code>.</p>
    public let forecastTypes: [String]?
    /// <p>Provides hyperparameter override values for the algorithm. If you don't provide this
    ///       parameter, Amazon Forecast uses default values. The individual algorithms specify which
    ///       hyperparameters support hyperparameter optimization (HPO). For more information, see <a>aws-forecast-choosing-recipes</a>.</p>
    ///          <p>If you included the <code>HPOConfig</code> object, you must set <code>PerformHPO</code> to
    ///       true.</p>
    public let hPOConfig: HyperParameterTuningJobConfig?
    /// <p>Describes the dataset group that contains the data to use to train the predictor.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>Whether to perform AutoML. When Amazon Forecast performs AutoML, it evaluates the algorithms it
    ///       provides and chooses the best algorithm and configuration for your training dataset.</p>
    ///          <p>The default value is <code>false</code>. In this case, you are required to specify an
    ///       algorithm.</p>
    ///          <p>Set <code>PerformAutoML</code> to <code>true</code> to have Amazon Forecast perform AutoML. This
    ///       is a good option if you aren't sure which algorithm is suitable for your training data. In
    ///       this case, <code>PerformHPO</code> must be false.</p>
    public let performAutoML: Bool?
    /// <p>Whether to perform hyperparameter optimization (HPO). HPO finds optimal hyperparameter
    ///       values for your training data. The process of performing HPO is known as running a
    ///       hyperparameter tuning job.</p>
    ///          <p>The default value is <code>false</code>. In this case, Amazon Forecast uses default
    ///       hyperparameter values from the chosen algorithm.</p>
    ///          <p>To override the default values, set <code>PerformHPO</code> to <code>true</code> and,
    ///       optionally, supply the <a>HyperParameterTuningJobConfig</a> object. The tuning job
    ///       specifies a metric to optimize, which hyperparameters participate in tuning, and the valid
    ///       range for each tunable hyperparameter. In this case, you are required to specify an algorithm
    ///       and <code>PerformAutoML</code> must be false.</p>
    ///          <p>The following algorithms support HPO:</p>
    ///          <ul>
    ///             <li>
    ///                <p>DeepAR+</p>
    ///             </li>
    ///             <li>
    ///                <p>CNN-QR</p>
    ///             </li>
    ///          </ul>
    public let performHPO: Bool?
    /// <p>A name for the predictor.</p>
    public let predictorName: String?
    /// <p>The optional metadata that you apply to the predictor to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?
    /// <p>The hyperparameters to override for model training. The hyperparameters that you can
    ///       override are listed in the individual algorithms. For the list of supported algorithms, see
    ///         <a>aws-forecast-choosing-recipes</a>.</p>
    public let trainingParameters: [String:String]?

    public init (
        algorithmArn: String? = nil,
        autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil,
        encryptionConfig: EncryptionConfig? = nil,
        evaluationParameters: EvaluationParameters? = nil,
        featurizationConfig: FeaturizationConfig? = nil,
        forecastHorizon: Int? = nil,
        forecastTypes: [String]? = nil,
        hPOConfig: HyperParameterTuningJobConfig? = nil,
        inputDataConfig: InputDataConfig? = nil,
        performAutoML: Bool? = nil,
        performHPO: Bool? = nil,
        predictorName: String? = nil,
        tags: [Tag]? = nil,
        trainingParameters: [String:String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.encryptionConfig = encryptionConfig
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorName = predictorName
        self.tags = tags
        self.trainingParameters = trainingParameters
    }
}

struct CreatePredictorInputBody: Equatable {
    public let predictorName: String?
    public let algorithmArn: String?
    public let forecastHorizon: Int?
    public let forecastTypes: [String]?
    public let performAutoML: Bool?
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
    public let performHPO: Bool?
    public let trainingParameters: [String:String]?
    public let evaluationParameters: EvaluationParameters?
    public let hPOConfig: HyperParameterTuningJobConfig?
    public let inputDataConfig: InputDataConfig?
    public let featurizationConfig: FeaturizationConfig?
    public let encryptionConfig: EncryptionConfig?
    public let tags: [Tag]?
}

extension CreatePredictorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case encryptionConfig = "EncryptionConfig"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorName = "PredictorName"
        case tags = "Tags"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [String:String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePredictorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePredictorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePredictorOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePredictorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePredictorOutputResponse(predictorArn: \(String(describing: predictorArn)))"}
}

extension CreatePredictorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePredictorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.predictorArn = output.predictorArn
        } else {
            self.predictorArn = nil
        }
    }
}

public struct CreatePredictorOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor.</p>
    public let predictorArn: String?

    public init (
        predictorArn: String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct CreatePredictorOutputResponseBody: Equatable {
    public let predictorArn: String?
}

extension CreatePredictorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DataDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension DataDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataDestination(s3Config: \(String(describing: s3Config)))"}
}

/// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
///       to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
public struct DataDestination: Equatable {
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket along with the credentials to access the
    ///       bucket.</p>
    public let s3Config: S3Config?

    public init (
        s3Config: S3Config? = nil
    )
    {
        self.s3Config = s3Config
    }
}

extension DataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Config = "S3Config"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Config = s3Config {
            try encodeContainer.encode(s3Config, forKey: .s3Config)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ConfigDecoded = try containerValues.decodeIfPresent(S3Config.self, forKey: .s3Config)
        s3Config = s3ConfigDecoded
    }
}

extension DataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataSource(s3Config: \(String(describing: s3Config)))"}
}

/// <p>The source of your training data, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast to
///       access the data and, optionally, an AWS Key Management Service (KMS) key. This object is submitted in the
///       <a>CreateDatasetImportJob</a> request.</p>
public struct DataSource: Equatable {
    /// <p>The path to the training data stored in an Amazon Simple Storage Service (Amazon S3) bucket along with the
    ///       credentials to access the data.</p>
    public let s3Config: S3Config?

    public init (
        s3Config: S3Config? = nil
    )
    {
        self.s3Config = s3Config
    }
}

extension DatasetGroupSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let datasetGroupName = datasetGroupName {
            try encodeContainer.encode(datasetGroupName, forKey: .datasetGroupName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DatasetGroupSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetGroupSummary(creationTime: \(String(describing: creationTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), datasetGroupName: \(String(describing: datasetGroupName)), lastModificationTime: \(String(describing: lastModificationTime)))"}
}

/// <p>Provides a summary of the dataset group properties used in the <a>ListDatasetGroups</a> operation. To get the complete set of properties, call the
///         <a>DescribeDatasetGroup</a> operation, and provide the
///         <code>DatasetGroupArn</code>.</p>
public struct DatasetGroupSummary: Equatable {
    /// <p>When the dataset group was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>The name of the dataset group.</p>
    public let datasetGroupName: String?
    /// <p>When the dataset group was created or last updated from a call to the <a>UpdateDatasetGroup</a> operation. While the dataset group is being updated,
    ///         <code>LastModificationTime</code> is the current time of the <code>ListDatasetGroups</code>
    ///       call.</p>
    public let lastModificationTime: Date?

    public init (
        creationTime: Date? = nil,
        datasetGroupArn: String? = nil,
        datasetGroupName: String? = nil,
        lastModificationTime: Date? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.lastModificationTime = lastModificationTime
    }
}

extension DatasetImportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case dataSource = "DataSource"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
        if let datasetImportJobName = datasetImportJobName {
            try encodeContainer.encode(datasetImportJobName, forKey: .datasetImportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DatasetImportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetImportJobSummary(creationTime: \(String(describing: creationTime)), dataSource: \(String(describing: dataSource)), datasetImportJobArn: \(String(describing: datasetImportJobArn)), datasetImportJobName: \(String(describing: datasetImportJobName)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the dataset import job properties used in the <a>ListDatasetImportJobs</a> operation. To get the complete set of properties, call the
///         <a>DescribeDatasetImportJob</a> operation, and provide the
///         <code>DatasetImportJobArn</code>.</p>
public struct DatasetImportJobSummary: Equatable {
    /// <p>When the dataset import job was created.</p>
    public let creationTime: Date?
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data. The training data must be stored in an Amazon S3 bucket.</p>
    ///          <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
    public let dataSource: DataSource?
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    public let datasetImportJobArn: String?
    /// <p>The name of the dataset import job.</p>
    public let datasetImportJobName: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the
    ///       job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The status of the dataset import job. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///             <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        dataSource: DataSource? = nil,
        datasetImportJobArn: String? = nil,
        datasetImportJobName: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataSource = dataSource
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

extension DatasetSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetName = datasetName {
            try encodeContainer.encode(datasetName, forKey: .datasetName)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType.rawValue, forKey: .datasetType)
        }
        if let domain = domain {
            try encodeContainer.encode(domain.rawValue, forKey: .domain)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension DatasetSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSummary(creationTime: \(String(describing: creationTime)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), datasetType: \(String(describing: datasetType)), domain: \(String(describing: domain)), lastModificationTime: \(String(describing: lastModificationTime)))"}
}

/// <p>Provides a summary of the dataset properties used in the <a>ListDatasets</a>
///       operation. To get the complete set of properties, call the <a>DescribeDataset</a>
///       operation, and provide the <code>DatasetArn</code>.</p>
public struct DatasetSummary: Equatable {
    /// <p>When the dataset was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let datasetArn: String?
    /// <p>The name of the dataset.</p>
    public let datasetName: String?
    /// <p>The dataset type.</p>
    public let datasetType: DatasetType?
    /// <p>The domain associated with the dataset.</p>
    public let domain: Domain?
    /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as
    ///         <code>CreationTime</code>. While data is being imported to the dataset,
    ///         <code>LastModificationTime</code> is the current time of the <code>ListDatasets</code> call.
    ///       After a <a>CreateDatasetImportJob</a> operation has finished,
    ///         <code>LastModificationTime</code> is when the import job completed or failed.</p>
    public let lastModificationTime: Date?

    public init (
        creationTime: Date? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        datasetType: DatasetType? = nil,
        domain: Domain? = nil,
        lastModificationTime: Date? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.lastModificationTime = lastModificationTime
    }
}

public enum DatasetType {
    case itemMetadata
    case relatedTimeSeries
    case targetTimeSeries
    case sdkUnknown(String)
}

extension DatasetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetType] {
        return [
            .itemMetadata,
            .relatedTimeSeries,
            .targetTimeSeries,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .itemMetadata: return "ITEM_METADATA"
        case .relatedTimeSeries: return "RELATED_TIME_SERIES"
        case .targetTimeSeries: return "TARGET_TIME_SERIES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetType(rawValue: rawValue) ?? DatasetType.sdkUnknown(rawValue)
    }
}

public struct DeleteDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

extension DeleteDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetGroupInput(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension DeleteDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DeleteDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetGroupInput>
    public typealias MOutput = OperationOutput<DeleteDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetGroupOutputError>
}

public struct DeleteDatasetGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group to delete.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DeleteDatasetGroupInputBody: Equatable {
    public let datasetGroupArn: String?
}

extension DeleteDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DeleteDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetGroupOutputResponse()"}
}

extension DeleteDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetGroupOutputResponseBody: Equatable {
}

extension DeleteDatasetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDatasetImportJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetImportJobOutputError>
}

extension DeleteDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetImportJobInput(datasetImportJobArn: \(String(describing: datasetImportJobArn)))"}
}

extension DeleteDatasetImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DeleteDatasetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetImportJobOutputError>
}

public struct DeleteDatasetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DeleteDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetImportJobOutputError>
}

public struct DeleteDatasetImportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job to delete.</p>
    public let datasetImportJobArn: String?

    public init (
        datasetImportJobArn: String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DeleteDatasetImportJobInputBody: Equatable {
    public let datasetImportJobArn: String?
}

extension DeleteDatasetImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DeleteDatasetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetImportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetImportJobOutputResponse()"}
}

extension DeleteDatasetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetImportJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetImportJobOutputResponseBody: Equatable {
}

extension DeleteDatasetImportJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(datasetArn: \(String(describing: datasetArn)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset to delete.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DeleteDatasetInputBody: Equatable {
    public let datasetArn: String?
}

extension DeleteDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Equatable {
}

extension DeleteDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteForecastExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DeleteForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastExportJobOutputError>
}

extension DeleteForecastExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteForecastExportJobInput(forecastExportJobArn: \(String(describing: forecastExportJobArn)))"}
}

extension DeleteForecastExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

public struct DeleteForecastExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastExportJobOutputError>
}

public struct DeleteForecastExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastExportJobInput>
    public typealias MOutput = OperationOutput<DeleteForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastExportJobOutputError>
}

public struct DeleteForecastExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the forecast export job to delete.</p>
    public let forecastExportJobArn: String?

    public init (
        forecastExportJobArn: String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DeleteForecastExportJobInputBody: Equatable {
    public let forecastExportJobArn: String?
}

extension DeleteForecastExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DeleteForecastExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteForecastExportJobOutputResponse()"}
}

extension DeleteForecastExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastExportJobOutputResponse: Equatable {

    public init() {}
}

struct DeleteForecastExportJobOutputResponseBody: Equatable {
}

extension DeleteForecastExportJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteForecastInputBodyMiddleware: Middleware {
    public let id: String = "DeleteForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastOutputError>
}

extension DeleteForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteForecastInput(forecastArn: \(String(describing: forecastArn)))"}
}

extension DeleteForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

public struct DeleteForecastInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastOutputError>
}

public struct DeleteForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteForecastInput>
    public typealias MOutput = OperationOutput<DeleteForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteForecastOutputError>
}

public struct DeleteForecastInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the forecast to delete.</p>
    public let forecastArn: String?

    public init (
        forecastArn: String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DeleteForecastInputBody: Equatable {
    public let forecastArn: String?
}

extension DeleteForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DeleteForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteForecastOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteForecastOutputResponse()"}
}

extension DeleteForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteForecastOutputResponse: Equatable {

    public init() {}
}

struct DeleteForecastOutputResponseBody: Equatable {
}

extension DeleteForecastOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePredictorBacktestExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DeletePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorBacktestExportJobOutputError>
}

extension DeletePredictorBacktestExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePredictorBacktestExportJobInput(predictorBacktestExportJobArn: \(String(describing: predictorBacktestExportJobArn)))"}
}

extension DeletePredictorBacktestExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

public struct DeletePredictorBacktestExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorBacktestExportJobOutputError>
}

public struct DeletePredictorBacktestExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DeletePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorBacktestExportJobOutputError>
}

public struct DeletePredictorBacktestExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job to delete.</p>
    public let predictorBacktestExportJobArn: String?

    public init (
        predictorBacktestExportJobArn: String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DeletePredictorBacktestExportJobInputBody: Equatable {
    public let predictorBacktestExportJobArn: String?
}

extension DeletePredictorBacktestExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DeletePredictorBacktestExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorBacktestExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorBacktestExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorBacktestExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePredictorBacktestExportJobOutputResponse()"}
}

extension DeletePredictorBacktestExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorBacktestExportJobOutputResponse: Equatable {

    public init() {}
}

struct DeletePredictorBacktestExportJobOutputResponseBody: Equatable {
}

extension DeletePredictorBacktestExportJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePredictorInputBodyMiddleware: Middleware {
    public let id: String = "DeletePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorOutputError>
}

extension DeletePredictorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePredictorInput(predictorArn: \(String(describing: predictorArn)))"}
}

extension DeletePredictorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct DeletePredictorInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorOutputError>
}

public struct DeletePredictorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePredictorInput>
    public typealias MOutput = OperationOutput<DeletePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePredictorOutputError>
}

public struct DeletePredictorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor to delete.</p>
    public let predictorArn: String?

    public init (
        predictorArn: String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DeletePredictorInputBody: Equatable {
    public let predictorArn: String?
}

extension DeletePredictorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DeletePredictorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePredictorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePredictorOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePredictorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePredictorOutputResponse()"}
}

extension DeletePredictorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePredictorOutputResponse: Equatable {

    public init() {}
}

struct DeletePredictorOutputResponseBody: Equatable {
}

extension DeletePredictorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteResourceTreeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourceTreeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceTreeOutputError>
}

extension DeleteResourceTreeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceTreeInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourceTreeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourceTreeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceTreeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceTreeOutputError>
}

public struct DeleteResourceTreeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceTreeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceTreeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceTreeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceTreeInput>
    public typealias MOutput = OperationOutput<DeleteResourceTreeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceTreeOutputError>
}

public struct DeleteResourceTreeInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the parent resource to delete. All child resources
    ///             of the parent resource will also be deleted.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourceTreeInputBody: Equatable {
    public let resourceArn: String?
}

extension DeleteResourceTreeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourceTreeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceTreeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceTreeOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceTreeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceTreeOutputResponse()"}
}

extension DeleteResourceTreeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceTreeOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceTreeOutputResponseBody: Equatable {
}

extension DeleteResourceTreeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

extension DescribeDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetGroupInput(datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension DescribeDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct DescribeDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetGroupInput>
    public typealias MOutput = OperationOutput<DescribeDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetGroupOutputError>
}

public struct DescribeDatasetGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?

    public init (
        datasetGroupArn: String? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
    }
}

struct DescribeDatasetGroupInputBody: Equatable {
    public let datasetGroupArn: String?
}

extension DescribeDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
    }
}

extension DescribeDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetGroupOutputResponse(creationTime: \(String(describing: creationTime)), datasetArns: \(String(describing: datasetArns)), datasetGroupArn: \(String(describing: datasetGroupArn)), datasetGroupName: \(String(describing: datasetGroupName)), domain: \(String(describing: domain)), lastModificationTime: \(String(describing: lastModificationTime)), status: \(String(describing: status)))"}
}

extension DescribeDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.datasetArns = output.datasetArns
            self.datasetGroupArn = output.datasetGroupArn
            self.datasetGroupName = output.datasetGroupName
            self.domain = output.domain
            self.lastModificationTime = output.lastModificationTime
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetArns = nil
            self.datasetGroupArn = nil
            self.datasetGroupName = nil
            self.domain = nil
            self.lastModificationTime = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetGroupOutputResponse: Equatable {
    /// <p>When the dataset group was created.</p>
    public let creationTime: Date?
    /// <p>An array of Amazon Resource Names (ARNs) of the datasets contained in the dataset
    ///       group.</p>
    public let datasetArns: [String]?
    /// <p>The ARN of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>The name of the dataset group.</p>
    public let datasetGroupName: String?
    /// <p>The domain associated with the dataset group.</p>
    public let domain: Domain?
    /// <p>When the dataset group was created or last updated from a call to the <a>UpdateDatasetGroup</a> operation. While the dataset group is being updated,
    ///         <code>LastModificationTime</code> is the current time of the
    ///         <code>DescribeDatasetGroup</code> call.</p>
    public let lastModificationTime: Date?
    /// <p>The status of the dataset group. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///             <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_PENDING</code>, <code>UPDATE_IN_PROGRESS</code>,
    ///             <code>UPDATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>The <code>UPDATE</code> states apply when you call the <a>UpdateDatasetGroup</a> operation.</p>
    ///          <note>
    ///             <p>The <code>Status</code> of the dataset group must be <code>ACTIVE</code> before you can
    ///         use the dataset group to create a predictor.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        datasetArns: [String]? = nil,
        datasetGroupArn: String? = nil,
        datasetGroupName: String? = nil,
        domain: Domain? = nil,
        lastModificationTime: Date? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
        self.datasetGroupName = datasetGroupName
        self.domain = domain
        self.lastModificationTime = lastModificationTime
        self.status = status
    }
}

struct DescribeDatasetGroupOutputResponseBody: Equatable {
    public let datasetGroupName: String?
    public let datasetGroupArn: String?
    public let datasetArns: [String]?
    public let domain: Domain?
    public let status: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribeDatasetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
        case datasetGroupName = "DatasetGroupName"
        case domain = "Domain"
        case lastModificationTime = "LastModificationTime"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupName)
        datasetGroupName = datasetGroupNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeDatasetImportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

extension DescribeDatasetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetImportJobInput(datasetImportJobArn: \(String(describing: datasetImportJobArn)))"}
}

extension DescribeDatasetImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetImportJobArn = datasetImportJobArn {
            try encodeContainer.encode(datasetImportJobArn, forKey: .datasetImportJobArn)
        }
    }
}

public struct DescribeDatasetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetImportJobInput>
    public typealias MOutput = OperationOutput<DescribeDatasetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetImportJobOutputError>
}

public struct DescribeDatasetImportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset import job.</p>
    public let datasetImportJobArn: String?

    public init (
        datasetImportJobArn: String? = nil
    )
    {
        self.datasetImportJobArn = datasetImportJobArn
    }
}

struct DescribeDatasetImportJobInputBody: Equatable {
    public let datasetImportJobArn: String?
}

extension DescribeDatasetImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobArn = "DatasetImportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
    }
}

extension DescribeDatasetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetImportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetImportJobOutputResponse(creationTime: \(String(describing: creationTime)), dataSize: \(String(describing: dataSize)), dataSource: \(String(describing: dataSource)), datasetArn: \(String(describing: datasetArn)), datasetImportJobArn: \(String(describing: datasetImportJobArn)), datasetImportJobName: \(String(describing: datasetImportJobName)), estimatedTimeRemainingInMinutes: \(String(describing: estimatedTimeRemainingInMinutes)), fieldStatistics: \(String(describing: fieldStatistics)), geolocationFormat: \(String(describing: geolocationFormat)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), status: \(String(describing: status)), timeZone: \(String(describing: timeZone)), timestampFormat: \(String(describing: timestampFormat)), useGeolocationForTimeZone: \(String(describing: useGeolocationForTimeZone)))"}
}

extension DescribeDatasetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.dataSize = output.dataSize
            self.dataSource = output.dataSource
            self.datasetArn = output.datasetArn
            self.datasetImportJobArn = output.datasetImportJobArn
            self.datasetImportJobName = output.datasetImportJobName
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.fieldStatistics = output.fieldStatistics
            self.geolocationFormat = output.geolocationFormat
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
            self.timeZone = output.timeZone
            self.timestampFormat = output.timestampFormat
            self.useGeolocationForTimeZone = output.useGeolocationForTimeZone
        } else {
            self.creationTime = nil
            self.dataSize = nil
            self.dataSource = nil
            self.datasetArn = nil
            self.datasetImportJobArn = nil
            self.datasetImportJobName = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.fieldStatistics = nil
            self.geolocationFormat = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
            self.timeZone = nil
            self.timestampFormat = nil
            self.useGeolocationForTimeZone = false
        }
    }
}

public struct DescribeDatasetImportJobOutputResponse: Equatable {
    /// <p>When the dataset import job was created.</p>
    public let creationTime: Date?
    /// <p>The size of the dataset in gigabytes (GB) after the import job has finished.</p>
    public let dataSize: Double?
    /// <p>The location of the training data to import and an AWS Identity and Access Management (IAM) role that Amazon Forecast
    ///       can assume to access the data.</p>
    ///          <p>If encryption is used, <code>DataSource</code> includes an AWS Key Management Service (KMS) key.</p>
    public let dataSource: DataSource?
    /// <p>The Amazon Resource Name (ARN) of the dataset that the training data was imported
    ///       to.</p>
    public let datasetArn: String?
    /// <p>The ARN of the dataset import job.</p>
    public let datasetImportJobArn: String?
    /// <p>The name of the dataset import job.</p>
    public let datasetImportJobName: String?
    /// <p>The estimated time remaining in minutes for the dataset import job to complete.</p>
    public let estimatedTimeRemainingInMinutes: Int?
    /// <p>Statistical information about each field in the input data.</p>
    public let fieldStatistics: [String:Statistics]?
    /// <p>The format of the geolocation attribute. Valid Values:<code>"LAT_LONG"</code> and
    ///                 <code>"CC_POSTALCODE"</code>.</p>
    public let geolocationFormat: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the
    ///       job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The status of the dataset import job. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///             <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The single time zone applied to every item in the dataset</p>
    public let timeZone: String?
    /// <p>The format of timestamps in the dataset. The format that you specify depends on the
    ///         <code>DataFrequency</code> specified when the dataset was created. The following formats are
    ///       supported</p>
    ///          <ul>
    ///             <li>
    ///                <p>"yyyy-MM-dd"</p>
    ///                <p>For the following data frequencies: Y, M, W, and D</p>
    ///             </li>
    ///             <li>
    ///                <p>"yyyy-MM-dd HH:mm:ss"</p>
    ///                <p>For the following data frequencies: H, 30min, 15min, and 1min; and optionally, for: Y,
    ///           M, W, and D</p>
    ///             </li>
    ///          </ul>
    public let timestampFormat: String?
    /// <p>Whether <code>TimeZone</code> is automatically derived from the geolocation
    ///             attribute.</p>
    public let useGeolocationForTimeZone: Bool

    public init (
        creationTime: Date? = nil,
        dataSize: Double? = nil,
        dataSource: DataSource? = nil,
        datasetArn: String? = nil,
        datasetImportJobArn: String? = nil,
        datasetImportJobName: String? = nil,
        estimatedTimeRemainingInMinutes: Int? = nil,
        fieldStatistics: [String:Statistics]? = nil,
        geolocationFormat: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        status: String? = nil,
        timeZone: String? = nil,
        timestampFormat: String? = nil,
        useGeolocationForTimeZone: Bool = false
    )
    {
        self.creationTime = creationTime
        self.dataSize = dataSize
        self.dataSource = dataSource
        self.datasetArn = datasetArn
        self.datasetImportJobArn = datasetImportJobArn
        self.datasetImportJobName = datasetImportJobName
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.fieldStatistics = fieldStatistics
        self.geolocationFormat = geolocationFormat
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
        self.timeZone = timeZone
        self.timestampFormat = timestampFormat
        self.useGeolocationForTimeZone = useGeolocationForTimeZone
    }
}

struct DescribeDatasetImportJobOutputResponseBody: Equatable {
    public let datasetImportJobName: String?
    public let datasetImportJobArn: String?
    public let datasetArn: String?
    public let timestampFormat: String?
    public let timeZone: String?
    public let useGeolocationForTimeZone: Bool
    public let geolocationFormat: String?
    public let dataSource: DataSource?
    public let estimatedTimeRemainingInMinutes: Int?
    public let fieldStatistics: [String:Statistics]?
    public let dataSize: Double?
    public let status: String?
    public let message: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribeDatasetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case dataSize = "DataSize"
        case dataSource = "DataSource"
        case datasetArn = "DatasetArn"
        case datasetImportJobArn = "DatasetImportJobArn"
        case datasetImportJobName = "DatasetImportJobName"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case fieldStatistics = "FieldStatistics"
        case geolocationFormat = "GeolocationFormat"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
        case timeZone = "TimeZone"
        case timestampFormat = "TimestampFormat"
        case useGeolocationForTimeZone = "UseGeolocationForTimeZone"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobName)
        datasetImportJobName = datasetImportJobNameDecoded
        let datasetImportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetImportJobArn)
        datasetImportJobArn = datasetImportJobArnDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let timestampFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestampFormat)
        timestampFormat = timestampFormatDecoded
        let timeZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeZone)
        timeZone = timeZoneDecoded
        let useGeolocationForTimeZoneDecoded = try containerValues.decode(Bool.self, forKey: .useGeolocationForTimeZone)
        useGeolocationForTimeZone = useGeolocationForTimeZoneDecoded
        let geolocationFormatDecoded = try containerValues.decodeIfPresent(String.self, forKey: .geolocationFormat)
        geolocationFormat = geolocationFormatDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let fieldStatisticsContainer = try containerValues.decodeIfPresent([String: Statistics?].self, forKey: .fieldStatistics)
        var fieldStatisticsDecoded0: [String:Statistics]? = nil
        if let fieldStatisticsContainer = fieldStatisticsContainer {
            fieldStatisticsDecoded0 = [String:Statistics]()
            for (key0, statistics0) in fieldStatisticsContainer {
                if let statistics0 = statistics0 {
                    fieldStatisticsDecoded0?[key0] = statistics0
                }
            }
        }
        fieldStatistics = fieldStatisticsDecoded0
        let dataSizeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeDatasetInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetArn: \(String(describing: datasetArn)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArn = datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let datasetArn: String?

    public init (
        datasetArn: String? = nil
    )
    {
        self.datasetArn = datasetArn
    }
}

struct DescribeDatasetInputBody: Equatable {
    public let datasetArn: String?
}

extension DescribeDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArn = "DatasetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(creationTime: \(String(describing: creationTime)), dataFrequency: \(String(describing: dataFrequency)), datasetArn: \(String(describing: datasetArn)), datasetName: \(String(describing: datasetName)), datasetType: \(String(describing: datasetType)), domain: \(String(describing: domain)), encryptionConfig: \(String(describing: encryptionConfig)), lastModificationTime: \(String(describing: lastModificationTime)), schema: \(String(describing: schema)), status: \(String(describing: status)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.dataFrequency = output.dataFrequency
            self.datasetArn = output.datasetArn
            self.datasetName = output.datasetName
            self.datasetType = output.datasetType
            self.domain = output.domain
            self.encryptionConfig = output.encryptionConfig
            self.lastModificationTime = output.lastModificationTime
            self.schema = output.schema
            self.status = output.status
        } else {
            self.creationTime = nil
            self.dataFrequency = nil
            self.datasetArn = nil
            self.datasetName = nil
            self.datasetType = nil
            self.domain = nil
            self.encryptionConfig = nil
            self.lastModificationTime = nil
            self.schema = nil
            self.status = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>When the dataset was created.</p>
    public let creationTime: Date?
    /// <p>The frequency of data collection.</p>
    ///          <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
    ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute). For example,
    ///       "M" indicates every month and "30min" indicates every 30 minutes.</p>
    public let dataFrequency: String?
    /// <p>The Amazon Resource Name (ARN) of the dataset.</p>
    public let datasetArn: String?
    /// <p>The name of the dataset.</p>
    public let datasetName: String?
    /// <p>The dataset type.</p>
    public let datasetType: DatasetType?
    /// <p>The domain associated with the dataset.</p>
    public let domain: Domain?
    /// <p>The AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.</p>
    public let encryptionConfig: EncryptionConfig?
    /// <p>When you create a dataset, <code>LastModificationTime</code> is the same as
    ///         <code>CreationTime</code>. While data is being imported to the dataset,
    ///         <code>LastModificationTime</code> is the current time of the <code>DescribeDataset</code>
    ///       call. After a <a>CreateDatasetImportJob</a> operation has finished,
    ///         <code>LastModificationTime</code> is when the import job completed or failed.</p>
    public let lastModificationTime: Date?
    /// <p>An array of <code>SchemaAttribute</code> objects that specify the dataset fields. Each
    ///         <code>SchemaAttribute</code> specifies the name and data type of a field.</p>
    public let schema: Schema?
    /// <p>The status of the dataset. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///             <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///             <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UPDATE_PENDING</code>, <code>UPDATE_IN_PROGRESS</code>,
    ///             <code>UPDATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>The <code>UPDATE</code> states apply while data is imported to the dataset from a call to
    ///       the <a>CreateDatasetImportJob</a> operation and reflect the status of the dataset
    ///       import job. For example, when the import job status is <code>CREATE_IN_PROGRESS</code>, the
    ///       status of the dataset is <code>UPDATE_IN_PROGRESS</code>.</p>
    ///          <note>
    ///             <p>The <code>Status</code> of the dataset must be <code>ACTIVE</code> before you can import
    ///         training data.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        dataFrequency: String? = nil,
        datasetArn: String? = nil,
        datasetName: String? = nil,
        datasetType: DatasetType? = nil,
        domain: Domain? = nil,
        encryptionConfig: EncryptionConfig? = nil,
        lastModificationTime: Date? = nil,
        schema: Schema? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.dataFrequency = dataFrequency
        self.datasetArn = datasetArn
        self.datasetName = datasetName
        self.datasetType = datasetType
        self.domain = domain
        self.encryptionConfig = encryptionConfig
        self.lastModificationTime = lastModificationTime
        self.schema = schema
        self.status = status
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let datasetArn: String?
    public let datasetName: String?
    public let domain: Domain?
    public let datasetType: DatasetType?
    public let dataFrequency: String?
    public let schema: Schema?
    public let encryptionConfig: EncryptionConfig?
    public let status: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case dataFrequency = "DataFrequency"
        case datasetArn = "DatasetArn"
        case datasetName = "DatasetName"
        case datasetType = "DatasetType"
        case domain = "Domain"
        case encryptionConfig = "EncryptionConfig"
        case lastModificationTime = "LastModificationTime"
        case schema = "Schema"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetName)
        datasetName = datasetNameDecoded
        let domainDecoded = try containerValues.decodeIfPresent(Domain.self, forKey: .domain)
        domain = domainDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(DatasetType.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let dataFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataFrequency)
        dataFrequency = dataFrequencyDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Schema.self, forKey: .schema)
        schema = schemaDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeForecastExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeForecastExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastExportJobOutputError>
}

extension DescribeForecastExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeForecastExportJobInput(forecastExportJobArn: \(String(describing: forecastExportJobArn)))"}
}

extension DescribeForecastExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
    }
}

public struct DescribeForecastExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeForecastExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastExportJobOutputError>
}

public struct DescribeForecastExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeForecastExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastExportJobInput>
    public typealias MOutput = OperationOutput<DescribeForecastExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastExportJobOutputError>
}

public struct DescribeForecastExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
    public let forecastExportJobArn: String?

    public init (
        forecastExportJobArn: String? = nil
    )
    {
        self.forecastExportJobArn = forecastExportJobArn
    }
}

struct DescribeForecastExportJobInputBody: Equatable {
    public let forecastExportJobArn: String?
}

extension DescribeForecastExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobArn = "ForecastExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
    }
}

extension DescribeForecastExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeForecastExportJobOutputResponse(creationTime: \(String(describing: creationTime)), destination: \(String(describing: destination)), forecastArn: \(String(describing: forecastArn)), forecastExportJobArn: \(String(describing: forecastExportJobArn)), forecastExportJobName: \(String(describing: forecastExportJobName)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), status: \(String(describing: status)))"}
}

extension DescribeForecastExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeForecastExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.forecastArn = output.forecastArn
            self.forecastExportJobArn = output.forecastExportJobArn
            self.forecastExportJobName = output.forecastExportJobName
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.forecastArn = nil
            self.forecastExportJobArn = nil
            self.forecastExportJobName = nil
            self.lastModificationTime = nil
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastExportJobOutputResponse: Equatable {
    /// <p>When the forecast export job was created.</p>
    public let creationTime: Date?
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    public let destination: DataDestination?
    /// <p>The Amazon Resource Name (ARN) of the exported forecast.</p>
    public let forecastArn: String?
    /// <p>The ARN of the forecast export job.</p>
    public let forecastExportJobArn: String?
    /// <p>The name of the forecast export job.</p>
    public let forecastExportJobName: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The status of the forecast export job. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before
    ///         you can access the forecast in your S3 bucket.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        destination: DataDestination? = nil,
        forecastArn: String? = nil,
        forecastExportJobArn: String? = nil,
        forecastExportJobName: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastArn = forecastArn
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

struct DescribeForecastExportJobOutputResponseBody: Equatable {
    public let forecastExportJobArn: String?
    public let forecastExportJobName: String?
    public let forecastArn: String?
    public let destination: DataDestination?
    public let message: String?
    public let status: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribeForecastExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastArn = "ForecastArn"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribeForecastInputBodyMiddleware: Middleware {
    public let id: String = "DescribeForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastOutputError>
}

extension DescribeForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeForecastInput(forecastArn: \(String(describing: forecastArn)))"}
}

extension DescribeForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastArn = "ForecastArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
    }
}

public struct DescribeForecastInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastOutputError>
}

public struct DescribeForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeForecastInput>
    public typealias MOutput = OperationOutput<DescribeForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeForecastOutputError>
}

public struct DescribeForecastInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the forecast.</p>
    public let forecastArn: String?

    public init (
        forecastArn: String? = nil
    )
    {
        self.forecastArn = forecastArn
    }
}

struct DescribeForecastInputBody: Equatable {
    public let forecastArn: String?
}

extension DescribeForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastArn = "ForecastArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
    }
}

extension DescribeForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeForecastOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeForecastOutputResponse(creationTime: \(String(describing: creationTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), estimatedTimeRemainingInMinutes: \(String(describing: estimatedTimeRemainingInMinutes)), forecastArn: \(String(describing: forecastArn)), forecastName: \(String(describing: forecastName)), forecastTypes: \(String(describing: forecastTypes)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), predictorArn: \(String(describing: predictorArn)), status: \(String(describing: status)))"}
}

extension DescribeForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeForecastOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.datasetGroupArn = output.datasetGroupArn
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.forecastArn = output.forecastArn
            self.forecastName = output.forecastName
            self.forecastTypes = output.forecastTypes
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.status = output.status
        } else {
            self.creationTime = nil
            self.datasetGroupArn = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.forecastArn = nil
            self.forecastName = nil
            self.forecastTypes = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.status = nil
        }
    }
}

public struct DescribeForecastOutputResponse: Equatable {
    /// <p>When the forecast creation task was created.</p>
    public let creationTime: Date?
    /// <p>The ARN of the dataset group that provided the data used to train the predictor.</p>
    public let datasetGroupArn: String?
    /// <p>The estimated time remaining in minutes for the forecast job to complete.</p>
    public let estimatedTimeRemainingInMinutes: Int?
    /// <p>The forecast ARN as specified in the request.</p>
    public let forecastArn: String?
    /// <p>The name of the forecast.</p>
    public let forecastName: String?
    /// <p>The quantiles at which probabilistic forecasts were generated.</p>
    public let forecastTypes: [String]?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The ARN of the predictor used to generate the forecast.</p>
    public let predictorArn: String?
    /// <p>The status of the forecast. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query
    ///         or export the forecast.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        datasetGroupArn: String? = nil,
        estimatedTimeRemainingInMinutes: Int? = nil,
        forecastArn: String? = nil,
        forecastName: String? = nil,
        forecastTypes: [String]? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        predictorArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.forecastTypes = forecastTypes
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
    }
}

struct DescribeForecastOutputResponseBody: Equatable {
    public let forecastArn: String?
    public let forecastName: String?
    public let forecastTypes: [String]?
    public let predictorArn: String?
    public let datasetGroupArn: String?
    public let estimatedTimeRemainingInMinutes: Int?
    public let status: String?
    public let message: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribeForecastOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case forecastTypes = "ForecastTypes"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribePredictorBacktestExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribePredictorBacktestExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorBacktestExportJobOutputError>
}

extension DescribePredictorBacktestExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePredictorBacktestExportJobInput(predictorBacktestExportJobArn: \(String(describing: predictorBacktestExportJobArn)))"}
}

extension DescribePredictorBacktestExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
    }
}

public struct DescribePredictorBacktestExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePredictorBacktestExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorBacktestExportJobOutputError>
}

public struct DescribePredictorBacktestExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePredictorBacktestExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorBacktestExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorBacktestExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorBacktestExportJobInput>
    public typealias MOutput = OperationOutput<DescribePredictorBacktestExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorBacktestExportJobOutputError>
}

public struct DescribePredictorBacktestExportJobInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
    public let predictorBacktestExportJobArn: String?

    public init (
        predictorBacktestExportJobArn: String? = nil
    )
    {
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
    }
}

struct DescribePredictorBacktestExportJobInputBody: Equatable {
    public let predictorBacktestExportJobArn: String?
}

extension DescribePredictorBacktestExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
    }
}

extension DescribePredictorBacktestExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorBacktestExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorBacktestExportJobOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorBacktestExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePredictorBacktestExportJobOutputResponse(creationTime: \(String(describing: creationTime)), destination: \(String(describing: destination)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), predictorArn: \(String(describing: predictorArn)), predictorBacktestExportJobArn: \(String(describing: predictorBacktestExportJobArn)), predictorBacktestExportJobName: \(String(describing: predictorBacktestExportJobName)), status: \(String(describing: status)))"}
}

extension DescribePredictorBacktestExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePredictorBacktestExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationTime = output.creationTime
            self.destination = output.destination
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.predictorArn = output.predictorArn
            self.predictorBacktestExportJobArn = output.predictorBacktestExportJobArn
            self.predictorBacktestExportJobName = output.predictorBacktestExportJobName
            self.status = output.status
        } else {
            self.creationTime = nil
            self.destination = nil
            self.lastModificationTime = nil
            self.message = nil
            self.predictorArn = nil
            self.predictorBacktestExportJobArn = nil
            self.predictorBacktestExportJobName = nil
            self.status = nil
        }
    }
}

public struct DescribePredictorBacktestExportJobOutputResponse: Equatable {
    /// <p>When the predictor backtest export job was created.</p>
    public let creationTime: Date?
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    public let destination: DataDestination?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///                     failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>Information about any errors that may have occurred during the backtest export.</p>
    public let message: String?
    /// <p>The Amazon Resource Name (ARN) of the predictor.</p>
    public let predictorArn: String?
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
    public let predictorBacktestExportJobArn: String?
    /// <p>The name of the predictor backtest export job.</p>
    public let predictorBacktestExportJobName: String?
    /// <p>The status of the predictor backtest export job. States include: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///                     <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///                     <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        destination: DataDestination? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        predictorArn: String? = nil,
        predictorBacktestExportJobArn: String? = nil,
        predictorBacktestExportJobName: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

struct DescribePredictorBacktestExportJobOutputResponseBody: Equatable {
    public let predictorBacktestExportJobArn: String?
    public let predictorBacktestExportJobName: String?
    public let predictorArn: String?
    public let destination: DataDestination?
    public let message: String?
    public let status: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribePredictorBacktestExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public struct DescribePredictorInputBodyMiddleware: Middleware {
    public let id: String = "DescribePredictorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorOutputError>
}

extension DescribePredictorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePredictorInput(predictorArn: \(String(describing: predictorArn)))"}
}

extension DescribePredictorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct DescribePredictorInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePredictorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorOutputError>
}

public struct DescribePredictorInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePredictorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePredictorInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePredictorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePredictorInput>
    public typealias MOutput = OperationOutput<DescribePredictorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePredictorOutputError>
}

public struct DescribePredictorInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor that you want information about.</p>
    public let predictorArn: String?

    public init (
        predictorArn: String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct DescribePredictorInputBody: Equatable {
    public let predictorArn: String?
}

extension DescribePredictorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension DescribePredictorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePredictorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePredictorOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePredictorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePredictorOutputResponse(algorithmArn: \(String(describing: algorithmArn)), autoMLAlgorithmArns: \(String(describing: autoMLAlgorithmArns)), autoMLOverrideStrategy: \(String(describing: autoMLOverrideStrategy)), creationTime: \(String(describing: creationTime)), datasetImportJobArns: \(String(describing: datasetImportJobArns)), encryptionConfig: \(String(describing: encryptionConfig)), estimatedTimeRemainingInMinutes: \(String(describing: estimatedTimeRemainingInMinutes)), evaluationParameters: \(String(describing: evaluationParameters)), featurizationConfig: \(String(describing: featurizationConfig)), forecastHorizon: \(String(describing: forecastHorizon)), forecastTypes: \(String(describing: forecastTypes)), hPOConfig: \(String(describing: hPOConfig)), inputDataConfig: \(String(describing: inputDataConfig)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), performAutoML: \(String(describing: performAutoML)), performHPO: \(String(describing: performHPO)), predictorArn: \(String(describing: predictorArn)), predictorExecutionDetails: \(String(describing: predictorExecutionDetails)), predictorName: \(String(describing: predictorName)), status: \(String(describing: status)), trainingParameters: \(String(describing: trainingParameters)))"}
}

extension DescribePredictorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePredictorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.algorithmArn = output.algorithmArn
            self.autoMLAlgorithmArns = output.autoMLAlgorithmArns
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.creationTime = output.creationTime
            self.datasetImportJobArns = output.datasetImportJobArns
            self.encryptionConfig = output.encryptionConfig
            self.estimatedTimeRemainingInMinutes = output.estimatedTimeRemainingInMinutes
            self.evaluationParameters = output.evaluationParameters
            self.featurizationConfig = output.featurizationConfig
            self.forecastHorizon = output.forecastHorizon
            self.forecastTypes = output.forecastTypes
            self.hPOConfig = output.hPOConfig
            self.inputDataConfig = output.inputDataConfig
            self.lastModificationTime = output.lastModificationTime
            self.message = output.message
            self.performAutoML = output.performAutoML
            self.performHPO = output.performHPO
            self.predictorArn = output.predictorArn
            self.predictorExecutionDetails = output.predictorExecutionDetails
            self.predictorName = output.predictorName
            self.status = output.status
            self.trainingParameters = output.trainingParameters
        } else {
            self.algorithmArn = nil
            self.autoMLAlgorithmArns = nil
            self.autoMLOverrideStrategy = nil
            self.creationTime = nil
            self.datasetImportJobArns = nil
            self.encryptionConfig = nil
            self.estimatedTimeRemainingInMinutes = nil
            self.evaluationParameters = nil
            self.featurizationConfig = nil
            self.forecastHorizon = nil
            self.forecastTypes = nil
            self.hPOConfig = nil
            self.inputDataConfig = nil
            self.lastModificationTime = nil
            self.message = nil
            self.performAutoML = nil
            self.performHPO = nil
            self.predictorArn = nil
            self.predictorExecutionDetails = nil
            self.predictorName = nil
            self.status = nil
            self.trainingParameters = nil
        }
    }
}

public struct DescribePredictorOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm used for model training.</p>
    public let algorithmArn: String?
    /// <p>When <code>PerformAutoML</code> is specified, the ARN of the chosen algorithm.</p>
    public let autoMLAlgorithmArns: [String]?
    /// <p>The AutoML strategy used to train the predictor. Unless <code>LatencyOptimized</code>
    ///             is specified, the AutoML strategy optimizes predictor accuracy.</p>
    ///         <p>This parameter is only valid for predictors trained using AutoML.</p>
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
    /// <p>When the model training task was created.</p>
    public let creationTime: Date?
    /// <p>An array of the ARNs of the dataset import jobs used to import training data for the
    ///       predictor.</p>
    public let datasetImportJobArns: [String]?
    /// <p>An AWS Key Management Service (KMS) key and the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access
    ///       the key.</p>
    public let encryptionConfig: EncryptionConfig?
    /// <p>The estimated time remaining in minutes for the predictor training job to complete.</p>
    public let estimatedTimeRemainingInMinutes: Int?
    /// <p>Used to override the default evaluation parameters of the specified algorithm. Amazon Forecast
    ///       evaluates a predictor by splitting a dataset into training data and testing data. The
    ///       evaluation parameters define how to perform the split and the number of iterations.</p>
    public let evaluationParameters: EvaluationParameters?
    /// <p>The featurization configuration.</p>
    public let featurizationConfig: FeaturizationConfig?
    /// <p>The number of time-steps of the forecast. The forecast horizon is also called the
    ///       prediction length.</p>
    public let forecastHorizon: Int?
    /// <p>The forecast types used during predictor training. Default value is <code>["0.1","0.5","0.9"]</code>
    ///          </p>
    public let forecastTypes: [String]?
    /// <p>The hyperparameter override values for the algorithm.</p>
    public let hPOConfig: HyperParameterTuningJobConfig?
    /// <p>Describes the dataset group that contains the data to use to train the predictor.</p>
    public let inputDataConfig: InputDataConfig?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>Whether the predictor is set to perform AutoML.</p>
    public let performAutoML: Bool?
    /// <p>Whether the predictor is set to perform hyperparameter optimization (HPO).</p>
    public let performHPO: Bool?
    /// <p>The ARN of the predictor.</p>
    public let predictorArn: String?
    /// <p>Details on the the status and results of the backtests performed to evaluate the accuracy
    ///       of the predictor. You specify the number of backtests to perform when you call the  operation.</p>
    public let predictorExecutionDetails: PredictorExecutionDetails?
    /// <p>The name of the predictor.</p>
    public let predictorName: String?
    /// <p>The status of the predictor. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use
    ///         the predictor to create a forecast.</p>
    ///          </note>
    public let status: String?
    /// <p>The default training parameters or overrides selected during model training. When running
    ///       AutoML or choosing HPO with CNN-QR or DeepAR+, the optimized values for the chosen
    ///       hyperparameters are returned. For more information, see <a>aws-forecast-choosing-recipes</a>.</p>
    public let trainingParameters: [String:String]?

    public init (
        algorithmArn: String? = nil,
        autoMLAlgorithmArns: [String]? = nil,
        autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil,
        creationTime: Date? = nil,
        datasetImportJobArns: [String]? = nil,
        encryptionConfig: EncryptionConfig? = nil,
        estimatedTimeRemainingInMinutes: Int? = nil,
        evaluationParameters: EvaluationParameters? = nil,
        featurizationConfig: FeaturizationConfig? = nil,
        forecastHorizon: Int? = nil,
        forecastTypes: [String]? = nil,
        hPOConfig: HyperParameterTuningJobConfig? = nil,
        inputDataConfig: InputDataConfig? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        performAutoML: Bool? = nil,
        performHPO: Bool? = nil,
        predictorArn: String? = nil,
        predictorExecutionDetails: PredictorExecutionDetails? = nil,
        predictorName: String? = nil,
        status: String? = nil,
        trainingParameters: [String:String]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.autoMLAlgorithmArns = autoMLAlgorithmArns
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.creationTime = creationTime
        self.datasetImportJobArns = datasetImportJobArns
        self.encryptionConfig = encryptionConfig
        self.estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutes
        self.evaluationParameters = evaluationParameters
        self.featurizationConfig = featurizationConfig
        self.forecastHorizon = forecastHorizon
        self.forecastTypes = forecastTypes
        self.hPOConfig = hPOConfig
        self.inputDataConfig = inputDataConfig
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.performAutoML = performAutoML
        self.performHPO = performHPO
        self.predictorArn = predictorArn
        self.predictorExecutionDetails = predictorExecutionDetails
        self.predictorName = predictorName
        self.status = status
        self.trainingParameters = trainingParameters
    }
}

struct DescribePredictorOutputResponseBody: Equatable {
    public let predictorArn: String?
    public let predictorName: String?
    public let algorithmArn: String?
    public let forecastHorizon: Int?
    public let forecastTypes: [String]?
    public let performAutoML: Bool?
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
    public let performHPO: Bool?
    public let trainingParameters: [String:String]?
    public let evaluationParameters: EvaluationParameters?
    public let hPOConfig: HyperParameterTuningJobConfig?
    public let inputDataConfig: InputDataConfig?
    public let featurizationConfig: FeaturizationConfig?
    public let encryptionConfig: EncryptionConfig?
    public let predictorExecutionDetails: PredictorExecutionDetails?
    public let estimatedTimeRemainingInMinutes: Int?
    public let datasetImportJobArns: [String]?
    public let autoMLAlgorithmArns: [String]?
    public let status: String?
    public let message: String?
    public let creationTime: Date?
    public let lastModificationTime: Date?
}

extension DescribePredictorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case algorithmArn = "AlgorithmArn"
        case autoMLAlgorithmArns = "AutoMLAlgorithmArns"
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case creationTime = "CreationTime"
        case datasetImportJobArns = "DatasetImportJobArns"
        case encryptionConfig = "EncryptionConfig"
        case estimatedTimeRemainingInMinutes = "EstimatedTimeRemainingInMinutes"
        case evaluationParameters = "EvaluationParameters"
        case featurizationConfig = "FeaturizationConfig"
        case forecastHorizon = "ForecastHorizon"
        case forecastTypes = "ForecastTypes"
        case hPOConfig = "HPOConfig"
        case inputDataConfig = "InputDataConfig"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case performAutoML = "PerformAutoML"
        case performHPO = "PerformHPO"
        case predictorArn = "PredictorArn"
        case predictorExecutionDetails = "PredictorExecutionDetails"
        case predictorName = "PredictorName"
        case status = "Status"
        case trainingParameters = "TrainingParameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let forecastHorizonDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .forecastHorizon)
        forecastHorizon = forecastHorizonDecoded
        let forecastTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .forecastTypes)
        var forecastTypesDecoded0:[String]? = nil
        if let forecastTypesContainer = forecastTypesContainer {
            forecastTypesDecoded0 = [String]()
            for string0 in forecastTypesContainer {
                if let string0 = string0 {
                    forecastTypesDecoded0?.append(string0)
                }
            }
        }
        forecastTypes = forecastTypesDecoded0
        let performAutoMLDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performAutoML)
        performAutoML = performAutoMLDecoded
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
        let performHPODecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .performHPO)
        performHPO = performHPODecoded
        let trainingParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .trainingParameters)
        var trainingParametersDecoded0: [String:String]? = nil
        if let trainingParametersContainer = trainingParametersContainer {
            trainingParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in trainingParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    trainingParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        trainingParameters = trainingParametersDecoded0
        let evaluationParametersDecoded = try containerValues.decodeIfPresent(EvaluationParameters.self, forKey: .evaluationParameters)
        evaluationParameters = evaluationParametersDecoded
        let hPOConfigDecoded = try containerValues.decodeIfPresent(HyperParameterTuningJobConfig.self, forKey: .hPOConfig)
        hPOConfig = hPOConfigDecoded
        let inputDataConfigDecoded = try containerValues.decodeIfPresent(InputDataConfig.self, forKey: .inputDataConfig)
        inputDataConfig = inputDataConfigDecoded
        let featurizationConfigDecoded = try containerValues.decodeIfPresent(FeaturizationConfig.self, forKey: .featurizationConfig)
        featurizationConfig = featurizationConfigDecoded
        let encryptionConfigDecoded = try containerValues.decodeIfPresent(EncryptionConfig.self, forKey: .encryptionConfig)
        encryptionConfig = encryptionConfigDecoded
        let predictorExecutionDetailsDecoded = try containerValues.decodeIfPresent(PredictorExecutionDetails.self, forKey: .predictorExecutionDetails)
        predictorExecutionDetails = predictorExecutionDetailsDecoded
        let estimatedTimeRemainingInMinutesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .estimatedTimeRemainingInMinutes)
        estimatedTimeRemainingInMinutes = estimatedTimeRemainingInMinutesDecoded
        let datasetImportJobArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .datasetImportJobArns)
        var datasetImportJobArnsDecoded0:[String]? = nil
        if let datasetImportJobArnsContainer = datasetImportJobArnsContainer {
            datasetImportJobArnsDecoded0 = [String]()
            for string0 in datasetImportJobArnsContainer {
                if let string0 = string0 {
                    datasetImportJobArnsDecoded0?.append(string0)
                }
            }
        }
        datasetImportJobArns = datasetImportJobArnsDecoded0
        let autoMLAlgorithmArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoMLAlgorithmArns)
        var autoMLAlgorithmArnsDecoded0:[String]? = nil
        if let autoMLAlgorithmArnsContainer = autoMLAlgorithmArnsContainer {
            autoMLAlgorithmArnsDecoded0 = [String]()
            for string0 in autoMLAlgorithmArnsContainer {
                if let string0 = string0 {
                    autoMLAlgorithmArnsDecoded0?.append(string0)
                }
            }
        }
        autoMLAlgorithmArns = autoMLAlgorithmArnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

public enum Domain {
    case custom
    case ec2Capacity
    case inventoryPlanning
    case metrics
    case retail
    case webTraffic
    case workForce
    case sdkUnknown(String)
}

extension Domain : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Domain] {
        return [
            .custom,
            .ec2Capacity,
            .inventoryPlanning,
            .metrics,
            .retail,
            .webTraffic,
            .workForce,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .ec2Capacity: return "EC2_CAPACITY"
        case .inventoryPlanning: return "INVENTORY_PLANNING"
        case .metrics: return "METRICS"
        case .retail: return "RETAIL"
        case .webTraffic: return "WEB_TRAFFIC"
        case .workForce: return "WORK_FORCE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Domain(rawValue: rawValue) ?? Domain.sdkUnknown(rawValue)
    }
}

extension EncryptionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension EncryptionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionConfig(kMSKeyArn: \(String(describing: kMSKeyArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>An AWS Key Management Service (KMS) key and an AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to
///       access the key. You can specify this optional object in the
///       <a>CreateDataset</a> and <a>CreatePredictor</a> requests.</p>
public struct EncryptionConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the KMS key.</p>
    public let kMSKeyArn: String?
    /// <p>The ARN of the IAM role that Amazon Forecast can assume to access the AWS KMS key.</p>
    ///          <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your
    ///       account, you get an <code>InvalidInputException</code> error.</p>
    public let roleArn: String?

    public init (
        kMSKeyArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.kMSKeyArn = kMSKeyArn
        self.roleArn = roleArn
    }
}

extension ErrorMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case forecastType = "ForecastType"
        case rMSE = "RMSE"
        case wAPE = "WAPE"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forecastType = forecastType {
            try encodeContainer.encode(forecastType, forKey: .forecastType)
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let wAPE = wAPE {
            try encodeContainer.encode(wAPE, forKey: .wAPE)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastType)
        forecastType = forecastTypeDecoded
        let wAPEDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .wAPE)
        wAPE = wAPEDecoded
        let rMSEDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
    }
}

extension ErrorMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorMetric(forecastType: \(String(describing: forecastType)), rMSE: \(String(describing: rMSE)), wAPE: \(String(describing: wAPE)))"}
}

/// <p>
///       Provides detailed error metrics to evaluate the performance of a predictor. This object is
///       part of the <a>Metrics</a> object.
///     </p>
public struct ErrorMetric: Equatable {
    /// <p>
    ///       The Forecast type used to compute WAPE and RMSE.
    ///     </p>
    public let forecastType: String?
    /// <p>
    ///       The root-mean-square error (RMSE).
    ///     </p>
    public let rMSE: Double?
    /// <p>
    ///       The weighted absolute percentage error (WAPE).
    ///     </p>
    public let wAPE: Double?

    public init (
        forecastType: String? = nil,
        rMSE: Double? = nil,
        wAPE: Double? = nil
    )
    {
        self.forecastType = forecastType
        self.rMSE = rMSE
        self.wAPE = wAPE
    }
}

extension EvaluationParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backTestWindowOffset = "BackTestWindowOffset"
        case numberOfBacktestWindows = "NumberOfBacktestWindows"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backTestWindowOffset = backTestWindowOffset {
            try encodeContainer.encode(backTestWindowOffset, forKey: .backTestWindowOffset)
        }
        if let numberOfBacktestWindows = numberOfBacktestWindows {
            try encodeContainer.encode(numberOfBacktestWindows, forKey: .numberOfBacktestWindows)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfBacktestWindowsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfBacktestWindows)
        numberOfBacktestWindows = numberOfBacktestWindowsDecoded
        let backTestWindowOffsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backTestWindowOffset)
        backTestWindowOffset = backTestWindowOffsetDecoded
    }
}

extension EvaluationParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationParameters(backTestWindowOffset: \(String(describing: backTestWindowOffset)), numberOfBacktestWindows: \(String(describing: numberOfBacktestWindows)))"}
}

/// <p>Parameters that define how to split a dataset into training data and testing data, and the
///       number of iterations to perform. These parameters are specified in the predefined algorithms
///       but you can override them in the <a>CreatePredictor</a> request.</p>
public struct EvaluationParameters: Equatable {
    /// <p>The point from the end of the dataset where you want to split the data for model training
    ///       and testing (evaluation). Specify the value as the number of data points. The default is the
    ///       value of the forecast horizon. <code>BackTestWindowOffset</code> can be used to mimic a past
    ///       virtual forecast start date. This value must be greater than or equal to the forecast horizon
    ///       and less than half of the TARGET_TIME_SERIES dataset length.</p>
    ///          <p>
    ///             <code>ForecastHorizon</code> <= <code>BackTestWindowOffset</code> < 1/2 *
    ///       TARGET_TIME_SERIES dataset length</p>
    public let backTestWindowOffset: Int?
    /// <p>The number of times to split the input data. The default is 1. Valid values are 1 through
    ///       5.</p>
    public let numberOfBacktestWindows: Int?

    public init (
        backTestWindowOffset: Int? = nil,
        numberOfBacktestWindows: Int? = nil
    )
    {
        self.backTestWindowOffset = backTestWindowOffset
        self.numberOfBacktestWindows = numberOfBacktestWindows
    }
}

extension EvaluationResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindows0 in testWindows {
                try testWindowsContainer.encode(testwindows0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([WindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[WindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [WindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension EvaluationResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EvaluationResult(algorithmArn: \(String(describing: algorithmArn)), testWindows: \(String(describing: testWindows)))"}
}

/// <p>The results of evaluating an algorithm. Returned as part of the
///       <a>GetAccuracyMetrics</a> response.</p>
public struct EvaluationResult: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the algorithm that was evaluated.</p>
    public let algorithmArn: String?
    /// <p>The array of test windows used for evaluating the algorithm. The
    ///       <code>NumberOfBacktestWindows</code> from the <a>EvaluationParameters</a>
    ///       object determines the number of windows in the array.</p>
    public let testWindows: [WindowSummary]?

    public init (
        algorithmArn: String? = nil,
        testWindows: [WindowSummary]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.testWindows = testWindows
    }
}

public enum EvaluationType {
    case computed
    case summary
    case sdkUnknown(String)
}

extension EvaluationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EvaluationType] {
        return [
            .computed,
            .summary,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .computed: return "COMPUTED"
        case .summary: return "SUMMARY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
    }
}

extension Featurization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case featurizationPipeline = "FeaturizationPipeline"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let featurizationPipeline = featurizationPipeline {
            var featurizationPipelineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizationPipeline)
            for featurizationpipeline0 in featurizationPipeline {
                try featurizationPipelineContainer.encode(featurizationpipeline0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let featurizationPipelineContainer = try containerValues.decodeIfPresent([FeaturizationMethod?].self, forKey: .featurizationPipeline)
        var featurizationPipelineDecoded0:[FeaturizationMethod]? = nil
        if let featurizationPipelineContainer = featurizationPipelineContainer {
            featurizationPipelineDecoded0 = [FeaturizationMethod]()
            for structure0 in featurizationPipelineContainer {
                if let structure0 = structure0 {
                    featurizationPipelineDecoded0?.append(structure0)
                }
            }
        }
        featurizationPipeline = featurizationPipelineDecoded0
    }
}

extension Featurization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Featurization(attributeName: \(String(describing: attributeName)), featurizationPipeline: \(String(describing: featurizationPipeline)))"}
}

/// <p>Provides featurization (transformation) information for a dataset field. This object
///       is part of the <a>FeaturizationConfig</a> object.</p>
///          <p>For example:</p>
///          <p>
///             <code>{</code>
///          </p>
///          <p>
///             <code>"AttributeName": "demand",</code>
///          </p>
///          <p>
///             <code>FeaturizationPipeline [ {</code>
///          </p>
///
///          <p>
///             <code>"FeaturizationMethodName": "filling",</code>
///          </p>
///          <p>
///             <code>"FeaturizationMethodParameters": {"aggregation": "avg", "backfill": "nan"}</code>
///          </p>
///          <p>
///             <code>} ]</code>
///          </p>
///          <p>
///             <code>}</code>
///          </p>
public struct Featurization: Equatable {
    /// <p>The name of the schema attribute that specifies the data field to be featurized. Amazon Forecast supports the target field of
    ///       the <code>TARGET_TIME_SERIES</code> and the <code>RELATED_TIME_SERIES</code> datasets. For example, for the <code>RETAIL</code> domain, the target is
    ///       <code>demand</code>, and for the <code>CUSTOM</code> domain, the target is
    ///       <code>target_value</code>.
    ///       For more information, see <a>howitworks-missing-values</a>.</p>
    public let attributeName: String?
    /// <p>An array of one <code>FeaturizationMethod</code> object that specifies the feature
    ///       transformation method.</p>
    public let featurizationPipeline: [FeaturizationMethod]?

    public init (
        attributeName: String? = nil,
        featurizationPipeline: [FeaturizationMethod]? = nil
    )
    {
        self.attributeName = attributeName
        self.featurizationPipeline = featurizationPipeline
    }
}

extension FeaturizationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featurizations = "Featurizations"
        case forecastDimensions = "ForecastDimensions"
        case forecastFrequency = "ForecastFrequency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizations = featurizations {
            var featurizationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .featurizations)
            for featurizations0 in featurizations {
                try featurizationsContainer.encode(featurizations0)
            }
        }
        if let forecastDimensions = forecastDimensions {
            var forecastDimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .forecastDimensions)
            for forecastdimensions0 in forecastDimensions {
                try forecastDimensionsContainer.encode(forecastdimensions0)
            }
        }
        if let forecastFrequency = forecastFrequency {
            try encodeContainer.encode(forecastFrequency, forKey: .forecastFrequency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastFrequency)
        forecastFrequency = forecastFrequencyDecoded
        let forecastDimensionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .forecastDimensions)
        var forecastDimensionsDecoded0:[String]? = nil
        if let forecastDimensionsContainer = forecastDimensionsContainer {
            forecastDimensionsDecoded0 = [String]()
            for string0 in forecastDimensionsContainer {
                if let string0 = string0 {
                    forecastDimensionsDecoded0?.append(string0)
                }
            }
        }
        forecastDimensions = forecastDimensionsDecoded0
        let featurizationsContainer = try containerValues.decodeIfPresent([Featurization?].self, forKey: .featurizations)
        var featurizationsDecoded0:[Featurization]? = nil
        if let featurizationsContainer = featurizationsContainer {
            featurizationsDecoded0 = [Featurization]()
            for structure0 in featurizationsContainer {
                if let structure0 = structure0 {
                    featurizationsDecoded0?.append(structure0)
                }
            }
        }
        featurizations = featurizationsDecoded0
    }
}

extension FeaturizationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FeaturizationConfig(featurizations: \(String(describing: featurizations)), forecastDimensions: \(String(describing: forecastDimensions)), forecastFrequency: \(String(describing: forecastFrequency)))"}
}

/// <p>In a <a>CreatePredictor</a> operation, the specified algorithm
///       trains a model using the specified dataset group. You can optionally tell the operation
///       to modify data fields prior to training a model. These modifications are referred to as
///       <i>featurization</i>.</p>
///          <p>You define featurization using the <code>FeaturizationConfig</code> object.
///       You specify an array of transformations, one for each field that you want to
///       featurize. You then include the <code>FeaturizationConfig</code> object in your
///       <code>CreatePredictor</code> request. Amazon Forecast applies the featurization to the
///       <code>TARGET_TIME_SERIES</code> and <code>RELATED_TIME_SERIES</code> datasets before model training.</p>
///          <p>You can create multiple featurization configurations. For example, you
///       might call the <code>CreatePredictor</code> operation twice by specifying different
///       featurization configurations.</p>
public struct FeaturizationConfig: Equatable {
    /// <p>An array of featurization (transformation) information for the fields of a dataset.</p>
    public let featurizations: [Featurization]?
    /// <p>An array of dimension (field) names that specify how to group the generated forecast.</p>
    ///          <p>For example, suppose that you are generating a forecast for item sales across all of
    ///       your stores, and your dataset contains a <code>store_id</code> field. If you want the sales
    ///       forecast for each item by store, you would specify <code>store_id</code> as the dimension.</p>
    ///          <p>All forecast dimensions specified in the <code>TARGET_TIME_SERIES</code> dataset don't
    ///       need to be specified in the <code>CreatePredictor</code> request.
    ///       All forecast dimensions specified in the <code>RELATED_TIME_SERIES</code> dataset must
    ///       be specified in the <code>CreatePredictor</code> request.</p>
    public let forecastDimensions: [String]?
    /// <p>The frequency of predictions in a forecast.</p>
    ///          <p>Valid intervals are Y (Year), M (Month), W (Week), D (Day), H (Hour), 30min (30 minutes),
    ///       15min (15 minutes), 10min (10 minutes), 5min (5 minutes), and 1min (1 minute).
    ///       For example, "Y" indicates every year and "5min" indicates every five minutes.</p>
    ///          <p>The frequency must be greater than or equal to the TARGET_TIME_SERIES dataset
    ///       frequency.</p>
    ///          <p>When a RELATED_TIME_SERIES dataset is provided, the frequency must be equal to the
    ///       RELATED_TIME_SERIES dataset frequency.</p>
    public let forecastFrequency: String?

    public init (
        featurizations: [Featurization]? = nil,
        forecastDimensions: [String]? = nil,
        forecastFrequency: String? = nil
    )
    {
        self.featurizations = featurizations
        self.forecastDimensions = forecastDimensions
        self.forecastFrequency = forecastFrequency
    }
}

extension FeaturizationMethod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case featurizationMethodName = "FeaturizationMethodName"
        case featurizationMethodParameters = "FeaturizationMethodParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let featurizationMethodName = featurizationMethodName {
            try encodeContainer.encode(featurizationMethodName.rawValue, forKey: .featurizationMethodName)
        }
        if let featurizationMethodParameters = featurizationMethodParameters {
            var featurizationMethodParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .featurizationMethodParameters)
            for (dictKey0, featurizationmethodparameters0) in featurizationMethodParameters {
                try featurizationMethodParametersContainer.encode(featurizationmethodparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featurizationMethodNameDecoded = try containerValues.decodeIfPresent(FeaturizationMethodName.self, forKey: .featurizationMethodName)
        featurizationMethodName = featurizationMethodNameDecoded
        let featurizationMethodParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .featurizationMethodParameters)
        var featurizationMethodParametersDecoded0: [String:String]? = nil
        if let featurizationMethodParametersContainer = featurizationMethodParametersContainer {
            featurizationMethodParametersDecoded0 = [String:String]()
            for (key0, parametervalue0) in featurizationMethodParametersContainer {
                if let parametervalue0 = parametervalue0 {
                    featurizationMethodParametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        featurizationMethodParameters = featurizationMethodParametersDecoded0
    }
}

extension FeaturizationMethod: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FeaturizationMethod(featurizationMethodName: \(String(describing: featurizationMethodName)), featurizationMethodParameters: \(String(describing: featurizationMethodParameters)))"}
}

/// <p>Provides information about the method that featurizes (transforms) a dataset field.
///       The method is part of the <code>FeaturizationPipeline</code> of the
///       <a>Featurization</a> object. </p>
///          <p>The following is an example of how you specify a <code>FeaturizationMethod</code> object.</p>
///          <p>
///             <code>{</code>
///          </p>
///          <p>
///             <code>"FeaturizationMethodName": "filling",</code>
///          </p>
///          <p>
///             <code>"FeaturizationMethodParameters": {"aggregation": "sum", "middlefill": "zero", "backfill": "zero"}</code>
///          </p>
///          <p>
///             <code>}</code>
///          </p>
public struct FeaturizationMethod: Equatable {
    /// <p>The name of the method. The "filling" method is the only supported method.</p>
    public let featurizationMethodName: FeaturizationMethodName?
    /// <p>The method parameters (key-value pairs), which are a map of override parameters. Specify these parameters to override the default values.
    ///       Related Time Series attributes do not accept aggregation parameters.</p>
    ///          <p>The following list shows the parameters and their valid values for the "filling" featurization method for a <b>Target Time Series</b> dataset. Bold signifies the default
    ///       value.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>aggregation</code>: <b>sum</b>, <code>avg</code>, <code>first</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>frontfill</code>: <b>none</b>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>middlefill</code>: <b>zero</b>, <code>nan</code> (not a number), <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>backfill</code>: <b>zero</b>, <code>nan</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following list shows the parameters and their valid values for a <b>Related Time Series</b> featurization method (there are no defaults):</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>middlefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>backfill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>futurefill</code>: <code>zero</code>, <code>value</code>, <code>median</code>, <code>mean</code>, <code>min</code>, <code>max</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>To set a filling method to a specific value, set the fill parameter to <code>value</code>
    ///       and define the value in a corresponding <code>_value</code> parameter. For example, to set
    ///       backfilling to a value of 2, include the following: <code>"backfill": "value"</code> and
    ///         <code>"backfill_value":"2"</code>. </p>
    public let featurizationMethodParameters: [String:String]?

    public init (
        featurizationMethodName: FeaturizationMethodName? = nil,
        featurizationMethodParameters: [String:String]? = nil
    )
    {
        self.featurizationMethodName = featurizationMethodName
        self.featurizationMethodParameters = featurizationMethodParameters
    }
}

public enum FeaturizationMethodName {
    case filling
    case sdkUnknown(String)
}

extension FeaturizationMethodName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeaturizationMethodName] {
        return [
            .filling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .filling: return "filling"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeaturizationMethodName(rawValue: rawValue) ?? FeaturizationMethodName.sdkUnknown(rawValue)
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(FilterConditionString.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(condition: \(String(describing: condition)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a filter for choosing a subset of objects. Each filter consists of a
///       condition and a match statement. The condition is either <code>IS</code> or
///       <code>IS_NOT</code>, which specifies whether to include or exclude
///       the objects that match the statement, respectively. The match statement consists of a key and a
///       value.</p>
public struct Filter: Equatable {
    /// <p>The condition to apply. To include the objects that match the statement, specify
    ///       <code>IS</code>. To exclude matching objects, specify <code>IS_NOT</code>.</p>
    public let condition: FilterConditionString?
    /// <p>The name of the parameter to filter on.</p>
    public let key: String?
    /// <p>The value to match.</p>
    public let value: String?

    public init (
        condition: FilterConditionString? = nil,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.condition = condition
        self.key = key
        self.value = value
    }
}

public enum FilterConditionString {
    case `is`
    case isNot
    case sdkUnknown(String)
}

extension FilterConditionString : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterConditionString] {
        return [
            .is,
            .isNot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .is: return "IS"
        case .isNot: return "IS_NOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterConditionString(rawValue: rawValue) ?? FilterConditionString.sdkUnknown(rawValue)
    }
}

extension ForecastExportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case forecastExportJobArn = "ForecastExportJobArn"
        case forecastExportJobName = "ForecastExportJobName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let forecastExportJobArn = forecastExportJobArn {
            try encodeContainer.encode(forecastExportJobArn, forKey: .forecastExportJobArn)
        }
        if let forecastExportJobName = forecastExportJobName {
            try encodeContainer.encode(forecastExportJobName, forKey: .forecastExportJobName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobArn)
        forecastExportJobArn = forecastExportJobArnDecoded
        let forecastExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastExportJobName)
        forecastExportJobName = forecastExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastExportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForecastExportJobSummary(creationTime: \(String(describing: creationTime)), destination: \(String(describing: destination)), forecastExportJobArn: \(String(describing: forecastExportJobArn)), forecastExportJobName: \(String(describing: forecastExportJobName)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the forecast export job properties used in the <a>ListForecastExportJobs</a> operation. To get the complete set of properties, call
///       the <a>DescribeForecastExportJob</a> operation, and provide the listed
///         <code>ForecastExportJobArn</code>.</p>
public struct ForecastExportJobSummary: Equatable {
    /// <p>When the forecast export job was created.</p>
    public let creationTime: Date?
    /// <p>The path to the Amazon Simple Storage Service (Amazon S3) bucket where the forecast is exported.</p>
    public let destination: DataDestination?
    /// <p>The Amazon Resource Name (ARN) of the forecast export job.</p>
    public let forecastExportJobArn: String?
    /// <p>The name of the forecast export job.</p>
    public let forecastExportJobName: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The status of the forecast export job. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the forecast export job must be <code>ACTIVE</code> before
    ///         you can access the forecast in your S3 bucket.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        destination: DataDestination? = nil,
        forecastExportJobArn: String? = nil,
        forecastExportJobName: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.forecastExportJobArn = forecastExportJobArn
        self.forecastExportJobName = forecastExportJobName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.status = status
    }
}

extension ForecastSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case forecastArn = "ForecastArn"
        case forecastName = "ForecastName"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let forecastArn = forecastArn {
            try encodeContainer.encode(forecastArn, forKey: .forecastArn)
        }
        if let forecastName = forecastName {
            try encodeContainer.encode(forecastName, forKey: .forecastName)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastArn)
        forecastArn = forecastArnDecoded
        let forecastNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forecastName)
        forecastName = forecastNameDecoded
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension ForecastSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForecastSummary(creationTime: \(String(describing: creationTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), forecastArn: \(String(describing: forecastArn)), forecastName: \(String(describing: forecastName)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), predictorArn: \(String(describing: predictorArn)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the forecast properties used in the <a>ListForecasts</a>
///       operation. To get the complete set of properties, call the <a>DescribeForecast</a>
///       operation, and provide the <code>ForecastArn</code> that is listed in the summary.</p>
public struct ForecastSummary: Equatable {
    /// <p>When the forecast creation task was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group that provided the data used to train
    ///       the predictor.</p>
    public let datasetGroupArn: String?
    /// <p>The ARN of the forecast.</p>
    public let forecastArn: String?
    /// <p>The name of the forecast.</p>
    public let forecastName: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The ARN of the predictor used to generate the forecast.</p>
    public let predictorArn: String?
    /// <p>The status of the forecast. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the forecast must be <code>ACTIVE</code> before you can query
    ///         or export the forecast.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        datasetGroupArn: String? = nil,
        forecastArn: String? = nil,
        forecastName: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        predictorArn: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.forecastArn = forecastArn
        self.forecastName = forecastName
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.status = status
    }
}

public struct GetAccuracyMetricsInputBodyMiddleware: Middleware {
    public let id: String = "GetAccuracyMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccuracyMetricsOutputError>
}

extension GetAccuracyMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccuracyMetricsInput(predictorArn: \(String(describing: predictorArn)))"}
}

extension GetAccuracyMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
    }
}

public struct GetAccuracyMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccuracyMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccuracyMetricsOutputError>
}

public struct GetAccuracyMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccuracyMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccuracyMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccuracyMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccuracyMetricsInput>
    public typealias MOutput = OperationOutput<GetAccuracyMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccuracyMetricsOutputError>
}

public struct GetAccuracyMetricsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the predictor to get metrics for.</p>
    public let predictorArn: String?

    public init (
        predictorArn: String? = nil
    )
    {
        self.predictorArn = predictorArn
    }
}

struct GetAccuracyMetricsInputBody: Equatable {
    public let predictorArn: String?
}

extension GetAccuracyMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case predictorArn = "PredictorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
    }
}

extension GetAccuracyMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccuracyMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccuracyMetricsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccuracyMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccuracyMetricsOutputResponse(autoMLOverrideStrategy: \(String(describing: autoMLOverrideStrategy)), predictorEvaluationResults: \(String(describing: predictorEvaluationResults)))"}
}

extension GetAccuracyMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccuracyMetricsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.autoMLOverrideStrategy = output.autoMLOverrideStrategy
            self.predictorEvaluationResults = output.predictorEvaluationResults
        } else {
            self.autoMLOverrideStrategy = nil
            self.predictorEvaluationResults = nil
        }
    }
}

public struct GetAccuracyMetricsOutputResponse: Equatable {
    /// <p>The AutoML strategy used to train the predictor. Unless <code>LatencyOptimized</code>
    ///             is specified, the AutoML strategy optimizes predictor accuracy.</p>
    ///         <p>This parameter is only valid for predictors trained using AutoML.</p>
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
    /// <p>An array of results from evaluating the predictor.</p>
    public let predictorEvaluationResults: [EvaluationResult]?

    public init (
        autoMLOverrideStrategy: AutoMLOverrideStrategy? = nil,
        predictorEvaluationResults: [EvaluationResult]? = nil
    )
    {
        self.autoMLOverrideStrategy = autoMLOverrideStrategy
        self.predictorEvaluationResults = predictorEvaluationResults
    }
}

struct GetAccuracyMetricsOutputResponseBody: Equatable {
    public let predictorEvaluationResults: [EvaluationResult]?
    public let autoMLOverrideStrategy: AutoMLOverrideStrategy?
}

extension GetAccuracyMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoMLOverrideStrategy = "AutoMLOverrideStrategy"
        case predictorEvaluationResults = "PredictorEvaluationResults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorEvaluationResultsContainer = try containerValues.decodeIfPresent([EvaluationResult?].self, forKey: .predictorEvaluationResults)
        var predictorEvaluationResultsDecoded0:[EvaluationResult]? = nil
        if let predictorEvaluationResultsContainer = predictorEvaluationResultsContainer {
            predictorEvaluationResultsDecoded0 = [EvaluationResult]()
            for structure0 in predictorEvaluationResultsContainer {
                if let structure0 = structure0 {
                    predictorEvaluationResultsDecoded0?.append(structure0)
                }
            }
        }
        predictorEvaluationResults = predictorEvaluationResultsDecoded0
        let autoMLOverrideStrategyDecoded = try containerValues.decodeIfPresent(AutoMLOverrideStrategy.self, forKey: .autoMLOverrideStrategy)
        autoMLOverrideStrategy = autoMLOverrideStrategyDecoded
    }
}

extension HyperParameterTuningJobConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterRanges = "ParameterRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterRanges = parameterRanges {
            try encodeContainer.encode(parameterRanges, forKey: .parameterRanges)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterRangesDecoded = try containerValues.decodeIfPresent(ParameterRanges.self, forKey: .parameterRanges)
        parameterRanges = parameterRangesDecoded
    }
}

extension HyperParameterTuningJobConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HyperParameterTuningJobConfig(parameterRanges: \(String(describing: parameterRanges)))"}
}

/// <p>Configuration information for a hyperparameter tuning job. You specify this object in
///       the <a>CreatePredictor</a> request.</p>
///          <p>A <i>hyperparameter</i> is a parameter that governs the model training process. You set
///       hyperparameters before training starts, unlike model parameters, which are determined during
///       training. The values of the hyperparameters effect which values are chosen for the model parameters.</p>
///          <p>In a <i>hyperparameter tuning job</i>, Amazon Forecast chooses the set of hyperparameter
///       values that optimize a specified metric.  Forecast accomplishes this by running many training jobs
///       over a range of hyperparameter values. The optimum set of values depends on the
///       algorithm, the training data, and the specified metric objective.</p>
public struct HyperParameterTuningJobConfig: Equatable {
    /// <p>Specifies the ranges of valid values for the hyperparameters.</p>
    public let parameterRanges: ParameterRanges?

    public init (
        parameterRanges: ParameterRanges? = nil
    )
    {
        self.parameterRanges = parameterRanges
    }
}

extension InputDataConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetGroupArn = "DatasetGroupArn"
        case supplementaryFeatures = "SupplementaryFeatures"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let supplementaryFeatures = supplementaryFeatures {
            var supplementaryFeaturesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supplementaryFeatures)
            for supplementaryfeatures0 in supplementaryFeatures {
                try supplementaryFeaturesContainer.encode(supplementaryfeatures0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let supplementaryFeaturesContainer = try containerValues.decodeIfPresent([SupplementaryFeature?].self, forKey: .supplementaryFeatures)
        var supplementaryFeaturesDecoded0:[SupplementaryFeature]? = nil
        if let supplementaryFeaturesContainer = supplementaryFeaturesContainer {
            supplementaryFeaturesDecoded0 = [SupplementaryFeature]()
            for structure0 in supplementaryFeaturesContainer {
                if let structure0 = structure0 {
                    supplementaryFeaturesDecoded0?.append(structure0)
                }
            }
        }
        supplementaryFeatures = supplementaryFeaturesDecoded0
    }
}

extension InputDataConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputDataConfig(datasetGroupArn: \(String(describing: datasetGroupArn)), supplementaryFeatures: \(String(describing: supplementaryFeatures)))"}
}

/// <p>The data used to train a predictor. The data includes a dataset group and any
///       supplementary features. You specify this object in the <a>CreatePredictor</a>
///       request.</p>
public struct InputDataConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the dataset group.</p>
    public let datasetGroupArn: String?
    /// <p>An array of supplementary features. The only supported feature is a holiday
    ///       calendar.</p>
    public let supplementaryFeatures: [SupplementaryFeature]?

    public init (
        datasetGroupArn: String? = nil,
        supplementaryFeatures: [SupplementaryFeature]? = nil
    )
    {
        self.datasetGroupArn = datasetGroupArn
        self.supplementaryFeatures = supplementaryFeatures
    }
}

extension IntegerParameterRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxValue = "MaxValue"
        case minValue = "MinValue"
        case name = "Name"
        case scalingType = "ScalingType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let scalingType = scalingType {
            try encodeContainer.encode(scalingType.rawValue, forKey: .scalingType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minValue)
        minValue = minValueDecoded
        let scalingTypeDecoded = try containerValues.decodeIfPresent(ScalingType.self, forKey: .scalingType)
        scalingType = scalingTypeDecoded
    }
}

extension IntegerParameterRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IntegerParameterRange(maxValue: \(String(describing: maxValue)), minValue: \(String(describing: minValue)), name: \(String(describing: name)), scalingType: \(String(describing: scalingType)))"}
}

/// <p>Specifies an integer hyperparameter and it's range of tunable values.
///       This object is part of the <a>ParameterRanges</a> object.</p>
public struct IntegerParameterRange: Equatable {
    /// <p>The maximum tunable value of the hyperparameter.</p>
    public let maxValue: Int?
    /// <p>The minimum tunable value of the hyperparameter.</p>
    public let minValue: Int?
    /// <p>The name of the hyperparameter to tune.</p>
    public let name: String?
    /// <p>The scale that hyperparameter tuning uses to search the hyperparameter range.
    ///       Valid values:</p>
    ///          <dl>
    ///             <dt>Auto</dt>
    ///             <dd>
    ///                <p>Amazon Forecast hyperparameter tuning chooses the best scale for the hyperparameter.</p>
    ///             </dd>
    ///             <dt>Linear</dt>
    ///             <dd>
    ///                <p>Hyperparameter tuning searches the values in the hyperparameter range by using a
    ///             linear scale.</p>
    ///             </dd>
    ///             <dt>Logarithmic</dt>
    ///             <dd>
    ///                <p>Hyperparameter tuning searches the values in the hyperparameter range by using a
    ///             logarithmic scale.</p>
    ///                <p>Logarithmic scaling works only for ranges that have values greater than 0.</p>
    ///             </dd>
    ///             <dt>ReverseLogarithmic</dt>
    ///             <dd>
    ///                <p>Not supported for <code>IntegerParameterRange</code>.</p>
    ///                <p>Reverse logarithmic scaling works only for ranges that are entirely within the
    ///             range 0 <= x < 1.0.</p>
    ///             </dd>
    ///          </dl>
    ///          <p>For information about choosing a hyperparameter scale, see
    ///       <a href="http://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-ranges.html#scaling-type">Hyperparameter Scaling</a>.
    ///       One of the following values:</p>
    public let scalingType: ScalingType?

    public init (
        maxValue: Int? = nil,
        minValue: Int? = nil,
        name: String? = nil,
        scalingType: ScalingType? = nil
    )
    {
        self.maxValue = maxValue
        self.minValue = minValue
        self.name = name
        self.scalingType = scalingType
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can't process the request because it includes an invalid value or a value that exceeds
///       the valid range.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token is not valid. Tokens expire after 24 hours.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit on the number of resources per account has been exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDatasetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

extension ListDatasetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetGroupsInput>
    public typealias MOutput = OperationOutput<ListDatasetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetGroupsOutputError>
}

public struct ListDatasetGroupsInput: Equatable {
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetGroupsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetGroupsOutputResponse(datasetGroups: \(String(describing: datasetGroups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetGroups = output.datasetGroups
            self.nextToken = output.nextToken
        } else {
            self.datasetGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetGroupsOutputResponse: Equatable {
    /// <p>An array of objects that summarize each dataset group's properties.</p>
    public let datasetGroups: [DatasetGroupSummary]?
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.</p>
    public let nextToken: String?

    public init (
        datasetGroups: [DatasetGroupSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetGroups = datasetGroups
        self.nextToken = nextToken
    }
}

struct ListDatasetGroupsOutputResponseBody: Equatable {
    public let datasetGroups: [DatasetGroupSummary]?
    public let nextToken: String?
}

extension ListDatasetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetGroups = "DatasetGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupsContainer = try containerValues.decodeIfPresent([DatasetGroupSummary?].self, forKey: .datasetGroups)
        var datasetGroupsDecoded0:[DatasetGroupSummary]? = nil
        if let datasetGroupsContainer = datasetGroupsContainer {
            datasetGroupsDecoded0 = [DatasetGroupSummary]()
            for structure0 in datasetGroupsContainer {
                if let structure0 = structure0 {
                    datasetGroupsDecoded0?.append(structure0)
                }
            }
        }
        datasetGroups = datasetGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetImportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

extension ListDatasetImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetImportJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetImportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetImportJobsInput>
    public typealias MOutput = OperationOutput<ListDatasetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetImportJobsOutputError>
}

public struct ListDatasetImportJobsInput: Equatable {
    /// <p>An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include
    ///       or exclude the datasets that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.</p>
    ///          <p>
    ///             <b>Filter properties</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are <code>IS</code> and
    ///             <code>IS_NOT</code>. To include the datasets that match the statement, specify
    ///             <code>IS</code>. To exclude matching datasets, specify <code>IS_NOT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///             <code>DatasetArn</code> and <code>Status</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to list all dataset import jobs whose status is ACTIVE, you specify the
    ///       following filter:</p>
    ///          <p>
    ///             <code>"Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" }
    ///       ]</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListDatasetImportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListDatasetImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetImportJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetImportJobsOutputResponse(datasetImportJobs: \(String(describing: datasetImportJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetImportJobs = output.datasetImportJobs
            self.nextToken = output.nextToken
        } else {
            self.datasetImportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetImportJobsOutputResponse: Equatable {
    /// <p>An array of objects that summarize each dataset import job's properties.</p>
    public let datasetImportJobs: [DatasetImportJobSummary]?
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.</p>
    public let nextToken: String?

    public init (
        datasetImportJobs: [DatasetImportJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetImportJobs = datasetImportJobs
        self.nextToken = nextToken
    }
}

struct ListDatasetImportJobsOutputResponseBody: Equatable {
    public let datasetImportJobs: [DatasetImportJobSummary]?
    public let nextToken: String?
}

extension ListDatasetImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetImportJobs = "DatasetImportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetImportJobsContainer = try containerValues.decodeIfPresent([DatasetImportJobSummary?].self, forKey: .datasetImportJobs)
        var datasetImportJobsDecoded0:[DatasetImportJobSummary]? = nil
        if let datasetImportJobsContainer = datasetImportJobsContainer {
            datasetImportJobsDecoded0 = [DatasetImportJobSummary]()
            for structure0 in datasetImportJobsContainer {
                if let structure0 = structure0 {
                    datasetImportJobsDecoded0?.append(structure0)
                }
            }
        }
        datasetImportJobs = datasetImportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDatasetsInputBodyMiddleware: Middleware {
    public let id: String = "ListDatasetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

extension ListDatasetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatasetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetsInput>
    public typealias MOutput = OperationOutput<ListDatasetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetsOutputError>
}

public struct ListDatasetsInput: Equatable {
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatasetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatasetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetsOutputResponse(datasets: \(String(describing: datasets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetsOutputResponse: Equatable {
    /// <p>An array of objects that summarize each dataset's properties.</p>
    public let datasets: [DatasetSummary]?
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.</p>
    public let nextToken: String?

    public init (
        datasets: [DatasetSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Equatable {
    public let datasets: [DatasetSummary]?
    public let nextToken: String?
}

extension ListDatasetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasets = "Datasets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([DatasetSummary?].self, forKey: .datasets)
        var datasetsDecoded0:[DatasetSummary]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [DatasetSummary]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListForecastExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListForecastExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastExportJobsOutputError>
}

extension ListForecastExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListForecastExportJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListForecastExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListForecastExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListForecastExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastExportJobsOutputError>
}

public struct ListForecastExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListForecastExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastExportJobsInput>
    public typealias MOutput = OperationOutput<ListForecastExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastExportJobsOutputError>
}

public struct ListForecastExportJobsInput: Equatable {
    /// <p>An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include
    ///       or exclude the forecast export jobs that match the statement from the list, respectively. The
    ///       match statement consists of a key and a value.</p>
    ///          <p>
    ///             <b>Filter properties</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are <code>IS</code> and
    ///             <code>IS_NOT</code>. To include the forecast export jobs that match the statement,
    ///           specify <code>IS</code>. To exclude matching forecast export jobs, specify
    ///             <code>IS_NOT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///             <code>ForecastArn</code> and <code>Status</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to list all jobs that export a forecast named
    ///         <i>electricityforecast</i>, specify the following filter:</p>
    ///          <p>
    ///             <code>"Filters": [ { "Condition": "IS", "Key": "ForecastArn", "Value":
    ///         "arn:aws:forecast:us-west-2:<acct-id>:forecast/electricityforecast" } ]</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListForecastExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastExportJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListForecastExportJobsOutputResponse(forecastExportJobs: \(String(describing: forecastExportJobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListForecastExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListForecastExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecastExportJobs = output.forecastExportJobs
            self.nextToken = output.nextToken
        } else {
            self.forecastExportJobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastExportJobsOutputResponse: Equatable {
    /// <p>An array of objects that summarize each export job's properties.</p>
    public let forecastExportJobs: [ForecastExportJobSummary]?
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.</p>
    public let nextToken: String?

    public init (
        forecastExportJobs: [ForecastExportJobSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.forecastExportJobs = forecastExportJobs
        self.nextToken = nextToken
    }
}

struct ListForecastExportJobsOutputResponseBody: Equatable {
    public let forecastExportJobs: [ForecastExportJobSummary]?
    public let nextToken: String?
}

extension ListForecastExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastExportJobs = "ForecastExportJobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastExportJobsContainer = try containerValues.decodeIfPresent([ForecastExportJobSummary?].self, forKey: .forecastExportJobs)
        var forecastExportJobsDecoded0:[ForecastExportJobSummary]? = nil
        if let forecastExportJobsContainer = forecastExportJobsContainer {
            forecastExportJobsDecoded0 = [ForecastExportJobSummary]()
            for structure0 in forecastExportJobsContainer {
                if let structure0 = structure0 {
                    forecastExportJobsDecoded0?.append(structure0)
                }
            }
        }
        forecastExportJobs = forecastExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListForecastsInputBodyMiddleware: Middleware {
    public let id: String = "ListForecastsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastsInput>
    public typealias MOutput = OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastsOutputError>
}

extension ListForecastsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListForecastsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListForecastsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListForecastsInputHeadersMiddleware: Middleware {
    public let id: String = "ListForecastsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastsInput>
    public typealias MOutput = OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastsOutputError>
}

public struct ListForecastsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListForecastsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListForecastsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListForecastsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListForecastsInput>
    public typealias MOutput = OperationOutput<ListForecastsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListForecastsOutputError>
}

public struct ListForecastsInput: Equatable {
    /// <p>An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include
    ///       or exclude the forecasts that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.</p>
    ///          <p>
    ///             <b>Filter properties</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are <code>IS</code> and
    ///             <code>IS_NOT</code>. To include the forecasts that match the statement, specify
    ///             <code>IS</code>. To exclude matching forecasts, specify <code>IS_NOT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///             <code>DatasetGroupArn</code>, <code>PredictorArn</code>, and <code>Status</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to list all forecasts whose status is not ACTIVE, you would specify:</p>
    ///          <p>
    ///             <code>"Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" }
    ///       ]</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListForecastsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListForecastsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListForecastsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListForecastsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListForecastsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListForecastsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListForecastsOutputResponse(forecasts: \(String(describing: forecasts)), nextToken: \(String(describing: nextToken)))"}
}

extension ListForecastsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListForecastsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecasts = output.forecasts
            self.nextToken = output.nextToken
        } else {
            self.forecasts = nil
            self.nextToken = nil
        }
    }
}

public struct ListForecastsOutputResponse: Equatable {
    /// <p>An array of objects that summarize each forecast's properties.</p>
    public let forecasts: [ForecastSummary]?
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set
    ///       of results, use the token in the next request.</p>
    public let nextToken: String?

    public init (
        forecasts: [ForecastSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.forecasts = forecasts
        self.nextToken = nextToken
    }
}

struct ListForecastsOutputResponseBody: Equatable {
    public let forecasts: [ForecastSummary]?
    public let nextToken: String?
}

extension ListForecastsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecasts = "Forecasts"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forecastsContainer = try containerValues.decodeIfPresent([ForecastSummary?].self, forKey: .forecasts)
        var forecastsDecoded0:[ForecastSummary]? = nil
        if let forecastsContainer = forecastsContainer {
            forecastsDecoded0 = [ForecastSummary]()
            for structure0 in forecastsContainer {
                if let structure0 = structure0 {
                    forecastsDecoded0?.append(structure0)
                }
            }
        }
        forecasts = forecastsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPredictorBacktestExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListPredictorBacktestExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorBacktestExportJobsOutputError>
}

extension ListPredictorBacktestExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPredictorBacktestExportJobsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPredictorBacktestExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPredictorBacktestExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPredictorBacktestExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorBacktestExportJobsOutputError>
}

public struct ListPredictorBacktestExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPredictorBacktestExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorBacktestExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorBacktestExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorBacktestExportJobsInput>
    public typealias MOutput = OperationOutput<ListPredictorBacktestExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorBacktestExportJobsOutputError>
}

public struct ListPredictorBacktestExportJobsInput: Equatable {
    /// <p>An array of filters. For each filter, provide a condition and a match statement. The
    ///                 condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to
    ///                 include or exclude the predictor backtest export jobs that match the statement from the
    ///                 list. The match statement consists of a key and a value.</p>
    ///             <p>
    ///                 <b>Filter properties</b>
    ///             </p>
    ///             <ul>
    ///             <li>
    ///                     <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are
    ///                         <code>IS</code> and <code>IS_NOT</code>. To include the predictor backtest
    ///                         export jobs that match the statement, specify <code>IS</code>. To exclude matching
    ///                         predictor backtest export jobs, specify <code>IS_NOT</code>.</p>
    ///                 </li>
    ///             <li>
    ///                     <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///                         <code>PredictorArn</code> and <code>Status</code>.</p>
    ///                 </li>
    ///             <li>
    ///                     <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///                 </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a NextToken.
    ///             To retrieve the next set of results, use the token in the next request. Tokens expire after
    ///             24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorBacktestExportJobsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListPredictorBacktestExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorBacktestExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorBacktestExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorBacktestExportJobsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorBacktestExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPredictorBacktestExportJobsOutputResponse(nextToken: \(String(describing: nextToken)), predictorBacktestExportJobs: \(String(describing: predictorBacktestExportJobs)))"}
}

extension ListPredictorBacktestExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPredictorBacktestExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.predictorBacktestExportJobs = output.predictorBacktestExportJobs
        } else {
            self.nextToken = nil
            self.predictorBacktestExportJobs = nil
        }
    }
}

public struct ListPredictorBacktestExportJobsOutputResponse: Equatable {
    /// <p>Returns this token if the response is truncated. To retrieve the next
    ///             set of results, use the token in the next request.</p>
    public let nextToken: String?
    /// <p>An array of objects that summarize the properties of each predictor backtest export
    ///             job.</p>
    public let predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]?

    public init (
        nextToken: String? = nil,
        predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictorBacktestExportJobs = predictorBacktestExportJobs
    }
}

struct ListPredictorBacktestExportJobsOutputResponseBody: Equatable {
    public let predictorBacktestExportJobs: [PredictorBacktestExportJobSummary]?
    public let nextToken: String?
}

extension ListPredictorBacktestExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case predictorBacktestExportJobs = "PredictorBacktestExportJobs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobsContainer = try containerValues.decodeIfPresent([PredictorBacktestExportJobSummary?].self, forKey: .predictorBacktestExportJobs)
        var predictorBacktestExportJobsDecoded0:[PredictorBacktestExportJobSummary]? = nil
        if let predictorBacktestExportJobsContainer = predictorBacktestExportJobsContainer {
            predictorBacktestExportJobsDecoded0 = [PredictorBacktestExportJobSummary]()
            for structure0 in predictorBacktestExportJobsContainer {
                if let structure0 = structure0 {
                    predictorBacktestExportJobsDecoded0?.append(structure0)
                }
            }
        }
        predictorBacktestExportJobs = predictorBacktestExportJobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPredictorsInputBodyMiddleware: Middleware {
    public let id: String = "ListPredictorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorsOutputError>
}

extension ListPredictorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPredictorsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPredictorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filters0 in filters {
                try filtersContainer.encode(filters0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPredictorsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPredictorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorsOutputError>
}

public struct ListPredictorsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPredictorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPredictorsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPredictorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPredictorsInput>
    public typealias MOutput = OperationOutput<ListPredictorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPredictorsOutputError>
}

public struct ListPredictorsInput: Equatable {
    /// <p>An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include
    ///       or exclude the predictors that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.</p>
    ///          <p>
    ///             <b>Filter properties</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are <code>IS</code> and
    ///             <code>IS_NOT</code>. To include the predictors that match the statement, specify
    ///             <code>IS</code>. To exclude matching predictors, specify <code>IS_NOT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///             <code>DatasetGroupArn</code> and <code>Status</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to list all predictors whose status is ACTIVE, you would specify:</p>
    ///          <p>
    ///             <code>"Filters": [ { "Condition": "IS", "Key": "Status", "Value": "ACTIVE" }
    ///       ]</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPredictorsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let filters: [Filter]?
}

extension ListPredictorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension ListPredictorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPredictorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPredictorsOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPredictorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPredictorsOutputResponse(nextToken: \(String(describing: nextToken)), predictors: \(String(describing: predictors)))"}
}

extension ListPredictorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPredictorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.predictors = output.predictors
        } else {
            self.nextToken = nil
            self.predictors = nil
        }
    }
}

public struct ListPredictorsOutputResponse: Equatable {
    /// <p>If the response is truncated, Amazon Forecast returns this token. To retrieve the next set of
    ///       results, use the token in the next request.</p>
    public let nextToken: String?
    /// <p>An array of objects that summarize each predictor's properties.</p>
    public let predictors: [PredictorSummary]?

    public init (
        nextToken: String? = nil,
        predictors: [PredictorSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.predictors = predictors
    }
}

struct ListPredictorsOutputResponseBody: Equatable {
    public let predictors: [PredictorSummary]?
    public let nextToken: String?
}

extension ListPredictorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case predictors = "Predictors"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorsContainer = try containerValues.decodeIfPresent([PredictorSummary?].self, forKey: .predictors)
        var predictorsDecoded0:[PredictorSummary]? = nil
        if let predictorsContainer = predictorsContainer {
            predictorsDecoded0 = [PredictorSummary]()
            for structure0 in predictorsContainer {
                if let structure0 = structure0 {
                    predictorsDecoded0?.append(structure0)
                }
            }
        }
        predictors = predictorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Metrics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMetrics = "ErrorMetrics"
        case rMSE = "RMSE"
        case weightedQuantileLosses = "WeightedQuantileLosses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMetrics = errorMetrics {
            var errorMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorMetrics)
            for errormetrics0 in errorMetrics {
                try errorMetricsContainer.encode(errormetrics0)
            }
        }
        if let rMSE = rMSE {
            try encodeContainer.encode(rMSE, forKey: .rMSE)
        }
        if let weightedQuantileLosses = weightedQuantileLosses {
            var weightedQuantileLossesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedQuantileLosses)
            for weightedquantilelosses0 in weightedQuantileLosses {
                try weightedQuantileLossesContainer.encode(weightedquantilelosses0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rMSEDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .rMSE)
        rMSE = rMSEDecoded
        let weightedQuantileLossesContainer = try containerValues.decodeIfPresent([WeightedQuantileLoss?].self, forKey: .weightedQuantileLosses)
        var weightedQuantileLossesDecoded0:[WeightedQuantileLoss]? = nil
        if let weightedQuantileLossesContainer = weightedQuantileLossesContainer {
            weightedQuantileLossesDecoded0 = [WeightedQuantileLoss]()
            for structure0 in weightedQuantileLossesContainer {
                if let structure0 = structure0 {
                    weightedQuantileLossesDecoded0?.append(structure0)
                }
            }
        }
        weightedQuantileLosses = weightedQuantileLossesDecoded0
        let errorMetricsContainer = try containerValues.decodeIfPresent([ErrorMetric?].self, forKey: .errorMetrics)
        var errorMetricsDecoded0:[ErrorMetric]? = nil
        if let errorMetricsContainer = errorMetricsContainer {
            errorMetricsDecoded0 = [ErrorMetric]()
            for structure0 in errorMetricsContainer {
                if let structure0 = structure0 {
                    errorMetricsDecoded0?.append(structure0)
                }
            }
        }
        errorMetrics = errorMetricsDecoded0
    }
}

extension Metrics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metrics(errorMetrics: \(String(describing: errorMetrics)), rMSE: \(String(describing: rMSE)), weightedQuantileLosses: \(String(describing: weightedQuantileLosses)))"}
}

/// <p>Provides metrics that are used to evaluate the performance of a predictor. This object
///       is part of the <a>WindowSummary</a> object.</p>
public struct Metrics: Equatable {
    /// <p>
    ///       Provides detailed error metrics on forecast type, root-mean square-error (RMSE), and weighted
    ///       average percentage error (WAPE).
    ///     </p>
    public let errorMetrics: [ErrorMetric]?
    /// <p>The root-mean-square error (RMSE).</p>
    @available(*, deprecated, message: "This property is deprecated, please refer to ErrorMetrics for both RMSE and WAPE")
    public let rMSE: Double?
    /// <p>An array of weighted quantile losses. Quantiles divide a probability distribution into
    ///       regions of equal probability. The distribution in this case is the loss function.</p>
    public let weightedQuantileLosses: [WeightedQuantileLoss]?

    public init (
        errorMetrics: [ErrorMetric]? = nil,
        rMSE: Double? = nil,
        weightedQuantileLosses: [WeightedQuantileLoss]? = nil
    )
    {
        self.errorMetrics = errorMetrics
        self.rMSE = rMSE
        self.weightedQuantileLosses = weightedQuantileLosses
    }
}

extension ParameterRanges: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case categoricalParameterRanges = "CategoricalParameterRanges"
        case continuousParameterRanges = "ContinuousParameterRanges"
        case integerParameterRanges = "IntegerParameterRanges"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoricalParameterRanges = categoricalParameterRanges {
            var categoricalParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .categoricalParameterRanges)
            for categoricalparameterranges0 in categoricalParameterRanges {
                try categoricalParameterRangesContainer.encode(categoricalparameterranges0)
            }
        }
        if let continuousParameterRanges = continuousParameterRanges {
            var continuousParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .continuousParameterRanges)
            for continuousparameterranges0 in continuousParameterRanges {
                try continuousParameterRangesContainer.encode(continuousparameterranges0)
            }
        }
        if let integerParameterRanges = integerParameterRanges {
            var integerParameterRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .integerParameterRanges)
            for integerparameterranges0 in integerParameterRanges {
                try integerParameterRangesContainer.encode(integerparameterranges0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoricalParameterRangesContainer = try containerValues.decodeIfPresent([CategoricalParameterRange?].self, forKey: .categoricalParameterRanges)
        var categoricalParameterRangesDecoded0:[CategoricalParameterRange]? = nil
        if let categoricalParameterRangesContainer = categoricalParameterRangesContainer {
            categoricalParameterRangesDecoded0 = [CategoricalParameterRange]()
            for structure0 in categoricalParameterRangesContainer {
                if let structure0 = structure0 {
                    categoricalParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        categoricalParameterRanges = categoricalParameterRangesDecoded0
        let continuousParameterRangesContainer = try containerValues.decodeIfPresent([ContinuousParameterRange?].self, forKey: .continuousParameterRanges)
        var continuousParameterRangesDecoded0:[ContinuousParameterRange]? = nil
        if let continuousParameterRangesContainer = continuousParameterRangesContainer {
            continuousParameterRangesDecoded0 = [ContinuousParameterRange]()
            for structure0 in continuousParameterRangesContainer {
                if let structure0 = structure0 {
                    continuousParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        continuousParameterRanges = continuousParameterRangesDecoded0
        let integerParameterRangesContainer = try containerValues.decodeIfPresent([IntegerParameterRange?].self, forKey: .integerParameterRanges)
        var integerParameterRangesDecoded0:[IntegerParameterRange]? = nil
        if let integerParameterRangesContainer = integerParameterRangesContainer {
            integerParameterRangesDecoded0 = [IntegerParameterRange]()
            for structure0 in integerParameterRangesContainer {
                if let structure0 = structure0 {
                    integerParameterRangesDecoded0?.append(structure0)
                }
            }
        }
        integerParameterRanges = integerParameterRangesDecoded0
    }
}

extension ParameterRanges: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterRanges(categoricalParameterRanges: \(String(describing: categoricalParameterRanges)), continuousParameterRanges: \(String(describing: continuousParameterRanges)), integerParameterRanges: \(String(describing: integerParameterRanges)))"}
}

/// <p>Specifies the categorical, continuous, and integer hyperparameters, and their ranges of
///       tunable values. The range of tunable values determines which values that a hyperparameter
///       tuning job can choose for the specified hyperparameter. This object is part of the
///       <a>HyperParameterTuningJobConfig</a> object.</p>
public struct ParameterRanges: Equatable {
    /// <p>Specifies the tunable range for each categorical hyperparameter.</p>
    public let categoricalParameterRanges: [CategoricalParameterRange]?
    /// <p>Specifies the tunable range for each continuous hyperparameter.</p>
    public let continuousParameterRanges: [ContinuousParameterRange]?
    /// <p>Specifies the tunable range for each integer hyperparameter.</p>
    public let integerParameterRanges: [IntegerParameterRange]?

    public init (
        categoricalParameterRanges: [CategoricalParameterRange]? = nil,
        continuousParameterRanges: [ContinuousParameterRange]? = nil,
        integerParameterRanges: [IntegerParameterRange]? = nil
    )
    {
        self.categoricalParameterRanges = categoricalParameterRanges
        self.continuousParameterRanges = continuousParameterRanges
        self.integerParameterRanges = integerParameterRanges
    }
}

extension PredictorBacktestExportJobSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case destination = "Destination"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorBacktestExportJobArn = "PredictorBacktestExportJobArn"
        case predictorBacktestExportJobName = "PredictorBacktestExportJobName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorBacktestExportJobArn = predictorBacktestExportJobArn {
            try encodeContainer.encode(predictorBacktestExportJobArn, forKey: .predictorBacktestExportJobArn)
        }
        if let predictorBacktestExportJobName = predictorBacktestExportJobName {
            try encodeContainer.encode(predictorBacktestExportJobName, forKey: .predictorBacktestExportJobName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorBacktestExportJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobArn)
        predictorBacktestExportJobArn = predictorBacktestExportJobArnDecoded
        let predictorBacktestExportJobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorBacktestExportJobName)
        predictorBacktestExportJobName = predictorBacktestExportJobNameDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(DataDestination.self, forKey: .destination)
        destination = destinationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension PredictorBacktestExportJobSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictorBacktestExportJobSummary(creationTime: \(String(describing: creationTime)), destination: \(String(describing: destination)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), predictorBacktestExportJobArn: \(String(describing: predictorBacktestExportJobArn)), predictorBacktestExportJobName: \(String(describing: predictorBacktestExportJobName)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the predictor backtest export job properties used in the <a>ListPredictorBacktestExportJobs</a> operation. To get a complete set of properties, call
///             the <a>DescribePredictorBacktestExportJob</a> operation, and provide the listed
///             <code>PredictorBacktestExportJobArn</code>.</p>
public struct PredictorBacktestExportJobSummary: Equatable {
    /// <p>When the predictor backtest export job was created.</p>
    public let creationTime: Date?
    /// <p>The destination for an export job. Provide an S3 path, an AWS Identity and Access Management (IAM) role that allows Amazon Forecast
    ///       to access the location, and an AWS Key Management Service (KMS) key (optional). </p>
    public let destination: DataDestination?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///                     failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>Information about any errors that may have occurred during the backtest export.</p>
    public let message: String?
    /// <p>The Amazon Resource Name (ARN) of the predictor backtest export job.</p>
    public let predictorBacktestExportJobArn: String?
    /// <p>The name of the predictor backtest export job.</p>
    public let predictorBacktestExportJobName: String?
    /// <p>The status of the predictor backtest export job. States include: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///                     <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///                     <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        destination: DataDestination? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        predictorBacktestExportJobArn: String? = nil,
        predictorBacktestExportJobName: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.destination = destination
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorBacktestExportJobArn = predictorBacktestExportJobArn
        self.predictorBacktestExportJobName = predictorBacktestExportJobName
        self.status = status
    }
}

extension PredictorExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case algorithmArn = "AlgorithmArn"
        case testWindows = "TestWindows"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithmArn = algorithmArn {
            try encodeContainer.encode(algorithmArn, forKey: .algorithmArn)
        }
        if let testWindows = testWindows {
            var testWindowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testWindows)
            for testwindowdetails0 in testWindows {
                try testWindowsContainer.encode(testwindowdetails0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .algorithmArn)
        algorithmArn = algorithmArnDecoded
        let testWindowsContainer = try containerValues.decodeIfPresent([TestWindowSummary?].self, forKey: .testWindows)
        var testWindowsDecoded0:[TestWindowSummary]? = nil
        if let testWindowsContainer = testWindowsContainer {
            testWindowsDecoded0 = [TestWindowSummary]()
            for structure0 in testWindowsContainer {
                if let structure0 = structure0 {
                    testWindowsDecoded0?.append(structure0)
                }
            }
        }
        testWindows = testWindowsDecoded0
    }
}

extension PredictorExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictorExecution(algorithmArn: \(String(describing: algorithmArn)), testWindows: \(String(describing: testWindows)))"}
}

/// <p>The algorithm used to perform a backtest and the status of those tests.</p>
public struct PredictorExecution: Equatable {
    /// <p>The ARN of the algorithm used to test the predictor.</p>
    public let algorithmArn: String?
    /// <p>An array of test windows used to evaluate the algorithm. The
    ///         <code>NumberOfBacktestWindows</code> from the
    ///       object determines the number of windows in the array.</p>
    public let testWindows: [TestWindowSummary]?

    public init (
        algorithmArn: String? = nil,
        testWindows: [TestWindowSummary]? = nil
    )
    {
        self.algorithmArn = algorithmArn
        self.testWindows = testWindows
    }
}

extension PredictorExecutionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case predictorExecutions = "PredictorExecutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let predictorExecutions = predictorExecutions {
            var predictorExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predictorExecutions)
            for predictorexecutions0 in predictorExecutions {
                try predictorExecutionsContainer.encode(predictorexecutions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorExecutionsContainer = try containerValues.decodeIfPresent([PredictorExecution?].self, forKey: .predictorExecutions)
        var predictorExecutionsDecoded0:[PredictorExecution]? = nil
        if let predictorExecutionsContainer = predictorExecutionsContainer {
            predictorExecutionsDecoded0 = [PredictorExecution]()
            for structure0 in predictorExecutionsContainer {
                if let structure0 = structure0 {
                    predictorExecutionsDecoded0?.append(structure0)
                }
            }
        }
        predictorExecutions = predictorExecutionsDecoded0
    }
}

extension PredictorExecutionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictorExecutionDetails(predictorExecutions: \(String(describing: predictorExecutions)))"}
}

/// <p>Contains details on the backtests performed to evaluate the accuracy of the predictor. The
///       tests are returned in descending order of accuracy, with the most accurate backtest appearing
///       first. You specify the number of backtests to perform when you call the  operation.</p>
public struct PredictorExecutionDetails: Equatable {
    /// <p>An array of the backtests performed to evaluate the accuracy of the predictor against a
    ///       particular algorithm. The <code>NumberOfBacktestWindows</code> from the  object determines the number of windows in the
    ///       array.</p>
    public let predictorExecutions: [PredictorExecution]?

    public init (
        predictorExecutions: [PredictorExecution]? = nil
    )
    {
        self.predictorExecutions = predictorExecutions
    }
}

extension PredictorSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTime = "CreationTime"
        case datasetGroupArn = "DatasetGroupArn"
        case lastModificationTime = "LastModificationTime"
        case message = "Message"
        case predictorArn = "PredictorArn"
        case predictorName = "PredictorName"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
        if let lastModificationTime = lastModificationTime {
            try encodeContainer.encode(lastModificationTime.timeIntervalSince1970, forKey: .lastModificationTime)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let predictorArn = predictorArn {
            try encodeContainer.encode(predictorArn, forKey: .predictorArn)
        }
        if let predictorName = predictorName {
            try encodeContainer.encode(predictorName, forKey: .predictorName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let predictorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorArn)
        predictorArn = predictorArnDecoded
        let predictorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictorName)
        predictorName = predictorNameDecoded
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModificationTime)
        lastModificationTime = lastModificationTimeDecoded
    }
}

extension PredictorSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PredictorSummary(creationTime: \(String(describing: creationTime)), datasetGroupArn: \(String(describing: datasetGroupArn)), lastModificationTime: \(String(describing: lastModificationTime)), message: \(String(describing: message)), predictorArn: \(String(describing: predictorArn)), predictorName: \(String(describing: predictorName)), status: \(String(describing: status)))"}
}

/// <p>Provides a summary of the predictor properties that are used in the <a>ListPredictors</a> operation. To get the complete set of properties, call the <a>DescribePredictor</a> operation, and provide the listed
///       <code>PredictorArn</code>.</p>
public struct PredictorSummary: Equatable {
    /// <p>When the model training task was created.</p>
    public let creationTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the dataset group that contains the data used to train
    ///       the predictor.</p>
    public let datasetGroupArn: String?
    /// <p>The last time the resource was modified. The timestamp depends on the status of the job:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code> - The <code>CreationTime</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code> - The current timestamp.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPED</code> - When the job stopped.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> or <code>CREATE_FAILED</code> - When the job finished or
    ///           failed.</p>
    ///             </li>
    ///          </ul>
    public let lastModificationTime: Date?
    /// <p>If an error occurred, an informational message about the error.</p>
    public let message: String?
    /// <p>The ARN of the predictor.</p>
    public let predictorArn: String?
    /// <p>The name of the predictor.</p>
    public let predictorName: String?
    /// <p>The status of the predictor. States include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_PENDING</code>, <code>CREATE_IN_PROGRESS</code>,
    ///           <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DELETE_PENDING</code>, <code>DELETE_IN_PROGRESS</code>,
    ///           <code>DELETE_FAILED</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_STOPPING</code>, <code>CREATE_STOPPED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>The <code>Status</code> of the predictor must be <code>ACTIVE</code> before you can use
    ///         the predictor to create a forecast.</p>
    ///          </note>
    public let status: String?

    public init (
        creationTime: Date? = nil,
        datasetGroupArn: String? = nil,
        lastModificationTime: Date? = nil,
        message: String? = nil,
        predictorArn: String? = nil,
        predictorName: String? = nil,
        status: String? = nil
    )
    {
        self.creationTime = creationTime
        self.datasetGroupArn = datasetGroupArn
        self.lastModificationTime = lastModificationTime
        self.message = message
        self.predictorArn = predictorArn
        self.predictorName = predictorName
        self.status = status
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is already a resource with this name. Try again with a different name.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>We can't find a resource with that Amazon Resource Name (ARN). Check the ARN and try
///       again.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Config: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kMSKeyArn = "KMSKeyArn"
        case path = "Path"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
    }
}

extension S3Config: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Config(kMSKeyArn: \(String(describing: kMSKeyArn)), path: \(String(describing: path)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>The path to the file(s) in an Amazon Simple Storage Service (Amazon S3) bucket, and an AWS Identity and Access Management (IAM) role that
///       Amazon Forecast can assume to access the file(s). Optionally, includes an AWS Key Management Service (KMS) key. This
///       object is part of the <a>DataSource</a> object that is submitted in the <a>CreateDatasetImportJob</a> request, and part of the <a>DataDestination</a> object.</p>
public struct S3Config: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key.</p>
    public let kMSKeyArn: String?
    /// <p>The path to an Amazon Simple Storage Service (Amazon S3) bucket or file(s) in an Amazon S3 bucket.</p>
    public let path: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Forecast can assume to access the Amazon S3
    ///       bucket or files. If you provide a value for the <code>KMSKeyArn</code> key, the role must
    ///       allow access to the key.</p>
    ///          <p>Passing a role across AWS accounts is not allowed. If you pass a role that isn't in your
    ///       account, you get an <code>InvalidInputException</code> error.</p>
    public let roleArn: String?

    public init (
        kMSKeyArn: String? = nil,
        path: String? = nil,
        roleArn: String? = nil
    )
    {
        self.kMSKeyArn = kMSKeyArn
        self.path = path
        self.roleArn = roleArn
    }
}

public enum ScalingType {
    case auto
    case linear
    case logarithmic
    case reverselogarithmic
    case sdkUnknown(String)
}

extension ScalingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScalingType] {
        return [
            .auto,
            .linear,
            .logarithmic,
            .reverselogarithmic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .auto: return "Auto"
        case .linear: return "Linear"
        case .logarithmic: return "Logarithmic"
        case .reverselogarithmic: return "ReverseLogarithmic"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScalingType(rawValue: rawValue) ?? ScalingType.sdkUnknown(rawValue)
    }
}

extension Schema: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for schemaattributes0 in attributes {
                try attributesContainer.encode(schemaattributes0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([SchemaAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[SchemaAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [SchemaAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Schema: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schema(attributes: \(String(describing: attributes)))"}
}

/// <p>Defines the fields of a dataset. You specify this object in the <a>CreateDataset</a> request.</p>
public struct Schema: Equatable {
    /// <p>An array of attributes specifying the name and type of each field in a dataset.</p>
    public let attributes: [SchemaAttribute]?

    public init (
        attributes: [SchemaAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

extension SchemaAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeType = "AttributeType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
    }
}

extension SchemaAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SchemaAttribute(attributeName: \(String(describing: attributeName)), attributeType: \(String(describing: attributeType)))"}
}

/// <p>An attribute of a schema, which defines a dataset field. A schema attribute is required
///       for every field in a dataset. The <a>Schema</a> object contains an array of
///         <code>SchemaAttribute</code> objects.</p>
public struct SchemaAttribute: Equatable {
    /// <p>The name of the dataset field.</p>
    public let attributeName: String?
    /// <p>The data type of the field.</p>
    public let attributeType: AttributeType?

    public init (
        attributeName: String? = nil,
        attributeType: AttributeType? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeType = attributeType
    }
}

extension Statistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case avg = "Avg"
        case count = "Count"
        case countDistinct = "CountDistinct"
        case countDistinctLong = "CountDistinctLong"
        case countLong = "CountLong"
        case countNan = "CountNan"
        case countNanLong = "CountNanLong"
        case countNull = "CountNull"
        case countNullLong = "CountNullLong"
        case max = "Max"
        case min = "Min"
        case stddev = "Stddev"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avg = avg {
            try encodeContainer.encode(avg, forKey: .avg)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let countDistinct = countDistinct {
            try encodeContainer.encode(countDistinct, forKey: .countDistinct)
        }
        if let countDistinctLong = countDistinctLong {
            try encodeContainer.encode(countDistinctLong, forKey: .countDistinctLong)
        }
        if let countLong = countLong {
            try encodeContainer.encode(countLong, forKey: .countLong)
        }
        if let countNan = countNan {
            try encodeContainer.encode(countNan, forKey: .countNan)
        }
        if let countNanLong = countNanLong {
            try encodeContainer.encode(countNanLong, forKey: .countNanLong)
        }
        if let countNull = countNull {
            try encodeContainer.encode(countNull, forKey: .countNull)
        }
        if let countNullLong = countNullLong {
            try encodeContainer.encode(countNullLong, forKey: .countNullLong)
        }
        if let max = max {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let min = min {
            try encodeContainer.encode(min, forKey: .min)
        }
        if let stddev = stddev {
            try encodeContainer.encode(stddev, forKey: .stddev)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
        let countDistinctDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countDistinct)
        countDistinct = countDistinctDecoded
        let countNullDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countNull)
        countNull = countNullDecoded
        let countNanDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countNan)
        countNan = countNanDecoded
        let minDecoded = try containerValues.decodeIfPresent(String.self, forKey: .min)
        min = minDecoded
        let maxDecoded = try containerValues.decodeIfPresent(String.self, forKey: .max)
        max = maxDecoded
        let avgDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .avg)
        avg = avgDecoded
        let stddevDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .stddev)
        stddev = stddevDecoded
        let countLongDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countLong)
        countLong = countLongDecoded
        let countDistinctLongDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countDistinctLong)
        countDistinctLong = countDistinctLongDecoded
        let countNullLongDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countNullLong)
        countNullLong = countNullLongDecoded
        let countNanLongDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .countNanLong)
        countNanLong = countNanLongDecoded
    }
}

extension Statistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Statistics(avg: \(String(describing: avg)), count: \(String(describing: count)), countDistinct: \(String(describing: countDistinct)), countDistinctLong: \(String(describing: countDistinctLong)), countLong: \(String(describing: countLong)), countNan: \(String(describing: countNan)), countNanLong: \(String(describing: countNanLong)), countNull: \(String(describing: countNull)), countNullLong: \(String(describing: countNullLong)), max: \(String(describing: max)), min: \(String(describing: min)), stddev: \(String(describing: stddev)))"}
}

/// <p>Provides statistics for each data field imported into to an Amazon Forecast dataset with
///       the <a>CreateDatasetImportJob</a> operation.</p>
public struct Statistics: Equatable {
    /// <p>For a numeric field, the average value in the field.</p>
    public let avg: Double?
    /// <p>The number of values in the field. If the response value is -1, refer to
    ///         <code>CountLong</code>.</p>
    public let count: Int?
    /// <p>The number of distinct values in the field. If the response value is -1, refer to
    ///       <code>CountDistinctLong</code>.</p>
    public let countDistinct: Int?
    /// <p>The number of distinct values in the field. <code>CountDistinctLong</code> is used instead
    ///       of <code>CountDistinct</code> if the value is greater than 2,147,483,647.</p>
    public let countDistinctLong: Int?
    /// <p>The number of values in the field. <code>CountLong</code> is used instead of
    ///         <code>Count</code> if the value is greater than 2,147,483,647.</p>
    public let countLong: Int?
    /// <p>The number of NAN (not a number) values in the field. If the response value is -1, refer to
    ///       <code>CountNanLong</code>.</p>
    public let countNan: Int?
    /// <p>The number of NAN (not a number) values in the field. <code>CountNanLong</code> is used
    ///       instead of <code>CountNan</code> if the value is greater than 2,147,483,647.</p>
    public let countNanLong: Int?
    /// <p>The number of null values in the field. If the response value is -1, refer to
    ///       <code>CountNullLong</code>.</p>
    public let countNull: Int?
    /// <p>The number of null values in the field. <code>CountNullLong</code> is used instead of
    ///         <code>CountNull</code> if the value is greater than 2,147,483,647.</p>
    public let countNullLong: Int?
    /// <p>For a numeric field, the maximum value in the field.</p>
    public let max: String?
    /// <p>For a numeric field, the minimum value in the field.</p>
    public let min: String?
    /// <p>For a numeric field, the standard deviation.</p>
    public let stddev: Double?

    public init (
        avg: Double? = nil,
        count: Int? = nil,
        countDistinct: Int? = nil,
        countDistinctLong: Int? = nil,
        countLong: Int? = nil,
        countNan: Int? = nil,
        countNanLong: Int? = nil,
        countNull: Int? = nil,
        countNullLong: Int? = nil,
        max: String? = nil,
        min: String? = nil,
        stddev: Double? = nil
    )
    {
        self.avg = avg
        self.count = count
        self.countDistinct = countDistinct
        self.countDistinctLong = countDistinctLong
        self.countLong = countLong
        self.countNan = countNan
        self.countNanLong = countNanLong
        self.countNull = countNull
        self.countNullLong = countNullLong
        self.max = max
        self.min = min
        self.stddev = stddev
    }
}

public struct StopResourceInputBodyMiddleware: Middleware {
    public let id: String = "StopResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopResourceInput>
    public typealias MOutput = OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopResourceOutputError>
}

extension StopResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension StopResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct StopResourceInputHeadersMiddleware: Middleware {
    public let id: String = "StopResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopResourceInput>
    public typealias MOutput = OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopResourceOutputError>
}

public struct StopResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "StopResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<StopResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopResourceInput>
    public typealias MOutput = OperationOutput<StopResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopResourceOutputError>
}

public struct StopResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource to stop. The supported ARNs
    ///          are <code>DatasetImportJobArn</code>, <code>PredictorArn</code>,
    ///             <code>PredictorBacktestExportJobArn</code>, <code>ForecastArn</code>, and
    ///             <code>ForecastExportJobArn</code>. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StopResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension StopResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StopResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopResourceOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopResourceOutputResponse()"}
}

extension StopResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopResourceOutputResponse: Equatable {

    public init() {}
}

struct StopResourceOutputResponseBody: Equatable {
}

extension StopResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SupplementaryFeature: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SupplementaryFeature: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SupplementaryFeature(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Describes a supplementary feature of a dataset group. This object is part of the <a>InputDataConfig</a> object. Forecast supports the Weather Index and Holidays built-in
///       featurizations.</p>
///          <p>
///             <b>Weather Index</b>
///          </p>
///          <p>The Amazon Forecast Weather Index is a built-in featurization that incorporates historical and
///       projected weather information into your model. The Weather Index supplements your datasets
///       with over two years of historical weather data and up to 14 days of projected weather data.
///       For more information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/weather.html">Amazon Forecast Weather Index</a>.</p>
///          <p>
///             <b>Holidays</b>
///          </p>
///          <p>Holidays is a built-in featurization that incorporates a feature-engineered dataset of
///       national holiday information into your model. It provides native support for the holiday
///       calendars of 66 countries. To view the holiday calendars, refer to the <a href="http://jollyday.sourceforge.net/data.html">Jollyday</a> library. For more
///       information, see <a href="https://docs.aws.amazon.com/forecast/latest/dg/holidays.html">Holidays Featurization</a>.</p>
public struct SupplementaryFeature: Equatable {
    /// <p>The name of the feature. Valid values: <code>"holiday"</code> and <code>"weather"</code>.</p>
    public let name: String?
    /// <p>
    ///             <b>Weather Index</b>
    ///          </p>
    ///          <p>To enable the Weather Index, set the value to <code>"true"</code>
    ///          </p>
    ///          <p>
    ///             <b>Holidays</b>
    ///          </p>
    ///          <p>To enable Holidays, specify a country with one of the following two-letter country
    ///       codes:</p>
    ///          <ul>
    ///             <li>
    ///                <p>"AL" - ALBANIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"AR" - ARGENTINA</p>
    ///             </li>
    ///             <li>
    ///                <p>"AT" - AUSTRIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"AU" - AUSTRALIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"BA" - BOSNIA HERZEGOVINA</p>
    ///             </li>
    ///             <li>
    ///                <p>"BE" - BELGIUM</p>
    ///             </li>
    ///             <li>
    ///                <p>"BG" - BULGARIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"BO" - BOLIVIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"BR" - BRAZIL</p>
    ///             </li>
    ///             <li>
    ///                <p>"BY" - BELARUS</p>
    ///             </li>
    ///             <li>
    ///                <p>"CA" - CANADA</p>
    ///             </li>
    ///             <li>
    ///                <p>"CL" - CHILE</p>
    ///             </li>
    ///             <li>
    ///                <p>"CO" - COLOMBIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"CR" - COSTA RICA</p>
    ///             </li>
    ///             <li>
    ///                <p>"HR" - CROATIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"CZ" - CZECH REPUBLIC</p>
    ///             </li>
    ///             <li>
    ///                <p>"DK" - DENMARK</p>
    ///             </li>
    ///             <li>
    ///                <p>"EC" - ECUADOR</p>
    ///             </li>
    ///             <li>
    ///                <p>"EE" - ESTONIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"ET" - ETHIOPIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"FI" - FINLAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"FR" - FRANCE</p>
    ///             </li>
    ///             <li>
    ///                <p>"DE" - GERMANY</p>
    ///             </li>
    ///             <li>
    ///                <p>"GR" - GREECE</p>
    ///             </li>
    ///             <li>
    ///                <p>"HU" - HUNGARY</p>
    ///             </li>
    ///             <li>
    ///                <p>"IS" - ICELAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"IN" - INDIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"IE" - IRELAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"IT" - ITALY</p>
    ///             </li>
    ///             <li>
    ///                <p>"JP" - JAPAN</p>
    ///             </li>
    ///             <li>
    ///                <p>"KZ" - KAZAKHSTAN</p>
    ///             </li>
    ///             <li>
    ///                <p>"KR" - KOREA</p>
    ///             </li>
    ///             <li>
    ///                <p>"LV" - LATVIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"LI" - LIECHTENSTEIN</p>
    ///             </li>
    ///             <li>
    ///                <p>"LT" - LITHUANIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"LU" - LUXEMBOURG</p>
    ///             </li>
    ///             <li>
    ///                <p>"MK" - MACEDONIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"MT" - MALTA</p>
    ///             </li>
    ///             <li>
    ///                <p>"MX" - MEXICO</p>
    ///             </li>
    ///             <li>
    ///                <p>"MD" - MOLDOVA</p>
    ///             </li>
    ///             <li>
    ///                <p>"ME" - MONTENEGRO</p>
    ///             </li>
    ///             <li>
    ///                <p>"NL" - NETHERLANDS</p>
    ///             </li>
    ///             <li>
    ///                <p>"NZ" - NEW ZEALAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"NI" - NICARAGUA</p>
    ///             </li>
    ///             <li>
    ///                <p>"NG" - NIGERIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"NO" - NORWAY</p>
    ///             </li>
    ///             <li>
    ///                <p>"PA" - PANAMA</p>
    ///             </li>
    ///             <li>
    ///                <p>"PY" - PARAGUAY</p>
    ///             </li>
    ///             <li>
    ///                <p>"PE" - PERU</p>
    ///             </li>
    ///             <li>
    ///                <p>"PL" - POLAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"PT" - PORTUGAL</p>
    ///             </li>
    ///             <li>
    ///                <p>"RO" - ROMANIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"RU" - RUSSIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"RS" - SERBIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"SK" - SLOVAKIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"SI" - SLOVENIA</p>
    ///             </li>
    ///             <li>
    ///                <p>"ZA" - SOUTH AFRICA</p>
    ///             </li>
    ///             <li>
    ///                <p>"ES" - SPAIN</p>
    ///             </li>
    ///             <li>
    ///                <p>"SE" - SWEDEN</p>
    ///             </li>
    ///             <li>
    ///                <p>"CH" - SWITZERLAND</p>
    ///             </li>
    ///             <li>
    ///                <p>"UA" - UKRAINE</p>
    ///             </li>
    ///             <li>
    ///                <p>"AE" - UNITED ARAB EMIRATES</p>
    ///             </li>
    ///             <li>
    ///                <p>"US" - UNITED STATES</p>
    ///             </li>
    ///             <li>
    ///                <p>"UK" - UNITED KINGDOM</p>
    ///             </li>
    ///             <li>
    ///                <p>"UY" - URUGUAY</p>
    ///             </li>
    ///             <li>
    ///                <p>"VE" - VENEZUELA</p>
    ///             </li>
    ///          </ul>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>The optional metadata that you apply to a resource to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define.</p>
///          <p>The following basic restrictions apply to tags:</p>
///          <ul>
///             <li>
///                <p>Maximum number of tags per resource - 50.</p>
///             </li>
///             <li>
///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
///             </li>
///             <li>
///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
///             </li>
///             <li>
///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
///             </li>
///             <li>
///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
///             </li>
///             <li>
///                <p>Tag keys and values are case sensitive.</p>
///             </li>
///             <li>
///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that makes up a tag. A <code>key</code> is a general label that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that makes up a tag. A <code>value</code> acts as a descriptor within a tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast export jobs.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs.</p>
    ///          <p>The following basic restrictions apply to tags:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Maximum number of tags per resource - 50.</p>
    ///             </li>
    ///             <li>
    ///                <p>For each resource, each tag key must be unique, and each tag key can have only one value.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum key length - 128 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>Maximum value length - 256 Unicode characters in UTF-8.</p>
    ///             </li>
    ///             <li>
    ///                <p>If your tagging schema is used across multiple services and resources, remember that other services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following characters: + - = . _ : / @.</p>
    ///             </li>
    ///             <li>
    ///                <p>Tag keys and values are case sensitive.</p>
    ///             </li>
    ///             <li>
    ///                <p>Do not use <code>aws:</code>, <code>AWS:</code>, or any upper or lowercase combination of such as a prefix for keys as it is reserved for AWS use. You cannot edit or delete tag keys with this prefix. Values can have this prefix. If a tag value has <code>aws</code> as its prefix but the key does not, then Forecast considers it to be a user tag and will count against the limit of 50 tags. Tags with only the key prefix of <code>aws</code> do not count against your tags per resource limit.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TestWindowSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case status = "Status"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TestWindowSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestWindowSummary(message: \(String(describing: message)), status: \(String(describing: status)), testWindowEnd: \(String(describing: testWindowEnd)), testWindowStart: \(String(describing: testWindowStart)))"}
}

/// <p>The status, start time, and end time of a backtest, as well as a failure reason if
///       applicable.</p>
public struct TestWindowSummary: Equatable {
    /// <p>If the test failed, the reason why it failed.</p>
    public let message: String?
    /// <p>The status of the test. Possible status values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_IN_PROGRESS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CREATE_FAILED</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let status: String?
    /// <p>The time at which the test ended.</p>
    public let testWindowEnd: Date?
    /// <p>The time at which the test began.</p>
    public let testWindowStart: Date?

    public init (
        message: String? = nil,
        status: String? = nil,
        testWindowEnd: Date? = nil,
        testWindowStart: Date? = nil
    )
    {
        self.message = message
        self.status = status
        self.testWindowEnd = testWindowEnd
        self.testWindowStart = testWindowStart
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeys0 in tagKeys {
                try tagKeysContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the supported resources are Forecast dataset groups, datasets, dataset import jobs, predictors, forecasts, and forecast exports.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatasetGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatasetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetGroupOutputError>
}

extension UpdateDatasetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetGroupInput(datasetArns: \(String(describing: datasetArns)), datasetGroupArn: \(String(describing: datasetGroupArn)))"}
}

extension UpdateDatasetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetArns = datasetArns {
            var datasetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetArns)
            for arnlist0 in datasetArns {
                try datasetArnsContainer.encode(arnlist0)
            }
        }
        if let datasetGroupArn = datasetGroupArn {
            try encodeContainer.encode(datasetGroupArn, forKey: .datasetGroupArn)
        }
    }
}

public struct UpdateDatasetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatasetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetGroupOutputError>
}

public struct UpdateDatasetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatasetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetGroupInput>
    public typealias MOutput = OperationOutput<UpdateDatasetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetGroupOutputError>
}

public struct UpdateDatasetGroupInput: Equatable {
    /// <p>An array of the Amazon Resource Names (ARNs) of the datasets to add to the dataset
    ///       group.</p>
    public let datasetArns: [String]?
    /// <p>The ARN of the dataset group.</p>
    public let datasetGroupArn: String?

    public init (
        datasetArns: [String]? = nil,
        datasetGroupArn: String? = nil
    )
    {
        self.datasetArns = datasetArns
        self.datasetGroupArn = datasetGroupArn
    }
}

struct UpdateDatasetGroupInputBody: Equatable {
    public let datasetGroupArn: String?
    public let datasetArns: [String]?
}

extension UpdateDatasetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetArns = "DatasetArns"
        case datasetGroupArn = "DatasetGroupArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetGroupArn)
        datasetGroupArn = datasetGroupArnDecoded
        let datasetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .datasetArns)
        var datasetArnsDecoded0:[String]? = nil
        if let datasetArnsContainer = datasetArnsContainer {
            datasetArnsDecoded0 = [String]()
            for string0 in datasetArnsContainer {
                if let string0 = string0 {
                    datasetArnsDecoded0?.append(string0)
                }
            }
        }
        datasetArns = datasetArnsDecoded0
    }
}

extension UpdateDatasetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetGroupOutputError: Equatable {
    case invalidInputException(InvalidInputException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetGroupOutputResponse()"}
}

extension UpdateDatasetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDatasetGroupOutputResponse: Equatable {

    public init() {}
}

struct UpdateDatasetGroupOutputResponseBody: Equatable {
}

extension UpdateDatasetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension WeightedQuantileLoss: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lossValue = "LossValue"
        case quantile = "Quantile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lossValue = lossValue {
            try encodeContainer.encode(lossValue, forKey: .lossValue)
        }
        if let quantile = quantile {
            try encodeContainer.encode(quantile, forKey: .quantile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let quantileDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .quantile)
        quantile = quantileDecoded
        let lossValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .lossValue)
        lossValue = lossValueDecoded
    }
}

extension WeightedQuantileLoss: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WeightedQuantileLoss(lossValue: \(String(describing: lossValue)), quantile: \(String(describing: quantile)))"}
}

/// <p>The weighted loss value for a quantile. This object is part of the
///       <a>Metrics</a> object.</p>
public struct WeightedQuantileLoss: Equatable {
    /// <p>The difference between the predicted value and the actual value over the quantile,
    ///       weighted (normalized) by dividing by the sum over all quantiles.</p>
    public let lossValue: Double?
    /// <p>The quantile. Quantiles divide a probability distribution into regions of equal
    ///       probability. For example, if the distribution was divided into 5 regions of equal
    ///       probability, the quantiles would be 0.2, 0.4, 0.6, and 0.8.</p>
    public let quantile: Double?

    public init (
        lossValue: Double? = nil,
        quantile: Double? = nil
    )
    {
        self.lossValue = lossValue
        self.quantile = quantile
    }
}

extension WindowSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evaluationType = "EvaluationType"
        case itemCount = "ItemCount"
        case metrics = "Metrics"
        case testWindowEnd = "TestWindowEnd"
        case testWindowStart = "TestWindowStart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evaluationType = evaluationType {
            try encodeContainer.encode(evaluationType.rawValue, forKey: .evaluationType)
        }
        if let itemCount = itemCount {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let metrics = metrics {
            try encodeContainer.encode(metrics, forKey: .metrics)
        }
        if let testWindowEnd = testWindowEnd {
            try encodeContainer.encode(testWindowEnd.timeIntervalSince1970, forKey: .testWindowEnd)
        }
        if let testWindowStart = testWindowStart {
            try encodeContainer.encode(testWindowStart.timeIntervalSince1970, forKey: .testWindowStart)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testWindowStartDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .testWindowStart)
        testWindowStart = testWindowStartDecoded
        let testWindowEndDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .testWindowEnd)
        testWindowEnd = testWindowEndDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .itemCount)
        itemCount = itemCountDecoded
        let evaluationTypeDecoded = try containerValues.decodeIfPresent(EvaluationType.self, forKey: .evaluationType)
        evaluationType = evaluationTypeDecoded
        let metricsDecoded = try containerValues.decodeIfPresent(Metrics.self, forKey: .metrics)
        metrics = metricsDecoded
    }
}

extension WindowSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WindowSummary(evaluationType: \(String(describing: evaluationType)), itemCount: \(String(describing: itemCount)), metrics: \(String(describing: metrics)), testWindowEnd: \(String(describing: testWindowEnd)), testWindowStart: \(String(describing: testWindowStart)))"}
}

/// <p>The metrics for a time range within the evaluation portion of a dataset. This object
///       is part of the <a>EvaluationResult</a> object.</p>
///          <p>The <code>TestWindowStart</code> and <code>TestWindowEnd</code> parameters are
///       determined by the <code>BackTestWindowOffset</code> parameter of the
///       <a>EvaluationParameters</a> object.</p>
public struct WindowSummary: Equatable {
    /// <p>The type of evaluation.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUMMARY</code> - The average metrics across all windows.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>COMPUTED</code> - The metrics for the specified window.</p>
    ///             </li>
    ///          </ul>
    public let evaluationType: EvaluationType?
    /// <p>The number of data points within the window.</p>
    public let itemCount: Int?
    /// <p>Provides metrics used to evaluate the performance of a predictor.</p>
    public let metrics: Metrics?
    /// <p>The timestamp that defines the end of the window.</p>
    public let testWindowEnd: Date?
    /// <p>The timestamp that defines the start of the window.</p>
    public let testWindowStart: Date?

    public init (
        evaluationType: EvaluationType? = nil,
        itemCount: Int? = nil,
        metrics: Metrics? = nil,
        testWindowEnd: Date? = nil,
        testWindowStart: Date? = nil
    )
    {
        self.evaluationType = evaluationType
        self.itemCount = itemCount
        self.metrics = metrics
        self.testWindowEnd = testWindowEnd
        self.testWindowStart = testWindowStart
    }
}
