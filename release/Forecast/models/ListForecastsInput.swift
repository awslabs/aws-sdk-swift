// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct ListForecastsInput: Equatable {
    /// <p>An array of filters. For each filter, you provide a condition and a match statement. The
    ///       condition is either <code>IS</code> or <code>IS_NOT</code>, which specifies whether to include
    ///       or exclude the forecasts that match the statement from the list, respectively. The match
    ///       statement consists of a key and a value.</p>
    ///          <p>
    ///             <b>Filter properties</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Condition</code> - The condition to apply. Valid values are <code>IS</code> and
    ///             <code>IS_NOT</code>. To include the forecasts that match the statement, specify
    ///             <code>IS</code>. To exclude matching forecasts, specify <code>IS_NOT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Key</code> - The name of the parameter to filter on. Valid values are
    ///             <code>DatasetGroupArn</code>, <code>PredictorArn</code>, and <code>Status</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Value</code> - The value to match.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, to list all forecasts whose status is not ACTIVE, you would specify:</p>
    ///          <p>
    ///             <code>"Filters": [ { "Condition": "IS_NOT", "Key": "Status", "Value": "ACTIVE" }
    ///       ]</code>
    ///          </p>
    public let filters: [Filter]?
    /// <p>The number of items to return in the response.</p>
    public let maxResults: Int?
    /// <p>If the result of the previous request was truncated, the response includes a
    ///         <code>NextToken</code>. To retrieve the next set of results, use the token in the next
    ///       request. Tokens expire after 24 hours.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListForecastsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListForecastsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}
