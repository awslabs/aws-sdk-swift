// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has the same name as another active human loop but has different input data. You cannot start two human loops with the same name and different input data.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum ContentClassifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case freeOfAdultContent
        case freeOfPersonallyIdentifiableInformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentClassifier] {
            return [
                .freeOfAdultContent,
                .freeOfPersonallyIdentifiableInformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .freeOfAdultContent: return "FreeOfAdultContent"
            case .freeOfPersonallyIdentifiableInformation: return "FreeOfPersonallyIdentifiableInformation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentClassifier(rawValue: rawValue) ?? ContentClassifier.sdkUnknown(rawValue)
        }
    }
}

extension DeleteHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let humanLoopName = humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

public struct DeleteHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want to delete.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DeleteHumanLoopInputBody: Swift.Equatable {
}

extension DeleteHumanLoopInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHumanLoopOutputResponse: Swift.Equatable {

}

extension DescribeHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let humanLoopName = humanLoopName else {
            return nil
        }
        return "/human-loops/\(humanLoopName.urlPercentEncoding())"
    }
}

public struct DescribeHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want information about.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct DescribeHumanLoopInputBody: Swift.Equatable {
}

extension DescribeHumanLoopInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.failureCode = output.failureCode
            self.failureReason = output.failureReason
            self.flowDefinitionArn = output.flowDefinitionArn
            self.humanLoopArn = output.humanLoopArn
            self.humanLoopName = output.humanLoopName
            self.humanLoopOutput = output.humanLoopOutput
            self.humanLoopStatus = output.humanLoopStatus
        } else {
            self.creationTime = nil
            self.failureCode = nil
            self.failureReason = nil
            self.flowDefinitionArn = nil
            self.humanLoopArn = nil
            self.humanLoopName = nil
            self.humanLoopOutput = nil
            self.humanLoopStatus = nil
        }
    }
}

public struct DescribeHumanLoopOutputResponse: Swift.Equatable {
    /// The creation time when Amazon Augmented AI created the human loop.
    /// This member is required.
    public var creationTime: ClientRuntime.Date?
    /// A failure code that identifies the type of failure. Possible values: ValidationError, Expired, InternalError
    public var failureCode: Swift.String?
    /// The reason why a human loop failed. The failure reason is returned when the status of the human loop is Failed.
    public var failureReason: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the human loop.
    /// This member is required.
    public var humanLoopArn: Swift.String?
    /// The name of the human loop. The name must be lowercase, unique within the Region in your account, and can have up to 63 characters. Valid characters: a-z, 0-9, and - (hyphen).
    /// This member is required.
    public var humanLoopName: Swift.String?
    /// An object that contains information about the output of the human loop.
    public var humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
    /// The status of the human loop.
    /// This member is required.
    public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        failureCode: Swift.String? = nil,
        failureReason: Swift.String? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopArn: Swift.String? = nil,
        humanLoopName: Swift.String? = nil,
        humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput? = nil,
        humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.failureCode = failureCode
        self.failureReason = failureReason
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopArn = humanLoopArn
        self.humanLoopName = humanLoopName
        self.humanLoopOutput = humanLoopOutput
        self.humanLoopStatus = humanLoopStatus
    }
}

struct DescribeHumanLoopOutputResponseBody: Swift.Equatable {
    let creationTime: ClientRuntime.Date?
    let failureReason: Swift.String?
    let failureCode: Swift.String?
    let humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?
    let humanLoopName: Swift.String?
    let humanLoopArn: Swift.String?
    let flowDefinitionArn: Swift.String?
    let humanLoopOutput: SageMakerA2IRuntimeClientTypes.HumanLoopOutput?
}

extension DescribeHumanLoopOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureCode = "FailureCode"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopArn = "HumanLoopArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopOutput = "HumanLoopOutput"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopOutputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopOutput.self, forKey: .humanLoopOutput)
        humanLoopOutput = humanLoopOutputDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentClassifiers = "ContentClassifiers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentClassifiers = contentClassifiers {
            var contentClassifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contentClassifiers)
            for contentclassifiers0 in contentClassifiers {
                try contentClassifiersContainer.encode(contentclassifiers0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentClassifiersContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.ContentClassifier?].self, forKey: .contentClassifiers)
        var contentClassifiersDecoded0:[SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        if let contentClassifiersContainer = contentClassifiersContainer {
            contentClassifiersDecoded0 = [SageMakerA2IRuntimeClientTypes.ContentClassifier]()
            for string0 in contentClassifiersContainer {
                if let string0 = string0 {
                    contentClassifiersDecoded0?.append(string0)
                }
            }
        }
        contentClassifiers = contentClassifiersDecoded0
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Attributes of the data specified by the customer. Use these to describe the data to be labeled.
    public struct HumanLoopDataAttributes: Swift.Equatable {
        /// Declares that your content is free of personally identifiable information or adult content. Amazon SageMaker can restrict the Amazon Mechanical Turk workers who can view your task based on this information.
        /// This member is required.
        public var contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]?

        public init (
            contentClassifiers: [SageMakerA2IRuntimeClientTypes.ContentClassifier]? = nil
        )
        {
            self.contentClassifiers = contentClassifiers
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputContent = "InputContent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputContent = inputContent {
            try encodeContainer.encode(inputContent, forKey: .inputContent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputContent)
        inputContent = inputContentDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// An object containing the human loop input in JSON format.
    public struct HumanLoopInput: Swift.Equatable {
        /// Serialized input from the human loop. The input must be a string representation of a file in JSON format.
        /// This member is required.
        public var inputContent: Swift.String?

        public init (
            inputContent: Swift.String? = nil
        )
        {
            self.inputContent = inputContent
        }
    }

}

extension SageMakerA2IRuntimeClientTypes.HumanLoopOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputS3Uri = "OutputS3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputS3Uri = outputS3Uri {
            try encodeContainer.encode(outputS3Uri, forKey: .outputS3Uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputS3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3Uri)
        outputS3Uri = outputS3UriDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Information about where the human output will be stored.
    public struct HumanLoopOutput: Swift.Equatable {
        /// The location of the Amazon S3 object where Amazon Augmented AI stores your human loop output.
        /// This member is required.
        public var outputS3Uri: Swift.String?

        public init (
            outputS3Uri: Swift.String? = nil
        )
        {
            self.outputS3Uri = outputS3Uri
        }
    }

}

extension SageMakerA2IRuntimeClientTypes {
    public enum HumanLoopStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inProgress
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [HumanLoopStatus] {
            return [
                .completed,
                .failed,
                .inProgress,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .inProgress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HumanLoopStatus(rawValue: rawValue) ?? HumanLoopStatus.sdkUnknown(rawValue)
        }
    }
}

extension SageMakerA2IRuntimeClientTypes.HumanLoopSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case failureReason = "FailureReason"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopName = "HumanLoopName"
        case humanLoopStatus = "HumanLoopStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
        if let humanLoopStatus = humanLoopStatus {
            try encodeContainer.encode(humanLoopStatus.rawValue, forKey: .humanLoopStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let humanLoopStatusDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopStatus.self, forKey: .humanLoopStatus)
        humanLoopStatus = humanLoopStatusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    /// Summary information about the human loop.
    public struct HumanLoopSummary: Swift.Equatable {
        /// When Amazon Augmented AI created the human loop.
        public var creationTime: ClientRuntime.Date?
        /// The reason why the human loop failed. A failure reason is returned when the status of the human loop is Failed.
        public var failureReason: Swift.String?
        /// The Amazon Resource Name (ARN) of the flow definition used to configure the human loop.
        public var flowDefinitionArn: Swift.String?
        /// The name of the human loop.
        public var humanLoopName: Swift.String?
        /// The status of the human loop.
        public var humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            flowDefinitionArn: Swift.String? = nil,
            humanLoopName: Swift.String? = nil,
            humanLoopStatus: SageMakerA2IRuntimeClientTypes.HumanLoopStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.failureReason = failureReason
            self.flowDefinitionArn = flowDefinitionArn
            self.humanLoopName = humanLoopName
            self.humanLoopStatus = humanLoopStatus
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We couldn't process your request because of an issue with the server. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListHumanLoopsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let flowDefinitionArn = flowDefinitionArn {
            let flowDefinitionArnQueryItem = ClientRuntime.URLQueryItem(name: "FlowDefinitionArn".urlPercentEncoding(), value: Swift.String(flowDefinitionArn).urlPercentEncoding())
            items.append(flowDefinitionArnQueryItem)
        }
        if let creationTimeBefore = creationTimeBefore {
            let creationTimeBeforeQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeBefore".urlPercentEncoding(), value: Swift.String(creationTimeBefore.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(creationTimeBeforeQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let sortOrder = sortOrder {
            let sortOrderQueryItem = ClientRuntime.URLQueryItem(name: "SortOrder".urlPercentEncoding(), value: Swift.String(sortOrder.rawValue).urlPercentEncoding())
            items.append(sortOrderQueryItem)
        }
        if let creationTimeAfter = creationTimeAfter {
            let creationTimeAfterQueryItem = ClientRuntime.URLQueryItem(name: "CreationTimeAfter".urlPercentEncoding(), value: Swift.String(creationTimeAfter.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            items.append(creationTimeAfterQueryItem)
        }
        return items
    }
}

extension ListHumanLoopsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops"
    }
}

public struct ListHumanLoopsInput: Swift.Equatable {
    /// (Optional) The timestamp of the date when you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeAfter: ClientRuntime.Date?
    /// (Optional) The timestamp of the date before which you want the human loops to begin in ISO 8601 format. For example, 2020-02-24.
    public var creationTimeBefore: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of a flow definition.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// The total number of items to return. If the total number of available items is more than the value specified in MaxResults, then a NextToken is returned in the output. You can use this token to display the next page of results.
    public var maxResults: Swift.Int
    /// A token to display the next page of results.
    public var nextToken: Swift.String?
    /// Optional. The order for displaying results. Valid values: Ascending and Descending.
    public var sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder?

    public init (
        creationTimeAfter: ClientRuntime.Date? = nil,
        creationTimeBefore: ClientRuntime.Date? = nil,
        flowDefinitionArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sortOrder: SageMakerA2IRuntimeClientTypes.SortOrder? = nil
    )
    {
        self.creationTimeAfter = creationTimeAfter
        self.creationTimeBefore = creationTimeBefore
        self.flowDefinitionArn = flowDefinitionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortOrder = sortOrder
    }
}

struct ListHumanLoopsInputBody: Swift.Equatable {
}

extension ListHumanLoopsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHumanLoopsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHumanLoopsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHumanLoopsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHumanLoopsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHumanLoopsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopSummaries = output.humanLoopSummaries
            self.nextToken = output.nextToken
        } else {
            self.humanLoopSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListHumanLoopsOutputResponse: Swift.Equatable {
    /// An array of objects that contain information about the human loops.
    /// This member is required.
    public var humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    /// A token to display the next page of results.
    public var nextToken: Swift.String?

    public init (
        humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.humanLoopSummaries = humanLoopSummaries
        self.nextToken = nextToken
    }
}

struct ListHumanLoopsOutputResponseBody: Swift.Equatable {
    let humanLoopSummaries: [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]?
    let nextToken: Swift.String?
}

extension ListHumanLoopsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopSummaries = "HumanLoopSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopSummariesContainer = try containerValues.decodeIfPresent([SageMakerA2IRuntimeClientTypes.HumanLoopSummary?].self, forKey: .humanLoopSummaries)
        var humanLoopSummariesDecoded0:[SageMakerA2IRuntimeClientTypes.HumanLoopSummary]? = nil
        if let humanLoopSummariesContainer = humanLoopSummariesContainer {
            humanLoopSummariesDecoded0 = [SageMakerA2IRuntimeClientTypes.HumanLoopSummary]()
            for structure0 in humanLoopSummariesContainer {
                if let structure0 = structure0 {
                    humanLoopSummariesDecoded0?.append(structure0)
                }
            }
        }
        humanLoopSummaries = humanLoopSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We couldn't find the requested resource. Check that your resources exists and were created in the same AWS Region as your request, and try your request again.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your AWS account. For a list of Amazon A2I service quotes, see [Amazon Augmented AI Service Quotes](https://docs.aws.amazon.com/general/latest/gr/a2i.html). Delete some resources or request an increase in your service quota. You can request a quota increase using Service Quotas or the AWS Support Center. To request an increase, see [AWS Service Quotas](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) in the AWS General Reference.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SageMakerA2IRuntimeClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "Ascending"
            case .descending: return "Descending"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension StartHumanLoopInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataAttributes = dataAttributes {
            try encodeContainer.encode(dataAttributes, forKey: .dataAttributes)
        }
        if let flowDefinitionArn = flowDefinitionArn {
            try encodeContainer.encode(flowDefinitionArn, forKey: .flowDefinitionArn)
        }
        if let humanLoopInput = humanLoopInput {
            try encodeContainer.encode(humanLoopInput, forKey: .humanLoopInput)
        }
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

extension StartHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops"
    }
}

public struct StartHumanLoopInput: Swift.Equatable {
    /// Attributes of the specified data. Use DataAttributes to specify if your data is free of personally identifiable information and/or free of adult content.
    public var dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
    /// The Amazon Resource Name (ARN) of the flow definition associated with this human loop.
    /// This member is required.
    public var flowDefinitionArn: Swift.String?
    /// An object that contains information about the human loop.
    /// This member is required.
    public var humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    /// The name of the human loop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init (
        dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes? = nil,
        flowDefinitionArn: Swift.String? = nil,
        humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput? = nil,
        humanLoopName: Swift.String? = nil
    )
    {
        self.dataAttributes = dataAttributes
        self.flowDefinitionArn = flowDefinitionArn
        self.humanLoopInput = humanLoopInput
        self.humanLoopName = humanLoopName
    }
}

struct StartHumanLoopInputBody: Swift.Equatable {
    let humanLoopName: Swift.String?
    let flowDefinitionArn: Swift.String?
    let humanLoopInput: SageMakerA2IRuntimeClientTypes.HumanLoopInput?
    let dataAttributes: SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes?
}

extension StartHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataAttributes = "DataAttributes"
        case flowDefinitionArn = "FlowDefinitionArn"
        case humanLoopInput = "HumanLoopInput"
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
        let flowDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowDefinitionArn)
        flowDefinitionArn = flowDefinitionArnDecoded
        let humanLoopInputDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopInput.self, forKey: .humanLoopInput)
        humanLoopInput = humanLoopInputDecoded
        let dataAttributesDecoded = try containerValues.decodeIfPresent(SageMakerA2IRuntimeClientTypes.HumanLoopDataAttributes.self, forKey: .dataAttributes)
        dataAttributes = dataAttributesDecoded
    }
}

extension StartHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartHumanLoopOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.humanLoopArn = output.humanLoopArn
        } else {
            self.humanLoopArn = nil
        }
    }
}

public struct StartHumanLoopOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the human loop.
    public var humanLoopArn: Swift.String?

    public init (
        humanLoopArn: Swift.String? = nil
    )
    {
        self.humanLoopArn = humanLoopArn
    }
}

struct StartHumanLoopOutputResponseBody: Swift.Equatable {
    let humanLoopArn: Swift.String?
}

extension StartHumanLoopOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopArn = "HumanLoopArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopArn)
        humanLoopArn = humanLoopArnDecoded
    }
}

extension StopHumanLoopInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let humanLoopName = humanLoopName {
            try encodeContainer.encode(humanLoopName, forKey: .humanLoopName)
        }
    }
}

extension StopHumanLoopInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/human-loops/stop"
    }
}

public struct StopHumanLoopInput: Swift.Equatable {
    /// The name of the human loop that you want to stop.
    /// This member is required.
    public var humanLoopName: Swift.String?

    public init (
        humanLoopName: Swift.String? = nil
    )
    {
        self.humanLoopName = humanLoopName
    }
}

struct StopHumanLoopInputBody: Swift.Equatable {
    let humanLoopName: Swift.String?
}

extension StopHumanLoopInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case humanLoopName = "HumanLoopName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let humanLoopNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .humanLoopName)
        humanLoopName = humanLoopNameDecoded
    }
}

extension StopHumanLoopOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopHumanLoopOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopHumanLoopOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopHumanLoopOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopHumanLoopOutputResponse: Swift.Equatable {

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You exceeded the maximum number of requests.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid. Check the syntax and try again.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
