// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Timestream was unable to process this request because it contains resource that already exists.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

extension CreateDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatabaseInput(databaseName: \(String(describing: databaseName)), kmsKeyId: \(String(describing: kmsKeyId)), tags: \(String(describing: tags)))"}
}

extension CreateDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatabaseInput>
    public typealias MOutput = OperationOutput<CreateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatabaseOutputError>
}

public struct CreateDatabaseInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The KMS key for the database. If the KMS key is not specified, the database will be encrypted with a Timestream
    ///          managed KMS key located in your account. Refer to <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#aws-managed-cmk">AWS managed KMS keys</a> for more info.</p>
    public let kmsKeyId: String?
    /// <p>
    ///       A list of key-value pairs to label the table.
    ///    </p>
    public let tags: [Tag]?

    public init (
        databaseName: String? = nil,
        kmsKeyId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
        self.tags = tags
    }
}

struct CreateDatabaseInputBody: Equatable {
    public let databaseName: String?
    public let kmsKeyId: String?
    public let tags: [Tag]?
}

extension CreateDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatabaseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatabaseOutputResponse(database: \(String(describing: database)))"}
}

extension CreateDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct CreateDatabaseOutputResponse: Equatable {
    /// <p>The newly created Timestream database.</p>
    public let database: Database?

    public init (
        database: Database? = nil
    )
    {
        self.database = database
    }
}

struct CreateDatabaseOutputResponseBody: Equatable {
    public let database: Database?
}

extension CreateDatabaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct CreateTableInputBodyMiddleware: Middleware {
    public let id: String = "CreateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

extension CreateTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTableInput(databaseName: \(String(describing: databaseName)), retentionProperties: \(String(describing: retentionProperties)), tableName: \(String(describing: tableName)), tags: \(String(describing: tags)))"}
}

extension CreateTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateTableInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

public struct CreateTableInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTableInput>
    public typealias MOutput = OperationOutput<CreateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTableOutputError>
}

public struct CreateTableInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The duration for which your time series data must be stored in the memory store and the magnetic store.</p>
    public let retentionProperties: RetentionProperties?
    /// <p>The name of the Timestream table.</p>
    public let tableName: String?
    /// <p>
    ///       A list of key-value pairs to label the table.
    ///    </p>
    public let tags: [Tag]?

    public init (
        databaseName: String? = nil,
        retentionProperties: RetentionProperties? = nil,
        tableName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.databaseName = databaseName
        self.retentionProperties = retentionProperties
        self.tableName = tableName
        self.tags = tags
    }
}

struct CreateTableInputBody: Equatable {
    public let databaseName: String?
    public let tableName: String?
    public let retentionProperties: RetentionProperties?
    public let tags: [Tag]?
}

extension CreateTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTableOutputResponse(table: \(String(describing: table)))"}
}

extension CreateTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct CreateTableOutputResponse: Equatable {
    /// <p>The newly created Timestream table.</p>
    public let table: Table?

    public init (
        table: Table? = nil
    )
    {
        self.table = table
    }
}

struct CreateTableOutputResponseBody: Equatable {
    public let table: Table?
}

extension CreateTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case table = "Table"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension Database: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
        case lastUpdatedTime = "LastUpdatedTime"
        case tableCount = "TableCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if tableCount != 0 {
            try encodeContainer.encode(tableCount, forKey: .tableCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableCountDecoded = try containerValues.decode(Int.self, forKey: .tableCount)
        tableCount = tableCountDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension Database: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Database(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), databaseName: \(String(describing: databaseName)), kmsKeyId: \(String(describing: kmsKeyId)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), tableCount: \(String(describing: tableCount)))"}
}

/// <p>A top level container for a table. Databases and tables are the
///       fundamental management concepts in Amazon Timestream. All tables in a
///       database are encrypted with the same KMS key.</p>
public struct Database: Equatable {
    /// <p>The Amazon Resource Name that uniquely identifies this database.</p>
    public let arn: String?
    /// <p>The time when the database was created, calculated from the Unix epoch time.</p>
    public let creationTime: Date?
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The identifier of the KMS key used to encrypt the data stored in the database.</p>
    public let kmsKeyId: String?
    /// <p>
    ///    The last time that this database was updated.
    ///    </p>
    public let lastUpdatedTime: Date?
    /// <p>The total number of tables found within a Timestream database. </p>
    public let tableCount: Int

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        databaseName: String? = nil,
        kmsKeyId: String? = nil,
        lastUpdatedTime: Date? = nil,
        tableCount: Int = 0
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
        self.lastUpdatedTime = lastUpdatedTime
        self.tableCount = tableCount
    }
}

public struct DeleteDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

extension DeleteDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatabaseInput(databaseName: \(String(describing: databaseName)))"}
}

extension DeleteDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

public struct DeleteDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatabaseInput>
    public typealias MOutput = OperationOutput<DeleteDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatabaseOutputError>
}

public struct DeleteDatabaseInput: Equatable {
    /// <p>The name of the Timestream database to be deleted.</p>
    public let databaseName: String?

    public init (
        databaseName: String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DeleteDatabaseInputBody: Equatable {
    public let databaseName: String?
}

extension DeleteDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DeleteDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatabaseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatabaseOutputResponse()"}
}

extension DeleteDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatabaseOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatabaseOutputResponseBody: Equatable {
}

extension DeleteDatabaseOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTableInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

extension DeleteTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableInput(databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension DeleteTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DeleteTableInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

public struct DeleteTableInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTableInput>
    public typealias MOutput = OperationOutput<DeleteTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTableOutputError>
}

public struct DeleteTableInput: Equatable {
    /// <p>The name of the database where the Timestream database is to be deleted.</p>
    public let databaseName: String?
    /// <p>The name of the Timestream table to be deleted.</p>
    public let tableName: String?

    public init (
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DeleteTableInputBody: Equatable {
    public let databaseName: String?
    public let tableName: String?
}

extension DeleteTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DeleteTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTableOutputResponse()"}
}

extension DeleteTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTableOutputResponse: Equatable {

    public init() {}
}

struct DeleteTableOutputResponseBody: Equatable {
}

extension DeleteTableOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatabaseOutputError>
}

extension DescribeDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatabaseInput(databaseName: \(String(describing: databaseName)))"}
}

extension DescribeDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
    }
}

public struct DescribeDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatabaseOutputError>
}

public struct DescribeDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatabaseInput>
    public typealias MOutput = OperationOutput<DescribeDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatabaseOutputError>
}

public struct DescribeDatabaseInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?

    public init (
        databaseName: String? = nil
    )
    {
        self.databaseName = databaseName
    }
}

struct DescribeDatabaseInputBody: Equatable {
    public let databaseName: String?
}

extension DescribeDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension DescribeDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatabaseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatabaseOutputResponse(database: \(String(describing: database)))"}
}

extension DescribeDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct DescribeDatabaseOutputResponse: Equatable {
    /// <p>The name of the Timestream table.</p>
    public let database: Database?

    public init (
        database: Database? = nil
    )
    {
        self.database = database
    }
}

struct DescribeDatabaseOutputResponseBody: Equatable {
    public let database: Database?
}

extension DescribeDatabaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Database.self, forKey: .database)
        database = databaseDecoded
    }
}

extension DescribeEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsInput()"}
}

extension DescribeEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEndpointsInput>
    public typealias MOutput = OperationOutput<DescribeEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEndpointsOutputError>
}

public struct DescribeEndpointsInput: Equatable {

    public init() {}
}

struct DescribeEndpointsInputBody: Equatable {
}

extension DescribeEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEndpointsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEndpointsOutputResponse(endpoints: \(String(describing: endpoints)))"}
}

extension DescribeEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEndpointsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endpoints = output.endpoints
        } else {
            self.endpoints = nil
        }
    }
}

public struct DescribeEndpointsOutputResponse: Equatable {
    /// <p>An <code>Endpoints</code> object is returned when a <code>DescribeEndpoints</code> request is made.</p>
    public let endpoints: [Endpoint]?

    public init (
        endpoints: [Endpoint]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

struct DescribeEndpointsOutputResponseBody: Equatable {
    public let endpoints: [Endpoint]?
}

extension DescribeEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpoints = "Endpoints"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([Endpoint?].self, forKey: .endpoints)
        var endpointsDecoded0:[Endpoint]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [Endpoint]()
            for structure0 in endpointsContainer {
                if let structure0 = structure0 {
                    endpointsDecoded0?.append(structure0)
                }
            }
        }
        endpoints = endpointsDecoded0
    }
}

public struct DescribeTableInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

extension DescribeTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableInput(databaseName: \(String(describing: databaseName)), tableName: \(String(describing: tableName)))"}
}

extension DescribeTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct DescribeTableInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

public struct DescribeTableInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableInput>
    public typealias MOutput = OperationOutput<DescribeTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableOutputError>
}

public struct DescribeTableInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The name of the Timestream table.</p>
    public let tableName: String?

    public init (
        databaseName: String? = nil,
        tableName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.tableName = tableName
    }
}

struct DescribeTableInputBody: Equatable {
    public let databaseName: String?
    public let tableName: String?
}

extension DescribeTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension DescribeTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableOutputResponse(table: \(String(describing: table)))"}
}

extension DescribeTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct DescribeTableOutputResponse: Equatable {
    /// <p>The Timestream table.</p>
    public let table: Table?

    public init (
        table: Table? = nil
    )
    {
        self.table = table
    }
}

struct DescribeTableOutputResponseBody: Equatable {
    public let table: Table?
}

extension DescribeTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case table = "Table"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension Dimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionValueType = "DimensionValueType"
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionValueType = dimensionValueType {
            try encodeContainer.encode(dimensionValueType.rawValue, forKey: .dimensionValueType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let dimensionValueTypeDecoded = try containerValues.decodeIfPresent(DimensionValueType.self, forKey: .dimensionValueType)
        dimensionValueType = dimensionValueTypeDecoded
    }
}

extension Dimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dimension(dimensionValueType: \(String(describing: dimensionValueType)), name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Dimension represents the meta data attributes of the time series. For example, the name and availability zone of an EC2 instance or the name of the manufacturer of a wind turbine are dimensions. </p>
public struct Dimension: Equatable {
    /// <p>The data type of the dimension for the time series data point.</p>
    public let dimensionValueType: DimensionValueType?
    /// <p>
    ///          Dimension represents the meta data attributes of the time series.
    ///          For example, the name and availability zone of an EC2 instance or
    ///          the name of the manufacturer of a wind turbine are dimensions.
    ///
    ///       </p>
    ///          <p>For constraints on Dimension names,
    ///          see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html#limits.naming">Naming Constraints</a>.</p>
    public let name: String?
    /// <p>The value of the dimension.</p>
    public let value: String?

    public init (
        dimensionValueType: DimensionValueType? = nil,
        name: String? = nil,
        value: String? = nil
    )
    {
        self.dimensionValueType = dimensionValueType
        self.name = name
        self.value = value
    }
}

public enum DimensionValueType {
    case varchar
    case sdkUnknown(String)
}

extension DimensionValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionValueType] {
        return [
            .varchar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .varchar: return "VARCHAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionValueType(rawValue: rawValue) ?? DimensionValueType.sdkUnknown(rawValue)
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case cachePeriodInMinutes = "CachePeriodInMinutes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if cachePeriodInMinutes != 0 {
            try encodeContainer.encode(cachePeriodInMinutes, forKey: .cachePeriodInMinutes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let cachePeriodInMinutesDecoded = try containerValues.decode(Int.self, forKey: .cachePeriodInMinutes)
        cachePeriodInMinutes = cachePeriodInMinutesDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), cachePeriodInMinutes: \(String(describing: cachePeriodInMinutes)))"}
}

/// <p>Represents an available endpoint against which to make API calls agaisnt, as well as the TTL for that endpoint.</p>
public struct Endpoint: Equatable {
    /// <p>An endpoint address.</p>
    public let address: String?
    /// <p>The TTL for the endpoint, in minutes.</p>
    public let cachePeriodInMinutes: Int

    public init (
        address: String? = nil,
        cachePeriodInMinutes: Int = 0
    )
    {
        self.address = address
        self.cachePeriodInMinutes = cachePeriodInMinutes
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Timestream was unable to fully process this request because of an internal server error.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEndpointException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEndpointException(message: \(String(describing: message)))"}
}

extension InvalidEndpointException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEndpointExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested endpoint was invalid.</p>
public struct InvalidEndpointException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEndpointExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEndpointExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListDatabasesInputBodyMiddleware: Middleware {
    public let id: String = "ListDatabasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

extension ListDatabasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatabasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDatabasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatabasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatabasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatabasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatabasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatabasesInput>
    public typealias MOutput = OperationOutput<ListDatabasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatabasesOutputError>
}

public struct ListDatabasesInput: Equatable {
    /// <p>The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let maxResults: Int?
    /// <p>The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatabasesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListDatabasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDatabasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatabasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatabasesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatabasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatabasesOutputResponse(databases: \(String(describing: databases)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatabasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatabasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.databases = output.databases
            self.nextToken = output.nextToken
        } else {
            self.databases = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatabasesOutputResponse: Equatable {
    /// <p>A list of database names.</p>
    public let databases: [Database]?
    /// <p>The pagination token. This parameter is returned when the response is truncated.</p>
    public let nextToken: String?

    public init (
        databases: [Database]? = nil,
        nextToken: String? = nil
    )
    {
        self.databases = databases
        self.nextToken = nextToken
    }
}

struct ListDatabasesOutputResponseBody: Equatable {
    public let databases: [Database]?
    public let nextToken: String?
}

extension ListDatabasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databases = "Databases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databasesContainer = try containerValues.decodeIfPresent([Database?].self, forKey: .databases)
        var databasesDecoded0:[Database]? = nil
        if let databasesContainer = databasesContainer {
            databasesDecoded0 = [Database]()
            for structure0 in databasesContainer {
                if let structure0 = structure0 {
                    databasesDecoded0?.append(structure0)
                }
            }
        }
        databases = databasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTablesInputBodyMiddleware: Middleware {
    public let id: String = "ListTablesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

extension ListTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesInput(databaseName: \(String(describing: databaseName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTablesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTablesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The total number of items to return in the output. If the total number of items available is more than the value specified, a NextToken is provided in the output. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let maxResults: Int?
    /// <p>The pagination token. To resume pagination, provide the NextToken value as argument of a subsequent API invocation.</p>
    public let nextToken: String?

    public init (
        databaseName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.databaseName = databaseName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTablesInputBody: Equatable {
    public let databaseName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTablesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTablesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesOutputResponse(nextToken: \(String(describing: nextToken)), tables: \(String(describing: tables)))"}
}

extension ListTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tables = output.tables
        } else {
            self.nextToken = nil
            self.tables = nil
        }
    }
}

public struct ListTablesOutputResponse: Equatable {
    /// <p>A token to specify where to start paginating. This is the NextToken from a previously truncated response.</p>
    public let nextToken: String?
    /// <p>A list of tables.</p>
    public let tables: [Table]?

    public init (
        nextToken: String? = nil,
        tables: [Table]? = nil
    )
    {
        self.nextToken = nextToken
        self.tables = tables
    }
}

struct ListTablesOutputResponseBody: Equatable {
    public let tables: [Table]?
    public let nextToken: String?
}

extension ListTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tables = "Tables"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([Table?].self, forKey: .tables)
        var tablesDecoded0:[Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    /// The Timestream resource with tags to be listed. This value is an Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    /// The tags currently associated with the Timestream resource.
    /// </p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum MeasureValueType {
    case bigint
    case boolean
    case double
    case varchar
    case sdkUnknown(String)
}

extension MeasureValueType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MeasureValueType] {
        return [
            .bigint,
            .boolean,
            .double,
            .varchar,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bigint: return "BIGINT"
        case .boolean: return "BOOLEAN"
        case .double: return "DOUBLE"
        case .varchar: return "VARCHAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MeasureValueType(rawValue: rawValue) ?? MeasureValueType.sdkUnknown(rawValue)
    }
}

extension Record: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case measureName = "MeasureName"
        case measureValue = "MeasureValue"
        case measureValueType = "MeasureValueType"
        case time = "Time"
        case timeUnit = "TimeUnit"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensions0 in dimensions {
                try dimensionsContainer.encode(dimensions0)
            }
        }
        if let measureName = measureName {
            try encodeContainer.encode(measureName, forKey: .measureName)
        }
        if let measureValue = measureValue {
            try encodeContainer.encode(measureValue, forKey: .measureValue)
        }
        if let measureValueType = measureValueType {
            try encodeContainer.encode(measureValueType.rawValue, forKey: .measureValueType)
        }
        if let time = time {
            try encodeContainer.encode(time, forKey: .time)
        }
        if let timeUnit = timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let measureNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .measureName)
        measureName = measureNameDecoded
        let measureValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .measureValue)
        measureValue = measureValueDecoded
        let measureValueTypeDecoded = try containerValues.decodeIfPresent(MeasureValueType.self, forKey: .measureValueType)
        measureValueType = measureValueTypeDecoded
        let timeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .time)
        time = timeDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension Record: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Record(dimensions: \(String(describing: dimensions)), measureName: \(String(describing: measureName)), measureValue: \(String(describing: measureValue)), measureValueType: \(String(describing: measureValueType)), time: \(String(describing: time)), timeUnit: \(String(describing: timeUnit)), version: \(String(describing: version)))"}
}

/// <p>Record represents a time series data point being written into
///        Timestream. Each record contains an array of dimensions. Dimensions
///        represent the meta data attributes of a time series data point such as
///        the instance name or availability zone of an EC2 instance. A record also
///        contains the measure name which is the name of the measure being collected
///        for example the CPU utilization of an EC2 instance. A record also contains
///        the measure value and the value type which is the data type of the measure value.
///        In addition, the record contains the timestamp when the measure was collected that
///        the timestamp unit which represents the granularity of the timestamp.
///        </p>
public struct Record: Equatable {
    /// <p>Contains the list of dimensions for time series data points.</p>
    public let dimensions: [Dimension]?
    /// <p>Measure represents the data attribute of the time series. For example, the CPU utilization of an EC2 instance or the RPM of a wind turbine are measures. </p>
    public let measureName: String?
    /// <p>
    /// Contains the measure value for the time series data point.
    /// </p>
    public let measureValue: String?
    /// <p>
    /// Contains the data type of the measure value for the time series data point.
    /// </p>
    public let measureValueType: MeasureValueType?
    /// <p>
    /// Contains the time at which the measure value for the data point was collected.
    /// The time value plus the unit provides the time elapsed since the epoch.
    /// For example, if the time value is <code>12345</code> and the unit is <code>ms</code>,
    ///    then <code>12345 ms</code> have elapsed since the epoch.
    /// </p>
    public let time: String?
    /// <p>
    /// The granularity of the timestamp unit. It indicates if the time value is in seconds, milliseconds, nanoseconds or other supported values.
    /// </p>
    public let timeUnit: TimeUnit?
    /// <p>64-bit attribute used for record updates.
    ///          Write requests for duplicate data with a higher version number will update the existing measure value and version.
    ///          In cases where the measure value is the same, <code>Version</code> will still be updated . Default value is to 1.</p>
    public let version: Int

    public init (
        dimensions: [Dimension]? = nil,
        measureName: String? = nil,
        measureValue: String? = nil,
        measureValueType: MeasureValueType? = nil,
        time: String? = nil,
        timeUnit: TimeUnit? = nil,
        version: Int = 0
    )
    {
        self.dimensions = dimensions
        self.measureName = measureName
        self.measureValue = measureValue
        self.measureValueType = measureValueType
        self.time = time
        self.timeUnit = timeUnit
        self.version = version
    }
}

extension RejectedRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case existingVersion = "ExistingVersion"
        case reason = "Reason"
        case recordIndex = "RecordIndex"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if existingVersion != 0 {
            try encodeContainer.encode(existingVersion, forKey: .existingVersion)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if recordIndex != 0 {
            try encodeContainer.encode(recordIndex, forKey: .recordIndex)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIndexDecoded = try containerValues.decode(Int.self, forKey: .recordIndex)
        recordIndex = recordIndexDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let existingVersionDecoded = try containerValues.decode(Int.self, forKey: .existingVersion)
        existingVersion = existingVersionDecoded
    }
}

extension RejectedRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectedRecord(existingVersion: \(String(describing: existingVersion)), reason: \(String(describing: reason)), recordIndex: \(String(describing: recordIndex)))"}
}

/// <p>
/// Records that were not successfully inserted into Timestream due to data validation issues
/// that must be resolved prior to reinserting time series data into the system.
/// </p>
public struct RejectedRecord: Equatable {
    /// <p>The existing version of the record.
    ///          This value is populated in scenarios where an identical record exists with a higher version than the version in the write request.</p>
    public let existingVersion: Int
    /// <p>
    ///          The reason why a record was not successfully inserted into Timestream. Possible causes of failure include:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                  Records with duplicate data where there are multiple records with the same dimensions,
    ///          timestamps, and measure names but different measure values.
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                  Records with timestamps that lie outside the retention duration of the memory store
    ///                </p>
    ///                <note>
    ///                   <p>When the retention window is updated, you will receive a <code>RejectedRecords</code> exception
    ///                   if you immediately try to ingest data within the new window.
    ///                   To avoid a <code>RejectedRecords</code> exception,
    ///                   wait until the duration of the new window to ingest new data.
    ///                   For further information,
    ///                   see
    ///                   <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/best-practices.html#configuration">
    ///                      Best Practices for Configuring Timestream</a>
    ///                   and
    ///                   <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/storage.html">the explanation of how storage works in Timestream</a>.</p>
    ///                </note>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                  Records with dimensions or measures that exceed the Timestream defined limits.
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             For more information, see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html">Access Management</a> in the Timestream Developer Guide.
    ///          </p>
    public let reason: String?
    /// <p>
    /// The index of the record in the input request for WriteRecords. Indexes begin with 0.
    /// </p>
    public let recordIndex: Int

    public init (
        existingVersion: Int = 0,
        reason: String? = nil,
        recordIndex: Int = 0
    )
    {
        self.existingVersion = existingVersion
        self.reason = reason
        self.recordIndex = recordIndex
    }
}

extension RejectedRecordsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RejectedRecordsException(message: \(String(describing: message)), rejectedRecords: \(String(describing: rejectedRecords)))"}
}

extension RejectedRecordsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RejectedRecordsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.rejectedRecords = output.rejectedRecords
        } else {
            self.message = nil
            self.rejectedRecords = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///          WriteRecords would throw this exception in the following cases:
///       </p>
///          <ul>
///             <li>
///                <p>
///                  Records with duplicate data where there are multiple records with the same dimensions,
///          timestamps, and measure names but different measure values.
///                </p>
///             </li>
///             <li>
///                <p>
///                  Records with timestamps that lie outside the retention duration of the memory store
///                </p>
///             </li>
///             <li>
///                <p>
///                  Records with dimensions or measures that exceed the Timestream defined limits.
///                </p>
///             </li>
///          </ul>
///          <p>
///          For more information, see <a href="https://docs.aws.amazon.com/timestream/latest/developerguide/ts-limits.html">Access Management</a> in the Timestream Developer Guide.
///          </p>
public struct RejectedRecordsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var rejectedRecords: [RejectedRecord]?

    public init (
        message: String? = nil,
        rejectedRecords: [RejectedRecord]? = nil
    )
    {
        self.message = message
        self.rejectedRecords = rejectedRecords
    }
}

struct RejectedRecordsExceptionBody: Equatable {
    public let message: String?
    public let rejectedRecords: [RejectedRecord]?
}

extension RejectedRecordsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case rejectedRecords = "RejectedRecords"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let rejectedRecordsContainer = try containerValues.decodeIfPresent([RejectedRecord?].self, forKey: .rejectedRecords)
        var rejectedRecordsDecoded0:[RejectedRecord]? = nil
        if let rejectedRecordsContainer = rejectedRecordsContainer {
            rejectedRecordsDecoded0 = [RejectedRecord]()
            for structure0 in rejectedRecordsContainer {
                if let structure0 = structure0 {
                    rejectedRecordsDecoded0?.append(structure0)
                }
            }
        }
        rejectedRecords = rejectedRecordsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation tried to access a nonexistent resource. The resource might not be specified correctly, or its status might not be ACTIVE.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetentionProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case magneticStoreRetentionPeriodInDays = "MagneticStoreRetentionPeriodInDays"
        case memoryStoreRetentionPeriodInHours = "MemoryStoreRetentionPeriodInHours"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if magneticStoreRetentionPeriodInDays != 0 {
            try encodeContainer.encode(magneticStoreRetentionPeriodInDays, forKey: .magneticStoreRetentionPeriodInDays)
        }
        if memoryStoreRetentionPeriodInHours != 0 {
            try encodeContainer.encode(memoryStoreRetentionPeriodInHours, forKey: .memoryStoreRetentionPeriodInHours)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memoryStoreRetentionPeriodInHoursDecoded = try containerValues.decode(Int.self, forKey: .memoryStoreRetentionPeriodInHours)
        memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHoursDecoded
        let magneticStoreRetentionPeriodInDaysDecoded = try containerValues.decode(Int.self, forKey: .magneticStoreRetentionPeriodInDays)
        magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDaysDecoded
    }
}

extension RetentionProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetentionProperties(magneticStoreRetentionPeriodInDays: \(String(describing: magneticStoreRetentionPeriodInDays)), memoryStoreRetentionPeriodInHours: \(String(describing: memoryStoreRetentionPeriodInHours)))"}
}

/// <p>Retention properties contain the duration for which your time series data must be stored in the magnetic store and the memory store.
///       </p>
public struct RetentionProperties: Equatable {
    /// <p>The duration for which data must be stored in the magnetic store. </p>
    public let magneticStoreRetentionPeriodInDays: Int
    /// <p>The duration for which data must be stored in the memory store. </p>
    public let memoryStoreRetentionPeriodInHours: Int

    public init (
        magneticStoreRetentionPeriodInDays: Int = 0,
        memoryStoreRetentionPeriodInHours: Int = 0
    )
    {
        self.magneticStoreRetentionPeriodInDays = magneticStoreRetentionPeriodInDays
        self.memoryStoreRetentionPeriodInHours = memoryStoreRetentionPeriodInHours
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Instance quota of resource exceeded for this account.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Table: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case databaseName = "DatabaseName"
        case lastUpdatedTime = "LastUpdatedTime"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
        case tableStatus = "TableStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let lastUpdatedTime = lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime.timeIntervalSince1970, forKey: .lastUpdatedTime)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if let tableStatus = tableStatus {
            try encodeContainer.encode(tableStatus.rawValue, forKey: .tableStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableStatusDecoded = try containerValues.decodeIfPresent(TableStatus.self, forKey: .tableStatus)
        tableStatus = tableStatusDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension Table: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Table(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), databaseName: \(String(describing: databaseName)), lastUpdatedTime: \(String(describing: lastUpdatedTime)), retentionProperties: \(String(describing: retentionProperties)), tableName: \(String(describing: tableName)), tableStatus: \(String(describing: tableStatus)))"}
}

/// <p>Table represents a database table in Timestream. Tables contain one or more related time series. You can modify the retention duration of the memory store and the magnetic store for a table.
///       </p>
public struct Table: Equatable {
    /// <p>The Amazon Resource Name that uniquely identifies this table.</p>
    public let arn: String?
    /// <p>The time when the Timestream table was created. </p>
    public let creationTime: Date?
    /// <p>The name of the Timestream database that contains this table.</p>
    public let databaseName: String?
    /// <p>The time when the Timestream table was last updated.</p>
    public let lastUpdatedTime: Date?
    /// <p>The retention duration for the memory store and magnetic store.</p>
    public let retentionProperties: RetentionProperties?
    /// <p>The name of the Timestream table.</p>
    public let tableName: String?
    /// <p>The current state of the table:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>DELETING</code> - The table is being deleted.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ACTIVE</code> - The table is ready for use.</p>
    ///             </li>
    ///          </ul>
    public let tableStatus: TableStatus?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        databaseName: String? = nil,
        lastUpdatedTime: Date? = nil,
        retentionProperties: RetentionProperties? = nil,
        tableName: String? = nil,
        tableStatus: TableStatus? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.databaseName = databaseName
        self.lastUpdatedTime = lastUpdatedTime
        self.retentionProperties = retentionProperties
        self.tableName = tableName
        self.tableStatus = tableStatus
    }
}

public enum TableStatus {
    case active
    case deleting
    case sdkUnknown(String)
}

extension TableStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TableStatus] {
        return [
            .active,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TableStatus(rawValue: rawValue) ?? TableStatus.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>
/// A tag is a label that you assign to a Timestream database and/or table. Each tag consists
/// of a key and an optional value, both of which you define. Tags enable you to
/// categorize databases and/or tables, for example, by purpose, owner, or environment.
/// </p>
public struct Tag: Equatable {
    /// <p>
    /// The key of the tag. Tag keys are case sensitive.
    /// </p>
    public let key: String?
    /// <p>
    /// The value of the tag. Tag values are case-sensitive and can be null.
    /// </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///     Identifies the Timestream resource to which tags should be added. This value is an
    ///     Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: String?
    /// <p>
    /// The tags to be assigned to the Timestream resource.
    /// </p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Too many requests were made by a user exceeding service quotas. The request was throttled.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum TimeUnit {
    case microseconds
    case milliseconds
    case nanoseconds
    case seconds
    case sdkUnknown(String)
}

extension TimeUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimeUnit] {
        return [
            .microseconds,
            .milliseconds,
            .nanoseconds,
            .seconds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .microseconds: return "MICROSECONDS"
        case .milliseconds: return "MILLISECONDS"
        case .nanoseconds: return "NANOSECONDS"
        case .seconds: return "SECONDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///     The Timestream resource that the tags will be removed from. This value
    ///     is an Amazon Resource Name (ARN).
    /// </p>
    public let resourceARN: String?
    /// <p>
    ///     A list of tags keys. Existing tags of the resource whose keys are members of this
    ///     list will be removed from the Timestream resource.
    /// </p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatabaseInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

extension UpdateDatabaseInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatabaseInput(databaseName: \(String(describing: databaseName)), kmsKeyId: \(String(describing: kmsKeyId)))"}
}

extension UpdateDatabaseInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

public struct UpdateDatabaseInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatabaseInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatabaseInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatabaseOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatabaseInput>
    public typealias MOutput = OperationOutput<UpdateDatabaseOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatabaseOutputError>
}

public struct UpdateDatabaseInput: Equatable {
    /// <p>
    ///      The name of the database.
    ///    </p>
    public let databaseName: String?
    /// <p>
    ///       The identifier of the new KMS key (<code>KmsKeyId</code>) to be used to encrypt the data stored in the database.
    ///       If the <code>KmsKeyId</code> currently registered with the database is the same as the <code>KmsKeyId</code> in the
    ///       request, there will not be any update.
    ///    </p>
    ///          <p>You can specify the <code>KmsKeyId</code> using any of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Key ID: <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Key ARN: <code>arn:aws:kms:us-east-1:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias name: <code>alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Alias ARN: <code>arn:aws:kms:us-east-1:111122223333:alias/ExampleAlias</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?

    public init (
        databaseName: String? = nil,
        kmsKeyId: String? = nil
    )
    {
        self.databaseName = databaseName
        self.kmsKeyId = kmsKeyId
    }
}

struct UpdateDatabaseInputBody: Equatable {
    public let databaseName: String?
    public let kmsKeyId: String?
}

extension UpdateDatabaseInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case kmsKeyId = "KmsKeyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateDatabaseOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatabaseOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatabaseOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatabaseOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatabaseOutputResponse(database: \(String(describing: database)))"}
}

extension UpdateDatabaseOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDatabaseOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.database = output.database
        } else {
            self.database = nil
        }
    }
}

public struct UpdateDatabaseOutputResponse: Equatable {
    /// <p>A top level container for a table. Databases and tables are the
    ///       fundamental management concepts in Amazon Timestream. All tables in a
    ///       database are encrypted with the same KMS key.</p>
    public let database: Database?

    public init (
        database: Database? = nil
    )
    {
        self.database = database
    }
}

struct UpdateDatabaseOutputResponseBody: Equatable {
    public let database: Database?
}

extension UpdateDatabaseOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseDecoded = try containerValues.decodeIfPresent(Database.self, forKey: .database)
        database = databaseDecoded
    }
}

public struct UpdateTableInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTableInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

extension UpdateTableInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTableInput(databaseName: \(String(describing: databaseName)), retentionProperties: \(String(describing: retentionProperties)), tableName: \(String(describing: tableName)))"}
}

extension UpdateTableInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let retentionProperties = retentionProperties {
            try encodeContainer.encode(retentionProperties, forKey: .retentionProperties)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct UpdateTableInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTableInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

public struct UpdateTableInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTableInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTableInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTableOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTableInput>
    public typealias MOutput = OperationOutput<UpdateTableOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTableOutputError>
}

public struct UpdateTableInput: Equatable {
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>The retention duration of the memory store and the magnetic store.</p>
    public let retentionProperties: RetentionProperties?
    /// <p>The name of the Timesream table.</p>
    public let tableName: String?

    public init (
        databaseName: String? = nil,
        retentionProperties: RetentionProperties? = nil,
        tableName: String? = nil
    )
    {
        self.databaseName = databaseName
        self.retentionProperties = retentionProperties
        self.tableName = tableName
    }
}

struct UpdateTableInputBody: Equatable {
    public let databaseName: String?
    public let tableName: String?
    public let retentionProperties: RetentionProperties?
}

extension UpdateTableInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case databaseName = "DatabaseName"
        case retentionProperties = "RetentionProperties"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let retentionPropertiesDecoded = try containerValues.decodeIfPresent(RetentionProperties.self, forKey: .retentionProperties)
        retentionProperties = retentionPropertiesDecoded
    }
}

extension UpdateTableOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTableOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTableOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTableOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTableOutputResponse(table: \(String(describing: table)))"}
}

extension UpdateTableOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTableOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.table = output.table
        } else {
            self.table = nil
        }
    }
}

public struct UpdateTableOutputResponse: Equatable {
    /// <p>The updated Timestream table.</p>
    public let table: Table?

    public init (
        table: Table? = nil
    )
    {
        self.table = table
    }
}

struct UpdateTableOutputResponseBody: Equatable {
    public let table: Table?
}

extension UpdateTableOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case table = "Table"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableDecoded = try containerValues.decodeIfPresent(Table.self, forKey: .table)
        table = tableDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> Invalid or malformed request.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct WriteRecordsInputBodyMiddleware: Middleware {
    public let id: String = "WriteRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteRecordsOutputError>
}

extension WriteRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteRecordsInput(commonAttributes: \(String(describing: commonAttributes)), databaseName: \(String(describing: databaseName)), records: \(String(describing: records)), tableName: \(String(describing: tableName)))"}
}

extension WriteRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commonAttributes = commonAttributes {
            try encodeContainer.encode(commonAttributes, forKey: .commonAttributes)
        }
        if let databaseName = databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }
}

public struct WriteRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "WriteRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteRecordsOutputError>
}

public struct WriteRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "WriteRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<WriteRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<WriteRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<WriteRecordsInput>
    public typealias MOutput = OperationOutput<WriteRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<WriteRecordsOutputError>
}

public struct WriteRecordsInput: Equatable {
    /// <p>A record containing the common measure and dimension attributes
    ///        shared across all the records in the request. The measure and dimension
    ///        attributes specified in here will be merged with the measure and dimension
    ///        attributes in the records object when the data is written into Timestream.
    ///        </p>
    public let commonAttributes: Record?
    /// <p>The name of the Timestream database.</p>
    public let databaseName: String?
    /// <p>An array of records containing the unique dimension and measure
    ///        attributes for each time series data point.
    ///        </p>
    public let records: [Record]?
    /// <p>The name of the Timesream table.</p>
    public let tableName: String?

    public init (
        commonAttributes: Record? = nil,
        databaseName: String? = nil,
        records: [Record]? = nil,
        tableName: String? = nil
    )
    {
        self.commonAttributes = commonAttributes
        self.databaseName = databaseName
        self.records = records
        self.tableName = tableName
    }
}

struct WriteRecordsInputBody: Equatable {
    public let databaseName: String?
    public let tableName: String?
    public let commonAttributes: Record?
    public let records: [Record]?
}

extension WriteRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commonAttributes = "CommonAttributes"
        case databaseName = "DatabaseName"
        case records = "Records"
        case tableName = "TableName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let commonAttributesDecoded = try containerValues.decodeIfPresent(Record.self, forKey: .commonAttributes)
        commonAttributes = commonAttributesDecoded
        let recordsContainer = try containerValues.decodeIfPresent([Record?].self, forKey: .records)
        var recordsDecoded0:[Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension WriteRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension WriteRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEndpointException" : self = .invalidEndpointException(try InvalidEndpointException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RejectedRecordsException" : self = .rejectedRecordsException(try RejectedRecordsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum WriteRecordsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case invalidEndpointException(InvalidEndpointException)
    case rejectedRecordsException(RejectedRecordsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension WriteRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteRecordsOutputResponse()"}
}

extension WriteRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct WriteRecordsOutputResponse: Equatable {

    public init() {}
}

struct WriteRecordsOutputResponseBody: Equatable {
}

extension WriteRecordsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
