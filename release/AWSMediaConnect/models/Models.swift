// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AddFlowMediaStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofaddmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofaddmediastreamrequest0)
            }
        }
    }
}

extension AddFlowMediaStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams"
    }
}

/// A request to add media streams to the flow.
public struct AddFlowMediaStreamsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The media streams that you want to add to the flow.
    /// This member is required.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?

    public init (
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsInputBody: Swift.Equatable {
    let mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
}

extension AddFlowMediaStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStreams = "mediaStreams"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

extension AddFlowMediaStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowMediaStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowMediaStreamsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowMediaStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddFlowMediaStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStreams = output.mediaStreams
        } else {
            self.flowArn = nil
            self.mediaStreams = nil
        }
    }
}

public struct AddFlowMediaStreamsOutputResponse: Swift.Equatable {
    /// The ARN of the flow that you added media streams to.
    public var flowArn: Swift.String?
    /// The media streams that you added to the flow.
    public var mediaStreams: [MediaConnectClientTypes.MediaStream]?

    public init (
        flowArn: Swift.String? = nil,
        mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreams = mediaStreams
    }
}

struct AddFlowMediaStreamsOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStreams: [MediaConnectClientTypes.MediaStream]?
}

extension AddFlowMediaStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
    }
}

extension AddFlowOutputs420Exception {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddFlowOutputs420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct AddFlowOutputs420Exception: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AddFlowOutputs420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AddFlowOutputs420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AddFlowOutputsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofaddoutputrequest0 in outputs {
                try outputsContainer.encode(__listofaddoutputrequest0)
            }
        }
    }
}

extension AddFlowOutputsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs"
    }
}

/// A request to add outputs to the specified flow.
public struct AddFlowOutputsInput: Swift.Equatable {
    /// The flow that you want to add outputs to.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of outputs that you want to add.
    /// This member is required.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?

    public init (
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsInputBody: Swift.Equatable {
    let outputs: [MediaConnectClientTypes.AddOutputRequest]?
}

extension AddFlowOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputs = "outputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension AddFlowOutputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowOutputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AddFlowOutputs420Exception" : self = .addFlowOutputs420Exception(try AddFlowOutputs420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowOutputsOutputError: Swift.Error, Swift.Equatable {
    case addFlowOutputs420Exception(AddFlowOutputs420Exception)
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowOutputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddFlowOutputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.outputs = output.outputs
        } else {
            self.flowArn = nil
            self.outputs = nil
        }
    }
}

public struct AddFlowOutputsOutputResponse: Swift.Equatable {
    /// The ARN of the flow that these outputs were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added outputs.
    public var outputs: [MediaConnectClientTypes.Output]?

    public init (
        flowArn: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.Output]? = nil
    )
    {
        self.flowArn = flowArn
        self.outputs = outputs
    }
}

struct AddFlowOutputsOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let outputs: [MediaConnectClientTypes.Output]?
}

extension AddFlowOutputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case outputs = "outputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
    }
}

extension AddFlowSourcesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsetsourcerequest0 in sources {
                try sourcesContainer.encode(__listofsetsourcerequest0)
            }
        }
    }
}

extension AddFlowSourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source"
    }
}

/// A request to add sources to the flow.
public struct AddFlowSourcesInput: Swift.Equatable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of sources that you want to add.
    /// This member is required.
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?

    public init (
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesInputBody: Swift.Equatable {
    let sources: [MediaConnectClientTypes.SetSourceRequest]?
}

extension AddFlowSourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sources = "sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AddFlowSourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowSourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowSourcesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowSourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddFlowSourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.sources = output.sources
        } else {
            self.flowArn = nil
            self.sources = nil
        }
    }
}

public struct AddFlowSourcesOutputResponse: Swift.Equatable {
    /// The ARN of the flow that these sources were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added sources.
    public var sources: [MediaConnectClientTypes.Source]?

    public init (
        flowArn: Swift.String? = nil,
        sources: [MediaConnectClientTypes.Source]? = nil
    )
    {
        self.flowArn = flowArn
        self.sources = sources
    }
}

struct AddFlowSourcesOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let sources: [MediaConnectClientTypes.Source]?
}

extension AddFlowSourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case sources = "sources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AddFlowVpcInterfacesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterfacerequest0)
            }
        }
    }
}

extension AddFlowVpcInterfacesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces"
    }
}

/// A request to add VPC interfaces to the flow.
public struct AddFlowVpcInterfacesInput: Swift.Equatable {
    /// The flow that you want to mutate.
    /// This member is required.
    public var flowArn: Swift.String?
    /// A list of VPC interfaces that you want to add.
    /// This member is required.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init (
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesInputBody: Swift.Equatable {
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?
}

extension AddFlowVpcInterfacesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension AddFlowVpcInterfacesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddFlowVpcInterfacesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddFlowVpcInterfacesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddFlowVpcInterfacesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AddFlowVpcInterfacesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.vpcInterfaces = output.vpcInterfaces
        } else {
            self.flowArn = nil
            self.vpcInterfaces = nil
        }
    }
}

public struct AddFlowVpcInterfacesOutputResponse: Swift.Equatable {
    /// The ARN of the flow that these VPC interfaces were added to.
    public var flowArn: Swift.String?
    /// The details of the newly added VPC interfaces.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

    public init (
        flowArn: Swift.String? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaces = vpcInterfaces
    }
}

struct AddFlowVpcInterfacesOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?
}

extension AddFlowVpcInterfacesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension MediaConnectClientTypes.AddMediaStreamRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaStreamId = mediaStreamId {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that you want to add to the flow.
    public struct AddMediaStreamRequest: Swift.Equatable {
        /// The attributes that you want to assign to the new media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
        /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init (
            attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }

}

extension MediaConnectClientTypes.AddOutputRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let maxLatency = maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfigurationrequest0)
            }
        }
        if let minLatency = minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let smoothingLatency = smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The output that you want to add to this flow.
    public struct AddOutputRequest: Swift.Equatable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The maximum latency in milliseconds for Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The media streams that are associated with the output, and the parameters for those associations.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the output. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// The protocol to use for the output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull output stream.
        public var remoteId: Swift.String?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init (
            cidrAllowList: [Swift.String]? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            maxLatency: Swift.Int? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            port: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            smoothingLatency: Swift.Int? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.maxLatency = maxLatency
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.minLatency = minLatency
            self.name = name
            self.port = port
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.smoothingLatency = smoothingLatency
            self.streamId = streamId
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes {
    public enum Algorithm: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes128
        case aes192
        case aes256
        case sdkUnknown(Swift.String)

        public static var allCases: [Algorithm] {
            return [
                .aes128,
                .aes192,
                .aes256,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes128: return "aes128"
            case .aes192: return "aes192"
            case .aes256: return "aes256"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Algorithm(rawValue: rawValue) ?? Algorithm.sdkUnknown(rawValue)
        }
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes {
    public enum Colorimetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bt2020
        case bt2100
        case bt601
        case bt709
        case st20651
        case st20653
        case xyz
        case sdkUnknown(Swift.String)

        public static var allCases: [Colorimetry] {
            return [
                .bt2020,
                .bt2100,
                .bt601,
                .bt709,
                .st20651,
                .st20653,
                .xyz,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bt2020: return "BT2020"
            case .bt2100: return "BT2100"
            case .bt601: return "BT601"
            case .bt709: return "BT709"
            case .st20651: return "ST2065-1"
            case .st20653: return "ST2065-3"
            case .xyz: return "XYZ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Colorimetry(rawValue: rawValue) ?? Colorimetry.sdkUnknown(rawValue)
        }
    }
}

extension CreateFlow420Exception {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFlow420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct CreateFlow420Exception: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CreateFlow420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreateFlow420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofgrantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(__listofgrantentitlementrequest0)
            }
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofaddmediastreamrequest0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofaddmediastreamrequest0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofaddoutputrequest0 in outputs {
                try outputsContainer.encode(__listofaddoutputrequest0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsetsourcerequest0 in sources {
                try sourcesContainer.encode(__listofsetsourcerequest0)
            }
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterfacerequest0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterfacerequest0)
            }
        }
    }
}

extension CreateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/flows"
    }
}

/// Creates a new flow. The request must include one source. The request optionally can include outputs (up to 50) and entitlements (up to 50).
public struct CreateFlowInput: Swift.Equatable {
    /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS Region.
    public var availabilityZone: Swift.String?
    /// The entitlements that you want to grant on a flow.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// The media streams that you want to add to the flow. You can associate these media streams with sources and outputs on the flow.
    public var mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    /// The name of the flow.
    /// This member is required.
    public var name: Swift.String?
    /// The outputs that you want to add to this flow.
    public var outputs: [MediaConnectClientTypes.AddOutputRequest]?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.SetSourceRequest?
    /// The settings for source failover
    public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    public var sources: [MediaConnectClientTypes.SetSourceRequest]?
    /// The VPC interfaces you want on the flow.
    public var vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?

    public init (
        availabilityZone: Swift.String? = nil,
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]? = nil,
        name: Swift.String? = nil,
        outputs: [MediaConnectClientTypes.AddOutputRequest]? = nil,
        source: MediaConnectClientTypes.SetSourceRequest? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
        sources: [MediaConnectClientTypes.SetSourceRequest]? = nil,
        vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.entitlements = entitlements
        self.mediaStreams = mediaStreams
        self.name = name
        self.outputs = outputs
        self.source = source
        self.sourceFailoverConfig = sourceFailoverConfig
        self.sources = sources
        self.vpcInterfaces = vpcInterfaces
    }
}

struct CreateFlowInputBody: Swift.Equatable {
    let availabilityZone: Swift.String?
    let entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    let mediaStreams: [MediaConnectClientTypes.AddMediaStreamRequest]?
    let name: Swift.String?
    let outputs: [MediaConnectClientTypes.AddOutputRequest]?
    let source: MediaConnectClientTypes.SetSourceRequest?
    let sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
    let sources: [MediaConnectClientTypes.SetSourceRequest]?
    let vpcInterfaces: [MediaConnectClientTypes.VpcInterfaceRequest]?
}

extension CreateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case entitlements = "entitlements"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case vpcInterfaces = "vpcInterfaces"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddMediaStreamRequest?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.AddMediaStreamRequest]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.AddMediaStreamRequest]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.AddOutputRequest?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.AddOutputRequest]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.AddOutputRequest]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SetSourceRequest.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.SetSourceRequest?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.SetSourceRequest]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.SetSourceRequest]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterfaceRequest?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterfaceRequest]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterfaceRequest]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension CreateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreateFlow420Exception" : self = .createFlow420Exception(try CreateFlow420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case createFlow420Exception(CreateFlow420Exception)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct CreateFlowOutputResponse: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init (
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct CreateFlowOutputResponseBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
}

extension CreateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

extension DeleteFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

public struct DeleteFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to delete.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DeleteFlowInputBody: Swift.Equatable {
}

extension DeleteFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct DeleteFlowOutputResponse: Swift.Equatable {
    /// The ARN of the flow that was deleted.
    public var flowArn: Swift.String?
    /// The status of the flow when the DeleteFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init (
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct DeleteFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension DeleteFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension DescribeFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

public struct DescribeFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to describe.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct DescribeFlowInputBody: Swift.Equatable {
}

extension DescribeFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
            self.messages = output.messages
        } else {
            self.flow = nil
            self.messages = nil
        }
    }
}

public struct DescribeFlowOutputResponse: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?
    /// Messages that provide the state of the flow.
    public var messages: MediaConnectClientTypes.Messages?

    public init (
        flow: MediaConnectClientTypes.Flow? = nil,
        messages: MediaConnectClientTypes.Messages? = nil
    )
    {
        self.flow = flow
        self.messages = messages
    }
}

struct DescribeFlowOutputResponseBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
    let messages: MediaConnectClientTypes.Messages?
}

extension DescribeFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
        case messages = "messages"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
        let messagesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Messages.self, forKey: .messages)
        messages = messagesDecoded
    }
}

extension DescribeOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let offeringArn = offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

public struct DescribeOfferingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?

    public init (
        offeringArn: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
    }
}

struct DescribeOfferingInputBody: Swift.Equatable {
}

extension DescribeOfferingInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOfferingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.offering = output.offering
        } else {
            self.offering = nil
        }
    }
}

public struct DescribeOfferingOutputResponse: Swift.Equatable {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public var offering: MediaConnectClientTypes.Offering?

    public init (
        offering: MediaConnectClientTypes.Offering? = nil
    )
    {
        self.offering = offering
    }
}

struct DescribeOfferingOutputResponseBody: Swift.Equatable {
    let offering: MediaConnectClientTypes.Offering?
}

extension DescribeOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offering = "offering"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Offering.self, forKey: .offering)
        offering = offeringDecoded
    }
}

extension DescribeReservationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let reservationArn = reservationArn else {
            return nil
        }
        return "/v1/reservations/\(reservationArn.urlPercentEncoding())"
    }
}

public struct DescribeReservationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the reservation.
    /// This member is required.
    public var reservationArn: Swift.String?

    public init (
        reservationArn: Swift.String? = nil
    )
    {
        self.reservationArn = reservationArn
    }
}

struct DescribeReservationInputBody: Swift.Equatable {
}

extension DescribeReservationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeReservationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReservationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReservationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReservationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReservationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct DescribeReservationOutputResponse: Swift.Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init (
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct DescribeReservationOutputResponseBody: Swift.Equatable {
    let reservation: MediaConnectClientTypes.Reservation?
}

extension DescribeReservationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservation = "reservation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

extension MediaConnectClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
        case outboundIp = "outboundIp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if let destinationPort = destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
        if let outboundIp = outboundIp {
            try encodeContainer.encode(outboundIp, forKey: .outboundIp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Interface.self, forKey: .interface)
        interface = interfaceDecoded
        let outboundIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outboundIp)
        outboundIp = outboundIpDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that are associated with an outbound media stream.
    public struct DestinationConfiguration: Swift.Equatable {
        /// The IP address where contents of the media stream will be sent.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port to use when the content of the media stream is distributed to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that is used for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?
        /// The IP address that the receiver requires in order to establish a connection with the flow. This value is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the CDI or ST 2110 JPEG XS protocol.
        /// This member is required.
        public var outboundIp: Swift.String?

        public init (
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil,
            outboundIp: Swift.String? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
            self.outboundIp = outboundIp
        }
    }

}

extension MediaConnectClientTypes.DestinationConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationIp = "destinationIp"
        case destinationPort = "destinationPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationIp = destinationIp {
            try encodeContainer.encode(destinationIp, forKey: .destinationIp)
        }
        if let destinationPort = destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationIp)
        destinationIp = destinationIpDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that you want to associate with an outbound media stream.
    public struct DestinationConfigurationRequest: Swift.Equatable {
        /// The IP address where you want MediaConnect to send contents of the media stream.
        /// This member is required.
        public var destinationIp: Swift.String?
        /// The port that you want MediaConnect to use when it distributes the media stream to the output.
        /// This member is required.
        public var destinationPort: Swift.Int?
        /// The VPC interface that you want to use for the media stream associated with the output.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init (
            destinationIp: Swift.String? = nil,
            destinationPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.destinationIp = destinationIp
            self.destinationPort = destinationPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes {
    public enum DurationUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case months
        case sdkUnknown(Swift.String)

        public static var allCases: [DurationUnits] {
            return [
                .months,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .months: return "MONTHS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DurationUnits(rawValue: rawValue) ?? DurationUnits.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum EncoderProfile: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case main
        case sdkUnknown(Swift.String)

        public static var allCases: [EncoderProfile] {
            return [
                .high,
                .main,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "high"
            case .main: return "main"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncoderProfile(rawValue: rawValue) ?? EncoderProfile.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum EncodingName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jxsv
        case pcm
        case raw
        case smpte291
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingName] {
            return [
                .jxsv,
                .pcm,
                .raw,
                .smpte291,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jxsv: return "jxsv"
            case .pcm: return "pcm"
            case .raw: return "raw"
            case .smpte291: return "smpte291"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingName(rawValue: rawValue) ?? EncodingName.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.EncodingParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFactor = compressionFactor {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension MediaConnectClientTypes {
    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParameters: Swift.Equatable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init (
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }

}

extension MediaConnectClientTypes.EncodingParametersRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compressionFactor = "compressionFactor"
        case encoderProfile = "encoderProfile"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compressionFactor = compressionFactor {
            try encodeContainer.encode(compressionFactor, forKey: .compressionFactor)
        }
        if let encoderProfile = encoderProfile {
            try encodeContainer.encode(encoderProfile.rawValue, forKey: .encoderProfile)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compressionFactorDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .compressionFactor)
        compressionFactor = compressionFactorDecoded
        let encoderProfileDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncoderProfile.self, forKey: .encoderProfile)
        encoderProfile = encoderProfileDecoded
    }
}

extension MediaConnectClientTypes {
    /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
    public struct EncodingParametersRequest: Swift.Equatable {
        /// A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are floating point numbers in the range of 3.0 to 10.0, inclusive.
        /// This member is required.
        public var compressionFactor: Swift.Double?
        /// A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, if at least one source on the flow uses the CDI protocol.
        /// This member is required.
        public var encoderProfile: MediaConnectClientTypes.EncoderProfile?

        public init (
            compressionFactor: Swift.Double? = nil,
            encoderProfile: MediaConnectClientTypes.EncoderProfile? = nil
        )
        {
            self.compressionFactor = compressionFactor
            self.encoderProfile = encoderProfile
        }
    }

}

extension MediaConnectClientTypes.Encryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Information about the encryption of the flow.
    public struct Encryption: Swift.Equatable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        /// This member is required.
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init (
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }

}

extension MediaConnectClientTypes.Entitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The settings for a flow entitlement.
    public struct Entitlement: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// An indication of whether the entitlement is enabled.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement.
        /// This member is required.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init (
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }

}

extension MediaConnectClientTypes {
    public enum EntitlementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntitlementStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntitlementStatus(rawValue: rawValue) ?? EntitlementStatus.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.FailoverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverMode = "failoverMode"
        case recoveryWindow = "recoveryWindow"
        case sourcePriority = "sourcePriority"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverMode = failoverMode {
            try encodeContainer.encode(failoverMode.rawValue, forKey: .failoverMode)
        }
        if let recoveryWindow = recoveryWindow {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let sourcePriority = sourcePriority {
            try encodeContainer.encode(sourcePriority, forKey: .sourcePriority)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverMode.self, forKey: .failoverMode)
        failoverMode = failoverModeDecoded
        let recoveryWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let sourcePriorityDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourcePriority.self, forKey: .sourcePriority)
        sourcePriority = sourcePriorityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for source failover
    public struct FailoverConfig: Swift.Equatable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Search window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init (
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }

}

extension MediaConnectClientTypes {
    public enum FailoverMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failover
        case merge
        case sdkUnknown(Swift.String)

        public static var allCases: [FailoverMode] {
            return [
                .failover,
                .merge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failover: return "FAILOVER"
            case .merge: return "MERGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailoverMode(rawValue: rawValue) ?? FailoverMode.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.Flow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case egressIp = "egressIp"
        case entitlements = "entitlements"
        case flowArn = "flowArn"
        case mediaStreams = "mediaStreams"
        case name = "name"
        case outputs = "outputs"
        case source = "source"
        case sourceFailoverConfig = "sourceFailoverConfig"
        case sources = "sources"
        case status = "status"
        case vpcInterfaces = "vpcInterfaces"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let egressIp = egressIp {
            try encodeContainer.encode(egressIp, forKey: .egressIp)
        }
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofentitlement0 in entitlements {
                try entitlementsContainer.encode(__listofentitlement0)
            }
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let mediaStreams = mediaStreams {
            var mediaStreamsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreams)
            for __listofmediastream0 in mediaStreams {
                try mediaStreamsContainer.encode(__listofmediastream0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputs = outputs {
            var outputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputs)
            for __listofoutput0 in outputs {
                try outputsContainer.encode(__listofoutput0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for __listofsource0 in sources {
                try sourcesContainer.encode(__listofsource0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let vpcInterfaces = vpcInterfaces {
            var vpcInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcInterfaces)
            for __listofvpcinterface0 in vpcInterfaces {
                try vpcInterfacesContainer.encode(__listofvpcinterface0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let egressIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .egressIp)
        egressIp = egressIpDecoded
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStream?].self, forKey: .mediaStreams)
        var mediaStreamsDecoded0:[MediaConnectClientTypes.MediaStream]? = nil
        if let mediaStreamsContainer = mediaStreamsContainer {
            mediaStreamsDecoded0 = [MediaConnectClientTypes.MediaStream]()
            for structure0 in mediaStreamsContainer {
                if let structure0 = structure0 {
                    mediaStreamsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreams = mediaStreamsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Output?].self, forKey: .outputs)
        var outputsDecoded0:[MediaConnectClientTypes.Output]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [MediaConnectClientTypes.Output]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Source?].self, forKey: .sources)
        var sourcesDecoded0:[MediaConnectClientTypes.Source]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [MediaConnectClientTypes.Source]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let vpcInterfacesContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.VpcInterface?].self, forKey: .vpcInterfaces)
        var vpcInterfacesDecoded0:[MediaConnectClientTypes.VpcInterface]? = nil
        if let vpcInterfacesContainer = vpcInterfacesContainer {
            vpcInterfacesDecoded0 = [MediaConnectClientTypes.VpcInterface]()
            for structure0 in vpcInterfacesContainer {
                if let structure0 = structure0 {
                    vpcInterfacesDecoded0?.append(structure0)
                }
            }
        }
        vpcInterfaces = vpcInterfacesDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public struct Flow: Swift.Equatable {
        /// The Availability Zone that you want to create the flow in. These options are limited to the Availability Zones within the current AWS.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The IP address from which video will be sent to output destinations.
        public var egressIp: Swift.String?
        /// The entitlements in this flow.
        /// This member is required.
        public var entitlements: [MediaConnectClientTypes.Entitlement]?
        /// The Amazon Resource Name (ARN), a unique identifier for any AWS resource, of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The media streams that are associated with the flow. After you associate a media stream with a source, you can also associate it with outputs on the flow.
        public var mediaStreams: [MediaConnectClientTypes.MediaStream]?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The outputs in this flow.
        /// This member is required.
        public var outputs: [MediaConnectClientTypes.Output]?
        /// The settings for the source of the flow.
        /// This member is required.
        public var source: MediaConnectClientTypes.Source?
        /// The settings for source failover
        public var sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig?
        public var sources: [MediaConnectClientTypes.Source]?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?
        /// The VPC Interfaces for this flow.
        public var vpcInterfaces: [MediaConnectClientTypes.VpcInterface]?

        public init (
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            egressIp: Swift.String? = nil,
            entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
            flowArn: Swift.String? = nil,
            mediaStreams: [MediaConnectClientTypes.MediaStream]? = nil,
            name: Swift.String? = nil,
            outputs: [MediaConnectClientTypes.Output]? = nil,
            source: MediaConnectClientTypes.Source? = nil,
            sourceFailoverConfig: MediaConnectClientTypes.FailoverConfig? = nil,
            sources: [MediaConnectClientTypes.Source]? = nil,
            status: MediaConnectClientTypes.Status? = nil,
            vpcInterfaces: [MediaConnectClientTypes.VpcInterface]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.egressIp = egressIp
            self.entitlements = entitlements
            self.flowArn = flowArn
            self.mediaStreams = mediaStreams
            self.name = name
            self.outputs = outputs
            self.source = source
            self.sourceFailoverConfig = sourceFailoverConfig
            self.sources = sources
            self.status = status
            self.vpcInterfaces = vpcInterfaces
        }
    }

}

extension MediaConnectClientTypes.Fmtp: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension MediaConnectClientTypes {
    /// FMTP
    public struct Fmtp: Swift.Equatable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init (
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }

}

extension MediaConnectClientTypes.FmtpRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelOrder = "channelOrder"
        case colorimetry = "colorimetry"
        case exactFramerate = "exactFramerate"
        case par = "par"
        case range = "range"
        case scanMode = "scanMode"
        case tcs = "tcs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelOrder = channelOrder {
            try encodeContainer.encode(channelOrder, forKey: .channelOrder)
        }
        if let colorimetry = colorimetry {
            try encodeContainer.encode(colorimetry.rawValue, forKey: .colorimetry)
        }
        if let exactFramerate = exactFramerate {
            try encodeContainer.encode(exactFramerate, forKey: .exactFramerate)
        }
        if let par = par {
            try encodeContainer.encode(par, forKey: .par)
        }
        if let range = range {
            try encodeContainer.encode(range.rawValue, forKey: .range)
        }
        if let scanMode = scanMode {
            try encodeContainer.encode(scanMode.rawValue, forKey: .scanMode)
        }
        if let tcs = tcs {
            try encodeContainer.encode(tcs.rawValue, forKey: .tcs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelOrderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelOrder)
        channelOrder = channelOrderDecoded
        let colorimetryDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Colorimetry.self, forKey: .colorimetry)
        colorimetry = colorimetryDecoded
        let exactFramerateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exactFramerate)
        exactFramerate = exactFramerateDecoded
        let parDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .par)
        par = parDecoded
        let rangeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Range.self, forKey: .range)
        range = rangeDecoded
        let scanModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ScanMode.self, forKey: .scanMode)
        scanMode = scanModeDecoded
        let tcsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Tcs.self, forKey: .tcs)
        tcs = tcsDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings that you want to use to define the media stream.
    public struct FmtpRequest: Swift.Equatable {
        /// The format of the audio channel.
        public var channelOrder: Swift.String?
        /// The format that is used for the representation of color.
        public var colorimetry: MediaConnectClientTypes.Colorimetry?
        /// The frame rate for the video stream, in frames/second. For example: 60000/1001. If you specify a whole number, MediaConnect uses a ratio of N/1. For example, if you specify 60, MediaConnect uses 60/1 as the exactFramerate.
        public var exactFramerate: Swift.String?
        /// The pixel aspect ratio (PAR) of the video.
        public var par: Swift.String?
        /// The encoding range of the video.
        public var range: MediaConnectClientTypes.Range?
        /// The type of compression that was used to smooth the video’s appearance.
        public var scanMode: MediaConnectClientTypes.ScanMode?
        /// The transfer characteristic system (TCS) that is used in the video.
        public var tcs: MediaConnectClientTypes.Tcs?

        public init (
            channelOrder: Swift.String? = nil,
            colorimetry: MediaConnectClientTypes.Colorimetry? = nil,
            exactFramerate: Swift.String? = nil,
            par: Swift.String? = nil,
            range: MediaConnectClientTypes.Range? = nil,
            scanMode: MediaConnectClientTypes.ScanMode? = nil,
            tcs: MediaConnectClientTypes.Tcs? = nil
        )
        {
            self.channelOrder = channelOrder
            self.colorimetry = colorimetry
            self.exactFramerate = exactFramerate
            self.par = par
            self.range = range
            self.scanMode = scanMode
            self.tcs = tcs
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.GrantEntitlementRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case name = "name"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension MediaConnectClientTypes {
    /// The entitlements that you want to grant on a flow.
    public struct GrantEntitlementRequest: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
        public var description: Swift.String?
        /// The type of encryption that will be used on the output that is associated with this entitlement.
        public var encryption: MediaConnectClientTypes.Encryption?
        /// An indication of whether the new entitlement should be enabled or disabled as soon as it is created. If you don’t specify the entitlementStatus field in your request, MediaConnect sets it to ENABLED.
        public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
        /// The name of the entitlement. This value must be unique within the current flow.
        public var name: Swift.String?
        /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flows using your content as the source.
        /// This member is required.
        public var subscribers: [Swift.String]?

        public init (
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
            name: Swift.String? = nil,
            subscribers: [Swift.String]? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.encryption = encryption
            self.entitlementStatus = entitlementStatus
            self.name = name
            self.subscribers = subscribers
        }
    }

}

extension GrantFlowEntitlements420Exception {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GrantFlowEntitlements420ExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct GrantFlowEntitlements420Exception: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct GrantFlowEntitlements420ExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension GrantFlowEntitlements420ExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GrantFlowEntitlementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entitlements = entitlements {
            var entitlementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entitlements)
            for __listofgrantentitlementrequest0 in entitlements {
                try entitlementsContainer.encode(__listofgrantentitlementrequest0)
            }
        }
    }
}

extension GrantFlowEntitlementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements"
    }
}

/// A request to grant entitlements on a flow.
public struct GrantFlowEntitlementsInput: Swift.Equatable {
    /// The list of entitlements that you want to grant.
    /// This member is required.
    public var entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
    /// The flow that you want to grant entitlements on.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsInputBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.GrantEntitlementRequest]?
}

extension GrantFlowEntitlementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.GrantEntitlementRequest?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.GrantEntitlementRequest]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.GrantEntitlementRequest]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
    }
}

extension GrantFlowEntitlementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GrantFlowEntitlementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "GrantFlowEntitlements420Exception" : self = .grantFlowEntitlements420Exception(try GrantFlowEntitlements420Exception(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GrantFlowEntitlementsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case grantFlowEntitlements420Exception(GrantFlowEntitlements420Exception)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GrantFlowEntitlementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GrantFlowEntitlementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.flowArn = output.flowArn
        } else {
            self.entitlements = nil
            self.flowArn = nil
        }
    }
}

public struct GrantFlowEntitlementsOutputResponse: Swift.Equatable {
    /// The entitlements that were just granted.
    public var entitlements: [MediaConnectClientTypes.Entitlement]?
    /// The ARN of the flow that these entitlements were granted to.
    public var flowArn: Swift.String?

    public init (
        entitlements: [MediaConnectClientTypes.Entitlement]? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.flowArn = flowArn
    }
}

struct GrantFlowEntitlementsOutputResponseBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.Entitlement]?
    let flowArn: Swift.String?
}

extension GrantFlowEntitlementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
        case flowArn = "flowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Entitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.Entitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.Entitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

extension MediaConnectClientTypes.InputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputIp = "inputIp"
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputIp = inputIp {
            try encodeContainer.encode(inputIp, forKey: .inputIp)
        }
        if let inputPort = inputPort {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputIp)
        inputIp = inputIpDecoded
        let inputPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Interface.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that are associated with an incoming media stream.
    public struct InputConfiguration: Swift.Equatable {
        /// The IP address that the flow listens on for incoming content for a media stream.
        /// This member is required.
        public var inputIp: Swift.String?
        /// The port that the flow listens on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface where the media stream comes in from.
        /// This member is required.
        public var interface: MediaConnectClientTypes.Interface?

        public init (
            inputIp: Swift.String? = nil,
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.Interface? = nil
        )
        {
            self.inputIp = inputIp
            self.inputPort = inputPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes.InputConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputPort = "inputPort"
        case interface = "interface"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPort = inputPort {
            try encodeContainer.encode(inputPort, forKey: .inputPort)
        }
        if let interface = interface {
            try encodeContainer.encode(interface, forKey: .interface)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inputPort)
        inputPort = inputPortDecoded
        let interfaceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.InterfaceRequest.self, forKey: .interface)
        interface = interfaceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The transport parameters that you want to associate with an incoming media stream.
    public struct InputConfigurationRequest: Swift.Equatable {
        /// The port that you want the flow to listen on for an incoming media stream.
        /// This member is required.
        public var inputPort: Swift.Int?
        /// The VPC interface that you want to use for the incoming media stream.
        /// This member is required.
        public var interface: MediaConnectClientTypes.InterfaceRequest?

        public init (
            inputPort: Swift.Int? = nil,
            interface: MediaConnectClientTypes.InterfaceRequest? = nil
        )
        {
            self.inputPort = inputPort
            self.interface = interface
        }
    }

}

extension MediaConnectClientTypes.Interface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The VPC interface that is used for the media stream associated with the source or output.
    public struct Interface: Swift.Equatable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension MediaConnectClientTypes.InterfaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The VPC interface that you want to designate where the media stream is coming from or going to.
    public struct InterfaceRequest: Swift.Equatable {
        /// The name of the VPC interface.
        /// This member is required.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes {
    public enum KeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case speke
        case srtPassword
        case staticKey
        case sdkUnknown(Swift.String)

        public static var allCases: [KeyType] {
            return [
                .speke,
                .srtPassword,
                .staticKey,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .speke: return "speke"
            case .srtPassword: return "srt-password"
            case .staticKey: return "static-key"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = KeyType(rawValue: rawValue) ?? KeyType.sdkUnknown(rawValue)
        }
    }
}

extension ListEntitlementsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEntitlementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/entitlements"
    }
}

public struct ListEntitlementsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListEntitlements request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 20 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEntitlementsInputBody: Swift.Equatable {
}

extension ListEntitlementsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEntitlementsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEntitlementsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEntitlementsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEntitlementsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEntitlementsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitlements = output.entitlements
            self.nextToken = output.nextToken
        } else {
            self.entitlements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEntitlementsOutputResponse: Swift.Equatable {
    /// A list of entitlements that have been granted to you from other AWS accounts.
    public var entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListEntitlements request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListEntitlements request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        entitlements: [MediaConnectClientTypes.ListedEntitlement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entitlements = entitlements
        self.nextToken = nextToken
    }
}

struct ListEntitlementsOutputResponseBody: Swift.Equatable {
    let entitlements: [MediaConnectClientTypes.ListedEntitlement]?
    let nextToken: Swift.String?
}

extension ListEntitlementsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlements = "entitlements"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedEntitlement?].self, forKey: .entitlements)
        var entitlementsDecoded0:[MediaConnectClientTypes.ListedEntitlement]? = nil
        if let entitlementsContainer = entitlementsContainer {
            entitlementsDecoded0 = [MediaConnectClientTypes.ListedEntitlement]()
            for structure0 in entitlementsContainer {
                if let structure0 = structure0 {
                    entitlementsDecoded0?.append(structure0)
                }
            }
        }
        entitlements = entitlementsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFlowsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFlowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/flows"
    }
}

public struct ListFlowsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListFlows request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFlowsInputBody: Swift.Equatable {
}

extension ListFlowsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFlowsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFlowsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFlowsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFlowsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListFlowsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flows = output.flows
            self.nextToken = output.nextToken
        } else {
            self.flows = nil
            self.nextToken = nil
        }
    }
}

public struct ListFlowsOutputResponse: Swift.Equatable {
    /// A list of flow summaries.
    public var flows: [MediaConnectClientTypes.ListedFlow]?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListFlows request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListFlows request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        flows: [MediaConnectClientTypes.ListedFlow]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.flows = flows
        self.nextToken = nextToken
    }
}

struct ListFlowsOutputResponseBody: Swift.Equatable {
    let flows: [MediaConnectClientTypes.ListedFlow]?
    let nextToken: Swift.String?
}

extension ListFlowsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flows = "flows"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.ListedFlow?].self, forKey: .flows)
        var flowsDecoded0:[MediaConnectClientTypes.ListedFlow]? = nil
        if let flowsContainer = flowsContainer {
            flowsDecoded0 = [MediaConnectClientTypes.ListedFlow]()
            for structure0 in flowsContainer {
                if let structure0 = structure0 {
                    flowsDecoded0?.append(structure0)
                }
            }
        }
        flows = flowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOfferingsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/offerings"
    }
}

public struct ListOfferingsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListOfferings request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOfferingsInputBody: Swift.Equatable {
}

extension ListOfferingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOfferingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.offerings = output.offerings
        } else {
            self.nextToken = nil
            self.offerings = nil
        }
    }
}

public struct ListOfferingsOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListOfferings request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of offerings that are available to this account in the current AWS Region.
    public var offerings: [MediaConnectClientTypes.Offering]?

    public init (
        nextToken: Swift.String? = nil,
        offerings: [MediaConnectClientTypes.Offering]? = nil
    )
    {
        self.nextToken = nextToken
        self.offerings = offerings
    }
}

struct ListOfferingsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let offerings: [MediaConnectClientTypes.Offering]?
}

extension ListOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case offerings = "offerings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let offeringsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Offering?].self, forKey: .offerings)
        var offeringsDecoded0:[MediaConnectClientTypes.Offering]? = nil
        if let offeringsContainer = offeringsContainer {
            offeringsDecoded0 = [MediaConnectClientTypes.Offering]()
            for structure0 in offeringsContainer {
                if let structure0 = structure0 {
                    offeringsDecoded0?.append(structure0)
                }
            }
        }
        offerings = offeringsDecoded0
    }
}

extension ListReservationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListReservationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/reservations"
    }
}

public struct ListReservationsInput: Swift.Equatable {
    /// The maximum number of results to return per API request. For example, you submit a ListReservations request with MaxResults set at 5. Although 20 items match your request, the service returns no more than the first 5 items. (The service also returns a NextToken value that you can use to fetch the next batch of results.) The service might return fewer results than the MaxResults value. If MaxResults is not included in the request, the service defaults to pagination with a maximum of 10 results per page.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListOfferings request a second time and specify the NextToken value.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReservationsInputBody: Swift.Equatable {
}

extension ListReservationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListReservationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReservationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReservationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReservationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListReservationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.reservations = output.reservations
        } else {
            self.nextToken = nil
            self.reservations = nil
        }
    }
}

public struct ListReservationsOutputResponse: Swift.Equatable {
    /// The token that identifies which batch of results that you want to see. For example, you submit a ListReservations request with MaxResults set at 5. The service returns the first batch of results (up to 5) and a NextToken value. To see the next batch of results, you can submit the ListReservations request a second time and specify the NextToken value.
    public var nextToken: Swift.String?
    /// A list of all reservations that have been purchased by this account in the current AWS Region.
    public var reservations: [MediaConnectClientTypes.Reservation]?

    public init (
        nextToken: Swift.String? = nil,
        reservations: [MediaConnectClientTypes.Reservation]? = nil
    )
    {
        self.nextToken = nextToken
        self.reservations = reservations
    }
}

struct ListReservationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let reservations: [MediaConnectClientTypes.Reservation]?
}

extension ListReservationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case reservations = "reservations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let reservationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.Reservation?].self, forKey: .reservations)
        var reservationsDecoded0:[MediaConnectClientTypes.Reservation]? = nil
        if let reservationsContainer = reservationsContainer {
            reservationsDecoded0 = [MediaConnectClientTypes.Reservation]()
            for structure0 in reservationsContainer {
                if let structure0 = structure0 {
                    reservationsDecoded0?.append(structure0)
                }
            }
        }
        reservations = reservationsDecoded0
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource for which to list the tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MediaConnectClientTypes.ListedEntitlement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case entitlementArn = "entitlementArn"
        case entitlementName = "entitlementName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let entitlementName = entitlementName {
            try encodeContainer.encode(entitlementName, forKey: .entitlementName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let entitlementNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementName)
        entitlementName = entitlementNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// An entitlement that has been granted to you from other AWS accounts.
    public struct ListedEntitlement: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The ARN of the entitlement.
        /// This member is required.
        public var entitlementArn: Swift.String?
        /// The name of the entitlement.
        /// This member is required.
        public var entitlementName: Swift.String?

        public init (
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            entitlementArn: Swift.String? = nil,
            entitlementName: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.entitlementArn = entitlementArn
            self.entitlementName = entitlementName
        }
    }

}

extension MediaConnectClientTypes.ListedFlow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case description = "description"
        case flowArn = "flowArn"
        case name = "name"
        case sourceType = "sourceType"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let flowArn = flowArn {
            try encodeContainer.encode(flowArn, forKey: .flowArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension MediaConnectClientTypes {
    /// Provides a summary of a flow, including its ARN, Availability Zone, and source type.
    public struct ListedFlow: Swift.Equatable {
        /// The Availability Zone that the flow was created in.
        /// This member is required.
        public var availabilityZone: Swift.String?
        /// A description of the flow.
        /// This member is required.
        public var description: Swift.String?
        /// The ARN of the flow.
        /// This member is required.
        public var flowArn: Swift.String?
        /// The name of the flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of source. This value is either owned (originated somewhere other than an AWS Elemental MediaConnect flow owned by another AWS account) or entitled (originated at an AWS Elemental MediaConnect flow owned by another AWS account).
        /// This member is required.
        public var sourceType: MediaConnectClientTypes.SourceType?
        /// The current status of the flow.
        /// This member is required.
        public var status: MediaConnectClientTypes.Status?

        public init (
            availabilityZone: Swift.String? = nil,
            description: Swift.String? = nil,
            flowArn: Swift.String? = nil,
            name: Swift.String? = nil,
            sourceType: MediaConnectClientTypes.SourceType? = nil,
            status: MediaConnectClientTypes.Status? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.description = description
            self.flowArn = flowArn
            self.name = name
            self.sourceType = sourceType
            self.status = status
        }
    }

}

extension MediaConnectClientTypes.MediaStream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case fmt = "fmt"
        case mediaStreamId = "mediaStreamId"
        case mediaStreamName = "mediaStreamName"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let fmt = fmt {
            try encodeContainer.encode(fmt, forKey: .fmt)
        }
        if let mediaStreamId = mediaStreamId {
            try encodeContainer.encode(mediaStreamId, forKey: .mediaStreamId)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributes.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let fmtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fmt)
        fmt = fmtDecoded
        let mediaStreamIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mediaStreamId)
        mediaStreamId = mediaStreamIdDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension MediaConnectClientTypes {
    /// A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
    public struct MediaStream: Swift.Equatable {
        /// Attributes that are related to the media stream.
        public var attributes: MediaConnectClientTypes.MediaStreamAttributes?
        /// The sample rate for the stream. This value is measured in Hz.
        public var clockRate: Swift.Int?
        /// A description that can help you quickly identify what your media stream is used for.
        public var description: Swift.String?
        /// The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        /// This member is required.
        public var fmt: Swift.Int?
        /// A unique identifier for the media stream.
        /// This member is required.
        public var mediaStreamId: Swift.Int?
        /// A name that helps you distinguish one media stream from another.
        /// This member is required.
        public var mediaStreamName: Swift.String?
        /// The type of media stream.
        /// This member is required.
        public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
        /// The resolution of the video.
        public var videoFormat: Swift.String?

        public init (
            attributes: MediaConnectClientTypes.MediaStreamAttributes? = nil,
            clockRate: Swift.Int? = nil,
            description: Swift.String? = nil,
            fmt: Swift.Int? = nil,
            mediaStreamId: Swift.Int? = nil,
            mediaStreamName: Swift.String? = nil,
            mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
            videoFormat: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.clockRate = clockRate
            self.description = description
            self.fmt = fmt
            self.mediaStreamId = mediaStreamId
            self.mediaStreamName = mediaStreamName
            self.mediaStreamType = mediaStreamType
            self.videoFormat = videoFormat
        }
    }

}

extension MediaConnectClientTypes.MediaStreamAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Fmtp.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributes: Swift.Equatable {
        /// A set of parameters that define the media stream.
        /// This member is required.
        public var fmtp: MediaConnectClientTypes.Fmtp?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init (
            fmtp: MediaConnectClientTypes.Fmtp? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }

}

extension MediaConnectClientTypes.MediaStreamAttributesRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fmtp = "fmtp"
        case lang = "lang"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fmtp = fmtp {
            try encodeContainer.encode(fmtp, forKey: .fmtp)
        }
        if let lang = lang {
            try encodeContainer.encode(lang, forKey: .lang)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fmtpDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FmtpRequest.self, forKey: .fmtp)
        fmtp = fmtpDecoded
        let langDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lang)
        lang = langDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes that are related to the media stream.
    public struct MediaStreamAttributesRequest: Swift.Equatable {
        /// The settings that you want to use to define the media stream.
        public var fmtp: MediaConnectClientTypes.FmtpRequest?
        /// The audio language, in a format that is recognized by the receiver.
        public var lang: Swift.String?

        public init (
            fmtp: MediaConnectClientTypes.FmtpRequest? = nil,
            lang: Swift.String? = nil
        )
        {
            self.fmtp = fmtp
            self.lang = lang
        }
    }

}

extension MediaConnectClientTypes.MediaStreamOutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for __listofdestinationconfiguration0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(__listofdestinationconfiguration0)
            }
        }
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.DestinationConfiguration?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[MediaConnectClientTypes.DestinationConfiguration]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [MediaConnectClientTypes.DestinationConfiguration]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingParameters.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that is associated with the output, and the parameters for that association.
    public struct MediaStreamOutputConfiguration: Swift.Equatable {
        /// The transport parameters that are associated with each outbound media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]?
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// Encoding parameters
        public var encodingParameters: MediaConnectClientTypes.EncodingParameters?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init (
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfiguration]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParameters? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamOutputConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfigurations = "destinationConfigurations"
        case encodingName = "encodingName"
        case encodingParameters = "encodingParameters"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfigurations = destinationConfigurations {
            var destinationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationConfigurations)
            for __listofdestinationconfigurationrequest0 in destinationConfigurations {
                try destinationConfigurationsContainer.encode(__listofdestinationconfigurationrequest0)
            }
        }
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let encodingParameters = encodingParameters {
            try encodeContainer.encode(encodingParameters, forKey: .encodingParameters)
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.DestinationConfigurationRequest?].self, forKey: .destinationConfigurations)
        var destinationConfigurationsDecoded0:[MediaConnectClientTypes.DestinationConfigurationRequest]? = nil
        if let destinationConfigurationsContainer = destinationConfigurationsContainer {
            destinationConfigurationsDecoded0 = [MediaConnectClientTypes.DestinationConfigurationRequest]()
            for structure0 in destinationConfigurationsContainer {
                if let structure0 = structure0 {
                    destinationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        destinationConfigurations = destinationConfigurationsDecoded0
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let encodingParametersDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingParametersRequest.self, forKey: .encodingParameters)
        encodingParameters = encodingParametersDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that you want to associate with the output, and the parameters for that association.
    public struct MediaStreamOutputConfigurationRequest: Swift.Equatable {
        /// The transport parameters that you want to associate with the media stream.
        public var destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]?
        /// The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        public var encodingParameters: MediaConnectClientTypes.EncodingParametersRequest?
        /// The name of the media stream that is associated with the output.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init (
            destinationConfigurations: [MediaConnectClientTypes.DestinationConfigurationRequest]? = nil,
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            encodingParameters: MediaConnectClientTypes.EncodingParametersRequest? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.destinationConfigurations = destinationConfigurations
            self.encodingName = encodingName
            self.encodingParameters = encodingParameters
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for __listofinputconfiguration0 in inputConfigurations {
                try inputConfigurationsContainer.encode(__listofinputconfiguration0)
            }
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.InputConfiguration?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[MediaConnectClientTypes.InputConfiguration]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [MediaConnectClientTypes.InputConfiguration]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The media stream that is associated with the source, and the parameters for that association.
    public struct MediaStreamSourceConfiguration: Swift.Equatable {
        /// The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that are associated with an incoming media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfiguration]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init (
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfiguration]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes.MediaStreamSourceConfigurationRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingName = "encodingName"
        case inputConfigurations = "inputConfigurations"
        case mediaStreamName = "mediaStreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingName = encodingName {
            try encodeContainer.encode(encodingName.rawValue, forKey: .encodingName)
        }
        if let inputConfigurations = inputConfigurations {
            var inputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputConfigurations)
            for __listofinputconfigurationrequest0 in inputConfigurations {
                try inputConfigurationsContainer.encode(__listofinputconfigurationrequest0)
            }
        }
        if let mediaStreamName = mediaStreamName {
            try encodeContainer.encode(mediaStreamName, forKey: .mediaStreamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingNameDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EncodingName.self, forKey: .encodingName)
        encodingName = encodingNameDecoded
        let inputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.InputConfigurationRequest?].self, forKey: .inputConfigurations)
        var inputConfigurationsDecoded0:[MediaConnectClientTypes.InputConfigurationRequest]? = nil
        if let inputConfigurationsContainer = inputConfigurationsContainer {
            inputConfigurationsDecoded0 = [MediaConnectClientTypes.InputConfigurationRequest]()
            for structure0 in inputConfigurationsContainer {
                if let structure0 = structure0 {
                    inputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        inputConfigurations = inputConfigurationsDecoded0
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The definition of a media stream that you want to associate with the source.
    public struct MediaStreamSourceConfigurationRequest: Swift.Equatable {
        /// The format you want to use to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        /// This member is required.
        public var encodingName: MediaConnectClientTypes.EncodingName?
        /// The transport parameters that you want to associate with the media stream.
        public var inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]?
        /// The name of the media stream.
        /// This member is required.
        public var mediaStreamName: Swift.String?

        public init (
            encodingName: MediaConnectClientTypes.EncodingName? = nil,
            inputConfigurations: [MediaConnectClientTypes.InputConfigurationRequest]? = nil,
            mediaStreamName: Swift.String? = nil
        )
        {
            self.encodingName = encodingName
            self.inputConfigurations = inputConfigurations
            self.mediaStreamName = mediaStreamName
        }
    }

}

extension MediaConnectClientTypes {
    public enum MediaStreamType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ancillaryData
        case audio
        case video
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStreamType] {
            return [
                .ancillaryData,
                .audio,
                .video,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ancillaryData: return "ancillary-data"
            case .audio: return "audio"
            case .video: return "video"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStreamType(rawValue: rawValue) ?? MediaStreamType.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.Messages: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors = "errors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for __listof__string0 in errors {
                try errorsContainer.encode(__listof__string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .errors)
        var errorsDecoded0:[Swift.String]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [Swift.String]()
            for string0 in errorsContainer {
                if let string0 = string0 {
                    errorsDecoded0?.append(string0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension MediaConnectClientTypes {
    /// Messages that provide the state of the flow.
    public struct Messages: Swift.Equatable {
        /// A list of errors that might have been generated from processes on this flow.
        /// This member is required.
        public var errors: [Swift.String]?

        public init (
            errors: [Swift.String]? = nil
        )
        {
            self.errors = errors
        }
    }

}

extension MediaConnectClientTypes {
    public enum NetworkInterfaceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case efa
        case ena
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkInterfaceType] {
            return [
                .efa,
                .ena,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .ena: return "ena"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkInterfaceType(rawValue: rawValue) ?? NetworkInterfaceType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Offering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case resourceSpecification = "resourceSpecification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let offeringArn = offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
    }
}

extension MediaConnectClientTypes {
    /// A savings plan that reserves a certain amount of outbound bandwidth usage at a discounted rate each month over a period of time.
    public struct Offering: Swift.Equatable {
        /// The type of currency that is used for billing. The currencyCode used for all reservations is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that your reservation would be active.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?

        public init (
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.resourceSpecification = resourceSpecification
        }
    }

}

extension MediaConnectClientTypes.Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case entitlementArn = "entitlementArn"
        case listenerAddress = "listenerAddress"
        case mediaLiveInputArn = "mediaLiveInputArn"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case name = "name"
        case outputArn = "outputArn"
        case port = "port"
        case transport = "transport"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let listenerAddress = listenerAddress {
            try encodeContainer.encode(listenerAddress, forKey: .listenerAddress)
        }
        if let mediaLiveInputArn = mediaLiveInputArn {
            try encodeContainer.encode(mediaLiveInputArn, forKey: .mediaLiveInputArn)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfiguration0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfiguration0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let outputArn = outputArn {
            try encodeContainer.encode(outputArn, forKey: .outputArn)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let transport = transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let listenerAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .listenerAddress)
        listenerAddress = listenerAddressDecoded
        let mediaLiveInputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaLiveInputArn)
        mediaLiveInputArn = mediaLiveInputArnDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfiguration?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfiguration]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let transportDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for an output.
    public struct Output: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// A description of the output.
        public var description: Swift.String?
        /// The address where you want to send the output.
        public var destination: Swift.String?
        /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var encryption: MediaConnectClientTypes.Encryption?
        /// The ARN of the entitlement on the originator''s flow. This value is relevant only on entitled flows.
        public var entitlementArn: Swift.String?
        /// The IP address that the receiver requires in order to establish a connection with the flow. For public networking, the ListenerAddress is represented by the elastic IP address of the flow. For private networking, the ListenerAddress is represented by the elastic network interface IP address of the VPC. This field applies only to outputs that use the Zixi pull or SRT listener protocol.
        public var listenerAddress: Swift.String?
        /// The input ARN of the AWS Elemental MediaLive channel. This parameter is relevant only for outputs that were added by creating a MediaLive input.
        public var mediaLiveInputArn: Swift.String?
        /// The configuration for each media stream that is associated with the output.
        public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]?
        /// The name of the output. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the output.
        /// This member is required.
        public var outputArn: Swift.String?
        /// The port to use when content is distributed to this output.
        public var port: Swift.Int?
        /// Attributes related to the transport stream that are used in the output.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface attachment to use for this output.
        public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

        public init (
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            description: Swift.String? = nil,
            destination: Swift.String? = nil,
            encryption: MediaConnectClientTypes.Encryption? = nil,
            entitlementArn: Swift.String? = nil,
            listenerAddress: Swift.String? = nil,
            mediaLiveInputArn: Swift.String? = nil,
            mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfiguration]? = nil,
            name: Swift.String? = nil,
            outputArn: Swift.String? = nil,
            port: Swift.Int? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.description = description
            self.destination = destination
            self.encryption = encryption
            self.entitlementArn = entitlementArn
            self.listenerAddress = listenerAddress
            self.mediaLiveInputArn = mediaLiveInputArn
            self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
            self.name = name
            self.outputArn = outputArn
            self.port = port
            self.transport = transport
            self.vpcInterfaceAttachment = vpcInterfaceAttachment
        }
    }

}

extension MediaConnectClientTypes {
    public enum PriceUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hourly
        case sdkUnknown(Swift.String)

        public static var allCases: [PriceUnits] {
            return [
                .hourly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hourly: return "HOURLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PriceUnits(rawValue: rawValue) ?? PriceUnits.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cdi
        case rist
        case rtp
        case rtpFec
        case srtListener
        case st2110Jpegxs
        case zixiPull
        case zixiPush
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .cdi,
                .rist,
                .rtp,
                .rtpFec,
                .srtListener,
                .st2110Jpegxs,
                .zixiPull,
                .zixiPush,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cdi: return "cdi"
            case .rist: return "rist"
            case .rtp: return "rtp"
            case .rtpFec: return "rtp-fec"
            case .srtListener: return "srt-listener"
            case .st2110Jpegxs: return "st2110-jpegxs"
            case .zixiPull: return "zixi-pull"
            case .zixiPush: return "zixi-push"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension PurchaseOfferingInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservationName = reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }
}

extension PurchaseOfferingInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let offeringArn = offeringArn else {
            return nil
        }
        return "/v1/offerings/\(offeringArn.urlPercentEncoding())"
    }
}

/// A request to purchase a offering.
public struct PurchaseOfferingInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the offering.
    /// This member is required.
    public var offeringArn: Swift.String?
    /// The name that you want to use for the reservation.
    /// This member is required.
    public var reservationName: Swift.String?
    /// The date and time that you want the reservation to begin, in Coordinated Universal Time (UTC). You can specify any date and time between 12:00am on the first day of the current month to the current time on today's date, inclusive. Specify the start in a 24-hour notation. Use the following format: YYYY-MM-DDTHH:mm:SSZ, where T and Z are literal characters. For example, to specify 11:30pm on March 5, 2020, enter 2020-03-05T23:30:00Z.
    /// This member is required.
    public var start: Swift.String?

    public init (
        offeringArn: Swift.String? = nil,
        reservationName: Swift.String? = nil,
        start: Swift.String? = nil
    )
    {
        self.offeringArn = offeringArn
        self.reservationName = reservationName
        self.start = start
    }
}

struct PurchaseOfferingInputBody: Swift.Equatable {
    let reservationName: Swift.String?
    let start: Swift.String?
}

extension PurchaseOfferingInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservationName = "reservationName"
        case start = "start"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
    }
}

extension PurchaseOfferingOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PurchaseOfferingOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PurchaseOfferingOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PurchaseOfferingOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PurchaseOfferingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.reservation = output.reservation
        } else {
            self.reservation = nil
        }
    }
}

public struct PurchaseOfferingOutputResponse: Swift.Equatable {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public var reservation: MediaConnectClientTypes.Reservation?

    public init (
        reservation: MediaConnectClientTypes.Reservation? = nil
    )
    {
        self.reservation = reservation
    }
}

struct PurchaseOfferingOutputResponseBody: Swift.Equatable {
    let reservation: MediaConnectClientTypes.Reservation?
}

extension PurchaseOfferingOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservation = "reservation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Reservation.self, forKey: .reservation)
        reservation = reservationDecoded
    }
}

extension MediaConnectClientTypes {
    public enum Range: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case full
        case fullprotect
        case narrow
        case sdkUnknown(Swift.String)

        public static var allCases: [Range] {
            return [
                .full,
                .fullprotect,
                .narrow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .full: return "FULL"
            case .fullprotect: return "FULLPROTECT"
            case .narrow: return "NARROW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Range(rawValue: rawValue) ?? Range.sdkUnknown(rawValue)
        }
    }
}

extension RemoveFlowMediaStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let mediaStreamName = mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

public struct RemoveFlowMediaStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to remove.
    /// This member is required.
    public var mediaStreamName: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamInputBody: Swift.Equatable {
}

extension RemoveFlowMediaStreamInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowMediaStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowMediaStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowMediaStreamOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowMediaStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFlowMediaStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStreamName = output.mediaStreamName
        } else {
            self.flowArn = nil
            self.mediaStreamName = nil
        }
    }
}

public struct RemoveFlowMediaStreamOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the flow.
    public var flowArn: Swift.String?
    /// The name of the media stream that was removed.
    public var mediaStreamName: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
    }
}

struct RemoveFlowMediaStreamOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStreamName: Swift.String?
}

extension RemoveFlowMediaStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStreamName = "mediaStreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaStreamName)
        mediaStreamName = mediaStreamNameDecoded
    }
}

extension RemoveFlowOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let outputArn = outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

public struct RemoveFlowOutputInput: Swift.Equatable {
    /// The flow that you want to remove an output from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the output that you want to remove.
    /// This member is required.
    public var outputArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputInputBody: Swift.Equatable {
}

extension RemoveFlowOutputInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowOutputOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFlowOutputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.outputArn = output.outputArn
        } else {
            self.flowArn = nil
            self.outputArn = nil
        }
    }
}

public struct RemoveFlowOutputOutputResponse: Swift.Equatable {
    /// The ARN of the flow that is associated with the output you removed.
    public var flowArn: Swift.String?
    /// The ARN of the output that was removed.
    public var outputArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        outputArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.outputArn = outputArn
    }
}

struct RemoveFlowOutputOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let outputArn: Swift.String?
}

extension RemoveFlowOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case outputArn = "outputArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputArn)
        outputArn = outputArnDecoded
    }
}

extension RemoveFlowSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let sourceArn = sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

public struct RemoveFlowSourceInput: Swift.Equatable {
    /// The flow that you want to remove a source from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The ARN of the source that you want to remove.
    /// This member is required.
    public var sourceArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceInputBody: Swift.Equatable {
}

extension RemoveFlowSourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFlowSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.sourceArn = output.sourceArn
        } else {
            self.flowArn = nil
            self.sourceArn = nil
        }
    }
}

public struct RemoveFlowSourceOutputResponse: Swift.Equatable {
    /// The ARN of the flow that is associated with the source you removed.
    public var flowArn: Swift.String?
    /// The ARN of the source that was removed.
    public var sourceArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        sourceArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceArn = sourceArn
    }
}

struct RemoveFlowSourceOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let sourceArn: Swift.String?
}

extension RemoveFlowSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case sourceArn = "sourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
    }
}

extension RemoveFlowVpcInterfaceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let vpcInterfaceName = vpcInterfaceName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/vpcInterfaces/\(vpcInterfaceName.urlPercentEncoding())"
    }
}

public struct RemoveFlowVpcInterfaceInput: Swift.Equatable {
    /// The flow that you want to remove a VPC interface from.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the VPC interface that you want to remove.
    /// This member is required.
    public var vpcInterfaceName: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceInputBody: Swift.Equatable {
}

extension RemoveFlowVpcInterfaceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RemoveFlowVpcInterfaceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveFlowVpcInterfaceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveFlowVpcInterfaceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveFlowVpcInterfaceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RemoveFlowVpcInterfaceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.nonDeletedNetworkInterfaceIds = output.nonDeletedNetworkInterfaceIds
            self.vpcInterfaceName = output.vpcInterfaceName
        } else {
            self.flowArn = nil
            self.nonDeletedNetworkInterfaceIds = nil
            self.vpcInterfaceName = nil
        }
    }
}

public struct RemoveFlowVpcInterfaceOutputResponse: Swift.Equatable {
    /// The ARN of the flow that is associated with the VPC interface you removed.
    public var flowArn: Swift.String?
    /// IDs of network interfaces associated with the removed VPC interface that Media Connect was unable to remove.
    public var nonDeletedNetworkInterfaceIds: [Swift.String]?
    /// The name of the VPC interface that was removed.
    public var vpcInterfaceName: Swift.String?

    public init (
        flowArn: Swift.String? = nil,
        nonDeletedNetworkInterfaceIds: [Swift.String]? = nil,
        vpcInterfaceName: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
        self.nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIds
        self.vpcInterfaceName = vpcInterfaceName
    }
}

struct RemoveFlowVpcInterfaceOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let nonDeletedNetworkInterfaceIds: [Swift.String]?
    let vpcInterfaceName: Swift.String?
}

extension RemoveFlowVpcInterfaceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case nonDeletedNetworkInterfaceIds = "nonDeletedNetworkInterfaceIds"
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let nonDeletedNetworkInterfaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .nonDeletedNetworkInterfaceIds)
        var nonDeletedNetworkInterfaceIdsDecoded0:[Swift.String]? = nil
        if let nonDeletedNetworkInterfaceIdsContainer = nonDeletedNetworkInterfaceIdsContainer {
            nonDeletedNetworkInterfaceIdsDecoded0 = [Swift.String]()
            for string0 in nonDeletedNetworkInterfaceIdsContainer {
                if let string0 = string0 {
                    nonDeletedNetworkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        nonDeletedNetworkInterfaceIds = nonDeletedNetworkInterfaceIdsDecoded0
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

extension MediaConnectClientTypes.Reservation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode = "currencyCode"
        case duration = "duration"
        case durationUnits = "durationUnits"
        case end = "end"
        case offeringArn = "offeringArn"
        case offeringDescription = "offeringDescription"
        case pricePerUnit = "pricePerUnit"
        case priceUnits = "priceUnits"
        case reservationArn = "reservationArn"
        case reservationName = "reservationName"
        case reservationState = "reservationState"
        case resourceSpecification = "resourceSpecification"
        case start = "start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let durationUnits = durationUnits {
            try encodeContainer.encode(durationUnits.rawValue, forKey: .durationUnits)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringArn = offeringArn {
            try encodeContainer.encode(offeringArn, forKey: .offeringArn)
        }
        if let offeringDescription = offeringDescription {
            try encodeContainer.encode(offeringDescription, forKey: .offeringDescription)
        }
        if let pricePerUnit = pricePerUnit {
            try encodeContainer.encode(pricePerUnit, forKey: .pricePerUnit)
        }
        if let priceUnits = priceUnits {
            try encodeContainer.encode(priceUnits.rawValue, forKey: .priceUnits)
        }
        if let reservationArn = reservationArn {
            try encodeContainer.encode(reservationArn, forKey: .reservationArn)
        }
        if let reservationName = reservationName {
            try encodeContainer.encode(reservationName, forKey: .reservationName)
        }
        if let reservationState = reservationState {
            try encodeContainer.encode(reservationState.rawValue, forKey: .reservationState)
        }
        if let resourceSpecification = resourceSpecification {
            try encodeContainer.encode(resourceSpecification, forKey: .resourceSpecification)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .duration)
        duration = durationDecoded
        let durationUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.DurationUnits.self, forKey: .durationUnits)
        durationUnits = durationUnitsDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
        let offeringArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringArn)
        offeringArn = offeringArnDecoded
        let offeringDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringDescription)
        offeringDescription = offeringDescriptionDecoded
        let pricePerUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pricePerUnit)
        pricePerUnit = pricePerUnitDecoded
        let priceUnitsDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.PriceUnits.self, forKey: .priceUnits)
        priceUnits = priceUnitsDecoded
        let reservationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationArn)
        reservationArn = reservationArnDecoded
        let reservationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservationName)
        reservationName = reservationNameDecoded
        let reservationStateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ReservationState.self, forKey: .reservationState)
        reservationState = reservationStateDecoded
        let resourceSpecificationDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceSpecification.self, forKey: .resourceSpecification)
        resourceSpecification = resourceSpecificationDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
    }
}

extension MediaConnectClientTypes {
    /// A pricing agreement for a discounted rate for a specific outbound bandwidth that your MediaConnect account will use each month over a specific time period. The discounted rate in the reservation applies to outbound bandwidth for all flows from your account until your account reaches the amount of bandwidth in your reservation. If you use more outbound bandwidth than the agreed upon amount in a single month, the overage is charged at the on-demand rate.
    public struct Reservation: Swift.Equatable {
        /// The type of currency that is used for billing. The currencyCode used for your reservation is US dollars.
        /// This member is required.
        public var currencyCode: Swift.String?
        /// The length of time that this reservation is active. MediaConnect defines this value in the offering.
        /// This member is required.
        public var duration: Swift.Int?
        /// The unit of measurement for the duration of the reservation. MediaConnect defines this value in the offering.
        /// This member is required.
        public var durationUnits: MediaConnectClientTypes.DurationUnits?
        /// The day and time that this reservation expires. This value is calculated based on the start date and time that you set and the offering's duration.
        /// This member is required.
        public var end: Swift.String?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the offering.
        /// This member is required.
        public var offeringArn: Swift.String?
        /// A description of the offering. MediaConnect defines this value in the offering.
        /// This member is required.
        public var offeringDescription: Swift.String?
        /// The cost of a single unit. This value, in combination with priceUnits, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var pricePerUnit: Swift.String?
        /// The unit of measurement that is used for billing. This value, in combination with pricePerUnit, makes up the rate. MediaConnect defines this value in the offering.
        /// This member is required.
        public var priceUnits: MediaConnectClientTypes.PriceUnits?
        /// The Amazon Resource Name (ARN) that MediaConnect assigns to the reservation when you purchase an offering.
        /// This member is required.
        public var reservationArn: Swift.String?
        /// The name that you assigned to the reservation when you purchased the offering.
        /// This member is required.
        public var reservationName: Swift.String?
        /// The status of your reservation.
        /// This member is required.
        public var reservationState: MediaConnectClientTypes.ReservationState?
        /// A definition of the amount of outbound bandwidth that you would be reserving if you purchase the offering. MediaConnect defines the values that make up the resourceSpecification in the offering.
        /// This member is required.
        public var resourceSpecification: MediaConnectClientTypes.ResourceSpecification?
        /// The day and time that the reservation becomes active. You set this value when you purchase the offering.
        /// This member is required.
        public var start: Swift.String?

        public init (
            currencyCode: Swift.String? = nil,
            duration: Swift.Int? = nil,
            durationUnits: MediaConnectClientTypes.DurationUnits? = nil,
            end: Swift.String? = nil,
            offeringArn: Swift.String? = nil,
            offeringDescription: Swift.String? = nil,
            pricePerUnit: Swift.String? = nil,
            priceUnits: MediaConnectClientTypes.PriceUnits? = nil,
            reservationArn: Swift.String? = nil,
            reservationName: Swift.String? = nil,
            reservationState: MediaConnectClientTypes.ReservationState? = nil,
            resourceSpecification: MediaConnectClientTypes.ResourceSpecification? = nil,
            start: Swift.String? = nil
        )
        {
            self.currencyCode = currencyCode
            self.duration = duration
            self.durationUnits = durationUnits
            self.end = end
            self.offeringArn = offeringArn
            self.offeringDescription = offeringDescription
            self.pricePerUnit = pricePerUnit
            self.priceUnits = priceUnits
            self.reservationArn = reservationArn
            self.reservationName = reservationName
            self.reservationState = reservationState
            self.resourceSpecification = resourceSpecification
            self.start = start
        }
    }

}

extension MediaConnectClientTypes {
    public enum ReservationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case expired
        case processing
        case sdkUnknown(Swift.String)

        public static var allCases: [ReservationState] {
            return [
                .active,
                .canceled,
                .expired,
                .processing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .processing: return "PROCESSING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReservationState(rawValue: rawValue) ?? ReservationState.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes.ResourceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reservedBitrate = "reservedBitrate"
        case resourceType = "resourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedBitrate = reservedBitrate {
            try encodeContainer.encode(reservedBitrate, forKey: .reservedBitrate)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reservedBitrate)
        reservedBitrate = reservedBitrateDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MediaConnectClientTypes {
    /// A definition of what is being billed for, including the type and amount.
    public struct ResourceSpecification: Swift.Equatable {
        /// The amount of outbound bandwidth that is discounted in the offering.
        public var reservedBitrate: Swift.Int?
        /// The type of resource and the unit that is being billed for.
        /// This member is required.
        public var resourceType: MediaConnectClientTypes.ResourceType?

        public init (
            reservedBitrate: Swift.Int? = nil,
            resourceType: MediaConnectClientTypes.ResourceType? = nil
        )
        {
            self.reservedBitrate = reservedBitrate
            self.resourceType = resourceType
        }
    }

}

extension MediaConnectClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mbpsOutboundBandwidth
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .mbpsOutboundBandwidth,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mbpsOutboundBandwidth: return "Mbps_Outbound_Bandwidth"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension RevokeFlowEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let entitlementArn = entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

public struct RevokeFlowEntitlementInput: Swift.Equatable {
    /// The ARN of the entitlement that you want to revoke.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// The flow that you want to revoke an entitlement from.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementInputBody: Swift.Equatable {
}

extension RevokeFlowEntitlementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RevokeFlowEntitlementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeFlowEntitlementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeFlowEntitlementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeFlowEntitlementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RevokeFlowEntitlementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitlementArn = output.entitlementArn
            self.flowArn = output.flowArn
        } else {
            self.entitlementArn = nil
            self.flowArn = nil
        }
    }
}

public struct RevokeFlowEntitlementOutputResponse: Swift.Equatable {
    /// The ARN of the entitlement that was revoked.
    public var entitlementArn: Swift.String?
    /// The ARN of the flow that the entitlement was revoked from.
    public var flowArn: Swift.String?

    public init (
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
    }
}

struct RevokeFlowEntitlementOutputResponseBody: Swift.Equatable {
    let entitlementArn: Swift.String?
    let flowArn: Swift.String?
}

extension RevokeFlowEntitlementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlementArn = "entitlementArn"
        case flowArn = "flowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

extension MediaConnectClientTypes {
    public enum ScanMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case interlace
        case progressive
        case progressiveSegmentedFrame
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanMode] {
            return [
                .interlace,
                .progressive,
                .progressiveSegmentedFrame,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .interlace: return "interlace"
            case .progressive: return "progressive"
            case .progressiveSegmentedFrame: return "progressive-segmented-frame"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanMode(rawValue: rawValue) ?? ScanMode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.SetSourceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case name = "name"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let ingestPort = ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let maxBitrate = maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfigurationrequest0)
            }
        }
        if let minLatency = minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for the source of the flow.
    public struct SetSourceRequest: Swift.Equatable {
        /// The type of encryption that is used on the content ingested from this source.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The name of the source.
        public var name: Swift.String?
        /// The protocol that is used by the source.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        public var streamId: Swift.String?
        /// The name of the VPC interface to use for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init (
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            ingestPort: Swift.Int? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
            minLatency: Swift.Int? = nil,
            name: Swift.String? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            streamId: Swift.String? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.ingestPort = ingestPort
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.minLatency = minLatency
            self.name = name
            self.`protocol` = `protocol`
            self.streamId = streamId
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }

}

extension MediaConnectClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTransferSubscriberFeePercent = "dataTransferSubscriberFeePercent"
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestIp = "ingestIp"
        case ingestPort = "ingestPort"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case name = "name"
        case sourceArn = "sourceArn"
        case transport = "transport"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent {
            try encodeContainer.encode(dataTransferSubscriberFeePercent, forKey: .dataTransferSubscriberFeePercent)
        }
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let ingestIp = ingestIp {
            try encodeContainer.encode(ingestIp, forKey: .ingestIp)
        }
        if let ingestPort = ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfiguration0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfiguration0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let transport = transport {
            try encodeContainer.encode(transport, forKey: .transport)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTransferSubscriberFeePercentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataTransferSubscriberFeePercent)
        dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercentDecoded
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Encryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestIp)
        ingestIp = ingestIpDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfiguration?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfiguration]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let transportDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Transport.self, forKey: .transport)
        transport = transportDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for the source of the flow.
    public struct Source: Swift.Equatable {
        /// Percentage from 0-100 of the data transfer cost to be billed to the subscriber.
        public var dataTransferSubscriberFeePercent: Swift.Int?
        /// The type of encryption that is used on the content ingested from this source.
        public var decryption: MediaConnectClientTypes.Encryption?
        /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        public var description: Swift.String?
        /// The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        public var entitlementArn: Swift.String?
        /// The IP address that the flow will be listening on for incoming content.
        public var ingestIp: Swift.String?
        /// The port that the flow will be listening on for incoming content.
        public var ingestPort: Swift.Int?
        /// The media streams that are associated with the source, and the parameters for those associations.
        public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]?
        /// The name of the source.
        /// This member is required.
        public var name: Swift.String?
        /// The ARN of the source.
        /// This member is required.
        public var sourceArn: Swift.String?
        /// Attributes related to the transport stream that are used in the source.
        public var transport: MediaConnectClientTypes.Transport?
        /// The name of the VPC interface that is used for this source.
        public var vpcInterfaceName: Swift.String?
        /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var whitelistCidr: Swift.String?

        public init (
            dataTransferSubscriberFeePercent: Swift.Int? = nil,
            decryption: MediaConnectClientTypes.Encryption? = nil,
            description: Swift.String? = nil,
            entitlementArn: Swift.String? = nil,
            ingestIp: Swift.String? = nil,
            ingestPort: Swift.Int? = nil,
            mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfiguration]? = nil,
            name: Swift.String? = nil,
            sourceArn: Swift.String? = nil,
            transport: MediaConnectClientTypes.Transport? = nil,
            vpcInterfaceName: Swift.String? = nil,
            whitelistCidr: Swift.String? = nil
        )
        {
            self.dataTransferSubscriberFeePercent = dataTransferSubscriberFeePercent
            self.decryption = decryption
            self.description = description
            self.entitlementArn = entitlementArn
            self.ingestIp = ingestIp
            self.ingestPort = ingestPort
            self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
            self.name = name
            self.sourceArn = sourceArn
            self.transport = transport
            self.vpcInterfaceName = vpcInterfaceName
            self.whitelistCidr = whitelistCidr
        }
    }

}

extension MediaConnectClientTypes.SourcePriority: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case primarySource = "primarySource"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primarySource = primarySource {
            try encodeContainer.encode(primarySource, forKey: .primarySource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primarySourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .primarySource)
        primarySource = primarySourceDecoded
    }
}

extension MediaConnectClientTypes {
    /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
    public struct SourcePriority: Swift.Equatable {
        /// The name of the source you choose as the primary source for this flow.
        public var primarySource: Swift.String?

        public init (
            primarySource: Swift.String? = nil
        )
        {
            self.primarySource = primarySource
        }
    }

}

extension MediaConnectClientTypes {
    public enum SourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case entitled
        case owned
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceType] {
            return [
                .entitled,
                .owned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .entitled: return "ENTITLED"
            case .owned: return "OWNED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
        }
    }
}

extension StartFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/start/\(flowArn.urlPercentEncoding())"
    }
}

public struct StartFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to start.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StartFlowInputBody: Swift.Equatable {
}

extension StartFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StartFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StartFlowOutputResponse: Swift.Equatable {
    /// The ARN of the flow that you started.
    public var flowArn: Swift.String?
    /// The status of the flow when the StartFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init (
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StartFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension StartFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension MediaConnectClientTypes {
    public enum State: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [State] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
        }
    }
}

extension MediaConnectClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case deleting
        case error
        case standby
        case starting
        case stopping
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .deleting,
                .error,
                .standby,
                .starting,
                .stopping,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .standby: return "STANDBY"
            case .starting: return "STARTING"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/stop/\(flowArn.urlPercentEncoding())"
    }
}

public struct StopFlowInput: Swift.Equatable {
    /// The ARN of the flow that you want to stop.
    /// This member is required.
    public var flowArn: Swift.String?

    public init (
        flowArn: Swift.String? = nil
    )
    {
        self.flowArn = flowArn
    }
}

struct StopFlowInputBody: Swift.Equatable {
}

extension StopFlowInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.status = output.status
        } else {
            self.flowArn = nil
            self.status = nil
        }
    }
}

public struct StopFlowOutputResponse: Swift.Equatable {
    /// The ARN of the flow that you stopped.
    public var flowArn: Swift.String?
    /// The status of the flow when the StopFlow process begins.
    public var status: MediaConnectClientTypes.Status?

    public init (
        flowArn: Swift.String? = nil,
        status: MediaConnectClientTypes.Status? = nil
    )
    {
        self.flowArn = flowArn
        self.status = status
    }
}

struct StopFlowOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let status: MediaConnectClientTypes.Status?
}

extension StopFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource to which to add tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map from tag keys to values. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension MediaConnectClientTypes {
    public enum Tcs: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bt2100linhlg
        case bt2100linpq
        case density
        case hlg
        case linear
        case pq
        case sdr
        case st20651
        case st4281
        case sdkUnknown(Swift.String)

        public static var allCases: [Tcs] {
            return [
                .bt2100linhlg,
                .bt2100linpq,
                .density,
                .hlg,
                .linear,
                .pq,
                .sdr,
                .st20651,
                .st4281,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bt2100linhlg: return "BT2100LINHLG"
            case .bt2100linpq: return "BT2100LINPQ"
            case .density: return "DENSITY"
            case .hlg: return "HLG"
            case .linear: return "LINEAR"
            case .pq: return "PQ"
            case .sdr: return "SDR"
            case .st20651: return "ST2065-1"
            case .st4281: return "ST428-1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Tcs(rawValue: rawValue) ?? Tcs.sdkUnknown(rawValue)
        }
    }
}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception raised by AWS Elemental MediaConnect. See the error message and documentation for the operation for more information on the cause of this exception.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by AWS Elemental MediaConnect.
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MediaConnectClientTypes.Transport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if let maxBitrate = maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let minLatency = minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let smoothingLatency = smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// Attributes related to the transport stream that are used in a source or output.
    public struct Transport: Swift.Equatable {
        /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        public var cidrAllowList: [Swift.String]?
        /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        public var maxBitrate: Swift.Int?
        /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        public var maxLatency: Swift.Int?
        /// The size of the buffer (in milliseconds) to use to sync incoming source data.
        public var maxSyncBuffer: Swift.Int?
        /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
        public var minLatency: Swift.Int?
        /// The protocol that is used by the source or output.
        /// This member is required.
        public var `protocol`: MediaConnectClientTypes.ModelProtocol?
        /// The remote ID for the Zixi-pull stream.
        public var remoteId: Swift.String?
        /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
        public var smoothingLatency: Swift.Int?
        /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        public var streamId: Swift.String?

        public init (
            cidrAllowList: [Swift.String]? = nil,
            maxBitrate: Swift.Int? = nil,
            maxLatency: Swift.Int? = nil,
            maxSyncBuffer: Swift.Int? = nil,
            minLatency: Swift.Int? = nil,
            `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
            remoteId: Swift.String? = nil,
            smoothingLatency: Swift.Int? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.cidrAllowList = cidrAllowList
            self.maxBitrate = maxBitrate
            self.maxLatency = maxLatency
            self.maxSyncBuffer = maxSyncBuffer
            self.minLatency = minLatency
            self.`protocol` = `protocol`
            self.remoteId = remoteId
            self.smoothingLatency = smoothingLatency
            self.streamId = streamId
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the AWS Elemental MediaConnect resource from which to delete tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension MediaConnectClientTypes.UpdateEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case algorithm = "algorithm"
        case constantInitializationVector = "constantInitializationVector"
        case deviceId = "deviceId"
        case keyType = "keyType"
        case region = "region"
        case resourceId = "resourceId"
        case roleArn = "roleArn"
        case secretArn = "secretArn"
        case url = "url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let algorithm = algorithm {
            try encodeContainer.encode(algorithm.rawValue, forKey: .algorithm)
        }
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let keyType = keyType {
            try encodeContainer.encode(keyType.rawValue, forKey: .keyType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let algorithmDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Algorithm.self, forKey: .algorithm)
        algorithm = algorithmDecoded
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let keyTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.KeyType.self, forKey: .keyType)
        keyType = keyTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension MediaConnectClientTypes {
    /// Information about the encryption of the flow.
    public struct UpdateEncryption: Swift.Equatable {
        /// The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        public var algorithm: MediaConnectClientTypes.Algorithm?
        /// A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        public var constantInitializationVector: Swift.String?
        /// The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var deviceId: Swift.String?
        /// The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        public var keyType: MediaConnectClientTypes.KeyType?
        /// The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var region: Swift.String?
        /// An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var resourceId: Swift.String?
        /// The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        public var roleArn: Swift.String?
        /// The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        public var secretArn: Swift.String?
        /// The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        public var url: Swift.String?

        public init (
            algorithm: MediaConnectClientTypes.Algorithm? = nil,
            constantInitializationVector: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            keyType: MediaConnectClientTypes.KeyType? = nil,
            region: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            secretArn: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.algorithm = algorithm
            self.constantInitializationVector = constantInitializationVector
            self.deviceId = deviceId
            self.keyType = keyType
            self.region = region
            self.resourceId = resourceId
            self.roleArn = roleArn
            self.secretArn = secretArn
            self.url = url
        }
    }

}

extension MediaConnectClientTypes.UpdateFailoverConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failoverMode = "failoverMode"
        case recoveryWindow = "recoveryWindow"
        case sourcePriority = "sourcePriority"
        case state = "state"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failoverMode = failoverMode {
            try encodeContainer.encode(failoverMode.rawValue, forKey: .failoverMode)
        }
        if let recoveryWindow = recoveryWindow {
            try encodeContainer.encode(recoveryWindow, forKey: .recoveryWindow)
        }
        if let sourcePriority = sourcePriority {
            try encodeContainer.encode(sourcePriority, forKey: .sourcePriority)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failoverModeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.FailoverMode.self, forKey: .failoverMode)
        failoverMode = failoverModeDecoded
        let recoveryWindowDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recoveryWindow)
        recoveryWindow = recoveryWindowDecoded
        let sourcePriorityDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.SourcePriority.self, forKey: .sourcePriority)
        sourcePriority = sourcePriorityDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.State.self, forKey: .state)
        state = stateDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for source failover
    public struct UpdateFailoverConfig: Swift.Equatable {
        /// The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        public var failoverMode: MediaConnectClientTypes.FailoverMode?
        /// Recovery window time to look for dash-7 packets
        public var recoveryWindow: Swift.Int?
        /// The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        public var sourcePriority: MediaConnectClientTypes.SourcePriority?
        public var state: MediaConnectClientTypes.State?

        public init (
            failoverMode: MediaConnectClientTypes.FailoverMode? = nil,
            recoveryWindow: Swift.Int? = nil,
            sourcePriority: MediaConnectClientTypes.SourcePriority? = nil,
            state: MediaConnectClientTypes.State? = nil
        )
        {
            self.failoverMode = failoverMode
            self.recoveryWindow = recoveryWindow
            self.sourcePriority = sourcePriority
            self.state = state
        }
    }

}

extension UpdateFlowEntitlementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let entitlementStatus = entitlementStatus {
            try encodeContainer.encode(entitlementStatus.rawValue, forKey: .entitlementStatus)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for __listof__string0 in subscribers {
                try subscribersContainer.encode(__listof__string0)
            }
        }
    }
}

extension UpdateFlowEntitlementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let entitlementArn = entitlementArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/entitlements/\(entitlementArn.urlPercentEncoding())"
    }
}

/// The entitlement fields that you want to update.
public struct UpdateFlowEntitlementInput: Swift.Equatable {
    /// A description of the entitlement. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the subscriber or end user.
    public var description: Swift.String?
    /// The type of encryption that will be used on the output associated with this entitlement.
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The ARN of the entitlement that you want to update.
    /// This member is required.
    public var entitlementArn: Swift.String?
    /// An indication of whether you want to enable the entitlement to allow access, or disable it to stop streaming content to the subscriber’s flow temporarily. If you don’t specify the entitlementStatus field in your request, MediaConnect leaves the value unchanged.
    public var entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    /// The flow that is associated with the entitlement that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The AWS account IDs that you want to share your content with. The receiving accounts (subscribers) will be allowed to create their own flow using your content as the source.
    public var subscribers: [Swift.String]?

    public init (
        description: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        entitlementArn: Swift.String? = nil,
        entitlementStatus: MediaConnectClientTypes.EntitlementStatus? = nil,
        flowArn: Swift.String? = nil,
        subscribers: [Swift.String]? = nil
    )
    {
        self.description = description
        self.encryption = encryption
        self.entitlementArn = entitlementArn
        self.entitlementStatus = entitlementStatus
        self.flowArn = flowArn
        self.subscribers = subscribers
    }
}

struct UpdateFlowEntitlementInputBody: Swift.Equatable {
    let description: Swift.String?
    let encryption: MediaConnectClientTypes.UpdateEncryption?
    let entitlementStatus: MediaConnectClientTypes.EntitlementStatus?
    let subscribers: [Swift.String]?
}

extension UpdateFlowEntitlementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case encryption = "encryption"
        case entitlementStatus = "entitlementStatus"
        case subscribers = "subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let entitlementStatusDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.EntitlementStatus.self, forKey: .entitlementStatus)
        entitlementStatus = entitlementStatusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subscribers)
        var subscribersDecoded0:[Swift.String]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Swift.String]()
            for string0 in subscribersContainer {
                if let string0 = string0 {
                    subscribersDecoded0?.append(string0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateFlowEntitlementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowEntitlementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowEntitlementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowEntitlementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowEntitlementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entitlement = output.entitlement
            self.flowArn = output.flowArn
        } else {
            self.entitlement = nil
            self.flowArn = nil
        }
    }
}

public struct UpdateFlowEntitlementOutputResponse: Swift.Equatable {
    /// The new configuration of the entitlement that you updated.
    public var entitlement: MediaConnectClientTypes.Entitlement?
    /// The ARN of the flow that this entitlement was granted on.
    public var flowArn: Swift.String?

    public init (
        entitlement: MediaConnectClientTypes.Entitlement? = nil,
        flowArn: Swift.String? = nil
    )
    {
        self.entitlement = entitlement
        self.flowArn = flowArn
    }
}

struct UpdateFlowEntitlementOutputResponseBody: Swift.Equatable {
    let entitlement: MediaConnectClientTypes.Entitlement?
    let flowArn: Swift.String?
}

extension UpdateFlowEntitlementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entitlement = "entitlement"
        case flowArn = "flowArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitlementDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Entitlement.self, forKey: .entitlement)
        entitlement = entitlementDecoded
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
    }
}

extension UpdateFlowInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceFailoverConfig = sourceFailoverConfig {
            try encodeContainer.encode(sourceFailoverConfig, forKey: .sourceFailoverConfig)
        }
    }
}

extension UpdateFlowInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())"
    }
}

/// A request to update flow.
public struct UpdateFlowInput: Swift.Equatable {
    /// The flow that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The settings for source failover
    public var sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?

    public init (
        flowArn: Swift.String? = nil,
        sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig? = nil
    )
    {
        self.flowArn = flowArn
        self.sourceFailoverConfig = sourceFailoverConfig
    }
}

struct UpdateFlowInputBody: Swift.Equatable {
    let sourceFailoverConfig: MediaConnectClientTypes.UpdateFailoverConfig?
}

extension UpdateFlowInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceFailoverConfig = "sourceFailoverConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceFailoverConfigDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateFailoverConfig.self, forKey: .sourceFailoverConfig)
        sourceFailoverConfig = sourceFailoverConfigDecoded
    }
}

extension UpdateFlowMediaStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            try encodeContainer.encode(attributes, forKey: .attributes)
        }
        if let clockRate = clockRate {
            try encodeContainer.encode(clockRate, forKey: .clockRate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let mediaStreamType = mediaStreamType {
            try encodeContainer.encode(mediaStreamType.rawValue, forKey: .mediaStreamType)
        }
        if let videoFormat = videoFormat {
            try encodeContainer.encode(videoFormat, forKey: .videoFormat)
        }
    }
}

extension UpdateFlowMediaStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let mediaStreamName = mediaStreamName else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/mediaStreams/\(mediaStreamName.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the media stream.
public struct UpdateFlowMediaStreamInput: Swift.Equatable {
    /// The attributes that you want to assign to the media stream.
    public var attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    /// The sample rate (in Hz) for the stream. If the media stream type is video or ancillary data, set this value to 90000. If the media stream type is audio, set this value to either 48000 or 96000.
    public var clockRate: Swift.Int?
    /// Description
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the flow.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The name of the media stream that you want to update.
    /// This member is required.
    public var mediaStreamName: Swift.String?
    /// The type of media stream.
    public var mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    /// The resolution of the video.
    public var videoFormat: Swift.String?

    public init (
        attributes: MediaConnectClientTypes.MediaStreamAttributesRequest? = nil,
        clockRate: Swift.Int? = nil,
        description: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        mediaStreamName: Swift.String? = nil,
        mediaStreamType: MediaConnectClientTypes.MediaStreamType? = nil,
        videoFormat: Swift.String? = nil
    )
    {
        self.attributes = attributes
        self.clockRate = clockRate
        self.description = description
        self.flowArn = flowArn
        self.mediaStreamName = mediaStreamName
        self.mediaStreamType = mediaStreamType
        self.videoFormat = videoFormat
    }
}

struct UpdateFlowMediaStreamInputBody: Swift.Equatable {
    let attributes: MediaConnectClientTypes.MediaStreamAttributesRequest?
    let clockRate: Swift.Int?
    let description: Swift.String?
    let mediaStreamType: MediaConnectClientTypes.MediaStreamType?
    let videoFormat: Swift.String?
}

extension UpdateFlowMediaStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "attributes"
        case clockRate = "clockRate"
        case description = "description"
        case mediaStreamType = "mediaStreamType"
        case videoFormat = "videoFormat"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamAttributesRequest.self, forKey: .attributes)
        attributes = attributesDecoded
        let clockRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .clockRate)
        clockRate = clockRateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let mediaStreamTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStreamType.self, forKey: .mediaStreamType)
        mediaStreamType = mediaStreamTypeDecoded
        let videoFormatDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .videoFormat)
        videoFormat = videoFormatDecoded
    }
}

extension UpdateFlowMediaStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowMediaStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowMediaStreamOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowMediaStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowMediaStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.mediaStream = output.mediaStream
        } else {
            self.flowArn = nil
            self.mediaStream = nil
        }
    }
}

public struct UpdateFlowMediaStreamOutputResponse: Swift.Equatable {
    /// The ARN of the flow that is associated with the media stream that you updated.
    public var flowArn: Swift.String?
    /// The media stream that you updated.
    public var mediaStream: MediaConnectClientTypes.MediaStream?

    public init (
        flowArn: Swift.String? = nil,
        mediaStream: MediaConnectClientTypes.MediaStream? = nil
    )
    {
        self.flowArn = flowArn
        self.mediaStream = mediaStream
    }
}

struct UpdateFlowMediaStreamOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let mediaStream: MediaConnectClientTypes.MediaStream?
}

extension UpdateFlowMediaStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case mediaStream = "mediaStream"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let mediaStreamDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.MediaStream.self, forKey: .mediaStream)
        mediaStream = mediaStreamDecoded
    }
}

extension UpdateFlowOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cidrAllowList = cidrAllowList {
            var cidrAllowListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cidrAllowList)
            for __listof__string0 in cidrAllowList {
                try cidrAllowListContainer.encode(__listof__string0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let maxLatency = maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let mediaStreamOutputConfigurations = mediaStreamOutputConfigurations {
            var mediaStreamOutputConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamOutputConfigurations)
            for __listofmediastreamoutputconfigurationrequest0 in mediaStreamOutputConfigurations {
                try mediaStreamOutputConfigurationsContainer.encode(__listofmediastreamoutputconfigurationrequest0)
            }
        }
        if let minLatency = minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let port = port {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let remoteId = remoteId {
            try encodeContainer.encode(remoteId, forKey: .remoteId)
        }
        if let smoothingLatency = smoothingLatency {
            try encodeContainer.encode(smoothingLatency, forKey: .smoothingLatency)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceAttachment = vpcInterfaceAttachment {
            try encodeContainer.encode(vpcInterfaceAttachment, forKey: .vpcInterfaceAttachment)
        }
    }
}

extension UpdateFlowOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let outputArn = outputArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/outputs/\(outputArn.urlPercentEncoding())"
    }
}

/// The fields that you want to update in the output.
public struct UpdateFlowOutputInput: Swift.Equatable {
    /// The range of IP addresses that should be allowed to initiate output requests to this flow. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var cidrAllowList: [Swift.String]?
    /// A description of the output. This description appears only on the AWS Elemental MediaConnect console and will not be seen by the end user.
    public var description: Swift.String?
    /// The IP address where you want to send the output.
    public var destination: Swift.String?
    /// The type of key used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
    public var encryption: MediaConnectClientTypes.UpdateEncryption?
    /// The flow that is associated with the output that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The maximum latency in milliseconds for Zixi-based streams.
    public var maxLatency: Swift.Int?
    /// The media streams that are associated with the output, and the parameters for those associations.
    public var mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// The ARN of the output that you want to update.
    /// This member is required.
    public var outputArn: Swift.String?
    /// The port to use when content is distributed to this output.
    public var port: Swift.Int?
    /// The protocol to use for the output.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The remote ID for the Zixi-pull stream.
    public var remoteId: Swift.String?
    /// The smoothing latency in milliseconds for RIST, RTP, and RTP-FEC streams.
    public var smoothingLatency: Swift.Int?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface attachment to use for this output.
    public var vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?

    public init (
        cidrAllowList: [Swift.String]? = nil,
        description: Swift.String? = nil,
        destination: Swift.String? = nil,
        encryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        flowArn: Swift.String? = nil,
        maxLatency: Swift.Int? = nil,
        mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        outputArn: Swift.String? = nil,
        port: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        remoteId: Swift.String? = nil,
        smoothingLatency: Swift.Int? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment? = nil
    )
    {
        self.cidrAllowList = cidrAllowList
        self.description = description
        self.destination = destination
        self.encryption = encryption
        self.flowArn = flowArn
        self.maxLatency = maxLatency
        self.mediaStreamOutputConfigurations = mediaStreamOutputConfigurations
        self.minLatency = minLatency
        self.outputArn = outputArn
        self.port = port
        self.`protocol` = `protocol`
        self.remoteId = remoteId
        self.smoothingLatency = smoothingLatency
        self.streamId = streamId
        self.vpcInterfaceAttachment = vpcInterfaceAttachment
    }
}

struct UpdateFlowOutputInputBody: Swift.Equatable {
    let cidrAllowList: [Swift.String]?
    let description: Swift.String?
    let destination: Swift.String?
    let encryption: MediaConnectClientTypes.UpdateEncryption?
    let maxLatency: Swift.Int?
    let mediaStreamOutputConfigurations: [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]?
    let minLatency: Swift.Int?
    let port: Swift.Int?
    let `protocol`: MediaConnectClientTypes.ModelProtocol?
    let remoteId: Swift.String?
    let smoothingLatency: Swift.Int?
    let streamId: Swift.String?
    let vpcInterfaceAttachment: MediaConnectClientTypes.VpcInterfaceAttachment?
}

extension UpdateFlowOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cidrAllowList = "cidrAllowList"
        case description = "description"
        case destination = "destination"
        case encryption = "encryption"
        case maxLatency = "maxLatency"
        case mediaStreamOutputConfigurations = "mediaStreamOutputConfigurations"
        case minLatency = "minLatency"
        case port = "port"
        case `protocol` = "protocol"
        case remoteId = "remoteId"
        case smoothingLatency = "smoothingLatency"
        case streamId = "streamId"
        case vpcInterfaceAttachment = "vpcInterfaceAttachment"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cidrAllowListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .cidrAllowList)
        var cidrAllowListDecoded0:[Swift.String]? = nil
        if let cidrAllowListContainer = cidrAllowListContainer {
            cidrAllowListDecoded0 = [Swift.String]()
            for string0 in cidrAllowListContainer {
                if let string0 = string0 {
                    cidrAllowListDecoded0?.append(string0)
                }
            }
        }
        cidrAllowList = cidrAllowListDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destination)
        destination = destinationDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let mediaStreamOutputConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamOutputConfigurationRequest?].self, forKey: .mediaStreamOutputConfigurations)
        var mediaStreamOutputConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]? = nil
        if let mediaStreamOutputConfigurationsContainer = mediaStreamOutputConfigurationsContainer {
            mediaStreamOutputConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamOutputConfigurationRequest]()
            for structure0 in mediaStreamOutputConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamOutputConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamOutputConfigurations = mediaStreamOutputConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let remoteIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteId)
        remoteId = remoteIdDecoded
        let smoothingLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smoothingLatency)
        smoothingLatency = smoothingLatencyDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceAttachmentDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.VpcInterfaceAttachment.self, forKey: .vpcInterfaceAttachment)
        vpcInterfaceAttachment = vpcInterfaceAttachmentDecoded
    }
}

extension UpdateFlowOutputOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowOutputOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowOutputOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowOutputOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowOutputOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.output = output.output
        } else {
            self.flowArn = nil
            self.output = nil
        }
    }
}

public struct UpdateFlowOutputOutputResponse: Swift.Equatable {
    /// The ARN of the flow that is associated with the updated output.
    public var flowArn: Swift.String?
    /// The new settings of the output that you updated.
    public var output: MediaConnectClientTypes.Output?

    public init (
        flowArn: Swift.String? = nil,
        output: MediaConnectClientTypes.Output? = nil
    )
    {
        self.flowArn = flowArn
        self.output = output
    }
}

struct UpdateFlowOutputOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let output: MediaConnectClientTypes.Output?
}

extension UpdateFlowOutputOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case output = "output"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let outputDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Output.self, forKey: .output)
        output = outputDecoded
    }
}

extension UpdateFlowOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flow = output.flow
        } else {
            self.flow = nil
        }
    }
}

public struct UpdateFlowOutputResponse: Swift.Equatable {
    /// The settings for a flow, including its source, outputs, and entitlements.
    public var flow: MediaConnectClientTypes.Flow?

    public init (
        flow: MediaConnectClientTypes.Flow? = nil
    )
    {
        self.flow = flow
    }
}

struct UpdateFlowOutputResponseBody: Swift.Equatable {
    let flow: MediaConnectClientTypes.Flow?
}

extension UpdateFlowOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flow = "flow"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Flow.self, forKey: .flow)
        flow = flowDecoded
    }
}

extension UpdateFlowSourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decryption = decryption {
            try encodeContainer.encode(decryption, forKey: .decryption)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entitlementArn = entitlementArn {
            try encodeContainer.encode(entitlementArn, forKey: .entitlementArn)
        }
        if let ingestPort = ingestPort {
            try encodeContainer.encode(ingestPort, forKey: .ingestPort)
        }
        if let maxBitrate = maxBitrate {
            try encodeContainer.encode(maxBitrate, forKey: .maxBitrate)
        }
        if let maxLatency = maxLatency {
            try encodeContainer.encode(maxLatency, forKey: .maxLatency)
        }
        if let maxSyncBuffer = maxSyncBuffer {
            try encodeContainer.encode(maxSyncBuffer, forKey: .maxSyncBuffer)
        }
        if let mediaStreamSourceConfigurations = mediaStreamSourceConfigurations {
            var mediaStreamSourceConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mediaStreamSourceConfigurations)
            for __listofmediastreamsourceconfigurationrequest0 in mediaStreamSourceConfigurations {
                try mediaStreamSourceConfigurationsContainer.encode(__listofmediastreamsourceconfigurationrequest0)
            }
        }
        if let minLatency = minLatency {
            try encodeContainer.encode(minLatency, forKey: .minLatency)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let streamId = streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
        if let whitelistCidr = whitelistCidr {
            try encodeContainer.encode(whitelistCidr, forKey: .whitelistCidr)
        }
    }
}

extension UpdateFlowSourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let flowArn = flowArn else {
            return nil
        }
        guard let sourceArn = sourceArn else {
            return nil
        }
        return "/v1/flows/\(flowArn.urlPercentEncoding())/source/\(sourceArn.urlPercentEncoding())"
    }
}

/// A request to update the source of a flow.
public struct UpdateFlowSourceInput: Swift.Equatable {
    /// The type of encryption used on the content ingested from this source.
    public var decryption: MediaConnectClientTypes.UpdateEncryption?
    /// A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
    public var description: Swift.String?
    /// The ARN of the entitlement that allows you to subscribe to this flow. The entitlement is set by the flow originator, and the ARN is generated as part of the originator's flow.
    public var entitlementArn: Swift.String?
    /// The flow that is associated with the source that you want to update.
    /// This member is required.
    public var flowArn: Swift.String?
    /// The port that the flow will be listening on for incoming content.
    public var ingestPort: Swift.Int?
    /// The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
    public var maxBitrate: Swift.Int?
    /// The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
    public var maxLatency: Swift.Int?
    /// The size of the buffer (in milliseconds) to use to sync incoming source data.
    public var maxSyncBuffer: Swift.Int?
    /// The media streams that are associated with the source, and the parameters for those associations.
    public var mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    /// The minimum latency in milliseconds for SRT-based streams. In streams that use the SRT protocol, this value that you set on your MediaConnect source or output represents the minimal potential latency of that connection. The latency of the stream is set to the highest number between the sender’s minimum latency and the receiver’s minimum latency.
    public var minLatency: Swift.Int?
    /// The protocol that is used by the source.
    public var `protocol`: MediaConnectClientTypes.ModelProtocol?
    /// The ARN of the source that you want to update.
    /// This member is required.
    public var sourceArn: Swift.String?
    /// The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
    public var streamId: Swift.String?
    /// The name of the VPC interface to use for this source.
    public var vpcInterfaceName: Swift.String?
    /// The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
    public var whitelistCidr: Swift.String?

    public init (
        decryption: MediaConnectClientTypes.UpdateEncryption? = nil,
        description: Swift.String? = nil,
        entitlementArn: Swift.String? = nil,
        flowArn: Swift.String? = nil,
        ingestPort: Swift.Int? = nil,
        maxBitrate: Swift.Int? = nil,
        maxLatency: Swift.Int? = nil,
        maxSyncBuffer: Swift.Int? = nil,
        mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil,
        minLatency: Swift.Int? = nil,
        `protocol`: MediaConnectClientTypes.ModelProtocol? = nil,
        sourceArn: Swift.String? = nil,
        streamId: Swift.String? = nil,
        vpcInterfaceName: Swift.String? = nil,
        whitelistCidr: Swift.String? = nil
    )
    {
        self.decryption = decryption
        self.description = description
        self.entitlementArn = entitlementArn
        self.flowArn = flowArn
        self.ingestPort = ingestPort
        self.maxBitrate = maxBitrate
        self.maxLatency = maxLatency
        self.maxSyncBuffer = maxSyncBuffer
        self.mediaStreamSourceConfigurations = mediaStreamSourceConfigurations
        self.minLatency = minLatency
        self.`protocol` = `protocol`
        self.sourceArn = sourceArn
        self.streamId = streamId
        self.vpcInterfaceName = vpcInterfaceName
        self.whitelistCidr = whitelistCidr
    }
}

struct UpdateFlowSourceInputBody: Swift.Equatable {
    let decryption: MediaConnectClientTypes.UpdateEncryption?
    let description: Swift.String?
    let entitlementArn: Swift.String?
    let ingestPort: Swift.Int?
    let maxBitrate: Swift.Int?
    let maxLatency: Swift.Int?
    let maxSyncBuffer: Swift.Int?
    let mediaStreamSourceConfigurations: [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]?
    let minLatency: Swift.Int?
    let `protocol`: MediaConnectClientTypes.ModelProtocol?
    let streamId: Swift.String?
    let vpcInterfaceName: Swift.String?
    let whitelistCidr: Swift.String?
}

extension UpdateFlowSourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decryption = "decryption"
        case description = "description"
        case entitlementArn = "entitlementArn"
        case ingestPort = "ingestPort"
        case maxBitrate = "maxBitrate"
        case maxLatency = "maxLatency"
        case maxSyncBuffer = "maxSyncBuffer"
        case mediaStreamSourceConfigurations = "mediaStreamSourceConfigurations"
        case minLatency = "minLatency"
        case `protocol` = "protocol"
        case streamId = "streamId"
        case vpcInterfaceName = "vpcInterfaceName"
        case whitelistCidr = "whitelistCidr"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decryptionDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.UpdateEncryption.self, forKey: .decryption)
        decryption = decryptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let entitlementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entitlementArn)
        entitlementArn = entitlementArnDecoded
        let ingestPortDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ingestPort)
        ingestPort = ingestPortDecoded
        let maxBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBitrate)
        maxBitrate = maxBitrateDecoded
        let maxLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLatency)
        maxLatency = maxLatencyDecoded
        let maxSyncBufferDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxSyncBuffer)
        maxSyncBuffer = maxSyncBufferDecoded
        let mediaStreamSourceConfigurationsContainer = try containerValues.decodeIfPresent([MediaConnectClientTypes.MediaStreamSourceConfigurationRequest?].self, forKey: .mediaStreamSourceConfigurations)
        var mediaStreamSourceConfigurationsDecoded0:[MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]? = nil
        if let mediaStreamSourceConfigurationsContainer = mediaStreamSourceConfigurationsContainer {
            mediaStreamSourceConfigurationsDecoded0 = [MediaConnectClientTypes.MediaStreamSourceConfigurationRequest]()
            for structure0 in mediaStreamSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    mediaStreamSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        mediaStreamSourceConfigurations = mediaStreamSourceConfigurationsDecoded0
        let minLatencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minLatency)
        minLatency = minLatencyDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
        let whitelistCidrDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .whitelistCidr)
        whitelistCidr = whitelistCidrDecoded
    }
}

extension UpdateFlowSourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFlowSourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFlowSourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFlowSourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFlowSourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.flowArn = output.flowArn
            self.source = output.source
        } else {
            self.flowArn = nil
            self.source = nil
        }
    }
}

public struct UpdateFlowSourceOutputResponse: Swift.Equatable {
    /// The ARN of the flow that you want to update.
    public var flowArn: Swift.String?
    /// The settings for the source of the flow.
    public var source: MediaConnectClientTypes.Source?

    public init (
        flowArn: Swift.String? = nil,
        source: MediaConnectClientTypes.Source? = nil
    )
    {
        self.flowArn = flowArn
        self.source = source
    }
}

struct UpdateFlowSourceOutputResponseBody: Swift.Equatable {
    let flowArn: Swift.String?
    let source: MediaConnectClientTypes.Source?
}

extension UpdateFlowSourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case flowArn = "flowArn"
        case source = "source"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flowArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .flowArn)
        flowArn = flowArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
    }
}

extension MediaConnectClientTypes.VpcInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case networkInterfaceIds = "networkInterfaceIds"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceIds = networkInterfaceIds {
            var networkInterfaceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaceIds)
            for __listof__string0 in networkInterfaceIds {
                try networkInterfaceIdsContainer.encode(__listof__string0)
            }
        }
        if let networkInterfaceType = networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __listof__string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__listof__string0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .networkInterfaceIds)
        var networkInterfaceIdsDecoded0:[Swift.String]? = nil
        if let networkInterfaceIdsContainer = networkInterfaceIdsContainer {
            networkInterfaceIdsDecoded0 = [Swift.String]()
            for string0 in networkInterfaceIdsContainer {
                if let string0 = string0 {
                    networkInterfaceIdsDecoded0?.append(string0)
                }
            }
        }
        networkInterfaceIds = networkInterfaceIdsDecoded0
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for a VPC Source.
    public struct VpcInterface: Swift.Equatable {
        /// Immutable and has to be a unique against other VpcInterfaces in this Flow
        /// This member is required.
        public var name: Swift.String?
        /// IDs of the network interfaces created in customer's account by MediaConnect.
        /// This member is required.
        public var networkInterfaceIds: [Swift.String]?
        /// The type of network interface.
        /// This member is required.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init (
            name: Swift.String? = nil,
            networkInterfaceIds: [Swift.String]? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceIds = networkInterfaceIds
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }

}

extension MediaConnectClientTypes.VpcInterfaceAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vpcInterfaceName = "vpcInterfaceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcInterfaceName = vpcInterfaceName {
            try encodeContainer.encode(vpcInterfaceName, forKey: .vpcInterfaceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcInterfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcInterfaceName)
        vpcInterfaceName = vpcInterfaceNameDecoded
    }
}

extension MediaConnectClientTypes {
    /// The settings for attaching a VPC interface to an output.
    public struct VpcInterfaceAttachment: Swift.Equatable {
        /// The name of the VPC interface to use for this output.
        public var vpcInterfaceName: Swift.String?

        public init (
            vpcInterfaceName: Swift.String? = nil
        )
        {
            self.vpcInterfaceName = vpcInterfaceName
        }
    }

}

extension MediaConnectClientTypes.VpcInterfaceRequest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case networkInterfaceType = "networkInterfaceType"
        case roleArn = "roleArn"
        case securityGroupIds = "securityGroupIds"
        case subnetId = "subnetId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkInterfaceType = networkInterfaceType {
            try encodeContainer.encode(networkInterfaceType.rawValue, forKey: .networkInterfaceType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for __listof__string0 in securityGroupIds {
                try securityGroupIdsContainer.encode(__listof__string0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let networkInterfaceTypeDecoded = try containerValues.decodeIfPresent(MediaConnectClientTypes.NetworkInterfaceType.self, forKey: .networkInterfaceType)
        networkInterfaceType = networkInterfaceTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension MediaConnectClientTypes {
    /// Desired VPC Interface for a Flow
    public struct VpcInterfaceRequest: Swift.Equatable {
        /// The name of the VPC Interface. This value must be unique within the current flow.
        /// This member is required.
        public var name: Swift.String?
        /// The type of network interface. If this value is not included in the request, MediaConnect uses ENA as the networkInterfaceType.
        public var networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType?
        /// Role Arn MediaConnect can assumes to create ENIs in customer's account
        /// This member is required.
        public var roleArn: Swift.String?
        /// Security Group IDs to be used on ENI.
        /// This member is required.
        public var securityGroupIds: [Swift.String]?
        /// Subnet must be in the AZ of the Flow
        /// This member is required.
        public var subnetId: Swift.String?

        public init (
            name: Swift.String? = nil,
            networkInterfaceType: MediaConnectClientTypes.NetworkInterfaceType? = nil,
            roleArn: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            subnetId: Swift.String? = nil
        )
        {
            self.name = name
            self.networkInterfaceType = networkInterfaceType
            self.roleArn = roleArn
            self.securityGroupIds = securityGroupIds
            self.subnetId = subnetId
        }
    }

}
