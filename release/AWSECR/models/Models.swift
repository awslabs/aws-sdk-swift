// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension EcrClientTypes.Attribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EcrClientTypes.Attribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attribute(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension EcrClientTypes {
    /// This data type is used in the ImageScanFinding data type.
    public struct Attribute: Swift.Equatable {
        /// The attribute key.
        /// This member is required.
        public let key: Swift.String?
        /// The value assigned to the attribute key.
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension EcrClientTypes.AuthorizationData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiresAt
        case proxyEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = expiresAt {
            try encodeContainer.encode(expiresAt.timeIntervalSince1970, forKey: .expiresAt)
        }
        if let proxyEndpoint = proxyEndpoint {
            try encodeContainer.encode(proxyEndpoint, forKey: .proxyEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let proxyEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyEndpoint)
        proxyEndpoint = proxyEndpointDecoded
    }
}

extension EcrClientTypes.AuthorizationData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AuthorizationData(authorizationToken: \(Swift.String(describing: authorizationToken)), expiresAt: \(Swift.String(describing: expiresAt)), proxyEndpoint: \(Swift.String(describing: proxyEndpoint)))"}
}

extension EcrClientTypes {
    /// An object representing authorization data for an Amazon ECR registry.
    public struct AuthorizationData: Swift.Equatable {
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR
        ///             registry. When the string is decoded, it is presented in the format
        ///                 user:password for private registry authentication using docker
        ///                 login.
        public let authorizationToken: Swift.String?
        /// The Unix time in seconds and milliseconds when the authorization token expires.
        ///             Authorization tokens are valid for 12 hours.
        public let expiresAt: ClientRuntime.Date?
        /// The registry URL to use for this authorization token in a docker login
        ///             command. The Amazon ECR registry URL format is
        ///         https://aws_account_id.dkr.ecr.region.amazonaws.com. For example,
        ///         https://012345678910.dkr.ecr.us-east-1.amazonaws.com..
        public let proxyEndpoint: Swift.String?

        public init (
            authorizationToken: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil,
            proxyEndpoint: Swift.String? = nil
        )
        {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
        }
    }

}

public struct BatchCheckLayerAvailabilityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

extension BatchCheckLayerAvailabilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCheckLayerAvailabilityInput(layerDigests: \(Swift.String(describing: layerDigests)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension BatchCheckLayerAvailabilityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchCheckLayerAvailabilityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchCheckLayerAvailabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchCheckLayerAvailabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchCheckLayerAvailabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchCheckLayerAvailabilityOutputError>
}

public struct BatchCheckLayerAvailabilityInput: Swift.Equatable {
    /// The digests of the image layers to check.
    /// This member is required.
    public let layerDigests: [Swift.String]?
    /// The AWS account ID associated with the registry that contains the image layers to
    ///             check. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository that is associated with the image layers to check.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let layerDigests: [Swift.String]?
}

extension BatchCheckLayerAvailabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCheckLayerAvailabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCheckLayerAvailabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCheckLayerAvailabilityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchCheckLayerAvailabilityOutputResponse(failures: \(Swift.String(describing: failures)), layers: \(Swift.String(describing: layers)))"}
}

extension BatchCheckLayerAvailabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchCheckLayerAvailabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public let failures: [EcrClientTypes.LayerFailure]?
    /// A list of image layer objects corresponding to the image layer references in the
    ///             request.
    public let layers: [EcrClientTypes.Layer]?

    public init (
        failures: [EcrClientTypes.LayerFailure]? = nil,
        layers: [EcrClientTypes.Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputResponseBody: Swift.Equatable {
    public let layers: [EcrClientTypes.Layer]?
    public let failures: [EcrClientTypes.LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case layers
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([EcrClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[EcrClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [EcrClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([EcrClientTypes.LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[EcrClientTypes.LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [EcrClientTypes.LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchDeleteImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

extension BatchDeleteImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteImageInput(imageIds: \(Swift.String(describing: imageIds)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension BatchDeleteImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchDeleteImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

public struct BatchDeleteImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDeleteImageOutputError>
}

/// Deletes specified images within a specified repository. Images are specified with
///             either the imageTag or imageDigest.
public struct BatchDeleteImageInput: Swift.Equatable {
    /// A list of image ID references that correspond to images to delete. The format of the
    ///                 imageIds reference is imageTag=tag or
    ///                 imageDigest=digest.
    /// This member is required.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    /// The AWS account ID associated with the registry that contains the image to delete.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The repository that contains the image to delete.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteImageOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDeleteImageOutputResponse(failures: \(Swift.String(describing: failures)), imageIds: \(Swift.String(describing: imageIds)))"}
}

extension BatchDeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public let failures: [EcrClientTypes.ImageFailure]?
    /// The image IDs of the deleted images.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?

    public init (
        failures: [EcrClientTypes.ImageFailure]? = nil,
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputResponseBody: Swift.Equatable {
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    public let failures: [EcrClientTypes.ImageFailure]?
}

extension BatchDeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case imageIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[EcrClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [EcrClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct BatchGetImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetImageOutputError>
}

extension BatchGetImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetImageInput(acceptedMediaTypes: \(Swift.String(describing: acceptedMediaTypes)), imageIds: \(Swift.String(describing: imageIds)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension BatchGetImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedMediaTypes = acceptedMediaTypes {
            var acceptedMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceptedMediaTypes)
            for mediatypelist0 in acceptedMediaTypes {
                try acceptedMediaTypesContainer.encode(mediatypelist0)
            }
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct BatchGetImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetImageOutputError>
}

public struct BatchGetImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchGetImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchGetImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchGetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchGetImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchGetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchGetImageOutputError>
}

public struct BatchGetImageInput: Swift.Equatable {
    /// The accepted media types for the request.
    ///         Valid values: application/vnd.docker.distribution.manifest.v1+json |
    ///                 application/vnd.docker.distribution.manifest.v2+json |
    ///                 application/vnd.oci.image.manifest.v1+json
    ///
    public let acceptedMediaTypes: [Swift.String]?
    /// A list of image ID references that correspond to images to describe. The format of the
    ///                 imageIds reference is imageTag=tag or
    ///                 imageDigest=digest.
    /// This member is required.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    /// The AWS account ID associated with the registry that contains the images to describe.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        acceptedMediaTypes: [Swift.String]? = nil,
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.acceptedMediaTypes = acceptedMediaTypes
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchGetImageInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    public let acceptedMediaTypes: [Swift.String]?
}

extension BatchGetImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let acceptedMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceptedMediaTypes)
        var acceptedMediaTypesDecoded0:[Swift.String]? = nil
        if let acceptedMediaTypesContainer = acceptedMediaTypesContainer {
            acceptedMediaTypesDecoded0 = [Swift.String]()
            for string0 in acceptedMediaTypesContainer {
                if let string0 = string0 {
                    acceptedMediaTypesDecoded0?.append(string0)
                }
            }
        }
        acceptedMediaTypes = acceptedMediaTypesDecoded0
    }
}

extension BatchGetImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetImageOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchGetImageOutputResponse(failures: \(Swift.String(describing: failures)), images: \(Swift.String(describing: images)))"}
}

extension BatchGetImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchGetImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.images = output.images
        } else {
            self.failures = nil
            self.images = nil
        }
    }
}

public struct BatchGetImageOutputResponse: Swift.Equatable {
    /// Any failures associated with the call.
    public let failures: [EcrClientTypes.ImageFailure]?
    /// A list of image objects corresponding to the image references in the request.
    public let images: [EcrClientTypes.Image]?

    public init (
        failures: [EcrClientTypes.ImageFailure]? = nil,
        images: [EcrClientTypes.Image]? = nil
    )
    {
        self.failures = failures
        self.images = images
    }
}

struct BatchGetImageOutputResponseBody: Swift.Equatable {
    public let images: [EcrClientTypes.Image]?
    public let failures: [EcrClientTypes.ImageFailure]?
}

extension BatchGetImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case images
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([EcrClientTypes.Image?].self, forKey: .images)
        var imagesDecoded0:[EcrClientTypes.Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [EcrClientTypes.Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[EcrClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [EcrClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

public struct CompleteLayerUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

extension CompleteLayerUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteLayerUploadInput(layerDigests: \(Swift.String(describing: layerDigests)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension CompleteLayerUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigestlist0 in layerDigests {
                try layerDigestsContainer.encode(layerdigestlist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct CompleteLayerUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CompleteLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CompleteLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CompleteLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CompleteLayerUploadOutputError>
}

public struct CompleteLayerUploadInput: Swift.Equatable {
    /// The sha256 digest of the image layer.
    /// This member is required.
    public let layerDigests: [Swift.String]?
    /// The AWS account ID associated with the registry to which to upload layers.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to associate with the image layer.
    /// This member is required.
    public let repositoryName: Swift.String?
    /// The upload ID from a previous InitiateLayerUpload operation to
    ///             associate with the image layer.
    /// This member is required.
    public let uploadId: Swift.String?

    public init (
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let layerDigests: [Swift.String]?
}

extension CompleteLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EmptyUploadException" : self = .emptyUploadException(try EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLayerException" : self = .invalidLayerException(try InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerAlreadyExistsException" : self = .layerAlreadyExistsException(try LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerPartTooSmallException" : self = .layerPartTooSmallException(try LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CompleteLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case emptyUploadException(EmptyUploadException)
    case invalidLayerException(InvalidLayerException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case layerAlreadyExistsException(LayerAlreadyExistsException)
    case layerPartTooSmallException(LayerPartTooSmallException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteLayerUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompleteLayerUploadOutputResponse(layerDigest: \(Swift.String(describing: layerDigest)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension CompleteLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CompleteLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutputResponse: Swift.Equatable {
    /// The sha256 digest of the image layer.
    public let layerDigest: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?
    /// The upload ID associated with the layer.
    public let uploadId: Swift.String?

    public init (
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let layerDigest: Swift.String?
}

extension CompleteLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct CreateRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

extension CreateRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryInput(encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), imageScanningConfiguration: \(Swift.String(describing: imageScanningConfiguration)), imageTagMutability: \(Swift.String(describing: imageTagMutability)), repositoryName: \(Swift.String(describing: repositoryName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateRepositoryOutputError>
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The encryption configuration for the repository. This determines how the contents of
    ///             your repository are encrypted at rest.
    public let encryptionConfiguration: EcrClientTypes.EncryptionConfiguration?
    /// The image scanning configuration for the repository. This determines whether images
    ///             are scanned for known vulnerabilities after being pushed to the repository.
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
    /// The tag mutability setting for the repository. If this parameter is omitted, the
    ///             default setting of MUTABLE will be used which will allow image tags to be
    ///             overwritten. If IMMUTABLE is specified, all image tags within the
    ///             repository will be immutable which will prevent them from being overwritten.
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
    /// The name to use for the repository. The repository name may be specified on its own
    ///             (such as nginx-web-app) or it can be prepended with a namespace to group
    ///             the repository into a category (such as project-a/nginx-web-app).
    /// This member is required.
    public let repositoryName: Swift.String?
    /// The metadata that you apply to the repository to help you categorize and organize
    ///             them. Each tag consists of a key and an optional value, both of which you define.
    ///             Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.
    public let tags: [EcrClientTypes.Tag]?

    public init (
        encryptionConfiguration: EcrClientTypes.EncryptionConfiguration? = nil,
        imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration? = nil,
        imageTagMutability: EcrClientTypes.ImageTagMutability? = nil,
        repositoryName: Swift.String? = nil,
        tags: [EcrClientTypes.Tag]? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTagMutability = imageTagMutability
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    public let repositoryName: Swift.String?
    public let tags: [EcrClientTypes.Tag]?
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
    public let encryptionConfiguration: EcrClientTypes.EncryptionConfiguration?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case repositoryName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcrClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension CreateRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryAlreadyExistsException" : self = .repositoryAlreadyExistsException(try RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case kmsException(KmsException)
    case limitExceededException(LimitExceededException)
    case repositoryAlreadyExistsException(RepositoryAlreadyExistsException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension CreateRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutputResponse: Swift.Equatable {
    /// The repository that was created.
    public let repository: EcrClientTypes.Repository?

    public init (
        repository: EcrClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: EcrClientTypes.Repository?
}

extension CreateRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(EcrClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteLifecyclePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

extension DeleteLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLifecyclePolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteLifecyclePolicyOutputError>
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteLifecyclePolicyOutputResponse(lastEvaluatedAt: \(Swift.String(describing: lastEvaluatedAt)), lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteLifecyclePolicyOutputResponse: Swift.Equatable {
    /// The time stamp of the last time that the lifecycle policy was run.
    public let lastEvaluatedAt: ClientRuntime.Date?
    /// The JSON lifecycle policy text.
    public let lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        lastEvaluatedAt: ClientRuntime.Date? = nil,
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
    public let lastEvaluatedAt: ClientRuntime.Date?
}

extension DeleteLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

extension DeleteRegistryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRegistryPolicyInput()"}
}

extension DeleteRegistryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteRegistryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRegistryPolicyOutputError>
}

public struct DeleteRegistryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRegistryPolicyOutputError>
}

public struct DeleteRegistryPolicyInput: Swift.Equatable {

    public init() {}
}

struct DeleteRegistryPolicyInputBody: Swift.Equatable {
}

extension DeleteRegistryPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRegistryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRegistryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryPolicyNotFoundException" : self = .registryPolicyNotFoundException(try RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRegistryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryPolicyNotFoundException(RegistryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRegistryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRegistryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)))"}
}

extension DeleteRegistryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct DeleteRegistryPolicyOutputResponse: Swift.Equatable {
    /// The contents of the registry permissions policy that was deleted.
    public let policyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct DeleteRegistryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let policyText: Swift.String?
}

extension DeleteRegistryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DeleteRepositoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

extension DeleteRepositoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryInput(force: \(Swift.String(describing: force)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryOutputError>
}

public struct DeleteRepositoryInput: Swift.Equatable {
    ///  If a repository contains images, forces the deletion.
    public let force: Swift.Bool
    /// The AWS account ID associated with the registry that contains the repository to
    ///             delete. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let force: Swift.Bool
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRepositoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotEmptyException" : self = .repositoryNotEmptyException(try RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case repositoryNotEmptyException(RepositoryNotEmptyException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryOutputResponse(repository: \(Swift.String(describing: repository)))"}
}

extension DeleteRepositoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutputResponse: Swift.Equatable {
    /// The repository that was deleted.
    public let repository: EcrClientTypes.Repository?

    public init (
        repository: EcrClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputResponseBody: Swift.Equatable {
    public let repository: EcrClientTypes.Repository?
}

extension DeleteRepositoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(EcrClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

public struct DeleteRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

extension DeleteRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DeleteRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRepositoryPolicyOutputError>
}

public struct DeleteRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repository policy to
    ///             delete. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository that is associated with the repository policy to
    ///             delete.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension DeleteRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DeleteRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy that was deleted from the repository.
    public let policyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension DeleteRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct DescribeImageScanFindingsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageScanFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageScanFindingsOutputError>
}

extension DescribeImageScanFindingsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageScanFindingsInput(imageId: \(Swift.String(describing: imageId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DescribeImageScanFindingsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImageScanFindingsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageScanFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageScanFindingsOutputError>
}

public struct DescribeImageScanFindingsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImageScanFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImageScanFindingsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImageScanFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImageScanFindingsOutputError>
}

public struct DescribeImageScanFindingsInput: Swift.Equatable {
    /// An object with identifying information for an Amazon ECR image.
    /// This member is required.
    public let imageId: EcrClientTypes.ImageIdentifier?
    /// The maximum number of image scan results returned by
    ///                 DescribeImageScanFindings in paginated output. When this parameter is
    ///             used, DescribeImageScanFindings only returns maxResults
    ///             results in a single page along with a nextToken response element. The
    ///             remaining results of the initial request can be seen by sending another
    ///                 DescribeImageScanFindings request with the returned
    ///                 nextToken value. This value can be between 1 and 1000. If this
    ///             parameter is not used, then DescribeImageScanFindings returns up to 100
    ///             results and a nextToken value, if applicable.
    public let maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///                 DescribeImageScanFindings request where maxResults was
    ///             used and the results exceeded the value of that parameter. Pagination continues from the
    ///             end of the previous results that returned the nextToken value. This value
    ///             is null when there are no more results to return.
    public let nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository in
    ///             which to describe the image scan findings for. If you do not specify a registry, the
    ///             default registry is assumed.
    public let registryId: Swift.String?
    /// The repository for the image for which to describe the scan findings.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageId: EcrClientTypes.ImageIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageId: EcrClientTypes.ImageIdentifier?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeImageScanFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageScanFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageScanFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ScanNotFoundException" : self = .scanNotFoundException(try ScanNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageScanFindingsOutputError: Swift.Error, Swift.Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case scanNotFoundException(ScanNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageScanFindingsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImageScanFindingsOutputResponse(imageId: \(Swift.String(describing: imageId)), imageScanFindings: \(Swift.String(describing: imageScanFindings)), imageScanStatus: \(Swift.String(describing: imageScanStatus)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DescribeImageScanFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImageScanFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imageScanFindings = output.imageScanFindings
            self.imageScanStatus = output.imageScanStatus
            self.nextToken = output.nextToken
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanFindings = nil
            self.imageScanStatus = nil
            self.nextToken = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DescribeImageScanFindingsOutputResponse: Swift.Equatable {
    /// An object with identifying information for an Amazon ECR image.
    public let imageId: EcrClientTypes.ImageIdentifier?
    /// The information contained in the image scan findings.
    public let imageScanFindings: EcrClientTypes.ImageScanFindings?
    /// The current state of the scan.
    public let imageScanStatus: EcrClientTypes.ImageScanStatus?
    /// The nextToken value to include in a future
    ///                 DescribeImageScanFindings request. When the results of a
    ///                 DescribeImageScanFindings request exceed maxResults, this
    ///             value can be used to retrieve the next page of results. This value is null when there
    ///             are no more results to return.
    public let nextToken: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        imageId: EcrClientTypes.ImageIdentifier? = nil,
        imageScanFindings: EcrClientTypes.ImageScanFindings? = nil,
        imageScanStatus: EcrClientTypes.ImageScanStatus? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanFindings = imageScanFindings
        self.imageScanStatus = imageScanStatus
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageId: EcrClientTypes.ImageIdentifier?
    public let imageScanStatus: EcrClientTypes.ImageScanStatus?
    public let imageScanFindings: EcrClientTypes.ImageScanFindings?
    public let nextToken: Swift.String?
}

extension DescribeImageScanFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageScanFindings
        case imageScanStatus
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanFindings.self, forKey: .imageScanFindings)
        imageScanFindings = imageScanFindingsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EcrClientTypes.DescribeImagesFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension EcrClientTypes.DescribeImagesFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesFilter(tagStatus: \(Swift.String(describing: tagStatus)))"}
}

extension EcrClientTypes {
    /// An object representing a filter on a DescribeImages
    ///             operation.
    public struct DescribeImagesFilter: Swift.Equatable {
        /// The tag status with which to filter your DescribeImages results. You
        ///             can filter results based on whether they are TAGGED or
        ///                 UNTAGGED.
        public let tagStatus: EcrClientTypes.TagStatus?

        public init (
            tagStatus: EcrClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

public struct DescribeImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

extension DescribeImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesInput(filter: \(Swift.String(describing: filter)), imageIds: \(Swift.String(describing: imageIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension DescribeImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct DescribeImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeImagesOutputError>
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The filter key and value with which to filter your DescribeImages
    ///             results.
    public let filter: EcrClientTypes.DescribeImagesFilter?
    /// The list of image IDs for the requested repository.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by DescribeImages in
    ///             paginated output. When this parameter is used, DescribeImages only returns
    ///                 maxResults results in a single page along with a nextToken
    ///             response element. The remaining results of the initial request can be seen by sending
    ///             another DescribeImages request with the returned nextToken
    ///             value. This value can be between 1 and 1000. If this
    ///             parameter is not used, then DescribeImages returns up to
    ///             100 results and a nextToken value, if applicable. This
    ///             option cannot be used when you specify images with imageIds.
    public let maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///                 DescribeImages request where maxResults was used and the
    ///             results exceeded the value of that parameter. Pagination continues from the end of the
    ///             previous results that returned the nextToken value. This value is
    ///                 null when there are no more results to return. This option cannot be
    ///             used when you specify images with imageIds.
    public let nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository in which
    ///             to describe images. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        filter: EcrClientTypes.DescribeImagesFilter? = nil,
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filter: EcrClientTypes.DescribeImagesFilter?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(EcrClientTypes.DescribeImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Swift.Error, Swift.Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeImagesOutputResponse(imageDetails: \(Swift.String(describing: imageDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Swift.Equatable {
    /// A list of ImageDetail objects that contain data about the
    ///             image.
    public let imageDetails: [EcrClientTypes.ImageDetail]?
    /// The nextToken value to include in a future DescribeImages
    ///             request. When the results of a DescribeImages request exceed
    ///                 maxResults, this value can be used to retrieve the next page of
    ///             results. This value is null when there are no more results to
    ///             return.
    public let nextToken: Swift.String?

    public init (
        imageDetails: [EcrClientTypes.ImageDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Swift.Equatable {
    public let imageDetails: [EcrClientTypes.ImageDetail]?
    public let nextToken: Swift.String?
}

extension DescribeImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[EcrClientTypes.ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [EcrClientTypes.ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRegistryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegistryInput()"}
}

extension DescribeRegistryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeRegistryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRegistryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRegistryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRegistryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRegistryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRegistryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRegistryOutputError>
}

public struct DescribeRegistryInput: Swift.Equatable {

    public init() {}
}

struct DescribeRegistryInputBody: Swift.Equatable {
}

extension DescribeRegistryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegistryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRegistryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRegistryOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRegistryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRegistryOutputResponse(registryId: \(Swift.String(describing: registryId)), replicationConfiguration: \(Swift.String(describing: replicationConfiguration)))"}
}

extension DescribeRegistryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRegistryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.registryId = output.registryId
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.registryId = nil
            self.replicationConfiguration = nil
        }
    }
}

public struct DescribeRegistryOutputResponse: Swift.Equatable {
    /// The ID of the registry.
    public let registryId: Swift.String?
    /// The replication configuration for the registry.
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?

    public init (
        registryId: Swift.String? = nil,
        replicationConfiguration: EcrClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.registryId = registryId
        self.replicationConfiguration = replicationConfiguration
    }
}

struct DescribeRegistryOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?
}

extension DescribeRegistryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case replicationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

public struct DescribeRepositoriesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

extension DescribeRepositoriesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoriesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryNames: \(Swift.String(describing: repositoryNames)))"}
}

extension DescribeRepositoriesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositorynamelist0 in repositoryNames {
                try repositoryNamesContainer.encode(repositorynamelist0)
            }
        }
    }
}

public struct DescribeRepositoriesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRepositoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRepositoriesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRepositoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRepositoriesOutputError>
}

public struct DescribeRepositoriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRepositories
    ///             in paginated output. When this parameter is used, DescribeRepositories only
    ///             returns maxResults results in a single page along with a
    ///                 nextToken response element. The remaining results of the initial
    ///             request can be seen by sending another DescribeRepositories request with
    ///             the returned nextToken value. This value can be between 1
    ///             and 1000. If this parameter is not used, then
    ///                 DescribeRepositories returns up to 100 results and a
    ///                 nextToken value, if applicable. This option cannot be used when you
    ///             specify repositories with repositoryNames.
    public let maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///                 DescribeRepositories request where maxResults was used and
    ///             the results exceeded the value of that parameter. Pagination continues from the end of
    ///             the previous results that returned the nextToken value. This value is
    ///                 null when there are no more results to return. This option cannot be
    ///             used when you specify repositories with repositoryNames.
    ///
    ///             This token should be treated as an opaque identifier that is only used to
    ///                 retrieve the next items in a list and not for other programmatic purposes.
    ///
    public let nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repositories to be
    ///             described. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// A list of repositories to describe. If this parameter is omitted, then all
    ///             repositories in a registry are described.
    public let repositoryNames: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryNames: [Swift.String]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRepositoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRepositoriesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRepositoriesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRepositoriesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), repositories: \(Swift.String(describing: repositories)))"}
}

extension DescribeRepositoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRepositoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutputResponse: Swift.Equatable {
    /// The nextToken value to include in a future
    ///                 DescribeRepositories request. When the results of a
    ///                 DescribeRepositories request exceed maxResults, this value
    ///             can be used to retrieve the next page of results. This value is null when
    ///             there are no more results to return.
    public let nextToken: Swift.String?
    /// A list of repository objects corresponding to valid repositories.
    public let repositories: [EcrClientTypes.Repository]?

    public init (
        nextToken: Swift.String? = nil,
        repositories: [EcrClientTypes.Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputResponseBody: Swift.Equatable {
    public let repositories: [EcrClientTypes.Repository]?
    public let nextToken: Swift.String?
}

extension DescribeRepositoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([EcrClientTypes.Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[EcrClientTypes.Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [EcrClientTypes.Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension EmptyUploadException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmptyUploadException(message: \(Swift.String(describing: message)))"}
}

extension EmptyUploadException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layer upload does not contain any layer parts.
public struct EmptyUploadException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmptyUploadExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EmptyUploadExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.EncryptionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(EcrClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension EcrClientTypes.EncryptionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionConfiguration(encryptionType: \(Swift.String(describing: encryptionType)), kmsKey: \(Swift.String(describing: kmsKey)))"}
}

extension EcrClientTypes {
    /// The encryption configuration for the repository. This determines how the contents of
    ///             your repository are encrypted at rest.
    ///         By default, when no encryption configuration is set or the AES256
    ///             encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption
    ///             keys which encrypts your data at rest using an AES-256 encryption algorithm. This does
    ///             not require any action on your part.
    ///         For more control over the encryption of the contents of your repository, you can use
    ///             server-side encryption with customer master keys (CMKs) stored in AWS Key Management Service (AWS KMS) to
    ///             encrypt your images. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html">Amazon ECR encryption at
    ///                 rest in the Amazon Elastic Container Registry User Guide.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The encryption type to use.
        ///         If you use the KMS encryption type, the contents of the repository will
        ///             be encrypted using server-side encryption with customer master keys (CMKs) stored in
        ///             AWS KMS. When you use AWS KMS to encrypt your data, you can either use the default AWS
        ///             managed CMK for Amazon ECR, or specify your own CMK, which you already created. For more
        ///             information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html">Protecting Data Using Server-Side
        ///                 Encryption with CMKs Stored in AWS Key Management Service (SSE-KMS) in the
        ///                 Amazon Simple Storage Service Console Developer Guide..
        ///         If you use the AES256 encryption type, Amazon ECR uses server-side encryption
        ///             with Amazon S3-managed encryption keys which encrypts the images in the repository using an
        ///             AES-256 encryption algorithm. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html">Protecting Data Using
        ///                 Server-Side Encryption with Amazon S3-Managed Encryption Keys (SSE-S3) in
        ///             the Amazon Simple Storage Service Console Developer Guide..
        /// This member is required.
        public let encryptionType: EcrClientTypes.EncryptionType?
        /// If you use the KMS encryption type, specify the CMK to use for
        ///             encryption. The alias, key ID, or full ARN of the CMK can be specified. The key must
        ///             exist in the same Region as the repository. If no key is specified, the default AWS
        ///             managed CMK for Amazon ECR will be used.
        public let kmsKey: Swift.String?

        public init (
            encryptionType: EcrClientTypes.EncryptionType? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsKey = kmsKey
        }
    }

}

extension EcrClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .aes256,
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension EcrClientTypes {
    public enum FindingSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingSeverity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .undefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .undefined: return "UNDEFINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingSeverity(rawValue: rawValue) ?? FindingSeverity.sdkUnknown(rawValue)
        }
    }
}

public struct GetAuthorizationTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

extension GetAuthorizationTokenInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenInput(registryIds: \(Swift.String(describing: registryIds)))"}
}

extension GetAuthorizationTokenInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryIds = registryIds {
            var registryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registryIds)
            for getauthorizationtokenregistryidlist0 in registryIds {
                try registryIdsContainer.encode(getauthorizationtokenregistryidlist0)
            }
        }
    }
}

public struct GetAuthorizationTokenInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAuthorizationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAuthorizationTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAuthorizationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAuthorizationTokenOutputError>
}

public struct GetAuthorizationTokenInput: Swift.Equatable {
    /// A list of AWS account IDs that are associated with the registries for which to get
    ///             AuthorizationData objects. If you do not specify a registry, the default registry is assumed.
    @available(*, deprecated, message: "This field is deprecated. The returned authorization token can be used to access any Amazon ECR registry that the IAM principal has access to, specifying a registry ID doesn't change the permissions scope of the authorization token.")
    public let registryIds: [Swift.String]?

    public init (
        registryIds: [Swift.String]? = nil
    )
    {
        self.registryIds = registryIds
    }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
    public let registryIds: [Swift.String]?
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryIds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .registryIds)
        var registryIdsDecoded0:[Swift.String]? = nil
        if let registryIdsContainer = registryIdsContainer {
            registryIdsDecoded0 = [Swift.String]()
            for string0 in registryIdsContainer {
                if let string0 = string0 {
                    registryIdsDecoded0?.append(string0)
                }
            }
        }
        registryIds = registryIdsDecoded0
    }
}

extension GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAuthorizationTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAuthorizationTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAuthorizationTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAuthorizationTokenOutputResponse(authorizationData: \(Swift.String(describing: authorizationData)))"}
}

extension GetAuthorizationTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAuthorizationTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutputResponse: Swift.Equatable {
    /// A list of authorization token data objects that correspond to the
    ///                 registryIds values in the request.
    public let authorizationData: [EcrClientTypes.AuthorizationData]?

    public init (
        authorizationData: [EcrClientTypes.AuthorizationData]? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputResponseBody: Swift.Equatable {
    public let authorizationData: [EcrClientTypes.AuthorizationData]?
}

extension GetAuthorizationTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationData
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataContainer = try containerValues.decodeIfPresent([EcrClientTypes.AuthorizationData?].self, forKey: .authorizationData)
        var authorizationDataDecoded0:[EcrClientTypes.AuthorizationData]? = nil
        if let authorizationDataContainer = authorizationDataContainer {
            authorizationDataDecoded0 = [EcrClientTypes.AuthorizationData]()
            for structure0 in authorizationDataContainer {
                if let structure0 = structure0 {
                    authorizationDataDecoded0?.append(structure0)
                }
            }
        }
        authorizationData = authorizationDataDecoded0
    }
}

public struct GetDownloadUrlForLayerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDownloadUrlForLayerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDownloadUrlForLayerOutputError>
}

extension GetDownloadUrlForLayerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDownloadUrlForLayerInput(layerDigest: \(Swift.String(describing: layerDigest)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetDownloadUrlForLayerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetDownloadUrlForLayerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDownloadUrlForLayerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDownloadUrlForLayerOutputError>
}

public struct GetDownloadUrlForLayerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDownloadUrlForLayerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDownloadUrlForLayerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDownloadUrlForLayerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDownloadUrlForLayerOutputError>
}

public struct GetDownloadUrlForLayerInput: Swift.Equatable {
    /// The digest of the image layer to download.
    /// This member is required.
    public let layerDigest: Swift.String?
    /// The AWS account ID associated with the registry that contains the image layer to
    ///             download. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository that is associated with the image layer to download.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetDownloadUrlForLayerInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let layerDigest: Swift.String?
}

extension GetDownloadUrlForLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

extension GetDownloadUrlForLayerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDownloadUrlForLayerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayerInaccessibleException" : self = .layerInaccessibleException(try LayerInaccessibleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDownloadUrlForLayerOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case layerInaccessibleException(LayerInaccessibleException)
    case layersNotFoundException(LayersNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDownloadUrlForLayerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDownloadUrlForLayerOutputResponse(downloadUrl: \(Swift.String(describing: downloadUrl)), layerDigest: \(Swift.String(describing: layerDigest)))"}
}

extension GetDownloadUrlForLayerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDownloadUrlForLayerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
            self.layerDigest = output.layerDigest
        } else {
            self.downloadUrl = nil
            self.layerDigest = nil
        }
    }
}

public struct GetDownloadUrlForLayerOutputResponse: Swift.Equatable {
    /// The pre-signed Amazon S3 download URL for the requested layer.
    public let downloadUrl: Swift.String?
    /// The digest of the image layer to download.
    public let layerDigest: Swift.String?

    public init (
        downloadUrl: Swift.String? = nil,
        layerDigest: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.layerDigest = layerDigest
    }
}

struct GetDownloadUrlForLayerOutputResponseBody: Swift.Equatable {
    public let downloadUrl: Swift.String?
    public let layerDigest: Swift.String?
}

extension GetDownloadUrlForLayerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
        case layerDigest
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

public struct GetLifecyclePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

extension GetLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyOutputError>
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyOutputResponse(lastEvaluatedAt: \(Swift.String(describing: lastEvaluatedAt)), lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetLifecyclePolicyOutputResponse: Swift.Equatable {
    /// The time stamp of the last time that the lifecycle policy was run.
    public let lastEvaluatedAt: ClientRuntime.Date?
    /// The JSON lifecycle policy text.
    public let lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        lastEvaluatedAt: ClientRuntime.Date? = nil,
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
    public let lastEvaluatedAt: ClientRuntime.Date?
}

extension GetLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

public struct GetLifecyclePolicyPreviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyPreviewOutputError>
}

extension GetLifecyclePolicyPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyPreviewInput(filter: \(Swift.String(describing: filter)), imageIds: \(Swift.String(describing: imageIds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetLifecyclePolicyPreviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifierlist0 in imageIds {
                try imageIdsContainer.encode(imageidentifierlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetLifecyclePolicyPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyPreviewOutputError>
}

public struct GetLifecyclePolicyPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetLifecyclePolicyPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetLifecyclePolicyPreviewOutputError>
}

public struct GetLifecyclePolicyPreviewInput: Swift.Equatable {
    /// An optional parameter that filters results based on image tag status and all tags, if
    ///             tagged.
    public let filter: EcrClientTypes.LifecyclePolicyPreviewFilter?
    /// The list of imageIDs to be included.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by
    ///                 GetLifecyclePolicyPreviewRequest in paginated output. When this
    ///             parameter is used, GetLifecyclePolicyPreviewRequest only returns
    ///                 maxResults results in a single page along with a
    ///             nextToken response element. The remaining results of the initial request
    ///             can be seen by sending another GetLifecyclePolicyPreviewRequest request
    ///             with the returned nextToken value. This value can be between
    ///             1 and 1000. If this parameter is not used, then
    ///                 GetLifecyclePolicyPreviewRequest returns up to 100
    ///             results and a nextToken value, if applicable. This option cannot be used
    ///             when you specify images with imageIds.
    public let maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///                 GetLifecyclePolicyPreviewRequest request where maxResults
    ///             was used and the results exceeded the value of that parameter. Pagination continues
    ///             from the end of the previous results that returned the nextToken value.
    ///             This value is null when there are no more results to return. This option
    ///             cannot be used when you specify images with imageIds.
    public let nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        filter: EcrClientTypes.LifecyclePolicyPreviewFilter? = nil,
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyPreviewInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filter: EcrClientTypes.LifecyclePolicyPreviewFilter?
}

extension GetLifecyclePolicyPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LifecyclePolicyPreviewFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetLifecyclePolicyPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLifecyclePolicyPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyPreviewNotFoundException" : self = .lifecyclePolicyPreviewNotFoundException(try LifecyclePolicyPreviewNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLifecyclePolicyPreviewOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyPreviewNotFoundException(LifecyclePolicyPreviewNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLifecyclePolicyPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetLifecyclePolicyPreviewOutputResponse(lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), nextToken: \(Swift.String(describing: nextToken)), previewResults: \(Swift.String(describing: previewResults)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), status: \(Swift.String(describing: status)), summary: \(Swift.String(describing: summary)))"}
}

extension GetLifecyclePolicyPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLifecyclePolicyPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.nextToken = output.nextToken
            self.previewResults = output.previewResults
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
            self.summary = output.summary
        } else {
            self.lifecyclePolicyText = nil
            self.nextToken = nil
            self.previewResults = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
            self.summary = nil
        }
    }
}

public struct GetLifecyclePolicyPreviewOutputResponse: Swift.Equatable {
    /// The JSON lifecycle policy text.
    public let lifecyclePolicyText: Swift.String?
    /// The nextToken value to include in a future
    ///                 GetLifecyclePolicyPreview request. When the results of a
    ///                 GetLifecyclePolicyPreview request exceed maxResults, this
    ///             value can be used to retrieve the next page of results. This value is null
    ///             when there are no more results to return.
    public let nextToken: Swift.String?
    /// The results of the lifecycle policy preview request.
    public let previewResults: [EcrClientTypes.LifecyclePolicyPreviewResult]?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?
    /// The status of the lifecycle policy preview request.
    public let status: EcrClientTypes.LifecyclePolicyPreviewStatus?
    /// The list of images that is returned as a result of the action.
    public let summary: EcrClientTypes.LifecyclePolicyPreviewSummary?

    public init (
        lifecyclePolicyText: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        previewResults: [EcrClientTypes.LifecyclePolicyPreviewResult]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        status: EcrClientTypes.LifecyclePolicyPreviewStatus? = nil,
        summary: EcrClientTypes.LifecyclePolicyPreviewSummary? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.nextToken = nextToken
        self.previewResults = previewResults
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
        self.summary = summary
    }
}

struct GetLifecyclePolicyPreviewOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
    public let status: EcrClientTypes.LifecyclePolicyPreviewStatus?
    public let nextToken: Swift.String?
    public let previewResults: [EcrClientTypes.LifecyclePolicyPreviewResult]?
    public let summary: EcrClientTypes.LifecyclePolicyPreviewSummary?
}

extension GetLifecyclePolicyPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case nextToken
        case previewResults
        case registryId
        case repositoryName
        case status
        case summary
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let previewResultsContainer = try containerValues.decodeIfPresent([EcrClientTypes.LifecyclePolicyPreviewResult?].self, forKey: .previewResults)
        var previewResultsDecoded0:[EcrClientTypes.LifecyclePolicyPreviewResult]? = nil
        if let previewResultsContainer = previewResultsContainer {
            previewResultsDecoded0 = [EcrClientTypes.LifecyclePolicyPreviewResult]()
            for structure0 in previewResultsContainer {
                if let structure0 = structure0 {
                    previewResultsDecoded0?.append(structure0)
                }
            }
        }
        previewResults = previewResultsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LifecyclePolicyPreviewSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

extension GetRegistryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRegistryPolicyInput()"}
}

extension GetRegistryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetRegistryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryPolicyOutputError>
}

public struct GetRegistryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRegistryPolicyOutputError>
}

public struct GetRegistryPolicyInput: Swift.Equatable {

    public init() {}
}

struct GetRegistryPolicyInputBody: Swift.Equatable {
}

extension GetRegistryPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRegistryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegistryPolicyNotFoundException" : self = .registryPolicyNotFoundException(try RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRegistryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case registryPolicyNotFoundException(RegistryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRegistryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRegistryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)))"}
}

extension GetRegistryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct GetRegistryPolicyOutputResponse: Swift.Equatable {
    /// The JSON text of the permissions policy for a registry.
    public let policyText: Swift.String?
    /// The ID of the registry.
    public let registryId: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct GetRegistryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let policyText: Swift.String?
}

extension GetRegistryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct GetRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

extension GetRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPolicyInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct GetRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetRepositoryPolicyOutputError>
}

public struct GetRepositoryPolicyInput: Swift.Equatable {
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository with the policy to retrieve.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension GetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryPolicyNotFoundException" : self = .repositoryPolicyNotFoundException(try RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case repositoryPolicyNotFoundException(RepositoryPolicyNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension GetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy text associated with the repository.
    public let policyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension GetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension EcrClientTypes.Image: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension EcrClientTypes.Image: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Image(imageId: \(Swift.String(describing: imageId)), imageManifest: \(Swift.String(describing: imageManifest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension EcrClientTypes {
    /// An object representing an Amazon ECR image.
    public struct Image: Swift.Equatable {
        /// An object containing the image tag and image digest associated with an image.
        public let imageId: EcrClientTypes.ImageIdentifier?
        /// The image manifest associated with the image.
        public let imageManifest: Swift.String?
        /// The manifest media type of the image.
        public let imageManifestMediaType: Swift.String?
        /// The AWS account ID associated with the registry containing the image.
        public let registryId: Swift.String?
        /// The name of the repository associated with the image.
        public let repositoryName: Swift.String?

        public init (
            imageId: EcrClientTypes.ImageIdentifier? = nil,
            imageManifest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension EcrClientTypes {
    public enum ImageActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case expire
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageActionType] {
            return [
                .expire,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .expire: return "EXPIRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageActionType(rawValue: rawValue) ?? ImageActionType.sdkUnknown(rawValue)
        }
    }
}

extension ImageAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ImageAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image has already been pushed, and there were no changes to the manifest
///             or image tag after the last push.
public struct ImageAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.ImageDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageScanFindingsSummary
        case imageScanStatus
        case imageSizeInBytes
        case imageTags
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageScanFindingsSummary = imageScanFindingsSummary {
            try encodeContainer.encode(imageScanFindingsSummary, forKey: .imageScanFindingsSummary)
        }
        if let imageScanStatus = imageScanStatus {
            try encodeContainer.encode(imageScanStatus, forKey: .imageScanStatus)
        }
        if let imageSizeInBytes = imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsSummaryDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanFindingsSummary.self, forKey: .imageScanFindingsSummary)
        imageScanFindingsSummary = imageScanFindingsSummaryDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
    }
}

extension EcrClientTypes.ImageDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageDetail(artifactMediaType: \(Swift.String(describing: artifactMediaType)), imageDigest: \(Swift.String(describing: imageDigest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), imagePushedAt: \(Swift.String(describing: imagePushedAt)), imageScanFindingsSummary: \(Swift.String(describing: imageScanFindingsSummary)), imageScanStatus: \(Swift.String(describing: imageScanStatus)), imageSizeInBytes: \(Swift.String(describing: imageSizeInBytes)), imageTags: \(Swift.String(describing: imageTags)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension EcrClientTypes {
    /// An object that describes an image returned by a DescribeImages
    ///             operation.
    public struct ImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public let artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public let imageDigest: Swift.String?
        /// The media type of the image manifest.
        public let imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current
        ///             image was pushed to the repository.
        public let imagePushedAt: ClientRuntime.Date?
        /// A summary of the last completed image scan.
        public let imageScanFindingsSummary: EcrClientTypes.ImageScanFindingsSummary?
        /// The current state of the scan.
        public let imageScanStatus: EcrClientTypes.ImageScanStatus?
        /// The size, in bytes, of the image in the repository.
        ///         If the image is a manifest list, this will be the max size of all manifests in the
        ///             list.
        ///
        ///             Beginning with Docker version 1.9, the Docker client compresses image layers
        ///                 before pushing them to a V2 Docker registry. The output of the docker
        ///                     images command shows the uncompressed image size, so it may return a
        ///                 larger image size than the image sizes returned by DescribeImages.
        ///
        public let imageSizeInBytes: Swift.Int?
        /// The list of tags associated with this image.
        public let imageTags: [Swift.String]?
        /// The AWS account ID associated with the registry to which this image belongs.
        public let registryId: Swift.String?
        /// The name of the repository to which this image belongs.
        public let repositoryName: Swift.String?

        public init (
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageScanFindingsSummary: EcrClientTypes.ImageScanFindingsSummary? = nil,
            imageScanStatus: EcrClientTypes.ImageScanStatus? = nil,
            imageSizeInBytes: Swift.Int? = nil,
            imageTags: [Swift.String]? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageScanFindingsSummary = imageScanFindingsSummary
            self.imageScanStatus = imageScanStatus
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageDigestDoesNotMatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageDigestDoesNotMatchException(message: \(Swift.String(describing: message)))"}
}

extension ImageDigestDoesNotMatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image digest does not match the digest that Amazon ECR calculated for the
///             image.
public struct ImageDigestDoesNotMatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageDigestDoesNotMatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.ImageFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension EcrClientTypes.ImageFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageFailure(failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), imageId: \(Swift.String(describing: imageId)))"}
}

extension EcrClientTypes {
    /// An object representing an Amazon ECR image failure.
    public struct ImageFailure: Swift.Equatable {
        /// The code associated with the failure.
        public let failureCode: EcrClientTypes.ImageFailureCode?
        /// The reason for the failure.
        public let failureReason: Swift.String?
        /// The image ID associated with the failure.
        public let imageId: EcrClientTypes.ImageIdentifier?

        public init (
            failureCode: EcrClientTypes.ImageFailureCode? = nil,
            failureReason: Swift.String? = nil,
            imageId: EcrClientTypes.ImageIdentifier? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }
    }

}

extension EcrClientTypes {
    public enum ImageFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imagenotfound
        case imagereferencedbymanifestlist
        case imagetagdoesnotmatchdigest
        case invalidimagedigest
        case invalidimagetag
        case kmserror
        case missingdigestandtag
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFailureCode] {
            return [
                .imagenotfound,
                .imagereferencedbymanifestlist,
                .imagetagdoesnotmatchdigest,
                .invalidimagedigest,
                .invalidimagetag,
                .kmserror,
                .missingdigestandtag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imagenotfound: return "ImageNotFound"
            case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
            case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
            case .invalidimagedigest: return "InvalidImageDigest"
            case .invalidimagetag: return "InvalidImageTag"
            case .kmserror: return "KmsError"
            case .missingdigestandtag: return "MissingDigestAndTag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension EcrClientTypes.ImageIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension EcrClientTypes.ImageIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageIdentifier(imageDigest: \(Swift.String(describing: imageDigest)), imageTag: \(Swift.String(describing: imageTag)))"}
}

extension EcrClientTypes {
    /// An object with identifying information for an Amazon ECR image.
    public struct ImageIdentifier: Swift.Equatable {
        /// The sha256 digest of the image manifest.
        public let imageDigest: Swift.String?
        /// The tag used for the image.
        public let imageTag: Swift.String?

        public init (
            imageDigest: Swift.String? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }
    }

}

extension ImageNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ImageNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image requested does not exist in the specified repository.
public struct ImageNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.ImageScanFinding: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
        case severity
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let severityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.FindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([EcrClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[EcrClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [EcrClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension EcrClientTypes.ImageScanFinding: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageScanFinding(attributes: \(Swift.String(describing: attributes)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), severity: \(Swift.String(describing: severity)), uri: \(Swift.String(describing: uri)))"}
}

extension EcrClientTypes {
    /// Contains information about an image scan finding.
    public struct ImageScanFinding: Swift.Equatable {
        /// A collection of attributes of the host from which the finding is generated.
        public let attributes: [EcrClientTypes.Attribute]?
        /// The description of the finding.
        public let description: Swift.String?
        /// The name associated with the finding, usually a CVE number.
        public let name: Swift.String?
        /// The finding severity.
        public let severity: EcrClientTypes.FindingSeverity?
        /// A link containing additional details about the security vulnerability.
        public let uri: Swift.String?

        public init (
            attributes: [EcrClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            severity: EcrClientTypes.FindingSeverity? = nil,
            uri: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.severity = severity
            self.uri = uri
        }
    }

}

extension EcrClientTypes.ImageScanFindings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingSeverityCounts
        case findings
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingseveritycounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingseveritycounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let findings = findings {
            var findingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findings)
            for imagescanfindinglist0 in findings {
                try findingsContainer.encode(imagescanfindinglist0)
            }
        }
        if let imageScanCompletedAt = imageScanCompletedAt {
            try encodeContainer.encode(imageScanCompletedAt.timeIntervalSince1970, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt {
            try encodeContainer.encode(vulnerabilitySourceUpdatedAt.timeIntervalSince1970, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageScanFinding?].self, forKey: .findings)
        var findingsDecoded0:[EcrClientTypes.ImageScanFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [EcrClientTypes.ImageScanFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
    }
}

extension EcrClientTypes.ImageScanFindings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageScanFindings(findingSeverityCounts: \(Swift.String(describing: findingSeverityCounts)), findings: \(Swift.String(describing: findings)), imageScanCompletedAt: \(Swift.String(describing: imageScanCompletedAt)), vulnerabilitySourceUpdatedAt: \(Swift.String(describing: vulnerabilitySourceUpdatedAt)))"}
}

extension EcrClientTypes {
    /// The details of an image scan.
    public struct ImageScanFindings: Swift.Equatable {
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [Swift.String:Swift.Int]?
        /// The findings from the image scan.
        public let findings: [EcrClientTypes.ImageScanFinding]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: ClientRuntime.Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: ClientRuntime.Date?

        public init (
            findingSeverityCounts: [Swift.String:Swift.Int]? = nil,
            findings: [EcrClientTypes.ImageScanFinding]? = nil,
            imageScanCompletedAt: ClientRuntime.Date? = nil,
            vulnerabilitySourceUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.findingSeverityCounts = findingSeverityCounts
            self.findings = findings
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }
    }

}

extension EcrClientTypes.ImageScanFindingsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingSeverityCounts
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingseveritycounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingseveritycounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let imageScanCompletedAt = imageScanCompletedAt {
            try encodeContainer.encode(imageScanCompletedAt.timeIntervalSince1970, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt {
            try encodeContainer.encode(vulnerabilitySourceUpdatedAt.timeIntervalSince1970, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
    }
}

extension EcrClientTypes.ImageScanFindingsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageScanFindingsSummary(findingSeverityCounts: \(Swift.String(describing: findingSeverityCounts)), imageScanCompletedAt: \(Swift.String(describing: imageScanCompletedAt)), vulnerabilitySourceUpdatedAt: \(Swift.String(describing: vulnerabilitySourceUpdatedAt)))"}
}

extension EcrClientTypes {
    /// A summary of the last completed image scan.
    public struct ImageScanFindingsSummary: Swift.Equatable {
        /// The image vulnerability counts, sorted by severity.
        public let findingSeverityCounts: [Swift.String:Swift.Int]?
        /// The time of the last completed image scan.
        public let imageScanCompletedAt: ClientRuntime.Date?
        /// The time when the vulnerability data was last scanned.
        public let vulnerabilitySourceUpdatedAt: ClientRuntime.Date?

        public init (
            findingSeverityCounts: [Swift.String:Swift.Int]? = nil,
            imageScanCompletedAt: ClientRuntime.Date? = nil,
            vulnerabilitySourceUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }
    }

}

extension EcrClientTypes.ImageScanStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ScanStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension EcrClientTypes.ImageScanStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageScanStatus(description: \(Swift.String(describing: description)), status: \(Swift.String(describing: status)))"}
}

extension EcrClientTypes {
    /// The current status of an image scan.
    public struct ImageScanStatus: Swift.Equatable {
        /// The description of the image scan status.
        public let description: Swift.String?
        /// The current state of an image scan.
        public let status: EcrClientTypes.ScanStatus?

        public init (
            description: Swift.String? = nil,
            status: EcrClientTypes.ScanStatus? = nil
        )
        {
            self.description = description
            self.status = status
        }
    }

}

extension EcrClientTypes.ImageScanningConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanOnPush
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if scanOnPush != false {
            try encodeContainer.encode(scanOnPush, forKey: .scanOnPush)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanOnPushDecoded = try containerValues.decode(Swift.Bool.self, forKey: .scanOnPush)
        scanOnPush = scanOnPushDecoded
    }
}

extension EcrClientTypes.ImageScanningConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageScanningConfiguration(scanOnPush: \(Swift.String(describing: scanOnPush)))"}
}

extension EcrClientTypes {
    /// The image scanning configuration for a repository.
    public struct ImageScanningConfiguration: Swift.Equatable {
        /// The setting that determines whether images are scanned after being pushed to a
        ///             repository. If set to true, images will be scanned after being pushed. If
        ///             this parameter is not specified, it will default to false and images will
        ///             not be scanned unless a scan is manually started with the StartImageScan API.
        public let scanOnPush: Swift.Bool

        public init (
            scanOnPush: Swift.Bool = false
        )
        {
            self.scanOnPush = scanOnPush
        }
    }

}

extension ImageTagAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageTagAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ImageTagAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image is tagged with a tag that already exists. The repository is
///             configured for tag immutability.
public struct ImageTagAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ImageTagAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes {
    public enum ImageTagMutability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immutable
        case mutable
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageTagMutability] {
            return [
                .immutable,
                .mutable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immutable: return "IMMUTABLE"
            case .mutable: return "MUTABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageTagMutability(rawValue: rawValue) ?? ImageTagMutability.sdkUnknown(rawValue)
        }
    }
}

public struct InitiateLayerUploadInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

extension InitiateLayerUploadInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateLayerUploadInput(registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension InitiateLayerUploadInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct InitiateLayerUploadInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "InitiateLayerUploadInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<InitiateLayerUploadInput>
    public typealias MOutput = ClientRuntime.OperationOutput<InitiateLayerUploadOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<InitiateLayerUploadOutputError>
}

public struct InitiateLayerUploadInput: Swift.Equatable {
    /// The AWS account ID associated with the registry to which you intend to upload layers.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to which you intend to upload layers.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
}

extension InitiateLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitiateLayerUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitiateLayerUploadOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitiateLayerUploadOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InitiateLayerUploadOutputResponse(partSize: \(Swift.String(describing: partSize)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension InitiateLayerUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InitiateLayerUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutputResponse: Swift.Equatable {
    /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
    public let partSize: Swift.Int?
    /// The upload ID for the layer upload. This parameter is passed to further UploadLayerPart and CompleteLayerUpload
    ///             operations.
    public let uploadId: Swift.String?

    public init (
        partSize: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputResponseBody: Swift.Equatable {
    public let uploadId: Swift.String?
    public let partSize: Swift.Int?
}

extension InitiateLayerUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partSize
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

extension InvalidLayerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLayerException(message: \(Swift.String(describing: message)))"}
}

extension InvalidLayerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer digest calculation performed by Amazon ECR upon receipt of the image layer does
///             not match the digest specified.
public struct InvalidLayerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLayerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidLayerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidLayerPartException(lastValidByteReceived: \(Swift.String(describing: lastValidByteReceived)), message: \(Swift.String(describing: message)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension InvalidLayerPartException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: data)
            self.lastValidByteReceived = output.lastValidByteReceived
            self.message = output.message
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastValidByteReceived = nil
            self.message = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The layer part size is not valid, or the first byte specified is not consecutive to
///             the last byte of a previous layer part upload.
public struct InvalidLayerPartException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The last valid byte received from the layer part upload that is associated with the
    ///             exception.
    public var lastValidByteReceived: Swift.Int?
    /// The error message associated with the exception.
    public var message: Swift.String?
    /// The registry ID associated with the exception.
    public var registryId: Swift.String?
    /// The repository name associated with the exception.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the exception.
    public var uploadId: Swift.String?

    public init (
        lastValidByteReceived: Swift.Int? = nil,
        message: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastValidByteReceived = lastValidByteReceived
        self.message = message
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let lastValidByteReceived: Swift.Int?
    public let message: Swift.String?
}

extension InvalidLayerPartExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API
///             request.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have
///             a maximum length of 256 characters.
public struct InvalidTagParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "KmsException(kmsError: \(Swift.String(describing: kmsError)), message: \(Swift.String(describing: message)))"}
}

extension KmsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.kmsError = output.kmsError
            self.message = output.message
        } else {
            self.kmsError = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation failed due to a KMS exception.
public struct KmsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error code returned by AWS KMS.
    public var kmsError: Swift.String?
    public var message: Swift.String?

    public init (
        kmsError: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.kmsError = kmsError
        self.message = message
    }
}

struct KmsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let kmsError: Swift.String?
}

extension KmsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsError
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let kmsErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsError)
        kmsError = kmsErrorDecoded
    }
}

extension EcrClientTypes.Layer: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension EcrClientTypes.Layer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Layer(layerAvailability: \(Swift.String(describing: layerAvailability)), layerDigest: \(Swift.String(describing: layerDigest)), layerSize: \(Swift.String(describing: layerSize)), mediaType: \(Swift.String(describing: mediaType)))"}
}

extension EcrClientTypes {
    /// An object representing an Amazon ECR image layer.
    public struct Layer: Swift.Equatable {
        /// The availability status of the image layer.
        public let layerAvailability: EcrClientTypes.LayerAvailability?
        /// The sha256 digest of the image layer.
        public let layerDigest: Swift.String?
        /// The size, in bytes, of the image layer.
        public let layerSize: Swift.Int?
        /// The media type of the layer, such as
        ///                 application/vnd.docker.image.rootfs.diff.tar.gzip or
        ///                 application/vnd.oci.image.layer.v1.tar+gzip.
        public let mediaType: Swift.String?

        public init (
            layerAvailability: EcrClientTypes.LayerAvailability? = nil,
            layerDigest: Swift.String? = nil,
            layerSize: Swift.Int? = nil,
            mediaType: Swift.String? = nil
        )
        {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }
    }

}

extension LayerAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension LayerAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image layer already exists in the associated repository.
public struct LayerAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayerAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes {
    public enum LayerAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAvailability] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
        }
    }
}

extension EcrClientTypes.LayerFailure: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension EcrClientTypes.LayerFailure: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerFailure(failureCode: \(Swift.String(describing: failureCode)), failureReason: \(Swift.String(describing: failureReason)), layerDigest: \(Swift.String(describing: layerDigest)))"}
}

extension EcrClientTypes {
    /// An object representing an Amazon ECR image layer failure.
    public struct LayerFailure: Swift.Equatable {
        /// The failure code associated with the failure.
        public let failureCode: EcrClientTypes.LayerFailureCode?
        /// The reason for the failure.
        public let failureReason: Swift.String?
        /// The layer digest associated with the failure.
        public let layerDigest: Swift.String?

        public init (
            failureCode: EcrClientTypes.LayerFailureCode? = nil,
            failureReason: Swift.String? = nil,
            layerDigest: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }
    }

}

extension EcrClientTypes {
    public enum LayerFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidlayerdigest
        case missinglayerdigest
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerFailureCode] {
            return [
                .invalidlayerdigest,
                .missinglayerdigest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidlayerdigest: return "InvalidLayerDigest"
            case .missinglayerdigest: return "MissingLayerDigest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension LayerInaccessibleException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerInaccessibleException(message: \(Swift.String(describing: message)))"}
}

extension LayerInaccessibleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayerInaccessibleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layer is not available because it is not associated with an image.
///             Unassociated image layers may be cleaned up at any time.
public struct LayerInaccessibleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerInaccessibleExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayerInaccessibleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayerPartTooSmallException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayerPartTooSmallException(message: \(Swift.String(describing: message)))"}
}

extension LayerPartTooSmallException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Layer parts must be at least 5 MiB in size.
public struct LayerPartTooSmallException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayerPartTooSmallExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LayersNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension LayersNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified layers could not be found, or the specified layer is not valid for this
///             repository.
public struct LayersNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LayersNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LayersNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension LifecyclePolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LifecyclePolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The lifecycle policy could not be found, and no policy is set to the
///             repository.
public struct LifecyclePolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LifecyclePolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyPreviewFilter(tagStatus: \(Swift.String(describing: tagStatus)))"}
}

extension EcrClientTypes {
    /// The filter for the lifecycle policy preview.
    public struct LifecyclePolicyPreviewFilter: Swift.Equatable {
        /// The tag status of the image.
        public let tagStatus: EcrClientTypes.TagStatus?

        public init (
            tagStatus: EcrClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

extension LifecyclePolicyPreviewInProgressException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyPreviewInProgressException(message: \(Swift.String(describing: message)))"}
}

extension LifecyclePolicyPreviewInProgressException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LifecyclePolicyPreviewInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The previous lifecycle policy preview request has not completed. Wait and try
///             again.
public struct LifecyclePolicyPreviewInProgressException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyPreviewInProgressExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LifecyclePolicyPreviewInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyPreviewNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyPreviewNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension LifecyclePolicyPreviewNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LifecyclePolicyPreviewNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is no dry run for this repository.
public struct LifecyclePolicyPreviewNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LifecyclePolicyPreviewNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LifecyclePolicyPreviewNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case appliedRulePriority
        case imageDigest
        case imagePushedAt
        case imageTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let appliedRulePriority = appliedRulePriority {
            try encodeContainer.encode(appliedRulePriority, forKey: .appliedRulePriority)
        }
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imagePushedAt = imagePushedAt {
            try encodeContainer.encode(imagePushedAt.timeIntervalSince1970, forKey: .imagePushedAt)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetaglist0 in imageTags {
                try imageTagsContainer.encode(imagetaglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imagePushedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let actionDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LifecyclePolicyRuleAction.self, forKey: .action)
        action = actionDecoded
        let appliedRulePriorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedRulePriority)
        appliedRulePriority = appliedRulePriorityDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyPreviewResult(action: \(Swift.String(describing: action)), appliedRulePriority: \(Swift.String(describing: appliedRulePriority)), imageDigest: \(Swift.String(describing: imageDigest)), imagePushedAt: \(Swift.String(describing: imagePushedAt)), imageTags: \(Swift.String(describing: imageTags)))"}
}

extension EcrClientTypes {
    /// The result of the lifecycle policy preview.
    public struct LifecyclePolicyPreviewResult: Swift.Equatable {
        /// The type of action to be taken.
        public let action: EcrClientTypes.LifecyclePolicyRuleAction?
        /// The priority of the applied rule.
        public let appliedRulePriority: Swift.Int?
        /// The sha256 digest of the image manifest.
        public let imageDigest: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current
        ///             image was pushed to the repository.
        public let imagePushedAt: ClientRuntime.Date?
        /// The list of tags associated with this image.
        public let imageTags: [Swift.String]?

        public init (
            action: EcrClientTypes.LifecyclePolicyRuleAction? = nil,
            appliedRulePriority: Swift.Int? = nil,
            imageDigest: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageTags: [Swift.String]? = nil
        )
        {
            self.action = action
            self.appliedRulePriority = appliedRulePriority
            self.imageDigest = imageDigest
            self.imagePushedAt = imagePushedAt
            self.imageTags = imageTags
        }
    }

}

extension EcrClientTypes {
    public enum LifecyclePolicyPreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case expired
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyPreviewStatus] {
            return [
                .complete,
                .expired,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyPreviewStatus(rawValue: rawValue) ?? LifecyclePolicyPreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiringImageTotalCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiringImageTotalCount = expiringImageTotalCount {
            try encodeContainer.encode(expiringImageTotalCount, forKey: .expiringImageTotalCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expiringImageTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiringImageTotalCount)
        expiringImageTotalCount = expiringImageTotalCountDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyPreviewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyPreviewSummary(expiringImageTotalCount: \(Swift.String(describing: expiringImageTotalCount)))"}
}

extension EcrClientTypes {
    /// The summary of the lifecycle policy preview request.
    public struct LifecyclePolicyPreviewSummary: Swift.Equatable {
        /// The number of expiring images.
        public let expiringImageTotalCount: Swift.Int?

        public init (
            expiringImageTotalCount: Swift.Int? = nil
        )
        {
            self.expiringImageTotalCount = expiringImageTotalCount
        }
    }

}

extension EcrClientTypes.LifecyclePolicyRuleAction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageActionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EcrClientTypes.LifecyclePolicyRuleAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifecyclePolicyRuleAction(type: \(Swift.String(describing: type)))"}
}

extension EcrClientTypes {
    /// The type of action to be taken.
    public struct LifecyclePolicyRuleAction: Swift.Equatable {
        /// The type of action to be taken.
        public let type: EcrClientTypes.ImageActionType?

        public init (
            type: EcrClientTypes.ImageActionType? = nil
        )
        {
            self.type = type
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your
///             account. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html">Amazon ECR Service Quotas in
///             the Amazon Elastic Container Registry User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.ListImagesFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension EcrClientTypes.ListImagesFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagesFilter(tagStatus: \(Swift.String(describing: tagStatus)))"}
}

extension EcrClientTypes {
    /// An object representing a filter on a ListImages operation.
    public struct ListImagesFilter: Swift.Equatable {
        /// The tag status with which to filter your ListImages results. You can
        ///             filter results based on whether they are TAGGED or
        ///             UNTAGGED.
        public let tagStatus: EcrClientTypes.TagStatus?

        public init (
            tagStatus: EcrClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

public struct ListImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

extension ListImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagesInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension ListImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct ListImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInput: Swift.Equatable {
    /// The filter key and value with which to filter your ListImages
    ///             results.
    public let filter: EcrClientTypes.ListImagesFilter?
    /// The maximum number of image results returned by ListImages in paginated
    ///             output. When this parameter is used, ListImages only returns
    ///                 maxResults results in a single page along with a nextToken
    ///             response element. The remaining results of the initial request can be seen by sending
    ///             another ListImages request with the returned nextToken value.
    ///             This value can be between 1 and 1000. If this parameter is
    ///             not used, then ListImages returns up to 100 results and a
    ///                 nextToken value, if applicable.
    public let maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated
    ///                 ListImages request where maxResults was used and the
    ///             results exceeded the value of that parameter. Pagination continues from the end of the
    ///             previous results that returned the nextToken value. This value is
    ///                 null when there are no more results to return.
    ///
    ///             This token should be treated as an opaque identifier that is only used to
    ///                 retrieve the next items in a list and not for other programmatic purposes.
    ///
    public let nextToken: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository in which
    ///             to list images. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The repository with image IDs to be listed.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        filter: EcrClientTypes.ListImagesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct ListImagesInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
    public let filter: EcrClientTypes.ListImagesFilter?
}

extension ListImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ListImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagesOutputResponse(imageIds: \(Swift.String(describing: imageIds)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageIds = output.imageIds
            self.nextToken = output.nextToken
        } else {
            self.imageIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListImagesOutputResponse: Swift.Equatable {
    /// The list of image IDs for the requested repository.
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    /// The nextToken value to include in a future ListImages
    ///             request. When the results of a ListImages request exceed
    ///                 maxResults, this value can be used to retrieve the next page of
    ///             results. This value is null when there are no more results to
    ///             return.
    public let nextToken: Swift.String?

    public init (
        imageIds: [EcrClientTypes.ImageIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.nextToken = nextToken
    }
}

struct ListImagesOutputResponseBody: Swift.Equatable {
    public let imageIds: [EcrClientTypes.ImageIdentifier]?
    public let nextToken: Swift.String?
}

extension ListImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[EcrClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [EcrClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the
    ///             only supported resource is an Amazon ECR repository.
    /// This member is required.
    public let resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the resource.
    public let tags: [EcrClientTypes.Tag]?

    public init (
        tags: [EcrClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [EcrClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([EcrClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct PutImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

extension PutImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageInput(imageDigest: \(Swift.String(describing: imageDigest)), imageManifest: \(Swift.String(describing: imageManifest)), imageManifestMediaType: \(Swift.String(describing: imageManifestMediaType)), imageTag: \(Swift.String(describing: imageTag)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageOutputError>
}

public struct PutImageInput: Swift.Equatable {
    /// The image digest of the image manifest corresponding to the image.
    public let imageDigest: Swift.String?
    /// The image manifest corresponding to the image to be uploaded.
    /// This member is required.
    public let imageManifest: Swift.String?
    /// The media type of the image manifest. If you push an image manifest that does not
    ///             contain the mediaType field, you must specify the
    ///                 imageManifestMediaType in the request.
    public let imageManifestMediaType: Swift.String?
    /// The tag to associate with the image. This parameter is required for images that use
    ///             the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
    public let imageTag: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository in which
    ///             to put the image. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository in which to put the image.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageDigest: Swift.String? = nil,
        imageManifest: Swift.String? = nil,
        imageManifestMediaType: Swift.String? = nil,
        imageTag: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageManifest: Swift.String?
    public let imageManifestMediaType: Swift.String?
    public let imageTag: Swift.String?
    public let imageDigest: Swift.String?
}

extension PutImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageAlreadyExistsException" : self = .imageAlreadyExistsException(try ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageDigestDoesNotMatchException" : self = .imageDigestDoesNotMatchException(try ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ImageTagAlreadyExistsException" : self = .imageTagAlreadyExistsException(try ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LayersNotFoundException" : self = .layersNotFoundException(try LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReferencedImagesNotFoundException" : self = .referencedImagesNotFoundException(try ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageOutputError: Swift.Error, Swift.Equatable {
    case imageAlreadyExistsException(ImageAlreadyExistsException)
    case imageDigestDoesNotMatchException(ImageDigestDoesNotMatchException)
    case imageTagAlreadyExistsException(ImageTagAlreadyExistsException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case layersNotFoundException(LayersNotFoundException)
    case limitExceededException(LimitExceededException)
    case referencedImagesNotFoundException(ReferencedImagesNotFoundException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageOutputResponse(image: \(Swift.String(describing: image)))"}
}

extension PutImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutputResponse: Swift.Equatable {
    /// Details of the image uploaded.
    public let image: EcrClientTypes.Image?

    public init (
        image: EcrClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputResponseBody: Swift.Equatable {
    public let image: EcrClientTypes.Image?
}

extension PutImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(EcrClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

public struct PutImageScanningConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageScanningConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageScanningConfigurationOutputError>
}

extension PutImageScanningConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageScanningConfigurationInput(imageScanningConfiguration: \(Swift.String(describing: imageScanningConfiguration)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageScanningConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageScanningConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageScanningConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageScanningConfigurationOutputError>
}

public struct PutImageScanningConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageScanningConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageScanningConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageScanningConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageScanningConfigurationOutputError>
}

public struct PutImageScanningConfigurationInput: Swift.Equatable {
    /// The image scanning configuration for the repository. This setting determines whether
    ///             images are scanned for known vulnerabilities after being pushed to the
    ///             repository.
    /// This member is required.
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
    /// The AWS account ID associated with the registry that contains the repository in
    ///             which to update the image scanning configuration setting.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository in which to update the image scanning configuration
    ///             setting.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
}

extension PutImageScanningConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension PutImageScanningConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageScanningConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageScanningConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageScanningConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageScanningConfigurationOutputResponse(imageScanningConfiguration: \(Swift.String(describing: imageScanningConfiguration)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageScanningConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImageScanningConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageScanningConfiguration = output.imageScanningConfiguration
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageScanningConfiguration = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageScanningConfigurationOutputResponse: Swift.Equatable {
    /// The image scanning configuration setting for the repository.
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
}

extension PutImageScanningConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

public struct PutImageTagMutabilityInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageTagMutabilityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageTagMutabilityOutputError>
}

extension PutImageTagMutabilityInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageTagMutabilityInput(imageTagMutability: \(Swift.String(describing: imageTagMutability)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageTagMutabilityInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutImageTagMutabilityInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageTagMutabilityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageTagMutabilityOutputError>
}

public struct PutImageTagMutabilityInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageTagMutabilityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageTagMutabilityInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageTagMutabilityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageTagMutabilityOutputError>
}

public struct PutImageTagMutabilityInput: Swift.Equatable {
    /// The tag mutability setting for the repository. If MUTABLE is specified,
    ///             image tags can be overwritten. If IMMUTABLE is specified, all image tags
    ///             within the repository will be immutable which will prevent them from being
    ///             overwritten.
    /// This member is required.
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
    /// The AWS account ID associated with the registry that contains the repository in which
    ///             to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository in which to update the image tag mutability
    ///             settings.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageTagMutability: EcrClientTypes.ImageTagMutability? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
}

extension PutImageTagMutabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

extension PutImageTagMutabilityOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageTagMutabilityOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageTagMutabilityOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageTagMutabilityOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageTagMutabilityOutputResponse(imageTagMutability: \(Swift.String(describing: imageTagMutability)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutImageTagMutabilityOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImageTagMutabilityOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageTagMutability = output.imageTagMutability
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageTagMutability = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageTagMutabilityOutputResponse: Swift.Equatable {
    /// The image tag mutability setting for the repository.
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        imageTagMutability: EcrClientTypes.ImageTagMutability? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageTagMutability: EcrClientTypes.ImageTagMutability?
}

extension PutImageTagMutabilityOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

public struct PutLifecyclePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecyclePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecyclePolicyOutputError>
}

extension PutLifecyclePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLifecyclePolicyInput(lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutLifecyclePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct PutLifecyclePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecyclePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLifecyclePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLifecyclePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLifecyclePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLifecyclePolicyOutputError>
}

public struct PutLifecyclePolicyInput: Swift.Equatable {
    /// The JSON repository policy text to apply to the repository.
    /// This member is required.
    public let lifecyclePolicyText: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository. If you
    ///             do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
}

extension PutLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension PutLifecyclePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLifecyclePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLifecyclePolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLifecyclePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLifecyclePolicyOutputResponse(lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension PutLifecyclePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutLifecyclePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutLifecyclePolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy text.
    public let lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
}

extension PutLifecyclePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

public struct PutRegistryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryPolicyOutputError>
}

extension PutRegistryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRegistryPolicyInput(policyText: \(Swift.String(describing: policyText)))"}
}

extension PutRegistryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
    }
}

public struct PutRegistryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryPolicyOutputError>
}

public struct PutRegistryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRegistryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRegistryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRegistryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRegistryPolicyOutputError>
}

public struct PutRegistryPolicyInput: Swift.Equatable {
    /// The JSON policy text to apply to your registry. The policy text follows the same
    ///             format as IAM policy text. For more information, see <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html">Registry
    ///                 permissions in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public let policyText: Swift.String?

    public init (
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

struct PutRegistryPolicyInputBody: Swift.Equatable {
    public let policyText: Swift.String?
}

extension PutRegistryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension PutRegistryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRegistryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRegistryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRegistryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRegistryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)))"}
}

extension PutRegistryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutRegistryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct PutRegistryPolicyOutputResponse: Swift.Equatable {
    /// The JSON policy text for your registry.
    public let policyText: Swift.String?
    /// The registry ID.
    public let registryId: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct PutRegistryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let policyText: Swift.String?
}

extension PutRegistryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct PutReplicationConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReplicationConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReplicationConfigurationOutputError>
}

extension PutReplicationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutReplicationConfigurationInput(replicationConfiguration: \(Swift.String(describing: replicationConfiguration)))"}
}

extension PutReplicationConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfiguration = replicationConfiguration {
            try encodeContainer.encode(replicationConfiguration, forKey: .replicationConfiguration)
        }
    }
}

public struct PutReplicationConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReplicationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReplicationConfigurationOutputError>
}

public struct PutReplicationConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutReplicationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutReplicationConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutReplicationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutReplicationConfigurationOutputError>
}

public struct PutReplicationConfigurationInput: Swift.Equatable {
    /// An object representing the replication configuration for a registry.
    /// This member is required.
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?

    public init (
        replicationConfiguration: EcrClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationInputBody: Swift.Equatable {
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?
}

extension PutReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case serverException(ServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutReplicationConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutReplicationConfigurationOutputResponse(replicationConfiguration: \(Swift.String(describing: replicationConfiguration)))"}
}

extension PutReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct PutReplicationConfigurationOutputResponse: Swift.Equatable {
    /// The contents of the replication configuration for the registry.
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?

    public init (
        replicationConfiguration: EcrClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationOutputResponseBody: Swift.Equatable {
    public let replicationConfiguration: EcrClientTypes.ReplicationConfiguration?
}

extension PutReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension ReferencedImagesNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReferencedImagesNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ReferencedImagesNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The manifest list is referencing an image that does not exist.
public struct ReferencedImagesNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReferencedImagesNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegistryPolicyNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegistryPolicyNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RegistryPolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegistryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The registry doesn't have an associated registry policy.
public struct RegistryPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RegistryPolicyNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RegistryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes.ReplicationConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for replicationrulelist0 in rules {
                try rulesContainer.encode(replicationrulelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([EcrClientTypes.ReplicationRule?].self, forKey: .rules)
        var rulesDecoded0:[EcrClientTypes.ReplicationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [EcrClientTypes.ReplicationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension EcrClientTypes.ReplicationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationConfiguration(rules: \(Swift.String(describing: rules)))"}
}

extension EcrClientTypes {
    /// The replication configuration for a registry.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// An array of objects representing the replication rules for a replication
        ///             configuration. A replication configuration may contain only one replication rule but the
        ///             rule may contain one or more replication destinations.
        /// This member is required.
        public let rules: [EcrClientTypes.ReplicationRule]?

        public init (
            rules: [EcrClientTypes.ReplicationRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension EcrClientTypes.ReplicationDestination: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region
        case registryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension EcrClientTypes.ReplicationDestination: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationDestination(region: \(Swift.String(describing: region)), registryId: \(Swift.String(describing: registryId)))"}
}

extension EcrClientTypes {
    /// An array of objects representing the details of a replication destination.
    public struct ReplicationDestination: Swift.Equatable {
        /// A Region to replicate to.
        /// This member is required.
        public let region: Swift.String?
        /// The account ID of the destination registry to replicate to.
        /// This member is required.
        public let registryId: Swift.String?

        public init (
            region: Swift.String? = nil,
            registryId: Swift.String? = nil
        )
        {
            self.region = region
            self.registryId = registryId
        }
    }

}

extension EcrClientTypes.ReplicationRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for replicationdestinationlist0 in destinations {
                try destinationsContainer.encode(replicationdestinationlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([EcrClientTypes.ReplicationDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[EcrClientTypes.ReplicationDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [EcrClientTypes.ReplicationDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
    }
}

extension EcrClientTypes.ReplicationRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationRule(destinations: \(Swift.String(describing: destinations)))"}
}

extension EcrClientTypes {
    /// An array of objects representing the replication destinations for a replication
    ///             configuration. A replication configuration may contain only one replication rule but the
    ///             rule may contain one or more replication destinations.
    public struct ReplicationRule: Swift.Equatable {
        /// An array of objects representing the details of a replication destination.
        /// This member is required.
        public let destinations: [EcrClientTypes.ReplicationDestination]?

        public init (
            destinations: [EcrClientTypes.ReplicationDestination]? = nil
        )
        {
            self.destinations = destinations
        }
    }

}

extension EcrClientTypes.Repository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let encryptionConfiguration = encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(EcrClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension EcrClientTypes.Repository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Repository(createdAt: \(Swift.String(describing: createdAt)), encryptionConfiguration: \(Swift.String(describing: encryptionConfiguration)), imageScanningConfiguration: \(Swift.String(describing: imageScanningConfiguration)), imageTagMutability: \(Swift.String(describing: imageTagMutability)), registryId: \(Swift.String(describing: registryId)), repositoryArn: \(Swift.String(describing: repositoryArn)), repositoryName: \(Swift.String(describing: repositoryName)), repositoryUri: \(Swift.String(describing: repositoryUri)))"}
}

extension EcrClientTypes {
    /// An object representing a repository.
    public struct Repository: Swift.Equatable {
        /// The date and time, in JavaScript date format, when the repository was created.
        public let createdAt: ClientRuntime.Date?
        /// The encryption configuration for the repository. This determines how the contents of
        ///             your repository are encrypted at rest.
        public let encryptionConfiguration: EcrClientTypes.EncryptionConfiguration?
        /// The image scanning configuration for a repository.
        public let imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration?
        /// The tag mutability setting for the repository.
        public let imageTagMutability: EcrClientTypes.ImageTagMutability?
        /// The AWS account ID associated with the registry that contains the repository.
        public let registryId: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the
        ///     repository, AWS account ID of the repository owner, repository namespace, and repository name.
        ///     For example, arn:aws:ecr:region:012345678910:repository/test.
        public let repositoryArn: Swift.String?
        /// The name of the repository.
        public let repositoryName: Swift.String?
        /// The URI for the repository. You can use this URI for container image push
        ///             and pull operations.
        public let repositoryUri: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            encryptionConfiguration: EcrClientTypes.EncryptionConfiguration? = nil,
            imageScanningConfiguration: EcrClientTypes.ImageScanningConfiguration? = nil,
            imageTagMutability: EcrClientTypes.ImageTagMutability? = nil,
            registryId: Swift.String? = nil,
            repositoryArn: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryUri: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }
    }

}

extension RepositoryAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository already exists in the specified registry.
public struct RepositoryAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotEmptyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryNotEmptyException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryNotEmptyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository contains images. To delete a repository that contains images,
///             you must force the deletion with the force parameter.
public struct RepositoryNotEmptyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryNotEmptyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository could not be found. Check the spelling of the specified
///             repository and ensure that you are performing operations on the correct registry.
public struct RepositoryNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RepositoryPolicyNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension RepositoryPolicyNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified repository and registry combination does not have an associated
///             repository policy.
public struct RepositoryPolicyNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RepositoryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ScanNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScanNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ScanNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ScanNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified image scan could not be found. Ensure that image scanning is enabled on
///             the repository and try again.
public struct ScanNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ScanNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ScanNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EcrClientTypes {
    public enum ScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatus(rawValue: rawValue) ?? ScanStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServerException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerException(message: \(Swift.String(describing: message)))"}
}

extension ServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// These errors are usually caused by a server-side issue.
public struct ServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServerExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetRepositoryPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

extension SetRepositoryPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRepositoryPolicyInput(force: \(Swift.String(describing: force)), policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct SetRepositoryPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SetRepositoryPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SetRepositoryPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SetRepositoryPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SetRepositoryPolicyOutputError>
}

public struct SetRepositoryPolicyInput: Swift.Equatable {
    /// If the policy you are attempting to set on a repository policy would prevent you from
    ///             setting another policy in the future, you must force the SetRepositoryPolicy operation. This is intended to prevent accidental
    ///             repository lock outs.
    public let force: Swift.Bool
    /// The JSON repository policy text to apply to the repository. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html">Amazon ECR Repository
    ///                 Policies in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public let policyText: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        force: Swift.Bool = false,
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
    public let force: Swift.Bool
}

extension SetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decode(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetRepositoryPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRepositoryPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRepositoryPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SetRepositoryPolicyOutputResponse(policyText: \(Swift.String(describing: policyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension SetRepositoryPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SetRepositoryPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutputResponse: Swift.Equatable {
    /// The JSON repository policy text applied to the repository.
    public let policyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let policyText: Swift.String?
}

extension SetRepositoryPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

public struct StartImageScanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageScanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageScanOutputError>
}

extension StartImageScanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImageScanInput(imageId: \(Swift.String(describing: imageId)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension StartImageScanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct StartImageScanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageScanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageScanOutputError>
}

public struct StartImageScanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImageScanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImageScanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImageScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImageScanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImageScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImageScanOutputError>
}

public struct StartImageScanInput: Swift.Equatable {
    /// An object with identifying information for an Amazon ECR image.
    /// This member is required.
    public let imageId: EcrClientTypes.ImageIdentifier?
    /// The AWS account ID associated with the registry that contains the repository in
    ///             which to start an image scan request. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository that contains the images to scan.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        imageId: EcrClientTypes.ImageIdentifier? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageId: EcrClientTypes.ImageIdentifier?
}

extension StartImageScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension StartImageScanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImageScanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ImageNotFoundException" : self = .imageNotFoundException(try ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedImageTypeException" : self = .unsupportedImageTypeException(try UnsupportedImageTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImageScanOutputError: Swift.Error, Swift.Equatable {
    case imageNotFoundException(ImageNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unsupportedImageTypeException(UnsupportedImageTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImageScanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImageScanOutputResponse(imageId: \(Swift.String(describing: imageId)), imageScanStatus: \(Swift.String(describing: imageScanStatus)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension StartImageScanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartImageScanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imageScanStatus = output.imageScanStatus
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanStatus = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct StartImageScanOutputResponse: Swift.Equatable {
    /// An object with identifying information for an Amazon ECR image.
    public let imageId: EcrClientTypes.ImageIdentifier?
    /// The current state of the scan.
    public let imageScanStatus: EcrClientTypes.ImageScanStatus?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?

    public init (
        imageId: EcrClientTypes.ImageIdentifier? = nil,
        imageScanStatus: EcrClientTypes.ImageScanStatus? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanStatus = imageScanStatus
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let imageId: EcrClientTypes.ImageIdentifier?
    public let imageScanStatus: EcrClientTypes.ImageScanStatus?
}

extension StartImageScanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageScanStatus
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
    }
}

public struct StartLifecyclePolicyPreviewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartLifecyclePolicyPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartLifecyclePolicyPreviewOutputError>
}

extension StartLifecyclePolicyPreviewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartLifecyclePolicyPreviewInput(lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)))"}
}

extension StartLifecyclePolicyPreviewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

public struct StartLifecyclePolicyPreviewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartLifecyclePolicyPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartLifecyclePolicyPreviewOutputError>
}

public struct StartLifecyclePolicyPreviewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartLifecyclePolicyPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartLifecyclePolicyPreviewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartLifecyclePolicyPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartLifecyclePolicyPreviewOutputError>
}

public struct StartLifecyclePolicyPreviewInput: Swift.Equatable {
    /// The policy to be evaluated against. If you do not specify a policy, the current policy
    ///             for the repository is used.
    public let lifecyclePolicyText: Swift.String?
    /// The AWS account ID associated with the registry that contains the repository.
    ///             If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to be evaluated.
    /// This member is required.
    public let repositoryName: Swift.String?

    public init (
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartLifecyclePolicyPreviewInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
}

extension StartLifecyclePolicyPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension StartLifecyclePolicyPreviewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLifecyclePolicyPreviewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyNotFoundException" : self = .lifecyclePolicyNotFoundException(try LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LifecyclePolicyPreviewInProgressException" : self = .lifecyclePolicyPreviewInProgressException(try LifecyclePolicyPreviewInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartLifecyclePolicyPreviewOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case lifecyclePolicyNotFoundException(LifecyclePolicyNotFoundException)
    case lifecyclePolicyPreviewInProgressException(LifecyclePolicyPreviewInProgressException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLifecyclePolicyPreviewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartLifecyclePolicyPreviewOutputResponse(lifecyclePolicyText: \(Swift.String(describing: lifecyclePolicyText)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), status: \(Swift.String(describing: status)))"}
}

extension StartLifecyclePolicyPreviewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartLifecyclePolicyPreviewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
        }
    }
}

public struct StartLifecyclePolicyPreviewOutputResponse: Swift.Equatable {
    /// The JSON repository policy text.
    public let lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?
    /// The status of the lifecycle policy preview request.
    public let status: EcrClientTypes.LifecyclePolicyPreviewStatus?

    public init (
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        status: EcrClientTypes.LifecyclePolicyPreviewStatus? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
    }
}

struct StartLifecyclePolicyPreviewOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let lifecyclePolicyText: Swift.String?
    public let status: EcrClientTypes.LifecyclePolicyPreviewStatus?
}

extension StartLifecyclePolicyPreviewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EcrClientTypes.LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension EcrClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EcrClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension EcrClientTypes {
    /// The metadata that you apply to a resource to help you categorize and organize them.
    ///             Each tag consists of a key and an optional value, both of which you define.
    ///             Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label
        ///             that acts like a category for more specific tag values.
        public let key: Swift.String?
        /// The optional part of a key-value pair that make up a tag. A value acts as
        ///             a descriptor within a tag category (key).
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported
    ///             resource is an Amazon ECR repository.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs.
    ///             Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.
    /// This member is required.
    public let tags: [EcrClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [EcrClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [EcrClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([EcrClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[EcrClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [EcrClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EcrClientTypes {
    public enum TagStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case any
        case tagged
        case untagged
        case sdkUnknown(Swift.String)

        public static var allCases: [TagStatus] {
            return [
                .any,
                .tagged,
                .untagged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .any: return "ANY"
            case .tagged: return "TAGGED"
            case .untagged: return "UNTAGGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TagStatus(rawValue: rawValue) ?? TagStatus.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that
///             can be applied to a repository is 50.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedImageTypeException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedImageTypeException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedImageTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedImageTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image is of a type that cannot be scanned.
public struct UnsupportedImageTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedImageTypeExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedImageTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported
    ///             resource is an Amazon ECR repository.
    /// This member is required.
    public let resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case invalidTagParameterException(InvalidTagParameterException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UploadLayerPartInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

extension UploadLayerPartInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadLayerPartInput(layerPartBlob: \(Swift.String(describing: layerPartBlob)), partFirstByte: \(Swift.String(describing: partFirstByte)), partLastByte: \(Swift.String(describing: partLastByte)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension UploadLayerPartInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

public struct UploadLayerPartInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UploadLayerPartInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UploadLayerPartInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UploadLayerPartInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UploadLayerPartOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UploadLayerPartOutputError>
}

public struct UploadLayerPartInput: Swift.Equatable {
    /// The base64-encoded layer part payload.
    /// This member is required.
    public let layerPartBlob: ClientRuntime.Data?
    /// The position of the first byte of the layer part witin the overall image layer.
    /// This member is required.
    public let partFirstByte: Swift.Int?
    /// The position of the last byte of the layer part within the overall image layer.
    /// This member is required.
    public let partLastByte: Swift.Int?
    /// The AWS account ID associated with the registry to which you are uploading layer
    ///             parts. If you do not specify a registry, the default registry is assumed.
    public let registryId: Swift.String?
    /// The name of the repository to which you are uploading layer parts.
    /// This member is required.
    public let repositoryName: Swift.String?
    /// The upload ID from a previous InitiateLayerUpload operation to
    ///             associate with the layer part upload.
    /// This member is required.
    public let uploadId: Swift.String?

    public init (
        layerPartBlob: ClientRuntime.Data? = nil,
        partFirstByte: Swift.Int? = nil,
        partLastByte: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let partFirstByte: Swift.Int?
    public let partLastByte: Swift.Int?
    public let layerPartBlob: ClientRuntime.Data?
}

extension UploadLayerPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UploadLayerPartOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidLayerPartException" : self = .invalidLayerPartException(try InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RepositoryNotFoundException" : self = .repositoryNotFoundException(try RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServerException" : self = .serverException(try ServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UploadNotFoundException" : self = .uploadNotFoundException(try UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UploadLayerPartOutputError: Swift.Error, Swift.Equatable {
    case invalidLayerPartException(InvalidLayerPartException)
    case invalidParameterException(InvalidParameterException)
    case kmsException(KmsException)
    case limitExceededException(LimitExceededException)
    case repositoryNotFoundException(RepositoryNotFoundException)
    case serverException(ServerException)
    case uploadNotFoundException(UploadNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UploadLayerPartOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadLayerPartOutputResponse(lastByteReceived: \(Swift.String(describing: lastByteReceived)), registryId: \(Swift.String(describing: registryId)), repositoryName: \(Swift.String(describing: repositoryName)), uploadId: \(Swift.String(describing: uploadId)))"}
}

extension UploadLayerPartOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UploadLayerPartOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutputResponse: Swift.Equatable {
    /// The integer value of the last byte received in the request.
    public let lastByteReceived: Swift.Int?
    /// The registry ID associated with the request.
    public let registryId: Swift.String?
    /// The repository name associated with the request.
    public let repositoryName: Swift.String?
    /// The upload ID associated with the request.
    public let uploadId: Swift.String?

    public init (
        lastByteReceived: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputResponseBody: Swift.Equatable {
    public let registryId: Swift.String?
    public let repositoryName: Swift.String?
    public let uploadId: Swift.String?
    public let lastByteReceived: Swift.Int?
}

extension UploadLayerPartOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

extension UploadNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UploadNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension UploadNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The upload could not be found, or the specified upload ID is not valid for this
///             repository.
public struct UploadNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message associated with the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UploadNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UploadNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an exception validating this request.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
