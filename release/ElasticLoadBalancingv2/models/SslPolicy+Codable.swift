// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SslPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ciphers = "Ciphers"
        case name = "Name"
        case sslProtocols = "SslProtocols"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ciphers = ciphers {
            var ciphersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ciphers"))
            for (index0, cipher0) in ciphers.enumerated() {
                try ciphersContainer.encode(cipher0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let sslProtocols = sslProtocols {
            var sslProtocolsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SslProtocols"))
            for (index0, sslprotocol0) in sslProtocols.enumerated() {
                try sslProtocolsContainer.encode(sslprotocol0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.sslProtocols) {
            struct KeyVal0{struct member{}}
            let sslProtocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslProtocols)
            if let sslProtocolsWrappedContainer = sslProtocolsWrappedContainer {
                let sslProtocolsContainer = try sslProtocolsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sslProtocolsBuffer:[String]? = nil
                if let sslProtocolsContainer = sslProtocolsContainer {
                    sslProtocolsBuffer = [String]()
                    for stringContainer0 in sslProtocolsContainer {
                        sslProtocolsBuffer?.append(stringContainer0)
                    }
                }
                sslProtocols = sslProtocolsBuffer
            } else {
                sslProtocols = []
            }
        } else {
            sslProtocols = nil
        }
        if containerValues.contains(.ciphers) {
            struct KeyVal0{struct member{}}
            let ciphersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ciphers)
            if let ciphersWrappedContainer = ciphersWrappedContainer {
                let ciphersContainer = try ciphersWrappedContainer.decodeIfPresent([Cipher].self, forKey: .member)
                var ciphersBuffer:[Cipher]? = nil
                if let ciphersContainer = ciphersContainer {
                    ciphersBuffer = [Cipher]()
                    for structureContainer0 in ciphersContainer {
                        ciphersBuffer?.append(structureContainer0)
                    }
                }
                ciphers = ciphersBuffer
            } else {
                ciphers = []
            }
        } else {
            ciphers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}
