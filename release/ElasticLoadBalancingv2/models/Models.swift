// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ALPNPolicyNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ALPNPolicyNotSupportedException(message: \(String(describing: message)))"}
}

extension ALPNPolicyNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ALPNPolicyNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified ALPN policy is not supported.</p>
public struct ALPNPolicyNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ALPNPolicyNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ALPNPolicyNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticateCognitoConfig = "AuthenticateCognitoConfig"
        case authenticateOidcConfig = "AuthenticateOidcConfig"
        case fixedResponseConfig = "FixedResponseConfig"
        case forwardConfig = "ForwardConfig"
        case order = "Order"
        case redirectConfig = "RedirectConfig"
        case targetGroupArn = "TargetGroupArn"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticateCognitoConfig = authenticateCognitoConfig {
            try container.encode(authenticateCognitoConfig, forKey: Key("AuthenticateCognitoConfig"))
        }
        if let authenticateOidcConfig = authenticateOidcConfig {
            try container.encode(authenticateOidcConfig, forKey: Key("AuthenticateOidcConfig"))
        }
        if let fixedResponseConfig = fixedResponseConfig {
            try container.encode(fixedResponseConfig, forKey: Key("FixedResponseConfig"))
        }
        if let forwardConfig = forwardConfig {
            try container.encode(forwardConfig, forKey: Key("ForwardConfig"))
        }
        if let order = order {
            try container.encode(order, forKey: Key("Order"))
        }
        if let redirectConfig = redirectConfig {
            try container.encode(redirectConfig, forKey: Key("RedirectConfig"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ActionTypeEnum.self, forKey: .type)
        type = typeDecoded
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let authenticateOidcConfigDecoded = try containerValues.decodeIfPresent(AuthenticateOidcActionConfig.self, forKey: .authenticateOidcConfig)
        authenticateOidcConfig = authenticateOidcConfigDecoded
        let authenticateCognitoConfigDecoded = try containerValues.decodeIfPresent(AuthenticateCognitoActionConfig.self, forKey: .authenticateCognitoConfig)
        authenticateCognitoConfig = authenticateCognitoConfigDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .order)
        order = orderDecoded
        let redirectConfigDecoded = try containerValues.decodeIfPresent(RedirectActionConfig.self, forKey: .redirectConfig)
        redirectConfig = redirectConfigDecoded
        let fixedResponseConfigDecoded = try containerValues.decodeIfPresent(FixedResponseActionConfig.self, forKey: .fixedResponseConfig)
        fixedResponseConfig = fixedResponseConfigDecoded
        let forwardConfigDecoded = try containerValues.decodeIfPresent(ForwardActionConfig.self, forKey: .forwardConfig)
        forwardConfig = forwardConfigDecoded
    }
}

extension Action: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Action(authenticateCognitoConfig: \(String(describing: authenticateCognitoConfig)), authenticateOidcConfig: \(String(describing: authenticateOidcConfig)), fixedResponseConfig: \(String(describing: fixedResponseConfig)), forwardConfig: \(String(describing: forwardConfig)), order: \(String(describing: order)), redirectConfig: \(String(describing: redirectConfig)), targetGroupArn: \(String(describing: targetGroupArn)), type: \(String(describing: type)))"}
}

/// <p>Information about an action.</p>
///          <p>Each rule must include exactly one of the following types of actions:
///       <code>forward</code>, <code>fixed-response</code>, or <code>redirect</code>, and it must be
///       the last action to be performed.</p>
public struct Action: Equatable {
    /// <p>[HTTPS listeners] Information for using Amazon Cognito to authenticate users. Specify only
    ///       when <code>Type</code> is <code>authenticate-cognito</code>.</p>
    public let authenticateCognitoConfig: AuthenticateCognitoActionConfig?
    /// <p>[HTTPS listeners] Information about an identity provider that is compliant with OpenID
    ///       Connect (OIDC). Specify only when <code>Type</code> is <code>authenticate-oidc</code>.</p>
    public let authenticateOidcConfig: AuthenticateOidcActionConfig?
    /// <p>[Application Load Balancer] Information for creating an action that returns a custom HTTP
    ///       response. Specify only when <code>Type</code> is <code>fixed-response</code>.</p>
    public let fixedResponseConfig: FixedResponseActionConfig?
    /// <p>Information for creating an action that distributes requests among one or more target
    ///       groups. For Network Load Balancers, you can specify a single target group. Specify only when
    ///         <code>Type</code> is <code>forward</code>. If you specify both <code>ForwardConfig</code>
    ///       and <code>TargetGroupArn</code>, you can specify only one target group using
    ///         <code>ForwardConfig</code> and it must be the same target group specified in
    ///         <code>TargetGroupArn</code>.</p>
    public let forwardConfig: ForwardActionConfig?
    /// <p>The order for the action. This value is required for rules with multiple actions. The
    ///       action with the lowest value for order is performed first.</p>
    public let order: Int?
    /// <p>[Application Load Balancer] Information for creating a redirect action. Specify only when
    ///         <code>Type</code> is <code>redirect</code>.</p>
    public let redirectConfig: RedirectActionConfig?
    /// <p>The Amazon Resource Name (ARN) of the target group. Specify only when <code>Type</code> is
    ///         <code>forward</code> and you want to route to a single target group. To route to one or more
    ///       target groups, use <code>ForwardConfig</code> instead.</p>
    public let targetGroupArn: String?
    /// <p>The type of action.</p>
    public let type: ActionTypeEnum?

    public init (
        authenticateCognitoConfig: AuthenticateCognitoActionConfig? = nil,
        authenticateOidcConfig: AuthenticateOidcActionConfig? = nil,
        fixedResponseConfig: FixedResponseActionConfig? = nil,
        forwardConfig: ForwardActionConfig? = nil,
        order: Int? = nil,
        redirectConfig: RedirectActionConfig? = nil,
        targetGroupArn: String? = nil,
        type: ActionTypeEnum? = nil
    )
    {
        self.authenticateCognitoConfig = authenticateCognitoConfig
        self.authenticateOidcConfig = authenticateOidcConfig
        self.fixedResponseConfig = fixedResponseConfig
        self.forwardConfig = forwardConfig
        self.order = order
        self.redirectConfig = redirectConfig
        self.targetGroupArn = targetGroupArn
        self.type = type
    }
}

public enum ActionTypeEnum {
    case authenticateCognito
    case authenticateOidc
    case fixedResponse
    case forward
    case redirect
    case sdkUnknown(String)
}

extension ActionTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionTypeEnum] {
        return [
            .authenticateCognito,
            .authenticateOidc,
            .fixedResponse,
            .forward,
            .redirect,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticateCognito: return "authenticate-cognito"
        case .authenticateOidc: return "authenticate-oidc"
        case .fixedResponse: return "fixed-response"
        case .forward: return "forward"
        case .redirect: return "redirect"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionTypeEnum(rawValue: rawValue) ?? ActionTypeEnum.sdkUnknown(rawValue)
    }
}

public struct AddListenerCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "AddListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddListenerCertificatesOutputError>
}

extension AddListenerCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddListenerCertificatesInput(certificates: \(String(describing: certificates)), listenerArn: \(String(describing: listenerArn)))"}
}

extension AddListenerCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        try container.encode("AddListenerCertificates", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct AddListenerCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "AddListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddListenerCertificatesOutputError>
}

public struct AddListenerCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "AddListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<AddListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddListenerCertificatesInput>
    public typealias MOutput = OperationOutput<AddListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddListenerCertificatesOutputError>
}

public struct AddListenerCertificatesInput: Equatable {
    /// <p>The certificate to add. You can specify one certificate per call. Set
    ///         <code>CertificateArn</code> to the certificate ARN but do not set
    ///       <code>IsDefault</code>.</p>
    public let certificates: [Certificate]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?

    public init (
        certificates: [Certificate]? = nil,
        listenerArn: String? = nil
    )
    {
        self.certificates = certificates
        self.listenerArn = listenerArn
    }
}

extension AddListenerCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddListenerCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddListenerCertificatesOutputError: Swift.Error, Equatable {
    case certificateNotFoundException(CertificateNotFoundException)
    case listenerNotFoundException(ListenerNotFoundException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddListenerCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddListenerCertificatesOutputResponse(certificates: \(String(describing: certificates)))"}
}

extension AddListenerCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddListenerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
        } else {
            self.certificates = nil
        }
    }
}

public struct AddListenerCertificatesOutputResponse: Equatable {
    /// <p>Information about the certificates in the certificate list.</p>
    public let certificates: [Certificate]?

    public init (
        certificates: [Certificate]? = nil
    )
    {
        self.certificates = certificates
    }
}

struct AddListenerCertificatesOutputResponseBody: Equatable {
    public let certificates: [Certificate]?
}

extension AddListenerCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates = "Certificates"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AddListenerCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([Certificate].self, forKey: .member)
                var certificatesBuffer:[Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
    }
}

public struct AddTagsInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

extension AddTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsInput(resourceArns: \(String(describing: resourceArns)), tags: \(String(describing: tags)))"}
}

extension AddTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AddTags", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct AddTagsInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

public struct AddTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

public struct AddTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArns: [String]?
    /// <p>The tags.</p>
    public let tags: [Tag]?

    public init (
        resourceArns: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArns = resourceArns
        self.tags = tags
    }
}

extension AddTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AddTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Swift.Error, Equatable {
    case duplicateTagKeysException(DuplicateTagKeysException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsOutputResponse()"}
}

extension AddTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AddTagsOutputResponse: Equatable {

    public init() {}
}

struct AddTagsOutputResponseBody: Equatable {
}

extension AddTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AllocationIdNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllocationIdNotFoundException(message: \(String(describing: message)))"}
}

extension AllocationIdNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AllocationIdNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified allocation ID does not exist.</p>
public struct AllocationIdNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AllocationIdNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension AllocationIdNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AuthenticateCognitoActionConditionalBehaviorEnum {
    case allow
    case authenticate
    case deny
    case sdkUnknown(String)
}

extension AuthenticateCognitoActionConditionalBehaviorEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthenticateCognitoActionConditionalBehaviorEnum] {
        return [
            .allow,
            .authenticate,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "allow"
        case .authenticate: return "authenticate"
        case .deny: return "deny"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthenticateCognitoActionConditionalBehaviorEnum(rawValue: rawValue) ?? AuthenticateCognitoActionConditionalBehaviorEnum.sdkUnknown(rawValue)
    }
}

extension AuthenticateCognitoActionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationRequestExtraParams = "AuthenticationRequestExtraParams"
        case onUnauthenticatedRequest = "OnUnauthenticatedRequest"
        case scope = "Scope"
        case sessionCookieName = "SessionCookieName"
        case sessionTimeout = "SessionTimeout"
        case userPoolArn = "UserPoolArn"
        case userPoolClientId = "UserPoolClientId"
        case userPoolDomain = "UserPoolDomain"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticationRequestExtraParams = authenticationRequestExtraParams {
            var authenticationRequestExtraParamsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AuthenticationRequestExtraParams"))
            for (index0, element0) in authenticationRequestExtraParams.sorted(by: { $0.key < $1.key }).enumerated() {
                let authenticatecognitoactionauthenticationrequestparamnameKey0 = element0.key
                let authenticatecognitoactionauthenticationrequestparamvalueValue0 = element0.value
                var entryContainer0 = authenticationRequestExtraParamsContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(authenticatecognitoactionauthenticationrequestparamnameKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(authenticatecognitoactionauthenticationrequestparamvalueValue0, forKey: Key(""))
            }
        }
        if let onUnauthenticatedRequest = onUnauthenticatedRequest {
            try container.encode(onUnauthenticatedRequest, forKey: Key("OnUnauthenticatedRequest"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: Key("Scope"))
        }
        if let sessionCookieName = sessionCookieName {
            try container.encode(sessionCookieName, forKey: Key("SessionCookieName"))
        }
        if let sessionTimeout = sessionTimeout {
            try container.encode(sessionTimeout, forKey: Key("SessionTimeout"))
        }
        if let userPoolArn = userPoolArn {
            try container.encode(userPoolArn, forKey: Key("UserPoolArn"))
        }
        if let userPoolClientId = userPoolClientId {
            try container.encode(userPoolClientId, forKey: Key("UserPoolClientId"))
        }
        if let userPoolDomain = userPoolDomain {
            try container.encode(userPoolDomain, forKey: Key("UserPoolDomain"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userPoolArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolArn)
        userPoolArn = userPoolArnDecoded
        let userPoolClientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolClientId)
        userPoolClientId = userPoolClientIdDecoded
        let userPoolDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userPoolDomain)
        userPoolDomain = userPoolDomainDecoded
        let sessionCookieNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionCookieName)
        sessionCookieName = sessionCookieNameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scope)
        scope = scopeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
        if containerValues.contains(.authenticationRequestExtraParams) {
            struct KeyVal0{struct key{}; struct value{}}
            let authenticationRequestExtraParamsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .authenticationRequestExtraParams)
            if let authenticationRequestExtraParamsWrappedContainer = authenticationRequestExtraParamsWrappedContainer {
                let authenticationRequestExtraParamsContainer = try authenticationRequestExtraParamsWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var authenticationRequestExtraParamsBuffer: [String:String]? = nil
                if let authenticationRequestExtraParamsContainer = authenticationRequestExtraParamsContainer {
                    authenticationRequestExtraParamsBuffer = [String:String]()
                    for stringContainer0 in authenticationRequestExtraParamsContainer {
                        authenticationRequestExtraParamsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                authenticationRequestExtraParams = authenticationRequestExtraParamsBuffer
            } else {
                authenticationRequestExtraParams = [:]
            }
        } else {
            authenticationRequestExtraParams = nil
        }
        let onUnauthenticatedRequestDecoded = try containerValues.decodeIfPresent(AuthenticateCognitoActionConditionalBehaviorEnum.self, forKey: .onUnauthenticatedRequest)
        onUnauthenticatedRequest = onUnauthenticatedRequestDecoded
    }
}

extension AuthenticateCognitoActionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthenticateCognitoActionConfig(authenticationRequestExtraParams: \(String(describing: authenticationRequestExtraParams)), onUnauthenticatedRequest: \(String(describing: onUnauthenticatedRequest)), scope: \(String(describing: scope)), sessionCookieName: \(String(describing: sessionCookieName)), sessionTimeout: \(String(describing: sessionTimeout)), userPoolArn: \(String(describing: userPoolArn)), userPoolClientId: \(String(describing: userPoolClientId)), userPoolDomain: \(String(describing: userPoolDomain)))"}
}

/// <p>Request parameters to use when integrating with Amazon Cognito to authenticate
///       users.</p>
public struct AuthenticateCognitoActionConfig: Equatable {
    /// <p>The query parameters (up to 10) to include in the redirect request to the authorization
    ///       endpoint.</p>
    public let authenticationRequestExtraParams: [String:String]?
    /// <p>The behavior if the user is not authenticated. The following are possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>deny<code></code> - Return an HTTP 401 Unauthorized error.</p>
    ///             </li>
    ///             <li>
    ///                <p>allow<code></code> - Allow the request to be forwarded to the target.</p>
    ///             </li>
    ///             <li>
    ///                <p>authenticate<code></code> - Redirect the request to the IdP authorization endpoint. This is
    ///           the default value.</p>
    ///             </li>
    ///          </ul>
    public let onUnauthenticatedRequest: AuthenticateCognitoActionConditionalBehaviorEnum?
    /// <p>The set of user claims to be requested from the IdP. The default is
    ///       <code>openid</code>.</p>
    ///          <p>To verify which scope values your IdP supports and how to separate multiple values, see
    ///       the documentation for your IdP.</p>
    public let scope: String?
    /// <p>The name of the cookie used to maintain session information. The default is
    ///       AWSELBAuthSessionCookie.</p>
    public let sessionCookieName: String?
    /// <p>The maximum duration of the authentication session, in seconds. The default is 604800
    ///       seconds (7 days).</p>
    public let sessionTimeout: Int?
    /// <p>The Amazon Resource Name (ARN) of the Amazon Cognito user pool.</p>
    public let userPoolArn: String?
    /// <p>The ID of the Amazon Cognito user pool client.</p>
    public let userPoolClientId: String?
    /// <p>The domain prefix or fully-qualified domain name of the Amazon Cognito user pool.</p>
    public let userPoolDomain: String?

    public init (
        authenticationRequestExtraParams: [String:String]? = nil,
        onUnauthenticatedRequest: AuthenticateCognitoActionConditionalBehaviorEnum? = nil,
        scope: String? = nil,
        sessionCookieName: String? = nil,
        sessionTimeout: Int? = nil,
        userPoolArn: String? = nil,
        userPoolClientId: String? = nil,
        userPoolDomain: String? = nil
    )
    {
        self.authenticationRequestExtraParams = authenticationRequestExtraParams
        self.onUnauthenticatedRequest = onUnauthenticatedRequest
        self.scope = scope
        self.sessionCookieName = sessionCookieName
        self.sessionTimeout = sessionTimeout
        self.userPoolArn = userPoolArn
        self.userPoolClientId = userPoolClientId
        self.userPoolDomain = userPoolDomain
    }
}

public enum AuthenticateOidcActionConditionalBehaviorEnum {
    case allow
    case authenticate
    case deny
    case sdkUnknown(String)
}

extension AuthenticateOidcActionConditionalBehaviorEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AuthenticateOidcActionConditionalBehaviorEnum] {
        return [
            .allow,
            .authenticate,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "allow"
        case .authenticate: return "authenticate"
        case .deny: return "deny"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AuthenticateOidcActionConditionalBehaviorEnum(rawValue: rawValue) ?? AuthenticateOidcActionConditionalBehaviorEnum.sdkUnknown(rawValue)
    }
}

extension AuthenticateOidcActionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authenticationRequestExtraParams = "AuthenticationRequestExtraParams"
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientId = "ClientId"
        case clientSecret = "ClientSecret"
        case issuer = "Issuer"
        case onUnauthenticatedRequest = "OnUnauthenticatedRequest"
        case scope = "Scope"
        case sessionCookieName = "SessionCookieName"
        case sessionTimeout = "SessionTimeout"
        case tokenEndpoint = "TokenEndpoint"
        case useExistingClientSecret = "UseExistingClientSecret"
        case userInfoEndpoint = "UserInfoEndpoint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let authenticationRequestExtraParams = authenticationRequestExtraParams {
            var authenticationRequestExtraParamsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AuthenticationRequestExtraParams"))
            for (index0, element0) in authenticationRequestExtraParams.sorted(by: { $0.key < $1.key }).enumerated() {
                let authenticateoidcactionauthenticationrequestparamnameKey0 = element0.key
                let authenticateoidcactionauthenticationrequestparamvalueValue0 = element0.value
                var entryContainer0 = authenticationRequestExtraParamsContainer.nestedContainer(keyedBy: Key.self, forKey: Key("entry.\(index0.advanced(by: 1))"))
                var keyContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("key"))
                try keyContainer0.encode(authenticateoidcactionauthenticationrequestparamnameKey0, forKey: Key(""))
                var valueContainer0 = entryContainer0.nestedContainer(keyedBy: Key.self, forKey: Key("value"))
                try valueContainer0.encode(authenticateoidcactionauthenticationrequestparamvalueValue0, forKey: Key(""))
            }
        }
        if let authorizationEndpoint = authorizationEndpoint {
            try container.encode(authorizationEndpoint, forKey: Key("AuthorizationEndpoint"))
        }
        if let clientId = clientId {
            try container.encode(clientId, forKey: Key("ClientId"))
        }
        if let clientSecret = clientSecret {
            try container.encode(clientSecret, forKey: Key("ClientSecret"))
        }
        if let issuer = issuer {
            try container.encode(issuer, forKey: Key("Issuer"))
        }
        if let onUnauthenticatedRequest = onUnauthenticatedRequest {
            try container.encode(onUnauthenticatedRequest, forKey: Key("OnUnauthenticatedRequest"))
        }
        if let scope = scope {
            try container.encode(scope, forKey: Key("Scope"))
        }
        if let sessionCookieName = sessionCookieName {
            try container.encode(sessionCookieName, forKey: Key("SessionCookieName"))
        }
        if let sessionTimeout = sessionTimeout {
            try container.encode(sessionTimeout, forKey: Key("SessionTimeout"))
        }
        if let tokenEndpoint = tokenEndpoint {
            try container.encode(tokenEndpoint, forKey: Key("TokenEndpoint"))
        }
        if let useExistingClientSecret = useExistingClientSecret {
            try container.encode(useExistingClientSecret, forKey: Key("UseExistingClientSecret"))
        }
        if let userInfoEndpoint = userInfoEndpoint {
            try container.encode(userInfoEndpoint, forKey: Key("UserInfoEndpoint"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let tokenEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenEndpoint)
        tokenEndpoint = tokenEndpointDecoded
        let userInfoEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userInfoEndpoint)
        userInfoEndpoint = userInfoEndpointDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let sessionCookieNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionCookieName)
        sessionCookieName = sessionCookieNameDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scope)
        scope = scopeDecoded
        let sessionTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sessionTimeout)
        sessionTimeout = sessionTimeoutDecoded
        if containerValues.contains(.authenticationRequestExtraParams) {
            struct KeyVal0{struct key{}; struct value{}}
            let authenticationRequestExtraParamsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: MapEntry<String, String, KeyVal0.key, KeyVal0.value>.CodingKeys.self, forKey: .authenticationRequestExtraParams)
            if let authenticationRequestExtraParamsWrappedContainer = authenticationRequestExtraParamsWrappedContainer {
                let authenticationRequestExtraParamsContainer = try authenticationRequestExtraParamsWrappedContainer.decodeIfPresent([MapKeyValue<String, String, KeyVal0.key, KeyVal0.value>].self, forKey: .entry)
                var authenticationRequestExtraParamsBuffer: [String:String]? = nil
                if let authenticationRequestExtraParamsContainer = authenticationRequestExtraParamsContainer {
                    authenticationRequestExtraParamsBuffer = [String:String]()
                    for stringContainer0 in authenticationRequestExtraParamsContainer {
                        authenticationRequestExtraParamsBuffer?[stringContainer0.key] = stringContainer0.value
                    }
                }
                authenticationRequestExtraParams = authenticationRequestExtraParamsBuffer
            } else {
                authenticationRequestExtraParams = [:]
            }
        } else {
            authenticationRequestExtraParams = nil
        }
        let onUnauthenticatedRequestDecoded = try containerValues.decodeIfPresent(AuthenticateOidcActionConditionalBehaviorEnum.self, forKey: .onUnauthenticatedRequest)
        onUnauthenticatedRequest = onUnauthenticatedRequestDecoded
        let useExistingClientSecretDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useExistingClientSecret)
        useExistingClientSecret = useExistingClientSecretDecoded
    }
}

extension AuthenticateOidcActionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AuthenticateOidcActionConfig(authenticationRequestExtraParams: \(String(describing: authenticationRequestExtraParams)), authorizationEndpoint: \(String(describing: authorizationEndpoint)), clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), issuer: \(String(describing: issuer)), onUnauthenticatedRequest: \(String(describing: onUnauthenticatedRequest)), scope: \(String(describing: scope)), sessionCookieName: \(String(describing: sessionCookieName)), sessionTimeout: \(String(describing: sessionTimeout)), tokenEndpoint: \(String(describing: tokenEndpoint)), useExistingClientSecret: \(String(describing: useExistingClientSecret)), userInfoEndpoint: \(String(describing: userInfoEndpoint)))"}
}

/// <p>Request parameters when using an identity provider (IdP) that is compliant with OpenID
///       Connect (OIDC) to authenticate users.</p>
public struct AuthenticateOidcActionConfig: Equatable {
    /// <p>The query parameters (up to 10) to include in the redirect request to the authorization
    ///       endpoint.</p>
    public let authenticationRequestExtraParams: [String:String]?
    /// <p>The authorization endpoint of the IdP. This must be a full URL, including the HTTPS
    ///       protocol, the domain, and the path.</p>
    public let authorizationEndpoint: String?
    /// <p>The OAuth 2.0 client identifier.</p>
    public let clientId: String?
    /// <p>The OAuth 2.0 client secret. This parameter is required if you are creating a rule. If you
    ///       are modifying a rule, you can omit this parameter if you set
    ///         <code>UseExistingClientSecret</code> to true.</p>
    public let clientSecret: String?
    /// <p>The OIDC issuer identifier of the IdP. This must be a full URL, including the HTTPS
    ///       protocol, the domain, and the path.</p>
    public let issuer: String?
    /// <p>The behavior if the user is not authenticated. The following are possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>deny<code></code> - Return an HTTP 401 Unauthorized error.</p>
    ///             </li>
    ///             <li>
    ///                <p>allow<code></code> - Allow the request to be forwarded to the target.</p>
    ///             </li>
    ///             <li>
    ///                <p>authenticate<code></code> - Redirect the request to the IdP authorization endpoint. This is
    ///           the default value.</p>
    ///             </li>
    ///          </ul>
    public let onUnauthenticatedRequest: AuthenticateOidcActionConditionalBehaviorEnum?
    /// <p>The set of user claims to be requested from the IdP. The default is
    ///       <code>openid</code>.</p>
    ///          <p>To verify which scope values your IdP supports and how to separate multiple values, see
    ///       the documentation for your IdP.</p>
    public let scope: String?
    /// <p>The name of the cookie used to maintain session information. The default is
    ///       AWSELBAuthSessionCookie.</p>
    public let sessionCookieName: String?
    /// <p>The maximum duration of the authentication session, in seconds. The default is 604800
    ///       seconds (7 days).</p>
    public let sessionTimeout: Int?
    /// <p>The token endpoint of the IdP. This must be a full URL, including the HTTPS protocol, the
    ///       domain, and the path.</p>
    public let tokenEndpoint: String?
    /// <p>Indicates whether to use the existing client secret when modifying a rule. If you are
    ///       creating a rule, you can omit this parameter or set it to false.</p>
    public let useExistingClientSecret: Bool?
    /// <p>The user info endpoint of the IdP. This must be a full URL, including the HTTPS protocol,
    ///       the domain, and the path.</p>
    public let userInfoEndpoint: String?

    public init (
        authenticationRequestExtraParams: [String:String]? = nil,
        authorizationEndpoint: String? = nil,
        clientId: String? = nil,
        clientSecret: String? = nil,
        issuer: String? = nil,
        onUnauthenticatedRequest: AuthenticateOidcActionConditionalBehaviorEnum? = nil,
        scope: String? = nil,
        sessionCookieName: String? = nil,
        sessionTimeout: Int? = nil,
        tokenEndpoint: String? = nil,
        useExistingClientSecret: Bool? = nil,
        userInfoEndpoint: String? = nil
    )
    {
        self.authenticationRequestExtraParams = authenticationRequestExtraParams
        self.authorizationEndpoint = authorizationEndpoint
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.issuer = issuer
        self.onUnauthenticatedRequest = onUnauthenticatedRequest
        self.scope = scope
        self.sessionCookieName = sessionCookieName
        self.sessionTimeout = sessionTimeout
        self.tokenEndpoint = tokenEndpoint
        self.useExistingClientSecret = useExistingClientSecret
        self.userInfoEndpoint = userInfoEndpoint
    }
}

extension AvailabilityZone: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loadBalancerAddresses = "LoadBalancerAddresses"
        case outpostId = "OutpostId"
        case subnetId = "SubnetId"
        case zoneName = "ZoneName"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerAddresses = loadBalancerAddresses {
            var loadBalancerAddressesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerAddresses"))
            for (index0, loadbalanceraddress0) in loadBalancerAddresses.enumerated() {
                try loadBalancerAddressesContainer.encode(loadbalanceraddress0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let outpostId = outpostId {
            try container.encode(outpostId, forKey: Key("OutpostId"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
        if let zoneName = zoneName {
            try container.encode(zoneName, forKey: Key("ZoneName"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zoneName)
        zoneName = zoneNameDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let outpostIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .outpostId)
        outpostId = outpostIdDecoded
        if containerValues.contains(.loadBalancerAddresses) {
            struct KeyVal0{struct member{}}
            let loadBalancerAddressesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerAddresses)
            if let loadBalancerAddressesWrappedContainer = loadBalancerAddressesWrappedContainer {
                let loadBalancerAddressesContainer = try loadBalancerAddressesWrappedContainer.decodeIfPresent([LoadBalancerAddress].self, forKey: .member)
                var loadBalancerAddressesBuffer:[LoadBalancerAddress]? = nil
                if let loadBalancerAddressesContainer = loadBalancerAddressesContainer {
                    loadBalancerAddressesBuffer = [LoadBalancerAddress]()
                    for structureContainer0 in loadBalancerAddressesContainer {
                        loadBalancerAddressesBuffer?.append(structureContainer0)
                    }
                }
                loadBalancerAddresses = loadBalancerAddressesBuffer
            } else {
                loadBalancerAddresses = []
            }
        } else {
            loadBalancerAddresses = nil
        }
    }
}

extension AvailabilityZone: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZone(loadBalancerAddresses: \(String(describing: loadBalancerAddresses)), outpostId: \(String(describing: outpostId)), subnetId: \(String(describing: subnetId)), zoneName: \(String(describing: zoneName)))"}
}

/// <p>Information about an Availability Zone.</p>
public struct AvailabilityZone: Equatable {
    /// <p>[Network Load Balancers] If you need static IP addresses for your load balancer, you can
    ///       specify one Elastic IP address per Availability Zone when you create an internal-facing load
    ///       balancer. For internal load balancers, you can specify a private IP address from the IPv4
    ///       range of the subnet.</p>
    public let loadBalancerAddresses: [LoadBalancerAddress]?
    /// <p>[Application Load Balancers on Outposts] The ID of the Outpost.</p>
    public let outpostId: String?
    /// <p>The ID of the subnet. You can specify one subnet per Availability Zone.</p>
    public let subnetId: String?
    /// <p>The name of the Availability Zone.</p>
    public let zoneName: String?

    public init (
        loadBalancerAddresses: [LoadBalancerAddress]? = nil,
        outpostId: String? = nil,
        subnetId: String? = nil,
        zoneName: String? = nil
    )
    {
        self.loadBalancerAddresses = loadBalancerAddresses
        self.outpostId = outpostId
        self.subnetId = subnetId
        self.zoneName = zoneName
    }
}

extension AvailabilityZoneNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AvailabilityZoneNotSupportedException(message: \(String(describing: message)))"}
}

extension AvailabilityZoneNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<AvailabilityZoneNotSupportedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified Availability Zone is not supported.</p>
public struct AvailabilityZoneNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AvailabilityZoneNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension AvailabilityZoneNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Certificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn = "CertificateArn"
        case isDefault = "IsDefault"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificateArn = certificateArn {
            try container.encode(certificateArn, forKey: Key("CertificateArn"))
        }
        if let isDefault = isDefault {
            try container.encode(isDefault, forKey: Key("IsDefault"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension Certificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Certificate(certificateArn: \(String(describing: certificateArn)), isDefault: \(String(describing: isDefault)))"}
}

/// <p>Information about an SSL server certificate.</p>
public struct Certificate: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the certificate.</p>
    public let certificateArn: String?
    /// <p>Indicates whether the certificate is the default certificate. Do not set this value when
    ///       specifying a certificate as an input. This value is not included in the output when describing
    ///       a listener, but is included when describing listener certificates.</p>
    public let isDefault: Bool?

    public init (
        certificateArn: String? = nil,
        isDefault: Bool? = nil
    )
    {
        self.certificateArn = certificateArn
        self.isDefault = isDefault
    }
}

extension CertificateNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateNotFoundException(message: \(String(describing: message)))"}
}

extension CertificateNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<CertificateNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified certificate does not exist.</p>
public struct CertificateNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CertificateNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension CertificateNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Cipher: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case priority = "Priority"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if priority != 0 {
            try container.encode(priority, forKey: Key("Priority"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension Cipher: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cipher(name: \(String(describing: name)), priority: \(String(describing: priority)))"}
}

/// <p>Information about a cipher used in a policy.</p>
public struct Cipher: Equatable {
    /// <p>The name of the cipher.</p>
    public let name: String?
    /// <p>The priority of the cipher.</p>
    public let priority: Int

    public init (
        name: String? = nil,
        priority: Int = 0
    )
    {
        self.name = name
        self.priority = priority
    }
}

public struct CreateListenerInputBodyMiddleware: Middleware {
    public let id: String = "CreateListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

extension CreateListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateListenerInput(alpnPolicy: \(String(describing: alpnPolicy)), certificates: \(String(describing: certificates)), defaultActions: \(String(describing: defaultActions)), loadBalancerArn: \(String(describing: loadBalancerArn)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), sslPolicy: \(String(describing: sslPolicy)), tags: \(String(describing: tags)))"}
}

extension CreateListenerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: Key("SslPolicy"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateListener", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct CreateListenerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

public struct CreateListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateListenerInput>
    public typealias MOutput = OperationOutput<CreateListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateListenerOutputError>
}

public struct CreateListenerInput: Equatable {
    /// <p>The protocol for connections from clients to the load balancer. For Application Load
    ///       Balancers, the supported protocols are HTTP and HTTPS. For Network Load Balancers, the
    ///       supported protocols are TCP, TLS, UDP, and TCP_UDP. You cant specify the UDP or TCP_UDP
    ///       protocol if dual-stack mode is enabled. You cannot specify a protocol for a Gateway Load
    ///       Balancer.</p>
    public let `protocol`: ProtocolEnum?
    /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
    ///       can specify one policy name. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP1Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Optional</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Preferred</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>None</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
    ///         policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let alpnPolicy: [String]?
    /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
    ///       exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
    ///         <code>IsDefault</code>.</p>
    public let certificates: [Certificate]?
    /// <p>The actions for the default rule.</p>
    public let defaultActions: [Action]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The port on which the load balancer is listening. You cannot specify a port for a Gateway
    ///       Load Balancer.</p>
    public let port: Int?
    /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
    ///       supported.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> and
    ///         <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let sslPolicy: String?
    /// <p>The tags to assign to the listener.</p>
    public let tags: [Tag]?

    public init (
        `protocol`: ProtocolEnum? = nil,
        alpnPolicy: [String]? = nil,
        certificates: [Certificate]? = nil,
        defaultActions: [Action]? = nil,
        loadBalancerArn: String? = nil,
        port: Int? = nil,
        sslPolicy: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.`protocol` = `protocol`
        self.alpnPolicy = alpnPolicy
        self.certificates = certificates
        self.defaultActions = defaultActions
        self.loadBalancerArn = loadBalancerArn
        self.port = port
        self.sslPolicy = sslPolicy
        self.tags = tags
    }
}

extension CreateListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ALPNPolicyNotSupportedException" : self = .aLPNPolicyNotSupportedException(try ALPNPolicyNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListenerException" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyListenersException" : self = .tooManyListenersException(try TooManyListenersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateListenerOutputError: Swift.Error, Equatable {
    case aLPNPolicyNotSupportedException(ALPNPolicyNotSupportedException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case tooManyListenersException(TooManyListenersException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateListenerOutputResponse(listeners: \(String(describing: listeners)))"}
}

extension CreateListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listeners = output.listeners
        } else {
            self.listeners = nil
        }
    }
}

public struct CreateListenerOutputResponse: Equatable {
    /// <p>Information about the listener.</p>
    public let listeners: [Listener]?

    public init (
        listeners: [Listener]? = nil
    )
    {
        self.listeners = listeners
    }
}

struct CreateListenerOutputResponseBody: Equatable {
    public let listeners: [Listener]?
}

extension CreateListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listeners = "Listeners"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateListenerResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([Listener].self, forKey: .member)
                var listenersBuffer:[Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

public struct CreateLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

extension CreateLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerInput(customerOwnedIpv4Pool: \(String(describing: customerOwnedIpv4Pool)), ipAddressType: \(String(describing: ipAddressType)), name: \(String(describing: name)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), subnetMappings: \(String(describing: subnetMappings)), subnets: \(String(describing: subnets)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: Key("CustomerOwnedIpv4Pool"))
        }
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: Key("IpAddressType"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetMappings"))
            for (index0, subnetmapping0) in subnetMappings.enumerated() {
                try subnetMappingsContainer.encode(subnetmapping0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        try container.encode("CreateLoadBalancer", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct CreateLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

public struct CreateLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLoadBalancerInput>
    public typealias MOutput = OperationOutput<CreateLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLoadBalancerOutputError>
}

public struct CreateLoadBalancerInput: Equatable {
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool (CoIP
    ///       pool).</p>
    public let customerOwnedIpv4Pool: String?
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
    ///       are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
    ///       addresses). Internal load balancers must use <code>ipv4</code>.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The name of the load balancer.</p>
    ///          <p>This name must be unique per region per account, can have a maximum of 32 characters, must
    ///       contain only alphanumeric characters or hyphens, must not begin or end with a hyphen, and must
    ///       not begin with "internal-".</p>
    public let name: String?
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
    ///       Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
    ///       Therefore, Internet-facing load balancers can route requests from clients over the
    ///       internet.</p>
    ///          <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
    ///       internal load balancer is publicly resolvable to the private IP addresses of the nodes.
    ///       Therefore, internal load balancers can route requests only from clients with access to the VPC
    ///       for the load balancer.</p>
    ///          <p>The default is an Internet-facing load balancer.</p>
    ///          <p>You cannot specify a scheme for a Gateway Load Balancer.</p>
    public let scheme: LoadBalancerSchemeEnum?
    /// <p>[Application Load Balancers] The IDs of the security groups for the load balancer.</p>
    public let securityGroups: [String]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones. You cannot specify Elastic IP addresses for your subnets.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       can specify one Elastic IP address per subnet if you need static IP addresses for your
    ///       internet-facing load balancer. For internal load balancers, you can specify one private IP
    ///       address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
    ///       can specify one IPv6 address per subnet.</p>
    ///          <p>[Gateway Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       cannot specify Elastic IP addresses for your subnets.</p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    ///          <p>[Gateway Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    public let subnets: [String]?
    /// <p>The tags to assign to the load balancer.</p>
    public let tags: [Tag]?
    /// <p>The type of load balancer. The default is <code>application</code>.</p>
    public let type: LoadBalancerTypeEnum?

    public init (
        customerOwnedIpv4Pool: String? = nil,
        ipAddressType: IpAddressType? = nil,
        name: String? = nil,
        scheme: LoadBalancerSchemeEnum? = nil,
        securityGroups: [String]? = nil,
        subnetMappings: [SubnetMapping]? = nil,
        subnets: [String]? = nil,
        tags: [Tag]? = nil,
        type: LoadBalancerTypeEnum? = nil
    )
    {
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.ipAddressType = ipAddressType
        self.name = name
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.subnetMappings = subnetMappings
        self.subnets = subnets
        self.tags = tags
        self.type = type
    }
}

extension CreateLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AllocationIdNotFoundException" : self = .allocationIdNotFoundException(try AllocationIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AvailabilityZoneNotSupportedException" : self = .availabilityZoneNotSupportedException(try AvailabilityZoneNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateLoadBalancerNameException" : self = .duplicateLoadBalancerNameException(try DuplicateLoadBalancerNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateTagKeysException" : self = .duplicateTagKeysException(try DuplicateTagKeysException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSchemeException" : self = .invalidSchemeException(try InvalidSchemeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyLoadBalancersException" : self = .tooManyLoadBalancersException(try TooManyLoadBalancersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLoadBalancerOutputError: Swift.Error, Equatable {
    case allocationIdNotFoundException(AllocationIdNotFoundException)
    case availabilityZoneNotSupportedException(AvailabilityZoneNotSupportedException)
    case duplicateLoadBalancerNameException(DuplicateLoadBalancerNameException)
    case duplicateTagKeysException(DuplicateTagKeysException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSchemeException(InvalidSchemeException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case invalidSubnetException(InvalidSubnetException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case subnetNotFoundException(SubnetNotFoundException)
    case tooManyLoadBalancersException(TooManyLoadBalancersException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLoadBalancerOutputResponse(loadBalancers: \(String(describing: loadBalancers)))"}
}

extension CreateLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLoadBalancerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBalancers = output.loadBalancers
        } else {
            self.loadBalancers = nil
        }
    }
}

public struct CreateLoadBalancerOutputResponse: Equatable {
    /// <p>Information about the load balancer.</p>
    public let loadBalancers: [LoadBalancer]?

    public init (
        loadBalancers: [LoadBalancer]? = nil
    )
    {
        self.loadBalancers = loadBalancers
    }
}

struct CreateLoadBalancerOutputResponseBody: Equatable {
    public let loadBalancers: [LoadBalancer]?
}

extension CreateLoadBalancerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBalancers = "LoadBalancers"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateLoadBalancerResult"))
        if containerValues.contains(.loadBalancers) {
            struct KeyVal0{struct member{}}
            let loadBalancersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancers)
            if let loadBalancersWrappedContainer = loadBalancersWrappedContainer {
                let loadBalancersContainer = try loadBalancersWrappedContainer.decodeIfPresent([LoadBalancer].self, forKey: .member)
                var loadBalancersBuffer:[LoadBalancer]? = nil
                if let loadBalancersContainer = loadBalancersContainer {
                    loadBalancersBuffer = [LoadBalancer]()
                    for structureContainer0 in loadBalancersContainer {
                        loadBalancersBuffer?.append(structureContainer0)
                    }
                }
                loadBalancers = loadBalancersBuffer
            } else {
                loadBalancers = []
            }
        } else {
            loadBalancers = nil
        }
    }
}

public struct CreateRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

extension CreateRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleInput(actions: \(String(describing: actions)), conditions: \(String(describing: conditions)), listenerArn: \(String(describing: listenerArn)), priority: \(String(describing: priority)), tags: \(String(describing: tags)))"}
}

extension CreateRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: Key("Priority"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("CreateRule", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct CreateRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleInput>
    public typealias MOutput = OperationOutput<CreateRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleOutputError>
}

public struct CreateRuleInput: Equatable {
    /// <p>The actions.</p>
    public let actions: [Action]?
    /// <p>The conditions.</p>
    public let conditions: [RuleCondition]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The rule priority. A listener can't have multiple rules with the same priority.</p>
    public let priority: Int?
    /// <p>The tags to assign to the rule.</p>
    public let tags: [Tag]?

    public init (
        actions: [Action]? = nil,
        conditions: [RuleCondition]? = nil,
        listenerArn: String? = nil,
        priority: Int? = nil,
        tags: [Tag]? = nil
    )
    {
        self.actions = actions
        self.conditions = conditions
        self.listenerArn = listenerArn
        self.priority = priority
        self.tags = tags
    }
}

extension CreateRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PriorityInUseException" : self = .priorityInUseException(try PriorityInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRulesException" : self = .tooManyRulesException(try TooManyRulesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetGroupsException" : self = .tooManyTargetGroupsException(try TooManyTargetGroupsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleOutputError: Swift.Error, Equatable {
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case listenerNotFoundException(ListenerNotFoundException)
    case priorityInUseException(PriorityInUseException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyRulesException(TooManyRulesException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetGroupsException(TooManyTargetGroupsException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleOutputResponse(rules: \(String(describing: rules)))"}
}

extension CreateRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct CreateRuleOutputResponse: Equatable {
    /// <p>Information about the rule.</p>
    public let rules: [Rule]?

    public init (
        rules: [Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct CreateRuleOutputResponseBody: Equatable {
    public let rules: [Rule]?
}

extension CreateRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateRuleResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([Rule].self, forKey: .member)
                var rulesBuffer:[Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct CreateTargetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTargetGroupOutputError>
}

extension CreateTargetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTargetGroupInput(healthCheckEnabled: \(String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(String(describing: healthyThresholdCount)), matcher: \(String(describing: matcher)), name: \(String(describing: name)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), protocolVersion: \(String(describing: protocolVersion)), tags: \(String(describing: tags)), targetType: \(String(describing: targetType)), unhealthyThresholdCount: \(String(describing: unhealthyThresholdCount)), vpcId: \(String(describing: vpcId)))"}
}

extension CreateTargetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: Key("HealthyThresholdCount"))
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: Key("Matcher"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let protocolVersion = protocolVersion {
            try container.encode(protocolVersion, forKey: Key("ProtocolVersion"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetType = targetType {
            try container.encode(targetType, forKey: Key("TargetType"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: Key("UnhealthyThresholdCount"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
        try container.encode("CreateTargetGroup", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct CreateTargetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTargetGroupOutputError>
}

public struct CreateTargetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTargetGroupInput>
    public typealias MOutput = OperationOutput<CreateTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTargetGroupOutputError>
}

public struct CreateTargetGroupInput: Equatable {
    /// <p>The protocol to use for routing traffic to the targets. For Application Load Balancers,
    ///       the supported protocols are HTTP and HTTPS. For Network Load Balancers, the supported
    ///       protocols are TCP, TLS, UDP, or TCP_UDP. For Gateway Load Balancers, the supported protocol is
    ///       GENEVE. A TCP_UDP listener must be associated with a TCP_UDP target group. If the target is a
    ///       Lambda function, this parameter does not apply.</p>
    public let `protocol`: ProtocolEnum?
    /// <p>Indicates whether health checks are enabled. If the target type is <code>lambda</code>,
    ///       health checks are disabled by default but can be enabled. If the target type is
    ///         <code>instance</code> or <code>ip</code>, health checks are always enabled and cannot be
    ///       disabled.</p>
    public let healthCheckEnabled: Bool?
    /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
    ///       If the target group protocol is TCP, TLS, UDP, or TCP_UDP, the supported values are 10 and 30
    ///       seconds. If the target group protocol is HTTP or HTTPS, the default is 30 seconds. If the
    ///       target group protocol is GENEVE, the default is 10 seconds. If the target type is
    ///         <code>lambda</code>, the default is 35 seconds.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
    ///          <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
    ///          <p>[GRPC protocol version] The path of a custom health check method with the format
    ///       /package.service/method. The default is /AWS.ALB/healthcheck.</p>
    public let healthCheckPath: String?
    /// <p>The port the load balancer uses when performing health checks on targets. If the protocol
    ///       is HTTP, HTTPS, TCP, TLS, UDP, or TCP_UDP, the default is <code>traffic-port</code>, which is
    ///       the port on which each target receives traffic from the load balancer. If the protocol is
    ///       GENEVE, the default is port 80.</p>
    public let healthCheckPort: String?
    /// <p>The protocol the load balancer uses when performing health checks on targets. For
    ///       Application Load Balancers, the default is HTTP. For Network Load Balancers and Gateway Load
    ///       Balancers, the default is TCP. The TCP protocol is not supported for health checks if the
    ///       protocol of the target group is HTTP or HTTPS. The GENEVE, TLS, UDP, and TCP_UDP protocols are
    ///       not supported for health checks.</p>
    public let healthCheckProtocol: ProtocolEnum?
    /// <p>The amount of time, in seconds, during which no response from a target means a failed
    ///       health check. For target groups with a protocol of HTTP, HTTPS, or GENEVE, the default is 5
    ///       seconds. For target groups with a protocol of TCP or TLS, this value must be 6 seconds for
    ///       HTTP health checks and 10 seconds for TCP and HTTPS health checks. If the target type is
    ///         <code>lambda</code>, the default is 30 seconds.</p>
    public let healthCheckTimeoutSeconds: Int?
    /// <p>The number of consecutive health checks successes required before considering an unhealthy
    ///       target healthy. For target groups with a protocol of HTTP or HTTPS, the default is 5. For
    ///       target groups with a protocol of TCP, TLS, or GENEVE, the default is 3. If the target type is
    ///         <code>lambda</code>, the default is 5.</p>
    public let healthyThresholdCount: Int?
    /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
    ///       response from a target.</p>
    public let matcher: Matcher?
    /// <p>The name of the target group.</p>
    ///          <p>This name must be unique per region per account, can have a maximum of 32 characters, must
    ///       contain only alphanumeric characters or hyphens, and must not begin or end with a
    ///       hyphen.</p>
    public let name: String?
    /// <p>The port on which the targets receive traffic. This port is used unless you specify a port
    ///       override when registering the target. If the target is a Lambda function, this parameter does
    ///       not apply. If the protocol is GENEVE, the supported port is 6081.</p>
    public let port: Int?
    /// <p>[HTTP/HTTPS protocol] The protocol version. Specify <code>GRPC</code> to send requests to
    ///       targets using gRPC. Specify <code>HTTP2</code> to send requests to targets using HTTP/2. The
    ///       default is <code>HTTP1</code>, which sends requests to targets using HTTP/1.1.</p>
    public let protocolVersion: String?
    /// <p>The tags to assign to the target group.</p>
    public let tags: [Tag]?
    /// <p>The type of target that you must specify when registering targets with this target group.
    ///       You can't specify targets for a target group using more than one target type.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>instance</code> - Register targets by instance ID. This is the default
    ///           value.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ip</code> - Register targets by IP address. You can specify IP addresses from
    ///           the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range
    ///           (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10).
    ///           You can't specify publicly routable IP addresses.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>lambda</code> - Register a single Lambda function as a target.</p>
    ///             </li>
    ///          </ul>
    public let targetType: TargetTypeEnum?
    /// <p>The number of consecutive health check failures required before considering a target
    ///       unhealthy. If the target group protocol is HTTP or HTTPS, the default is 2. If the target
    ///       group protocol is TCP or TLS, this value must be the same as the healthy threshold count. If
    ///       the target group protocol is GENEVE, the default is 3. If the target type is
    ///         <code>lambda</code>, the default is 2.</p>
    public let unhealthyThresholdCount: Int?
    /// <p>The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
    ///       this parameter does not apply. Otherwise, this parameter is required.</p>
    public let vpcId: String?

    public init (
        `protocol`: ProtocolEnum? = nil,
        healthCheckEnabled: Bool? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: String? = nil,
        healthCheckProtocol: ProtocolEnum? = nil,
        healthCheckTimeoutSeconds: Int? = nil,
        healthyThresholdCount: Int? = nil,
        matcher: Matcher? = nil,
        name: String? = nil,
        port: Int? = nil,
        protocolVersion: String? = nil,
        tags: [Tag]? = nil,
        targetType: TargetTypeEnum? = nil,
        unhealthyThresholdCount: Int? = nil,
        vpcId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.healthCheckEnabled = healthCheckEnabled
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
        self.healthyThresholdCount = healthyThresholdCount
        self.matcher = matcher
        self.name = name
        self.port = port
        self.protocolVersion = protocolVersion
        self.tags = tags
        self.targetType = targetType
        self.unhealthyThresholdCount = unhealthyThresholdCount
        self.vpcId = vpcId
    }
}

extension CreateTargetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension CreateTargetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DuplicateTargetGroupNameException" : self = .duplicateTargetGroupNameException(try DuplicateTargetGroupNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetGroupsException" : self = .tooManyTargetGroupsException(try TooManyTargetGroupsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTargetGroupOutputError: Swift.Error, Equatable {
    case duplicateTargetGroupNameException(DuplicateTargetGroupNameException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case tooManyTagsException(TooManyTagsException)
    case tooManyTargetGroupsException(TooManyTargetGroupsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTargetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTargetGroupOutputResponse(targetGroups: \(String(describing: targetGroups)))"}
}

extension CreateTargetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetGroups = output.targetGroups
        } else {
            self.targetGroups = nil
        }
    }
}

public struct CreateTargetGroupOutputResponse: Equatable {
    /// <p>Information about the target group.</p>
    public let targetGroups: [TargetGroup]?

    public init (
        targetGroups: [TargetGroup]? = nil
    )
    {
        self.targetGroups = targetGroups
    }
}

struct CreateTargetGroupOutputResponseBody: Equatable {
    public let targetGroups: [TargetGroup]?
}

extension CreateTargetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("CreateTargetGroupResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
    }
}

public struct DeleteListenerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

extension DeleteListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteListenerInput(listenerArn: \(String(describing: listenerArn)))"}
}

extension DeleteListenerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        try container.encode("DeleteListener", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DeleteListenerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteListenerInput>
    public typealias MOutput = OperationOutput<DeleteListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteListenerOutputError>
}

public struct DeleteListenerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?

    public init (
        listenerArn: String? = nil
    )
    {
        self.listenerArn = listenerArn
    }
}

extension DeleteListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteListenerOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteListenerOutputResponse()"}
}

extension DeleteListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteListenerOutputResponse: Equatable {

    public init() {}
}

struct DeleteListenerOutputResponseBody: Equatable {
}

extension DeleteListenerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLoadBalancerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

extension DeleteLoadBalancerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerInput(loadBalancerArn: \(String(describing: loadBalancerArn)))"}
}

extension DeleteLoadBalancerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        try container.encode("DeleteLoadBalancer", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DeleteLoadBalancerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

public struct DeleteLoadBalancerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLoadBalancerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLoadBalancerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLoadBalancerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLoadBalancerInput>
    public typealias MOutput = OperationOutput<DeleteLoadBalancerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLoadBalancerOutputError>
}

public struct DeleteLoadBalancerInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?

    public init (
        loadBalancerArn: String? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
    }
}

extension DeleteLoadBalancerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteLoadBalancerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLoadBalancerOutputError: Swift.Error, Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLoadBalancerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLoadBalancerOutputResponse()"}
}

extension DeleteLoadBalancerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLoadBalancerOutputResponse: Equatable {

    public init() {}
}

struct DeleteLoadBalancerOutputResponseBody: Equatable {
}

extension DeleteLoadBalancerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleInput(ruleArn: \(String(describing: ruleArn)))"}
}

extension DeleteRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: Key("RuleArn"))
        }
        try container.encode("DeleteRule", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DeleteRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: String?

    public init (
        ruleArn: String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

extension DeleteRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Swift.Error, Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case ruleNotFoundException(RuleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Equatable {
}

extension DeleteRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTargetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetGroupOutputError>
}

extension DeleteTargetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTargetGroupInput(targetGroupArn: \(String(describing: targetGroupArn)))"}
}

extension DeleteTargetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        try container.encode("DeleteTargetGroup", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DeleteTargetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetGroupOutputError>
}

public struct DeleteTargetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTargetGroupInput>
    public typealias MOutput = OperationOutput<DeleteTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTargetGroupOutputError>
}

public struct DeleteTargetGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?

    public init (
        targetGroupArn: String? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
    }
}

extension DeleteTargetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeleteTargetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTargetGroupOutputError: Swift.Error, Equatable {
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTargetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTargetGroupOutputResponse()"}
}

extension DeleteTargetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTargetGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteTargetGroupOutputResponseBody: Equatable {
}

extension DeleteTargetGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetsOutputError>
}

extension DeregisterTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTargetsInput(targetGroupArn: \(String(describing: targetGroupArn)), targets: \(String(describing: targets)))"}
}

extension DeregisterTargetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DeregisterTargets", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DeregisterTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetsOutputError>
}

public struct DeregisterTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTargetsInput>
    public typealias MOutput = OperationOutput<DeregisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTargetsOutputError>
}

public struct DeregisterTargetsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The targets. If you specified a port override when you registered a target, you must
    ///       specify both the target ID and the port when you deregister it.</p>
    public let targets: [TargetDescription]?

    public init (
        targetGroupArn: String? = nil,
        targets: [TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension DeregisterTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DeregisterTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTargetsOutputError: Swift.Error, Equatable {
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTargetsOutputResponse()"}
}

extension DeregisterTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterTargetsOutputResponse: Equatable {

    public init() {}
}

struct DeregisterTargetsOutputResponseBody: Equatable {
}

extension DeregisterTargetsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAccountLimitsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

extension DescribeAccountLimitsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsInput(marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeAccountLimitsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeAccountLimits", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeAccountLimitsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountLimitsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountLimitsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountLimitsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountLimitsInput>
    public typealias MOutput = OperationOutput<DescribeAccountLimitsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountLimitsOutputError>
}

public struct DescribeAccountLimitsInput: Equatable {
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeAccountLimitsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeAccountLimitsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountLimitsOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountLimitsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountLimitsOutputResponse(limits: \(String(describing: limits)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeAccountLimitsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountLimitsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limits = output.limits
            self.nextMarker = output.nextMarker
        } else {
            self.limits = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeAccountLimitsOutputResponse: Equatable {
    /// <p>Information about the limits.</p>
    public let limits: [Limit]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?

    public init (
        limits: [Limit]? = nil,
        nextMarker: String? = nil
    )
    {
        self.limits = limits
        self.nextMarker = nextMarker
    }
}

struct DescribeAccountLimitsOutputResponseBody: Equatable {
    public let limits: [Limit]?
    public let nextMarker: String?
}

extension DescribeAccountLimitsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limits = "Limits"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeAccountLimitsResult"))
        if containerValues.contains(.limits) {
            struct KeyVal0{struct member{}}
            let limitsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .limits)
            if let limitsWrappedContainer = limitsWrappedContainer {
                let limitsContainer = try limitsWrappedContainer.decodeIfPresent([Limit].self, forKey: .member)
                var limitsBuffer:[Limit]? = nil
                if let limitsContainer = limitsContainer {
                    limitsBuffer = [Limit]()
                    for structureContainer0 in limitsContainer {
                        limitsBuffer?.append(structureContainer0)
                    }
                }
                limits = limitsBuffer
            } else {
                limits = []
            }
        } else {
            limits = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeListenerCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerCertificatesOutputError>
}

extension DescribeListenerCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenerCertificatesInput(listenerArn: \(String(describing: listenerArn)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeListenerCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeListenerCertificates", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeListenerCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerCertificatesOutputError>
}

public struct DescribeListenerCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenerCertificatesInput>
    public typealias MOutput = OperationOutput<DescribeListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenerCertificatesOutputError>
}

public struct DescribeListenerCertificatesInput: Equatable {
    /// <p>The Amazon Resource Names (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        listenerArn: String? = nil,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.listenerArn = listenerArn
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeListenerCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeListenerCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenerCertificatesOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenerCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenerCertificatesOutputResponse(certificates: \(String(describing: certificates)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeListenerCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeListenerCertificatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.certificates = output.certificates
            self.nextMarker = output.nextMarker
        } else {
            self.certificates = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeListenerCertificatesOutputResponse: Equatable {
    /// <p>Information about the certificates.</p>
    public let certificates: [Certificate]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?

    public init (
        certificates: [Certificate]? = nil,
        nextMarker: String? = nil
    )
    {
        self.certificates = certificates
        self.nextMarker = nextMarker
    }
}

struct DescribeListenerCertificatesOutputResponseBody: Equatable {
    public let certificates: [Certificate]?
    public let nextMarker: String?
}

extension DescribeListenerCertificatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case certificates = "Certificates"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeListenerCertificatesResult"))
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([Certificate].self, forKey: .member)
                var certificatesBuffer:[Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeListenersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeListenersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenersOutputError>
}

extension DescribeListenersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenersInput(listenerArns: \(String(describing: listenerArns)), loadBalancerArn: \(String(describing: loadBalancerArn)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeListenersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listenerArns = listenerArns {
            var listenerArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ListenerArns"))
            for (index0, listenerarn0) in listenerArns.enumerated() {
                try listenerArnsContainer.encode(listenerarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeListeners", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeListenersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeListenersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenersOutputError>
}

public struct DescribeListenersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeListenersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeListenersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeListenersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeListenersInput>
    public typealias MOutput = OperationOutput<DescribeListenersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeListenersOutputError>
}

public struct DescribeListenersInput: Equatable {
    /// <p>The Amazon Resource Names (ARN) of the listeners.</p>
    public let listenerArns: [String]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        listenerArns: [String]? = nil,
        loadBalancerArn: String? = nil,
        marker: String? = nil,
        pageSize: Int? = nil
    )
    {
        self.listenerArns = listenerArns
        self.loadBalancerArn = loadBalancerArn
        self.marker = marker
        self.pageSize = pageSize
    }
}

extension DescribeListenersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeListenersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeListenersOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeListenersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeListenersOutputResponse(listeners: \(String(describing: listeners)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeListenersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeListenersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listeners = output.listeners
            self.nextMarker = output.nextMarker
        } else {
            self.listeners = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeListenersOutputResponse: Equatable {
    /// <p>Information about the listeners.</p>
    public let listeners: [Listener]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?

    public init (
        listeners: [Listener]? = nil,
        nextMarker: String? = nil
    )
    {
        self.listeners = listeners
        self.nextMarker = nextMarker
    }
}

struct DescribeListenersOutputResponseBody: Equatable {
    public let listeners: [Listener]?
    public let nextMarker: String?
}

extension DescribeListenersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listeners = "Listeners"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeListenersResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([Listener].self, forKey: .member)
                var listenersBuffer:[Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeLoadBalancerAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

extension DescribeLoadBalancerAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerAttributesInput(loadBalancerArn: \(String(describing: loadBalancerArn)))"}
}

extension DescribeLoadBalancerAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        try container.encode("DescribeLoadBalancerAttributes", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancerAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

public struct DescribeLoadBalancerAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancerAttributesOutputError>
}

public struct DescribeLoadBalancerAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?

    public init (
        loadBalancerArn: String? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
    }
}

extension DescribeLoadBalancerAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancerAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancerAttributesOutputError: Swift.Error, Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancerAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancerAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension DescribeLoadBalancerAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeLoadBalancerAttributesOutputResponse: Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let attributes: [LoadBalancerAttribute]?

    public init (
        attributes: [LoadBalancerAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeLoadBalancerAttributesOutputResponseBody: Equatable {
    public let attributes: [LoadBalancerAttribute]?
}

extension DescribeLoadBalancerAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancerAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([LoadBalancerAttribute].self, forKey: .member)
                var attributesBuffer:[LoadBalancerAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [LoadBalancerAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct DescribeLoadBalancersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

extension DescribeLoadBalancersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancersInput(loadBalancerArns: \(String(describing: loadBalancerArns)), marker: \(String(describing: marker)), names: \(String(describing: names)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeLoadBalancersInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerArns = loadBalancerArns {
            var loadBalancerArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerArns"))
            for (index0, loadbalancerarn0) in loadBalancerArns.enumerated() {
                try loadBalancerArnsContainer.encode(loadbalancerarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Names"))
            for (index0, loadbalancername0) in names.enumerated() {
                try namesContainer.encode(loadbalancername0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeLoadBalancers", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeLoadBalancersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

public struct DescribeLoadBalancersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoadBalancersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoadBalancersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoadBalancersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoadBalancersInput>
    public typealias MOutput = OperationOutput<DescribeLoadBalancersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoadBalancersOutputError>
}

public struct DescribeLoadBalancersInput: Equatable {
    /// <p>The Amazon Resource Names (ARN) of the load balancers. You can specify up to 20 load
    ///       balancers in a single call.</p>
    public let loadBalancerArns: [String]?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The names of the load balancers.</p>
    public let names: [String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        loadBalancerArns: [String]? = nil,
        marker: String? = nil,
        names: [String]? = nil,
        pageSize: Int? = nil
    )
    {
        self.loadBalancerArns = loadBalancerArns
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
    }
}

extension DescribeLoadBalancersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeLoadBalancersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoadBalancersOutputError: Swift.Error, Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoadBalancersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoadBalancersOutputResponse(loadBalancers: \(String(describing: loadBalancers)), nextMarker: \(String(describing: nextMarker)))"}
}

extension DescribeLoadBalancersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoadBalancersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loadBalancers = output.loadBalancers
            self.nextMarker = output.nextMarker
        } else {
            self.loadBalancers = nil
            self.nextMarker = nil
        }
    }
}

public struct DescribeLoadBalancersOutputResponse: Equatable {
    /// <p>Information about the load balancers.</p>
    public let loadBalancers: [LoadBalancer]?
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?

    public init (
        loadBalancers: [LoadBalancer]? = nil,
        nextMarker: String? = nil
    )
    {
        self.loadBalancers = loadBalancers
        self.nextMarker = nextMarker
    }
}

struct DescribeLoadBalancersOutputResponseBody: Equatable {
    public let loadBalancers: [LoadBalancer]?
    public let nextMarker: String?
}

extension DescribeLoadBalancersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loadBalancers = "LoadBalancers"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeLoadBalancersResult"))
        if containerValues.contains(.loadBalancers) {
            struct KeyVal0{struct member{}}
            let loadBalancersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancers)
            if let loadBalancersWrappedContainer = loadBalancersWrappedContainer {
                let loadBalancersContainer = try loadBalancersWrappedContainer.decodeIfPresent([LoadBalancer].self, forKey: .member)
                var loadBalancersBuffer:[LoadBalancer]? = nil
                if let loadBalancersContainer = loadBalancersContainer {
                    loadBalancersBuffer = [LoadBalancer]()
                    for structureContainer0 in loadBalancersContainer {
                        loadBalancersBuffer?.append(structureContainer0)
                    }
                }
                loadBalancers = loadBalancersBuffer
            } else {
                loadBalancers = []
            }
        } else {
            loadBalancers = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeRulesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesOutputError>
}

extension DescribeRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRulesInput(listenerArn: \(String(describing: listenerArn)), marker: \(String(describing: marker)), pageSize: \(String(describing: pageSize)), ruleArns: \(String(describing: ruleArns)))"}
}

extension DescribeRulesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        if let ruleArns = ruleArns {
            var ruleArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RuleArns"))
            for (index0, rulearn0) in ruleArns.enumerated() {
                try ruleArnsContainer.encode(rulearn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeRules", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeRulesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesOutputError>
}

public struct DescribeRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesInput>
    public typealias MOutput = OperationOutput<DescribeRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesOutputError>
}

public struct DescribeRulesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?
    /// <p>The Amazon Resource Names (ARN) of the rules.</p>
    public let ruleArns: [String]?

    public init (
        listenerArn: String? = nil,
        marker: String? = nil,
        pageSize: Int? = nil,
        ruleArns: [String]? = nil
    )
    {
        self.listenerArn = listenerArn
        self.marker = marker
        self.pageSize = pageSize
        self.ruleArns = ruleArns
    }
}

extension DescribeRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRulesOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRulesOutputResponse(nextMarker: \(String(describing: nextMarker)), rules: \(String(describing: rules)))"}
}

extension DescribeRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.rules = output.rules
        } else {
            self.nextMarker = nil
            self.rules = nil
        }
    }
}

public struct DescribeRulesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?
    /// <p>Information about the rules.</p>
    public let rules: [Rule]?

    public init (
        nextMarker: String? = nil,
        rules: [Rule]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.rules = rules
    }
}

struct DescribeRulesOutputResponseBody: Equatable {
    public let rules: [Rule]?
    public let nextMarker: String?
}

extension DescribeRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeRulesResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([Rule].self, forKey: .member)
                var rulesBuffer:[Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeSSLPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSSLPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSSLPoliciesOutputError>
}

extension DescribeSSLPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSSLPoliciesInput(marker: \(String(describing: marker)), names: \(String(describing: names)), pageSize: \(String(describing: pageSize)))"}
}

extension DescribeSSLPoliciesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Names"))
            for (index0, sslpolicyname0) in names.enumerated() {
                try namesContainer.encode(sslpolicyname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        try container.encode("DescribeSSLPolicies", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeSSLPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSSLPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSSLPoliciesOutputError>
}

public struct DescribeSSLPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSSLPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSSLPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSSLPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSSLPoliciesInput>
    public typealias MOutput = OperationOutput<DescribeSSLPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSSLPoliciesOutputError>
}

public struct DescribeSSLPoliciesInput: Equatable {
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The names of the policies.</p>
    public let names: [String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?

    public init (
        marker: String? = nil,
        names: [String]? = nil,
        pageSize: Int? = nil
    )
    {
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
    }
}

extension DescribeSSLPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeSSLPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSSLPoliciesOutputError: Swift.Error, Equatable {
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSSLPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSSLPoliciesOutputResponse(nextMarker: \(String(describing: nextMarker)), sslPolicies: \(String(describing: sslPolicies)))"}
}

extension DescribeSSLPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSSLPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.sslPolicies = output.sslPolicies
        } else {
            self.nextMarker = nil
            self.sslPolicies = nil
        }
    }
}

public struct DescribeSSLPoliciesOutputResponse: Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?
    /// <p>Information about the security policies.</p>
    public let sslPolicies: [SslPolicy]?

    public init (
        nextMarker: String? = nil,
        sslPolicies: [SslPolicy]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.sslPolicies = sslPolicies
    }
}

struct DescribeSSLPoliciesOutputResponseBody: Equatable {
    public let sslPolicies: [SslPolicy]?
    public let nextMarker: String?
}

extension DescribeSSLPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case sslPolicies = "SslPolicies"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeSSLPoliciesResult"))
        if containerValues.contains(.sslPolicies) {
            struct KeyVal0{struct member{}}
            let sslPoliciesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslPolicies)
            if let sslPoliciesWrappedContainer = sslPoliciesWrappedContainer {
                let sslPoliciesContainer = try sslPoliciesWrappedContainer.decodeIfPresent([SslPolicy].self, forKey: .member)
                var sslPoliciesBuffer:[SslPolicy]? = nil
                if let sslPoliciesContainer = sslPoliciesContainer {
                    sslPoliciesBuffer = [SslPolicy]()
                    for structureContainer0 in sslPoliciesContainer {
                        sslPoliciesBuffer?.append(structureContainer0)
                    }
                }
                sslPolicies = sslPoliciesBuffer
            } else {
                sslPolicies = []
            }
        } else {
            sslPolicies = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeTagsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

extension DescribeTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsInput(resourceArns: \(String(describing: resourceArns)))"}
}

extension DescribeTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTags", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTagsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTagsInput>
    public typealias MOutput = OperationOutput<DescribeTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTagsOutputError>
}

public struct DescribeTagsInput: Equatable {
    /// <p>The Amazon Resource Names (ARN) of the resources. You can specify up to 20 resources in a
    ///       single call.</p>
    public let resourceArns: [String]?

    public init (
        resourceArns: [String]? = nil
    )
    {
        self.resourceArns = resourceArns
    }
}

extension DescribeTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagsOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTagsOutputResponse(tagDescriptions: \(String(describing: tagDescriptions)))"}
}

extension DescribeTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagDescriptions = output.tagDescriptions
        } else {
            self.tagDescriptions = nil
        }
    }
}

public struct DescribeTagsOutputResponse: Equatable {
    /// <p>Information about the tags.</p>
    public let tagDescriptions: [TagDescription]?

    public init (
        tagDescriptions: [TagDescription]? = nil
    )
    {
        self.tagDescriptions = tagDescriptions
    }
}

struct DescribeTagsOutputResponseBody: Equatable {
    public let tagDescriptions: [TagDescription]?
}

extension DescribeTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagDescriptions = "TagDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTagsResult"))
        if containerValues.contains(.tagDescriptions) {
            struct KeyVal0{struct member{}}
            let tagDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tagDescriptions)
            if let tagDescriptionsWrappedContainer = tagDescriptionsWrappedContainer {
                let tagDescriptionsContainer = try tagDescriptionsWrappedContainer.decodeIfPresent([TagDescription].self, forKey: .member)
                var tagDescriptionsBuffer:[TagDescription]? = nil
                if let tagDescriptionsContainer = tagDescriptionsContainer {
                    tagDescriptionsBuffer = [TagDescription]()
                    for structureContainer0 in tagDescriptionsContainer {
                        tagDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                tagDescriptions = tagDescriptionsBuffer
            } else {
                tagDescriptions = []
            }
        } else {
            tagDescriptions = nil
        }
    }
}

public struct DescribeTargetGroupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupAttributesOutputError>
}

extension DescribeTargetGroupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetGroupAttributesInput(targetGroupArn: \(String(describing: targetGroupArn)))"}
}

extension DescribeTargetGroupAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        try container.encode("DescribeTargetGroupAttributes", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTargetGroupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupAttributesOutputError>
}

public struct DescribeTargetGroupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupAttributesOutputError>
}

public struct DescribeTargetGroupAttributesInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?

    public init (
        targetGroupArn: String? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
    }
}

extension DescribeTargetGroupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetGroupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetGroupAttributesOutputError: Swift.Error, Equatable {
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetGroupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetGroupAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension DescribeTargetGroupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTargetGroupAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeTargetGroupAttributesOutputResponse: Equatable {
    /// <p>Information about the target group attributes</p>
    public let attributes: [TargetGroupAttribute]?

    public init (
        attributes: [TargetGroupAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeTargetGroupAttributesOutputResponseBody: Equatable {
    public let attributes: [TargetGroupAttribute]?
}

extension DescribeTargetGroupAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTargetGroupAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([TargetGroupAttribute].self, forKey: .member)
                var attributesBuffer:[TargetGroupAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [TargetGroupAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct DescribeTargetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupsOutputError>
}

extension DescribeTargetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetGroupsInput(loadBalancerArn: \(String(describing: loadBalancerArn)), marker: \(String(describing: marker)), names: \(String(describing: names)), pageSize: \(String(describing: pageSize)), targetGroupArns: \(String(describing: targetGroupArns)))"}
}

extension DescribeTargetGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let marker = marker {
            try container.encode(marker, forKey: Key("Marker"))
        }
        if let names = names {
            var namesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Names"))
            for (index0, targetgroupname0) in names.enumerated() {
                try namesContainer.encode(targetgroupname0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let pageSize = pageSize {
            try container.encode(pageSize, forKey: Key("PageSize"))
        }
        if let targetGroupArns = targetGroupArns {
            var targetGroupArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TargetGroupArns"))
            for (index0, targetgrouparn0) in targetGroupArns.enumerated() {
                try targetGroupArnsContainer.encode(targetgrouparn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTargetGroups", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTargetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupsOutputError>
}

public struct DescribeTargetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTargetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeTargetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetGroupsOutputError>
}

public struct DescribeTargetGroupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The marker for the next set of results. (You received this marker from a previous
    ///       call.)</p>
    public let marker: String?
    /// <p>The names of the target groups.</p>
    public let names: [String]?
    /// <p>The maximum number of results to return with this call.</p>
    public let pageSize: Int?
    /// <p>The Amazon Resource Names (ARN) of the target groups.</p>
    public let targetGroupArns: [String]?

    public init (
        loadBalancerArn: String? = nil,
        marker: String? = nil,
        names: [String]? = nil,
        pageSize: Int? = nil,
        targetGroupArns: [String]? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
        self.marker = marker
        self.names = names
        self.pageSize = pageSize
        self.targetGroupArns = targetGroupArns
    }
}

extension DescribeTargetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetGroupsOutputError: Swift.Error, Equatable {
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetGroupsOutputResponse(nextMarker: \(String(describing: nextMarker)), targetGroups: \(String(describing: targetGroups)))"}
}

extension DescribeTargetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTargetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.targetGroups = output.targetGroups
        } else {
            self.nextMarker = nil
            self.targetGroups = nil
        }
    }
}

public struct DescribeTargetGroupsOutputResponse: Equatable {
    /// <p>If there are additional results, this is the marker for the next set of results.
    ///       Otherwise, this is null.</p>
    public let nextMarker: String?
    /// <p>Information about the target groups.</p>
    public let targetGroups: [TargetGroup]?

    public init (
        nextMarker: String? = nil,
        targetGroups: [TargetGroup]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.targetGroups = targetGroups
    }
}

struct DescribeTargetGroupsOutputResponseBody: Equatable {
    public let targetGroups: [TargetGroup]?
    public let nextMarker: String?
}

extension DescribeTargetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTargetGroupsResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

public struct DescribeTargetHealthInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTargetHealthInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetHealthOutputError>
}

extension DescribeTargetHealthInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetHealthInput(targetGroupArn: \(String(describing: targetGroupArn)), targets: \(String(describing: targets)))"}
}

extension DescribeTargetHealthInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("DescribeTargetHealth", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct DescribeTargetHealthInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTargetHealthInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetHealthOutputError>
}

public struct DescribeTargetHealthInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTargetHealthInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTargetHealthInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTargetHealthOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTargetHealthInput>
    public typealias MOutput = OperationOutput<DescribeTargetHealthOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTargetHealthOutputError>
}

public struct DescribeTargetHealthInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The targets.</p>
    public let targets: [TargetDescription]?

    public init (
        targetGroupArn: String? = nil,
        targets: [TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension DescribeTargetHealthOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DescribeTargetHealthOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "HealthUnavailableException" : self = .healthUnavailableException(try HealthUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTargetHealthOutputError: Swift.Error, Equatable {
    case healthUnavailableException(HealthUnavailableException)
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTargetHealthOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTargetHealthOutputResponse(targetHealthDescriptions: \(String(describing: targetHealthDescriptions)))"}
}

extension DescribeTargetHealthOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTargetHealthOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetHealthDescriptions = output.targetHealthDescriptions
        } else {
            self.targetHealthDescriptions = nil
        }
    }
}

public struct DescribeTargetHealthOutputResponse: Equatable {
    /// <p>Information about the health of the targets.</p>
    public let targetHealthDescriptions: [TargetHealthDescription]?

    public init (
        targetHealthDescriptions: [TargetHealthDescription]? = nil
    )
    {
        self.targetHealthDescriptions = targetHealthDescriptions
    }
}

struct DescribeTargetHealthOutputResponseBody: Equatable {
    public let targetHealthDescriptions: [TargetHealthDescription]?
}

extension DescribeTargetHealthOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetHealthDescriptions = "TargetHealthDescriptions"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DescribeTargetHealthResult"))
        if containerValues.contains(.targetHealthDescriptions) {
            struct KeyVal0{struct member{}}
            let targetHealthDescriptionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetHealthDescriptions)
            if let targetHealthDescriptionsWrappedContainer = targetHealthDescriptionsWrappedContainer {
                let targetHealthDescriptionsContainer = try targetHealthDescriptionsWrappedContainer.decodeIfPresent([TargetHealthDescription].self, forKey: .member)
                var targetHealthDescriptionsBuffer:[TargetHealthDescription]? = nil
                if let targetHealthDescriptionsContainer = targetHealthDescriptionsContainer {
                    targetHealthDescriptionsBuffer = [TargetHealthDescription]()
                    for structureContainer0 in targetHealthDescriptionsContainer {
                        targetHealthDescriptionsBuffer?.append(structureContainer0)
                    }
                }
                targetHealthDescriptions = targetHealthDescriptionsBuffer
            } else {
                targetHealthDescriptions = []
            }
        } else {
            targetHealthDescriptions = nil
        }
    }
}

extension DuplicateListenerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateListenerException(message: \(String(describing: message)))"}
}

extension DuplicateListenerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateListenerExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A listener with the specified port already exists.</p>
public struct DuplicateListenerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateListenerExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateListenerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateLoadBalancerNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateLoadBalancerNameException(message: \(String(describing: message)))"}
}

extension DuplicateLoadBalancerNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateLoadBalancerNameExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A load balancer with the specified name already exists.</p>
public struct DuplicateLoadBalancerNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateLoadBalancerNameExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateLoadBalancerNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTagKeysException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateTagKeysException(message: \(String(describing: message)))"}
}

extension DuplicateTagKeysException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateTagKeysExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A tag key was specified more than once.</p>
public struct DuplicateTagKeysException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTagKeysExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateTagKeysExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DuplicateTargetGroupNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicateTargetGroupNameException(message: \(String(describing: message)))"}
}

extension DuplicateTargetGroupNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<DuplicateTargetGroupNameExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A target group with the specified name already exists.</p>
public struct DuplicateTargetGroupNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateTargetGroupNameExceptionBody: Equatable {
    public let message: String?
}

extension DuplicateTargetGroupNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FixedResponseActionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contentType = "ContentType"
        case messageBody = "MessageBody"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let contentType = contentType {
            try container.encode(contentType, forKey: Key("ContentType"))
        }
        if let messageBody = messageBody {
            try container.encode(messageBody, forKey: Key("MessageBody"))
        }
        if let statusCode = statusCode {
            try container.encode(statusCode, forKey: Key("StatusCode"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension FixedResponseActionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FixedResponseActionConfig(contentType: \(String(describing: contentType)), messageBody: \(String(describing: messageBody)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Information about an action that returns a custom HTTP response.</p>
public struct FixedResponseActionConfig: Equatable {
    /// <p>The content type.</p>
    ///          <p>Valid Values: text/plain | text/css | text/html | application/javascript |
    ///       application/json</p>
    public let contentType: String?
    /// <p>The message.</p>
    public let messageBody: String?
    /// <p>The HTTP response code (2XX, 4XX, or 5XX).</p>
    public let statusCode: String?

    public init (
        contentType: String? = nil,
        messageBody: String? = nil,
        statusCode: String? = nil
    )
    {
        self.contentType = contentType
        self.messageBody = messageBody
        self.statusCode = statusCode
    }
}

extension ForwardActionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetGroupStickinessConfig = "TargetGroupStickinessConfig"
        case targetGroups = "TargetGroups"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupStickinessConfig = targetGroupStickinessConfig {
            try container.encode(targetGroupStickinessConfig, forKey: Key("TargetGroupStickinessConfig"))
        }
        if let targetGroups = targetGroups {
            var targetGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TargetGroups"))
            for (index0, targetgrouptuple0) in targetGroups.enumerated() {
                try targetGroupsContainer.encode(targetgrouptuple0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([TargetGroupTuple].self, forKey: .member)
                var targetGroupsBuffer:[TargetGroupTuple]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [TargetGroupTuple]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
        let targetGroupStickinessConfigDecoded = try containerValues.decodeIfPresent(TargetGroupStickinessConfig.self, forKey: .targetGroupStickinessConfig)
        targetGroupStickinessConfig = targetGroupStickinessConfigDecoded
    }
}

extension ForwardActionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForwardActionConfig(targetGroupStickinessConfig: \(String(describing: targetGroupStickinessConfig)), targetGroups: \(String(describing: targetGroups)))"}
}

/// <p>Information about a forward action.</p>
public struct ForwardActionConfig: Equatable {
    /// <p>The target group stickiness for the rule.</p>
    public let targetGroupStickinessConfig: TargetGroupStickinessConfig?
    /// <p>One or more target groups. For Network Load Balancers, you can specify a single target
    ///       group.</p>
    public let targetGroups: [TargetGroupTuple]?

    public init (
        targetGroupStickinessConfig: TargetGroupStickinessConfig? = nil,
        targetGroups: [TargetGroupTuple]? = nil
    )
    {
        self.targetGroupStickinessConfig = targetGroupStickinessConfig
        self.targetGroups = targetGroups
    }
}

extension HealthUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthUnavailableException(message: \(String(describing: message)))"}
}

extension HealthUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<HealthUnavailableExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The health of the specified targets could not be retrieved due to an internal
///       error.</p>
public struct HealthUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct HealthUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension HealthUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HostHeaderConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension HostHeaderConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HostHeaderConditionConfig(values: \(String(describing: values)))"}
}

/// <p>Information about a host header condition.</p>
public struct HostHeaderConditionConfig: Equatable {
    /// <p>One or more host names. The maximum size of each name is 128 characters. The comparison is
    ///       case insensitive. The following wildcard characters are supported: * (matches 0 or more
    ///       characters) and ? (matches exactly 1 character).</p>
    ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
    ///       the host name.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

extension HttpHeaderConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpHeaderName = "HttpHeaderName"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let httpHeaderName = httpHeaderName {
            try container.encode(httpHeaderName, forKey: Key("HttpHeaderName"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpHeaderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpHeaderName)
        httpHeaderName = httpHeaderNameDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension HttpHeaderConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpHeaderConditionConfig(httpHeaderName: \(String(describing: httpHeaderName)), values: \(String(describing: values)))"}
}

/// <p>Information about an HTTP header condition.</p>
///          <p>There is a set of standard HTTP header fields. You can also define custom HTTP header
///       fields.</p>
public struct HttpHeaderConditionConfig: Equatable {
    /// <p>The name of the HTTP header field. The maximum size is 40 characters. The header name is
    ///       case insensitive. The allowed characters are specified by RFC 7230. Wildcards are not
    ///       supported.</p>
    ///          <p>You can't use an HTTP header condition to specify the host header. Use <a>HostHeaderConditionConfig</a> to specify a host header condition.</p>
    public let httpHeaderName: String?
    /// <p>One or more strings to compare against the value of the HTTP header. The maximum size of
    ///       each string is 128 characters. The comparison strings are case insensitive. The following
    ///       wildcard characters are supported: * (matches 0 or more characters) and ? (matches exactly 1
    ///       character).</p>
    ///          <p>If the same header appears multiple times in the request, we search them in order until a
    ///       match is found.</p>
    ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
    ///       the value of the HTTP header. To require that all of the strings are a match, create one
    ///       condition per string.</p>
    public let values: [String]?

    public init (
        httpHeaderName: String? = nil,
        values: [String]? = nil
    )
    {
        self.httpHeaderName = httpHeaderName
        self.values = values
    }
}

extension HttpRequestMethodConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension HttpRequestMethodConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRequestMethodConditionConfig(values: \(String(describing: values)))"}
}

/// <p>Information about an HTTP method condition.</p>
///          <p>HTTP defines a set of request methods, also referred to as HTTP verbs. For more
///       information, see the <a href="https://www.iana.org/assignments/http-methods/http-methods.xhtml">HTTP Method
///         Registry</a>. You can also define custom HTTP methods.</p>
public struct HttpRequestMethodConditionConfig: Equatable {
    /// <p>The name of the request method. The maximum size is 40 characters. The allowed characters
    ///       are A-Z, hyphen (-), and underscore (_). The comparison is case sensitive. Wildcards are not
    ///       supported; therefore, the method name must be an exact match.</p>
    ///          <p>If you specify multiple strings, the condition is satisfied if one of the strings matches
    ///       the HTTP request method. We recommend that you route GET and HEAD requests in the same way,
    ///       because the response to a HEAD request may be cached.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

extension IncompatibleProtocolsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncompatibleProtocolsException(message: \(String(describing: message)))"}
}

extension IncompatibleProtocolsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IncompatibleProtocolsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration is not valid with this protocol.</p>
public struct IncompatibleProtocolsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleProtocolsExceptionBody: Equatable {
    public let message: String?
}

extension IncompatibleProtocolsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidConfigurationRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationRequestException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidConfigurationRequestExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested configuration is not valid.</p>
public struct InvalidConfigurationRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLoadBalancerActionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLoadBalancerActionException(message: \(String(describing: message)))"}
}

extension InvalidLoadBalancerActionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidLoadBalancerActionExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested action is not valid.</p>
public struct InvalidLoadBalancerActionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLoadBalancerActionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLoadBalancerActionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSchemeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSchemeException(message: \(String(describing: message)))"}
}

extension InvalidSchemeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSchemeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested scheme is not valid.</p>
public struct InvalidSchemeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSchemeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSchemeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSecurityGroupException(message: \(String(describing: message)))"}
}

extension InvalidSecurityGroupException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSecurityGroupExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified security group does not exist.</p>
public struct InvalidSecurityGroupException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecurityGroupExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSecurityGroupExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnetException(message: \(String(describing: message)))"}
}

extension InvalidSubnetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidSubnetExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet is out of available addresses.</p>
public struct InvalidSubnetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSubnetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTargetException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTargetException(message: \(String(describing: message)))"}
}

extension InvalidTargetException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidTargetExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target does not exist, is not in the same VPC as the target group, or has an
///       unsupported instance type.</p>
public struct InvalidTargetException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTargetExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTargetExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IpAddressType {
    case dualstack
    case ipv4
    case sdkUnknown(String)
}

extension IpAddressType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IpAddressType] {
        return [
            .dualstack,
            .ipv4,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dualstack: return "dualstack"
        case .ipv4: return "ipv4"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IpAddressType(rawValue: rawValue) ?? IpAddressType.sdkUnknown(rawValue)
    }
}

extension Limit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case max = "Max"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let max = max {
            try container.encode(max, forKey: Key("Max"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decodeIfPresent(String.self, forKey: .max)
        max = maxDecoded
    }
}

extension Limit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Limit(max: \(String(describing: max)), name: \(String(describing: name)))"}
}

/// <p>Information about an Elastic Load Balancing resource limit for your AWS account.</p>
public struct Limit: Equatable {
    /// <p>The maximum value of the limit.</p>
    public let max: String?
    /// <p>The name of the limit. The possible values are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>application-load-balancers</p>
    ///             </li>
    ///             <li>
    ///                <p>condition-values-per-alb-rule</p>
    ///             </li>
    ///             <li>
    ///                <p>condition-wildcards-per-alb-rule</p>
    ///             </li>
    ///             <li>
    ///                <p>gateway-load-balancers</p>
    ///             </li>
    ///             <li>
    ///                <p>gateway-load-balancers-per-vpc</p>
    ///             </li>
    ///             <li>
    ///                <p>geneve-target-groups</p>
    ///             </li>
    ///             <li>
    ///                <p>listeners-per-application-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>listeners-per-network-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>network-load-balancers</p>
    ///             </li>
    ///             <li>
    ///                <p>rules-per-application-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>target-groups</p>
    ///             </li>
    ///             <li>
    ///                <p>target-groups-per-action-on-application-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>target-groups-per-action-on-network-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>target-groups-per-application-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>targets-per-application-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>targets-per-availability-zone-per-gateway-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>targets-per-availability-zone-per-network-load-balancer</p>
    ///             </li>
    ///             <li>
    ///                <p>targets-per-network-load-balancer</p>
    ///             </li>
    ///          </ul>
    public let name: String?

    public init (
        max: String? = nil,
        name: String? = nil
    )
    {
        self.max = max
        self.name = name
    }
}

extension Listener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alpnPolicy = "AlpnPolicy"
        case certificates = "Certificates"
        case defaultActions = "DefaultActions"
        case listenerArn = "ListenerArn"
        case loadBalancerArn = "LoadBalancerArn"
        case port = "Port"
        case `protocol` = "Protocol"
        case sslPolicy = "SslPolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: Key("SslPolicy"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .listenerArn)
        listenerArn = listenerArnDecoded
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ProtocolEnum.self, forKey: .protocol)
        `protocol` = protocolDecoded
        if containerValues.contains(.certificates) {
            struct KeyVal0{struct member{}}
            let certificatesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .certificates)
            if let certificatesWrappedContainer = certificatesWrappedContainer {
                let certificatesContainer = try certificatesWrappedContainer.decodeIfPresent([Certificate].self, forKey: .member)
                var certificatesBuffer:[Certificate]? = nil
                if let certificatesContainer = certificatesContainer {
                    certificatesBuffer = [Certificate]()
                    for structureContainer0 in certificatesContainer {
                        certificatesBuffer?.append(structureContainer0)
                    }
                }
                certificates = certificatesBuffer
            } else {
                certificates = []
            }
        } else {
            certificates = nil
        }
        let sslPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sslPolicy)
        sslPolicy = sslPolicyDecoded
        if containerValues.contains(.defaultActions) {
            struct KeyVal0{struct member{}}
            let defaultActionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .defaultActions)
            if let defaultActionsWrappedContainer = defaultActionsWrappedContainer {
                let defaultActionsContainer = try defaultActionsWrappedContainer.decodeIfPresent([Action].self, forKey: .member)
                var defaultActionsBuffer:[Action]? = nil
                if let defaultActionsContainer = defaultActionsContainer {
                    defaultActionsBuffer = [Action]()
                    for structureContainer0 in defaultActionsContainer {
                        defaultActionsBuffer?.append(structureContainer0)
                    }
                }
                defaultActions = defaultActionsBuffer
            } else {
                defaultActions = []
            }
        } else {
            defaultActions = nil
        }
        if containerValues.contains(.alpnPolicy) {
            struct KeyVal0{struct member{}}
            let alpnPolicyWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .alpnPolicy)
            if let alpnPolicyWrappedContainer = alpnPolicyWrappedContainer {
                let alpnPolicyContainer = try alpnPolicyWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var alpnPolicyBuffer:[String]? = nil
                if let alpnPolicyContainer = alpnPolicyContainer {
                    alpnPolicyBuffer = [String]()
                    for stringContainer0 in alpnPolicyContainer {
                        alpnPolicyBuffer?.append(stringContainer0)
                    }
                }
                alpnPolicy = alpnPolicyBuffer
            } else {
                alpnPolicy = []
            }
        } else {
            alpnPolicy = nil
        }
    }
}

extension Listener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Listener(alpnPolicy: \(String(describing: alpnPolicy)), certificates: \(String(describing: certificates)), defaultActions: \(String(describing: defaultActions)), listenerArn: \(String(describing: listenerArn)), loadBalancerArn: \(String(describing: loadBalancerArn)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), sslPolicy: \(String(describing: sslPolicy)))"}
}

/// <p>Information about a listener.</p>
public struct Listener: Equatable {
    /// <p>The protocol for connections from clients to the load balancer.</p>
    public let `protocol`: ProtocolEnum?
    /// <p>[TLS listener] The name of the Application-Layer Protocol Negotiation (ALPN)
    ///       policy.</p>
    public let alpnPolicy: [String]?
    /// <p>[HTTPS or TLS listener] The default certificate for the listener.</p>
    public let certificates: [Certificate]?
    /// <p>The default actions for the listener.</p>
    public let defaultActions: [Action]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The port on which the load balancer is listening.</p>
    public let port: Int?
    /// <p>[HTTPS or TLS listener] The security policy that defines which protocols and ciphers are
    ///       supported.</p>
    public let sslPolicy: String?

    public init (
        `protocol`: ProtocolEnum? = nil,
        alpnPolicy: [String]? = nil,
        certificates: [Certificate]? = nil,
        defaultActions: [Action]? = nil,
        listenerArn: String? = nil,
        loadBalancerArn: String? = nil,
        port: Int? = nil,
        sslPolicy: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.alpnPolicy = alpnPolicy
        self.certificates = certificates
        self.defaultActions = defaultActions
        self.listenerArn = listenerArn
        self.loadBalancerArn = loadBalancerArn
        self.port = port
        self.sslPolicy = sslPolicy
    }
}

extension ListenerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerNotFoundException(message: \(String(describing: message)))"}
}

extension ListenerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ListenerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified listener does not exist.</p>
public struct ListenerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ListenerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ListenerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoadBalancer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case canonicalHostedZoneId = "CanonicalHostedZoneId"
        case createdTime = "CreatedTime"
        case customerOwnedIpv4Pool = "CustomerOwnedIpv4Pool"
        case dNSName = "DNSName"
        case ipAddressType = "IpAddressType"
        case loadBalancerArn = "LoadBalancerArn"
        case loadBalancerName = "LoadBalancerName"
        case scheme = "Scheme"
        case securityGroups = "SecurityGroups"
        case state = "State"
        case type = "Type"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AvailabilityZones"))
            for (index0, availabilityzone0) in availabilityZones.enumerated() {
                try availabilityZonesContainer.encode(availabilityzone0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let canonicalHostedZoneId = canonicalHostedZoneId {
            try container.encode(canonicalHostedZoneId, forKey: Key("CanonicalHostedZoneId"))
        }
        if let createdTime = createdTime {
            try container.encode(TimestampWrapper(createdTime, format: .dateTime), forKey: Key("createdTime"))
        }
        if let customerOwnedIpv4Pool = customerOwnedIpv4Pool {
            try container.encode(customerOwnedIpv4Pool, forKey: Key("CustomerOwnedIpv4Pool"))
        }
        if let dNSName = dNSName {
            try container.encode(dNSName, forKey: Key("DNSName"))
        }
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let loadBalancerName = loadBalancerName {
            try container.encode(loadBalancerName, forKey: Key("LoadBalancerName"))
        }
        if let scheme = scheme {
            try container.encode(scheme, forKey: Key("Scheme"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
        if let type = type {
            try container.encode(type, forKey: Key("Type"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loadBalancerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerArn)
        loadBalancerArn = loadBalancerArnDecoded
        let dNSNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dNSName)
        dNSName = dNSNameDecoded
        let canonicalHostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .canonicalHostedZoneId)
        canonicalHostedZoneId = canonicalHostedZoneIdDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdTime)
        var createdTimeBuffer:Date? = nil
        if let createdTimeDecoded = createdTimeDecoded {
            createdTimeBuffer = try TimestampWrapperDecoder.parseDateStringValue(createdTimeDecoded, format: .dateTime)
        }
        createdTime = createdTimeBuffer
        let loadBalancerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loadBalancerName)
        loadBalancerName = loadBalancerNameDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(LoadBalancerSchemeEnum.self, forKey: .scheme)
        scheme = schemeDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LoadBalancerState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(LoadBalancerTypeEnum.self, forKey: .type)
        type = typeDecoded
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        if containerValues.contains(.securityGroups) {
            struct KeyVal0{struct member{}}
            let securityGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroups)
            if let securityGroupsWrappedContainer = securityGroupsWrappedContainer {
                let securityGroupsContainer = try securityGroupsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupsBuffer:[String]? = nil
                if let securityGroupsContainer = securityGroupsContainer {
                    securityGroupsBuffer = [String]()
                    for stringContainer0 in securityGroupsContainer {
                        securityGroupsBuffer?.append(stringContainer0)
                    }
                }
                securityGroups = securityGroupsBuffer
            } else {
                securityGroups = []
            }
        } else {
            securityGroups = nil
        }
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
        let customerOwnedIpv4PoolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerOwnedIpv4Pool)
        customerOwnedIpv4Pool = customerOwnedIpv4PoolDecoded
    }
}

extension LoadBalancer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancer(availabilityZones: \(String(describing: availabilityZones)), canonicalHostedZoneId: \(String(describing: canonicalHostedZoneId)), createdTime: \(String(describing: createdTime)), customerOwnedIpv4Pool: \(String(describing: customerOwnedIpv4Pool)), dNSName: \(String(describing: dNSName)), ipAddressType: \(String(describing: ipAddressType)), loadBalancerArn: \(String(describing: loadBalancerArn)), loadBalancerName: \(String(describing: loadBalancerName)), scheme: \(String(describing: scheme)), securityGroups: \(String(describing: securityGroups)), state: \(String(describing: state)), type: \(String(describing: type)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about a load balancer.</p>
public struct LoadBalancer: Equatable {
    /// <p>The subnets for the load balancer.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>The ID of the Amazon Route 53 hosted zone associated with the load balancer.</p>
    public let canonicalHostedZoneId: String?
    /// <p>The date and time the load balancer was created.</p>
    public let createdTime: Date?
    /// <p>[Application Load Balancers on Outposts] The ID of the customer-owned address pool.</p>
    public let customerOwnedIpv4Pool: String?
    /// <p>The public DNS name of the load balancer.</p>
    public let dNSName: String?
    /// <p>The type of IP addresses used by the subnets for your load balancer. The possible values
    ///       are <code>ipv4</code> (for IPv4 addresses) and <code>dualstack</code> (for IPv4 and IPv6
    ///       addresses).</p>
    public let ipAddressType: IpAddressType?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The name of the load balancer.</p>
    public let loadBalancerName: String?
    /// <p>The nodes of an Internet-facing load balancer have public IP addresses. The DNS name of an
    ///       Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
    ///       Therefore, Internet-facing load balancers can route requests from clients over the
    ///       internet.</p>
    ///          <p>The nodes of an internal load balancer have only private IP addresses. The DNS name of an
    ///       internal load balancer is publicly resolvable to the private IP addresses of the nodes.
    ///       Therefore, internal load balancers can route requests only from clients with access to the VPC
    ///       for the load balancer.</p>
    public let scheme: LoadBalancerSchemeEnum?
    /// <p>The IDs of the security groups for the load balancer.</p>
    public let securityGroups: [String]?
    /// <p>The state of the load balancer.</p>
    public let state: LoadBalancerState?
    /// <p>The type of load balancer.</p>
    public let type: LoadBalancerTypeEnum?
    /// <p>The ID of the VPC for the load balancer.</p>
    public let vpcId: String?

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        canonicalHostedZoneId: String? = nil,
        createdTime: Date? = nil,
        customerOwnedIpv4Pool: String? = nil,
        dNSName: String? = nil,
        ipAddressType: IpAddressType? = nil,
        loadBalancerArn: String? = nil,
        loadBalancerName: String? = nil,
        scheme: LoadBalancerSchemeEnum? = nil,
        securityGroups: [String]? = nil,
        state: LoadBalancerState? = nil,
        type: LoadBalancerTypeEnum? = nil,
        vpcId: String? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.canonicalHostedZoneId = canonicalHostedZoneId
        self.createdTime = createdTime
        self.customerOwnedIpv4Pool = customerOwnedIpv4Pool
        self.dNSName = dNSName
        self.ipAddressType = ipAddressType
        self.loadBalancerArn = loadBalancerArn
        self.loadBalancerName = loadBalancerName
        self.scheme = scheme
        self.securityGroups = securityGroups
        self.state = state
        self.type = type
        self.vpcId = vpcId
    }
}

extension LoadBalancerAddress: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case iPv6Address = "IPv6Address"
        case ipAddress = "IpAddress"
        case privateIPv4Address = "PrivateIPv4Address"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocationId = allocationId {
            try container.encode(allocationId, forKey: Key("AllocationId"))
        }
        if let iPv6Address = iPv6Address {
            try container.encode(iPv6Address, forKey: Key("IPv6Address"))
        }
        if let ipAddress = ipAddress {
            try container.encode(ipAddress, forKey: Key("IpAddress"))
        }
        if let privateIPv4Address = privateIPv4Address {
            try container.encode(privateIPv4Address, forKey: Key("PrivateIPv4Address"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let privateIPv4AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIPv4Address)
        privateIPv4Address = privateIPv4AddressDecoded
        let iPv6AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPv6Address)
        iPv6Address = iPv6AddressDecoded
    }
}

extension LoadBalancerAddress: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerAddress(allocationId: \(String(describing: allocationId)), iPv6Address: \(String(describing: iPv6Address)), ipAddress: \(String(describing: ipAddress)), privateIPv4Address: \(String(describing: privateIPv4Address)))"}
}

/// <p>Information about a static IP address for a load balancer.</p>
public struct LoadBalancerAddress: Equatable {
    /// <p>[Network Load Balancers] The allocation ID of the Elastic IP address for an
    ///       internal-facing load balancer.</p>
    public let allocationId: String?
    /// <p>[Network Load Balancers] The IPv6 address.</p>
    public let iPv6Address: String?
    /// <p>The static IP address.</p>
    public let ipAddress: String?
    /// <p>[Network Load Balancers] The private IPv4 address for an internal load balancer.</p>
    public let privateIPv4Address: String?

    public init (
        allocationId: String? = nil,
        iPv6Address: String? = nil,
        ipAddress: String? = nil,
        privateIPv4Address: String? = nil
    )
    {
        self.allocationId = allocationId
        self.iPv6Address = iPv6Address
        self.ipAddress = ipAddress
        self.privateIPv4Address = privateIPv4Address
    }
}

extension LoadBalancerAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LoadBalancerAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a load balancer attribute.</p>
public struct LoadBalancerAttribute: Equatable {
    /// <p>The name of the attribute.</p>
    ///
    ///          <p>The following attribute is supported by all load balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deletion_protection.enabled</code> - Indicates whether deletion protection is
    ///           enabled. The value is <code>true</code> or <code>false</code>. The default is
    ///             <code>false</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attributes are supported by both Application Load Balancers and Network Load
    ///       Balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>access_logs.s3.enabled</code> - Indicates whether access logs are enabled. The
    ///           value is <code>true</code> or <code>false</code>. The default is
    ///           <code>false</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>access_logs.s3.bucket</code> - The name of the S3 bucket for the access logs.
    ///           This attribute is required if access logs are enabled. The bucket must exist in the same
    ///           region as the load balancer and have a bucket policy that grants Elastic Load Balancing
    ///           permissions to write to the bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>access_logs.s3.prefix</code> - The prefix for the location in the S3 bucket for the
    ///           access logs.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attributes are supported by only Application Load Balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>idle_timeout.timeout_seconds</code> - The idle timeout value, in seconds. The
    ///           valid range is 1-4000 seconds. The default is 60 seconds.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>routing.http.desync_mitigation_mode</code> - Determines how the load balancer
    ///           handles requests that might pose a security risk to your application. The possible values
    ///           are <code>monitor</code>, <code>defensive</code>, and <code>strictest</code>. The default
    ///           is <code>defensive</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>routing.http.drop_invalid_header_fields.enabled</code> - Indicates whether HTTP
    ///           headers with invalid header fields are removed by the load balancer (<code>true</code>) or
    ///           routed to targets (<code>false</code>). The default is <code>false</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>routing.http2.enabled</code> - Indicates whether HTTP/2 is enabled. The value is
    ///             <code>true</code> or <code>false</code>. The default is <code>true</code>. Elastic Load
    ///           Balancing requires that message header names contain only alphanumeric characters and
    ///           hyphens.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>waf.fail_open.enabled</code> - Indicates whether to allow a WAF-enabled load
    ///           balancer to route requests to targets if it is unable to forward the request to AWS WAF.
    ///           The value is <code>true</code> or <code>false</code>. The default is
    ///           <code>false</code>.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attribute is supported by Network Load Balancers and Gateway Load
    ///       Balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>load_balancing.cross_zone.enabled</code> - Indicates whether cross-zone load
    ///           balancing is enabled. The value is <code>true</code> or <code>false</code>. The default is
    ///             <code>false</code>.</p>
    ///             </li>
    ///          </ul>
    public let key: String?
    /// <p>The value of the attribute.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension LoadBalancerNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerNotFoundException(message: \(String(describing: message)))"}
}

extension LoadBalancerNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<LoadBalancerNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified load balancer does not exist.</p>
public struct LoadBalancerNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LoadBalancerNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension LoadBalancerNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LoadBalancerSchemeEnum {
    case `internal`
    case internetFacing
    case sdkUnknown(String)
}

extension LoadBalancerSchemeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoadBalancerSchemeEnum] {
        return [
            .internal,
            .internetFacing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internal: return "internal"
        case .internetFacing: return "internet-facing"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoadBalancerSchemeEnum(rawValue: rawValue) ?? LoadBalancerSchemeEnum.sdkUnknown(rawValue)
    }
}

extension LoadBalancerState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case reason = "Reason"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let code = code {
            try container.encode(code, forKey: Key("Code"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: Key("Reason"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(LoadBalancerStateEnum.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension LoadBalancerState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoadBalancerState(code: \(String(describing: code)), reason: \(String(describing: reason)))"}
}

/// <p>Information about the state of the load balancer.</p>
public struct LoadBalancerState: Equatable {
    /// <p>The state code. The initial state of the load balancer is <code>provisioning</code>. After
    ///       the load balancer is fully set up and ready to route traffic, its state is
    ///       <code>active</code>. If load balancer is routing traffic but does not have the resources it
    ///       needs to scale, its state is<code>active_impaired</code>. If the load balancer could not be
    ///       set up, its state is <code>failed</code>.</p>
    public let code: LoadBalancerStateEnum?
    /// <p>A description of the state.</p>
    public let reason: String?

    public init (
        code: LoadBalancerStateEnum? = nil,
        reason: String? = nil
    )
    {
        self.code = code
        self.reason = reason
    }
}

public enum LoadBalancerStateEnum {
    case active
    case activeImpaired
    case failed
    case provisioning
    case sdkUnknown(String)
}

extension LoadBalancerStateEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoadBalancerStateEnum] {
        return [
            .active,
            .activeImpaired,
            .failed,
            .provisioning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "active"
        case .activeImpaired: return "active_impaired"
        case .failed: return "failed"
        case .provisioning: return "provisioning"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoadBalancerStateEnum(rawValue: rawValue) ?? LoadBalancerStateEnum.sdkUnknown(rawValue)
    }
}

public enum LoadBalancerTypeEnum {
    case application
    case gateway
    case network
    case sdkUnknown(String)
}

extension LoadBalancerTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoadBalancerTypeEnum] {
        return [
            .application,
            .gateway,
            .network,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .application: return "application"
        case .gateway: return "gateway"
        case .network: return "network"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoadBalancerTypeEnum(rawValue: rawValue) ?? LoadBalancerTypeEnum.sdkUnknown(rawValue)
    }
}

extension Matcher: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpcCode = "GrpcCode"
        case httpCode = "HttpCode"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let grpcCode = grpcCode {
            try container.encode(grpcCode, forKey: Key("GrpcCode"))
        }
        if let httpCode = httpCode {
            try container.encode(httpCode, forKey: Key("HttpCode"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .httpCode)
        httpCode = httpCodeDecoded
        let grpcCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .grpcCode)
        grpcCode = grpcCodeDecoded
    }
}

extension Matcher: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Matcher(grpcCode: \(String(describing: grpcCode)), httpCode: \(String(describing: httpCode)))"}
}

/// <p>The codes to use when checking for a successful response from a target. If the protocol
///       version is gRPC, these are gRPC codes. Otherwise, these are HTTP codes.</p>
public struct Matcher: Equatable {
    /// <p>You can specify values between 0 and 99. You can specify multiple values (for example,
    ///       "0,1") or a range of values (for example, "0-5"). The default value is 12.</p>
    public let grpcCode: String?
    /// <p>For Application Load Balancers, you can specify values between 200 and 499, and the
    ///       default value is 200. You can specify multiple values (for example, "200,202") or a range of
    ///       values (for example, "200-299").</p>
    ///          <p>For Network Load Balancers and Gateway Load Balancers, this must be "200399".</p>
    public let httpCode: String?

    public init (
        grpcCode: String? = nil,
        httpCode: String? = nil
    )
    {
        self.grpcCode = grpcCode
        self.httpCode = httpCode
    }
}

public struct ModifyListenerInputBodyMiddleware: Middleware {
    public let id: String = "ModifyListenerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyListenerOutputError>
}

extension ModifyListenerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyListenerInput(alpnPolicy: \(String(describing: alpnPolicy)), certificates: \(String(describing: certificates)), defaultActions: \(String(describing: defaultActions)), listenerArn: \(String(describing: listenerArn)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), sslPolicy: \(String(describing: sslPolicy)))"}
}

extension ModifyListenerInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let alpnPolicy = alpnPolicy {
            var alpnPolicyContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("AlpnPolicy"))
            for (index0, alpnpolicyvalue0) in alpnPolicy.enumerated() {
                try alpnPolicyContainer.encode(alpnpolicyvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let defaultActions = defaultActions {
            var defaultActionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("DefaultActions"))
            for (index0, action0) in defaultActions.enumerated() {
                try defaultActionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let sslPolicy = sslPolicy {
            try container.encode(sslPolicy, forKey: Key("SslPolicy"))
        }
        try container.encode("ModifyListener", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct ModifyListenerInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyListenerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyListenerOutputError>
}

public struct ModifyListenerInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyListenerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyListenerInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyListenerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyListenerInput>
    public typealias MOutput = OperationOutput<ModifyListenerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyListenerOutputError>
}

public struct ModifyListenerInput: Equatable {
    /// <p>The protocol for connections from clients to the load balancer. Application Load Balancers
    ///       support the HTTP and HTTPS protocols. Network Load Balancers support the TCP, TLS, UDP, and
    ///       TCP_UDP protocols. You cant change the protocol to UDP or TCP_UDP if dual-stack mode is
    ///       enabled. You cannot specify a protocol for a Gateway Load Balancer.</p>
    public let `protocol`: ProtocolEnum?
    /// <p>[TLS listeners] The name of the Application-Layer Protocol Negotiation (ALPN) policy. You
    ///       can specify one policy name. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP1Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Only</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Optional</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>HTTP2Preferred</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>None</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#alpn-policies">ALPN
    ///         policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let alpnPolicy: [String]?
    /// <p>[HTTPS and TLS listeners] The default certificate for the listener. You must provide
    ///       exactly one certificate. Set <code>CertificateArn</code> to the certificate ARN but do not set
    ///         <code>IsDefault</code>.</p>
    public let certificates: [Certificate]?
    /// <p>The actions for the default rule.</p>
    public let defaultActions: [Action]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?
    /// <p>The port for connections from clients to the load balancer. You cannot specify a port for
    ///       a Gateway Load Balancer.</p>
    public let port: Int?
    /// <p>[HTTPS and TLS listeners] The security policy that defines which protocols and ciphers are
    ///       supported.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/application/create-https-listener.html#describe-ssl-policies">Security policies</a> in the <i>Application Load Balancers Guide</i> or
    ///         <a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/create-tls-listener.html#describe-ssl-policies">Security policies</a> in the <i>Network Load Balancers Guide</i>.</p>
    public let sslPolicy: String?

    public init (
        `protocol`: ProtocolEnum? = nil,
        alpnPolicy: [String]? = nil,
        certificates: [Certificate]? = nil,
        defaultActions: [Action]? = nil,
        listenerArn: String? = nil,
        port: Int? = nil,
        sslPolicy: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.alpnPolicy = alpnPolicy
        self.certificates = certificates
        self.defaultActions = defaultActions
        self.listenerArn = listenerArn
        self.port = port
        self.sslPolicy = sslPolicy
    }
}

extension ModifyListenerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyListenerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ALPNPolicyNotSupportedException" : self = .aLPNPolicyNotSupportedException(try ALPNPolicyNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CertificateNotFoundException" : self = .certificateNotFoundException(try CertificateNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateListenerException" : self = .duplicateListenerException(try DuplicateListenerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SSLPolicyNotFoundException" : self = .sSLPolicyNotFoundException(try SSLPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyCertificatesException" : self = .tooManyCertificatesException(try TooManyCertificatesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyListenersException" : self = .tooManyListenersException(try TooManyListenersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyListenerOutputError: Swift.Error, Equatable {
    case aLPNPolicyNotSupportedException(ALPNPolicyNotSupportedException)
    case certificateNotFoundException(CertificateNotFoundException)
    case duplicateListenerException(DuplicateListenerException)
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case listenerNotFoundException(ListenerNotFoundException)
    case sSLPolicyNotFoundException(SSLPolicyNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyCertificatesException(TooManyCertificatesException)
    case tooManyListenersException(TooManyListenersException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyListenerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyListenerOutputResponse(listeners: \(String(describing: listeners)))"}
}

extension ModifyListenerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyListenerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.listeners = output.listeners
        } else {
            self.listeners = nil
        }
    }
}

public struct ModifyListenerOutputResponse: Equatable {
    /// <p>Information about the modified listener.</p>
    public let listeners: [Listener]?

    public init (
        listeners: [Listener]? = nil
    )
    {
        self.listeners = listeners
    }
}

struct ModifyListenerOutputResponseBody: Equatable {
    public let listeners: [Listener]?
}

extension ModifyListenerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listeners = "Listeners"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyListenerResult"))
        if containerValues.contains(.listeners) {
            struct KeyVal0{struct member{}}
            let listenersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .listeners)
            if let listenersWrappedContainer = listenersWrappedContainer {
                let listenersContainer = try listenersWrappedContainer.decodeIfPresent([Listener].self, forKey: .member)
                var listenersBuffer:[Listener]? = nil
                if let listenersContainer = listenersContainer {
                    listenersBuffer = [Listener]()
                    for structureContainer0 in listenersContainer {
                        listenersBuffer?.append(structureContainer0)
                    }
                }
                listeners = listenersBuffer
            } else {
                listeners = []
            }
        } else {
            listeners = nil
        }
    }
}

public struct ModifyLoadBalancerAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

extension ModifyLoadBalancerAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLoadBalancerAttributesInput(attributes: \(String(describing: attributes)), loadBalancerArn: \(String(describing: loadBalancerArn)))"}
}

extension ModifyLoadBalancerAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, loadbalancerattribute0) in attributes.enumerated() {
                try attributesContainer.encode(loadbalancerattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        try container.encode("ModifyLoadBalancerAttributes", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct ModifyLoadBalancerAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

public struct ModifyLoadBalancerAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyLoadBalancerAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyLoadBalancerAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyLoadBalancerAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyLoadBalancerAttributesInput>
    public typealias MOutput = OperationOutput<ModifyLoadBalancerAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyLoadBalancerAttributesOutputError>
}

public struct ModifyLoadBalancerAttributesInput: Equatable {
    /// <p>The load balancer attributes.</p>
    public let attributes: [LoadBalancerAttribute]?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?

    public init (
        attributes: [LoadBalancerAttribute]? = nil,
        loadBalancerArn: String? = nil
    )
    {
        self.attributes = attributes
        self.loadBalancerArn = loadBalancerArn
    }
}

extension ModifyLoadBalancerAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyLoadBalancerAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyLoadBalancerAttributesOutputError: Swift.Error, Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyLoadBalancerAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyLoadBalancerAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension ModifyLoadBalancerAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyLoadBalancerAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct ModifyLoadBalancerAttributesOutputResponse: Equatable {
    /// <p>Information about the load balancer attributes.</p>
    public let attributes: [LoadBalancerAttribute]?

    public init (
        attributes: [LoadBalancerAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct ModifyLoadBalancerAttributesOutputResponseBody: Equatable {
    public let attributes: [LoadBalancerAttribute]?
}

extension ModifyLoadBalancerAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyLoadBalancerAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([LoadBalancerAttribute].self, forKey: .member)
                var attributesBuffer:[LoadBalancerAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [LoadBalancerAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct ModifyRuleInputBodyMiddleware: Middleware {
    public let id: String = "ModifyRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyRuleOutputError>
}

extension ModifyRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyRuleInput(actions: \(String(describing: actions)), conditions: \(String(describing: conditions)), ruleArn: \(String(describing: ruleArn)))"}
}

extension ModifyRuleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: Key("RuleArn"))
        }
        try container.encode("ModifyRule", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct ModifyRuleInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyRuleOutputError>
}

public struct ModifyRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyRuleInput>
    public typealias MOutput = OperationOutput<ModifyRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyRuleOutputError>
}

public struct ModifyRuleInput: Equatable {
    /// <p>The actions.</p>
    public let actions: [Action]?
    /// <p>The conditions.</p>
    public let conditions: [RuleCondition]?
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: String?

    public init (
        actions: [Action]? = nil,
        conditions: [RuleCondition]? = nil,
        ruleArn: String? = nil
    )
    {
        self.actions = actions
        self.conditions = conditions
        self.ruleArn = ruleArn
    }
}

extension ModifyRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "IncompatibleProtocolsException" : self = .incompatibleProtocolsException(try IncompatibleProtocolsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLoadBalancerActionException" : self = .invalidLoadBalancerActionException(try InvalidLoadBalancerActionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupAssociationLimitException" : self = .targetGroupAssociationLimitException(try TargetGroupAssociationLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyActionsException" : self = .tooManyActionsException(try TooManyActionsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyUniqueTargetGroupsPerLoadBalancerException" : self = .tooManyUniqueTargetGroupsPerLoadBalancerException(try TooManyUniqueTargetGroupsPerLoadBalancerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedProtocolException" : self = .unsupportedProtocolException(try UnsupportedProtocolException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyRuleOutputError: Swift.Error, Equatable {
    case incompatibleProtocolsException(IncompatibleProtocolsException)
    case invalidLoadBalancerActionException(InvalidLoadBalancerActionException)
    case operationNotPermittedException(OperationNotPermittedException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupAssociationLimitException(TargetGroupAssociationLimitException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyActionsException(TooManyActionsException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case tooManyUniqueTargetGroupsPerLoadBalancerException(TooManyUniqueTargetGroupsPerLoadBalancerException)
    case unsupportedProtocolException(UnsupportedProtocolException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyRuleOutputResponse(rules: \(String(describing: rules)))"}
}

extension ModifyRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ModifyRuleOutputResponse: Equatable {
    /// <p>Information about the modified rule.</p>
    public let rules: [Rule]?

    public init (
        rules: [Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ModifyRuleOutputResponseBody: Equatable {
    public let rules: [Rule]?
}

extension ModifyRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyRuleResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([Rule].self, forKey: .member)
                var rulesBuffer:[Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct ModifyTargetGroupAttributesInputBodyMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupAttributesOutputError>
}

extension ModifyTargetGroupAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyTargetGroupAttributesInput(attributes: \(String(describing: attributes)), targetGroupArn: \(String(describing: targetGroupArn)))"}
}

extension ModifyTargetGroupAttributesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let attributes = attributes {
            var attributesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Attributes"))
            for (index0, targetgroupattribute0) in attributes.enumerated() {
                try attributesContainer.encode(targetgroupattribute0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        try container.encode("ModifyTargetGroupAttributes", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct ModifyTargetGroupAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupAttributesOutputError>
}

public struct ModifyTargetGroupAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupAttributesInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupAttributesOutputError>
}

public struct ModifyTargetGroupAttributesInput: Equatable {
    /// <p>The attributes.</p>
    public let attributes: [TargetGroupAttribute]?
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?

    public init (
        attributes: [TargetGroupAttribute]? = nil,
        targetGroupArn: String? = nil
    )
    {
        self.attributes = attributes
        self.targetGroupArn = targetGroupArn
    }
}

extension ModifyTargetGroupAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyTargetGroupAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyTargetGroupAttributesOutputError: Swift.Error, Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyTargetGroupAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyTargetGroupAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension ModifyTargetGroupAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyTargetGroupAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct ModifyTargetGroupAttributesOutputResponse: Equatable {
    /// <p>Information about the attributes.</p>
    public let attributes: [TargetGroupAttribute]?

    public init (
        attributes: [TargetGroupAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct ModifyTargetGroupAttributesOutputResponseBody: Equatable {
    public let attributes: [TargetGroupAttribute]?
}

extension ModifyTargetGroupAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyTargetGroupAttributesResult"))
        if containerValues.contains(.attributes) {
            struct KeyVal0{struct member{}}
            let attributesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .attributes)
            if let attributesWrappedContainer = attributesWrappedContainer {
                let attributesContainer = try attributesWrappedContainer.decodeIfPresent([TargetGroupAttribute].self, forKey: .member)
                var attributesBuffer:[TargetGroupAttribute]? = nil
                if let attributesContainer = attributesContainer {
                    attributesBuffer = [TargetGroupAttribute]()
                    for structureContainer0 in attributesContainer {
                        attributesBuffer?.append(structureContainer0)
                    }
                }
                attributes = attributesBuffer
            } else {
                attributes = []
            }
        } else {
            attributes = nil
        }
    }
}

public struct ModifyTargetGroupInputBodyMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupOutputError>
}

extension ModifyTargetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyTargetGroupInput(healthCheckEnabled: \(String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(String(describing: healthyThresholdCount)), matcher: \(String(describing: matcher)), targetGroupArn: \(String(describing: targetGroupArn)), unhealthyThresholdCount: \(String(describing: unhealthyThresholdCount)))"}
}

extension ModifyTargetGroupInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: Key("HealthyThresholdCount"))
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: Key("Matcher"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: Key("UnhealthyThresholdCount"))
        }
        try container.encode("ModifyTargetGroup", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct ModifyTargetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupOutputError>
}

public struct ModifyTargetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "ModifyTargetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ModifyTargetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<ModifyTargetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ModifyTargetGroupInput>
    public typealias MOutput = OperationOutput<ModifyTargetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ModifyTargetGroupOutputError>
}

public struct ModifyTargetGroupInput: Equatable {
    /// <p>Indicates whether health checks are enabled.</p>
    public let healthCheckEnabled: Bool?
    /// <p>The approximate amount of time, in seconds, between health checks of an individual target.
    ///       For TCP health checks, the supported values are 10 or 30 seconds.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>[HTTP/HTTPS health checks] The destination for health checks on the targets.</p>
    ///          <p>[HTTP1 or HTTP2 protocol version] The ping path. The default is /.</p>
    ///          <p>[GRPC protocol version] The path of a custom health check method with the format
    ///       /package.service/method. The default is /AWS.ALB/healthcheck.</p>
    public let healthCheckPath: String?
    /// <p>The port the load balancer uses when performing health checks on targets.</p>
    public let healthCheckPort: String?
    /// <p>The protocol the load balancer uses when performing health checks on targets. The TCP
    ///       protocol is supported for health checks only if the protocol of the target group is TCP, TLS,
    ///       UDP, or TCP_UDP. The GENEVE, TLS, UDP, and TCP_UDP protocols are not supported for health
    ///       checks.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckProtocol: ProtocolEnum?
    /// <p>[HTTP/HTTPS health checks] The amount of time, in seconds, during which no response means
    ///       a failed health check.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let healthCheckTimeoutSeconds: Int?
    /// <p>The number of consecutive health checks successes required before considering an unhealthy
    ///       target healthy.</p>
    public let healthyThresholdCount: Int?
    /// <p>[HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
    ///       response from a target.</p>
    ///          <p>With Network Load Balancers, you can't modify this setting.</p>
    public let matcher: Matcher?
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The number of consecutive health check failures required before considering the target
    ///       unhealthy. For target groups with a protocol of TCP or TLS, this value must be the same as the
    ///       healthy threshold count.</p>
    public let unhealthyThresholdCount: Int?

    public init (
        healthCheckEnabled: Bool? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: String? = nil,
        healthCheckProtocol: ProtocolEnum? = nil,
        healthCheckTimeoutSeconds: Int? = nil,
        healthyThresholdCount: Int? = nil,
        matcher: Matcher? = nil,
        targetGroupArn: String? = nil,
        unhealthyThresholdCount: Int? = nil
    )
    {
        self.healthCheckEnabled = healthCheckEnabled
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
        self.healthyThresholdCount = healthyThresholdCount
        self.matcher = matcher
        self.targetGroupArn = targetGroupArn
        self.unhealthyThresholdCount = unhealthyThresholdCount
    }
}

extension ModifyTargetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension ModifyTargetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ModifyTargetGroupOutputError: Swift.Error, Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ModifyTargetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyTargetGroupOutputResponse(targetGroups: \(String(describing: targetGroups)))"}
}

extension ModifyTargetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ModifyTargetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.targetGroups = output.targetGroups
        } else {
            self.targetGroups = nil
        }
    }
}

public struct ModifyTargetGroupOutputResponse: Equatable {
    /// <p>Information about the modified target group.</p>
    public let targetGroups: [TargetGroup]?

    public init (
        targetGroups: [TargetGroup]? = nil
    )
    {
        self.targetGroups = targetGroups
    }
}

struct ModifyTargetGroupOutputResponseBody: Equatable {
    public let targetGroups: [TargetGroup]?
}

extension ModifyTargetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case targetGroups = "TargetGroups"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("ModifyTargetGroupResult"))
        if containerValues.contains(.targetGroups) {
            struct KeyVal0{struct member{}}
            let targetGroupsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .targetGroups)
            if let targetGroupsWrappedContainer = targetGroupsWrappedContainer {
                let targetGroupsContainer = try targetGroupsWrappedContainer.decodeIfPresent([TargetGroup].self, forKey: .member)
                var targetGroupsBuffer:[TargetGroup]? = nil
                if let targetGroupsContainer = targetGroupsContainer {
                    targetGroupsBuffer = [TargetGroup]()
                    for structureContainer0 in targetGroupsContainer {
                        targetGroupsBuffer?.append(structureContainer0)
                    }
                }
                targetGroups = targetGroupsBuffer
            } else {
                targetGroups = []
            }
        } else {
            targetGroups = nil
        }
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<OperationNotPermittedExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This operation is not allowed.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PathPatternConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension PathPatternConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PathPatternConditionConfig(values: \(String(describing: values)))"}
}

/// <p>Information about a path pattern condition.</p>
public struct PathPatternConditionConfig: Equatable {
    /// <p>One or more path patterns to compare against the request URL. The maximum size of each
    ///       string is 128 characters. The comparison is case sensitive. The following wildcard characters
    ///       are supported: * (matches 0 or more characters) and ? (matches exactly 1 character).</p>
    ///          <p>If you specify multiple strings, the condition is satisfied if one of them matches the
    ///       request URL. The path pattern is compared only to the path of the URL, not to its query
    ///       string. To compare against the query string, use <a>QueryStringConditionConfig</a>.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

extension PriorityInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PriorityInUseException(message: \(String(describing: message)))"}
}

extension PriorityInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PriorityInUseExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified priority is in use.</p>
public struct PriorityInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PriorityInUseExceptionBody: Equatable {
    public let message: String?
}

extension PriorityInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ProtocolEnum {
    case geneve
    case http
    case https
    case tcp
    case tcpUdp
    case tls
    case udp
    case sdkUnknown(String)
}

extension ProtocolEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProtocolEnum] {
        return [
            .geneve,
            .http,
            .https,
            .tcp,
            .tcpUdp,
            .tls,
            .udp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .geneve: return "GENEVE"
        case .http: return "HTTP"
        case .https: return "HTTPS"
        case .tcp: return "TCP"
        case .tcpUdp: return "TCP_UDP"
        case .tls: return "TLS"
        case .udp: return "UDP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProtocolEnum(rawValue: rawValue) ?? ProtocolEnum.sdkUnknown(rawValue)
    }
}

extension QueryStringConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, querystringkeyvaluepair0) in values.enumerated() {
                try valuesContainer.encode(querystringkeyvaluepair0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([QueryStringKeyValuePair].self, forKey: .member)
                var valuesBuffer:[QueryStringKeyValuePair]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [QueryStringKeyValuePair]()
                    for structureContainer0 in valuesContainer {
                        valuesBuffer?.append(structureContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension QueryStringConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryStringConditionConfig(values: \(String(describing: values)))"}
}

/// <p>Information about a query string condition.</p>
///          <p>The query string component of a URI starts after the first '?' character and is terminated
///       by either a '#' character or the end of the URI. A typical query string contains key/value
///       pairs separated by '&' characters. The allowed characters are specified by RFC 3986. Any
///       character can be percentage encoded.</p>
public struct QueryStringConditionConfig: Equatable {
    /// <p>One or more key/value pairs or values to find in the query string. The maximum size of
    ///       each string is 128 characters. The comparison is case insensitive. The following wildcard
    ///       characters are supported: * (matches 0 or more characters) and ? (matches exactly 1
    ///       character). To search for a literal '*' or '?' character in a query string, you must escape
    ///       these characters in <code>Values</code> using a '\' character.</p>
    ///          <p>If you specify multiple key/value pairs or values, the condition is satisfied if one of
    ///       them is found in the query string.</p>
    public let values: [QueryStringKeyValuePair]?

    public init (
        values: [QueryStringKeyValuePair]? = nil
    )
    {
        self.values = values
    }
}

extension QueryStringKeyValuePair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension QueryStringKeyValuePair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryStringKeyValuePair(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a key/value pair.</p>
public struct QueryStringKeyValuePair: Equatable {
    /// <p>The key. You can omit the key.</p>
    public let key: String?
    /// <p>The value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension RedirectActionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case host = "Host"
        case path = "Path"
        case port = "Port"
        case `protocol` = "Protocol"
        case query = "Query"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let host = host {
            try container.encode(host, forKey: Key("Host"))
        }
        if let path = path {
            try container.encode(path, forKey: Key("Path"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let query = query {
            try container.encode(query, forKey: Key("Query"))
        }
        if let statusCode = statusCode {
            try container.encode(statusCode, forKey: Key("StatusCode"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(String.self, forKey: .port)
        port = portDecoded
        let hostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .host)
        host = hostDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let queryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .query)
        query = queryDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(RedirectActionStatusCodeEnum.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension RedirectActionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedirectActionConfig(host: \(String(describing: host)), path: \(String(describing: path)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), query: \(String(describing: query)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Information about a redirect action.</p>
///          <p>A URI consists of the following components: protocol://hostname:port/path?query. You must
///       modify at least one of the following components to avoid a redirect loop: protocol, hostname,
///       port, or path. Any components that you do not modify retain their original values.</p>
///          <p>You can reuse URI components using the following reserved keywords:</p>
///          <ul>
///             <li>
///                <p>#{protocol}</p>
///             </li>
///             <li>
///                <p>#{host}</p>
///             </li>
///             <li>
///                <p>#{port}</p>
///             </li>
///             <li>
///                <p>#{path} (the leading "/" is removed)</p>
///             </li>
///             <li>
///                <p>#{query}</p>
///             </li>
///          </ul>
///          <p>For example, you can change the path to "/new/#{path}", the hostname to "example.#{host}",
///       or the query to "#{query}&value=xyz".</p>
public struct RedirectActionConfig: Equatable {
    /// <p>The protocol. You can specify HTTP, HTTPS, or #{protocol}. You can redirect HTTP to HTTP,
    ///       HTTP to HTTPS, and HTTPS to HTTPS. You cannot redirect HTTPS to HTTP.</p>
    public let `protocol`: String?
    /// <p>The hostname. This component is not percent-encoded. The hostname can contain
    ///       #{host}.</p>
    public let host: String?
    /// <p>The absolute path, starting with the leading "/". This component is not percent-encoded.
    ///       The path can contain #{host}, #{path}, and #{port}.</p>
    public let path: String?
    /// <p>The port. You can specify a value from 1 to 65535 or #{port}.</p>
    public let port: String?
    /// <p>The query parameters, URL-encoded when necessary, but not percent-encoded. Do not include
    ///       the leading "?", as it is automatically added. You can specify any of the reserved
    ///       keywords.</p>
    public let query: String?
    /// <p>The HTTP redirect code. The redirect is either permanent (HTTP 301) or temporary (HTTP
    ///       302).</p>
    public let statusCode: RedirectActionStatusCodeEnum?

    public init (
        `protocol`: String? = nil,
        host: String? = nil,
        path: String? = nil,
        port: String? = nil,
        query: String? = nil,
        statusCode: RedirectActionStatusCodeEnum? = nil
    )
    {
        self.`protocol` = `protocol`
        self.host = host
        self.path = path
        self.port = port
        self.query = query
        self.statusCode = statusCode
    }
}

public enum RedirectActionStatusCodeEnum {
    case http301
    case http302
    case sdkUnknown(String)
}

extension RedirectActionStatusCodeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RedirectActionStatusCodeEnum] {
        return [
            .http301,
            .http302,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http301: return "HTTP_301"
        case .http302: return "HTTP_302"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RedirectActionStatusCodeEnum(rawValue: rawValue) ?? RedirectActionStatusCodeEnum.sdkUnknown(rawValue)
    }
}

public struct RegisterTargetsInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetsOutputError>
}

extension RegisterTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTargetsInput(targetGroupArn: \(String(describing: targetGroupArn)), targets: \(String(describing: targets)))"}
}

extension RegisterTargetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let targets = targets {
            var targetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Targets"))
            for (index0, targetdescription0) in targets.enumerated() {
                try targetsContainer.encode(targetdescription0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RegisterTargets", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct RegisterTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetsOutputError>
}

public struct RegisterTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTargetsInput>
    public typealias MOutput = OperationOutput<RegisterTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTargetsOutputError>
}

public struct RegisterTargetsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The targets.</p>
    public let targets: [TargetDescription]?

    public init (
        targetGroupArn: String? = nil,
        targets: [TargetDescription]? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.targets = targets
    }
}

extension RegisterTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RegisterTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTargetException" : self = .invalidTargetException(try InvalidTargetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRegistrationsForTargetIdException" : self = .tooManyRegistrationsForTargetIdException(try TooManyRegistrationsForTargetIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTargetsException" : self = .tooManyTargetsException(try TooManyTargetsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTargetsOutputError: Swift.Error, Equatable {
    case invalidTargetException(InvalidTargetException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyRegistrationsForTargetIdException(TooManyRegistrationsForTargetIdException)
    case tooManyTargetsException(TooManyTargetsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTargetsOutputResponse()"}
}

extension RegisterTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterTargetsOutputResponse: Equatable {

    public init() {}
}

struct RegisterTargetsOutputResponseBody: Equatable {
}

extension RegisterTargetsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveListenerCertificatesInputBodyMiddleware: Middleware {
    public let id: String = "RemoveListenerCertificatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveListenerCertificatesOutputError>
}

extension RemoveListenerCertificatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveListenerCertificatesInput(certificates: \(String(describing: certificates)), listenerArn: \(String(describing: listenerArn)))"}
}

extension RemoveListenerCertificatesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let certificates = certificates {
            var certificatesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Certificates"))
            for (index0, certificate0) in certificates.enumerated() {
                try certificatesContainer.encode(certificate0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let listenerArn = listenerArn {
            try container.encode(listenerArn, forKey: Key("ListenerArn"))
        }
        try container.encode("RemoveListenerCertificates", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct RemoveListenerCertificatesInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveListenerCertificatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveListenerCertificatesOutputError>
}

public struct RemoveListenerCertificatesInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveListenerCertificatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveListenerCertificatesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveListenerCertificatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveListenerCertificatesInput>
    public typealias MOutput = OperationOutput<RemoveListenerCertificatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveListenerCertificatesOutputError>
}

public struct RemoveListenerCertificatesInput: Equatable {
    /// <p>The certificate to remove. You can specify one certificate per call. Set
    ///         <code>CertificateArn</code> to the certificate ARN but do not set
    ///       <code>IsDefault</code>.</p>
    public let certificates: [Certificate]?
    /// <p>The Amazon Resource Name (ARN) of the listener.</p>
    public let listenerArn: String?

    public init (
        certificates: [Certificate]? = nil,
        listenerArn: String? = nil
    )
    {
        self.certificates = certificates
        self.listenerArn = listenerArn
    }
}

extension RemoveListenerCertificatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveListenerCertificatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveListenerCertificatesOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveListenerCertificatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveListenerCertificatesOutputResponse()"}
}

extension RemoveListenerCertificatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveListenerCertificatesOutputResponse: Equatable {

    public init() {}
}

struct RemoveListenerCertificatesOutputResponseBody: Equatable {
}

extension RemoveListenerCertificatesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveTagsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

extension RemoveTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsInput(resourceArns: \(String(describing: resourceArns)), tagKeys: \(String(describing: tagKeys)))"}
}

extension RemoveTagsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArns = resourceArns {
            var resourceArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("ResourceArns"))
            for (index0, resourcearn0) in resourceArns.enumerated() {
                try resourceArnsContainer.encode(resourcearn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TagKeys"))
            for (index0, tagkey0) in tagKeys.enumerated() {
                try tagKeysContainer.encode(tagkey0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("RemoveTags", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct RemoveTagsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArns: [String]?
    /// <p>The tag keys for the tags to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArns: [String]? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArns = resourceArns
        self.tagKeys = tagKeys
    }
}

extension RemoveTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ListenerNotFoundException" : self = .listenerNotFoundException(try ListenerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TargetGroupNotFoundException" : self = .targetGroupNotFoundException(try TargetGroupNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Swift.Error, Equatable {
    case listenerNotFoundException(ListenerNotFoundException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case ruleNotFoundException(RuleNotFoundException)
    case targetGroupNotFoundException(TargetGroupNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsOutputResponse()"}
}

extension RemoveTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTagsOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsOutputResponseBody: Equatable {
}

extension RemoveTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ResourceInUseExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A specified resource is in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case conditions = "Conditions"
        case isDefault = "IsDefault"
        case priority = "Priority"
        case ruleArn = "RuleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let actions = actions {
            var actionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Actions"))
            for (index0, action0) in actions.enumerated() {
                try actionsContainer.encode(action0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let conditions = conditions {
            var conditionsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Conditions"))
            for (index0, rulecondition0) in conditions.enumerated() {
                try conditionsContainer.encode(rulecondition0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if isDefault != false {
            try container.encode(isDefault, forKey: Key("IsDefault"))
        }
        if let priority = priority {
            try container.encode(priority, forKey: Key("Priority"))
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: Key("RuleArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .priority)
        priority = priorityDecoded
        if containerValues.contains(.conditions) {
            struct KeyVal0{struct member{}}
            let conditionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .conditions)
            if let conditionsWrappedContainer = conditionsWrappedContainer {
                let conditionsContainer = try conditionsWrappedContainer.decodeIfPresent([RuleCondition].self, forKey: .member)
                var conditionsBuffer:[RuleCondition]? = nil
                if let conditionsContainer = conditionsContainer {
                    conditionsBuffer = [RuleCondition]()
                    for structureContainer0 in conditionsContainer {
                        conditionsBuffer?.append(structureContainer0)
                    }
                }
                conditions = conditionsBuffer
            } else {
                conditions = []
            }
        } else {
            conditions = nil
        }
        if containerValues.contains(.actions) {
            struct KeyVal0{struct member{}}
            let actionsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .actions)
            if let actionsWrappedContainer = actionsWrappedContainer {
                let actionsContainer = try actionsWrappedContainer.decodeIfPresent([Action].self, forKey: .member)
                var actionsBuffer:[Action]? = nil
                if let actionsContainer = actionsContainer {
                    actionsBuffer = [Action]()
                    for structureContainer0 in actionsContainer {
                        actionsBuffer?.append(structureContainer0)
                    }
                }
                actions = actionsBuffer
            } else {
                actions = []
            }
        } else {
            actions = nil
        }
        let isDefaultDecoded = try containerValues.decode(Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(actions: \(String(describing: actions)), conditions: \(String(describing: conditions)), isDefault: \(String(describing: isDefault)), priority: \(String(describing: priority)), ruleArn: \(String(describing: ruleArn)))"}
}

/// <p>Information about a rule.</p>
public struct Rule: Equatable {
    /// <p>The actions. Each rule must include exactly one of the following types of actions:
    ///         <code>forward</code>, <code>redirect</code>, or <code>fixed-response</code>, and it must be
    ///       the last action to be performed.</p>
    public let actions: [Action]?
    /// <p>The conditions. Each rule can include zero or one of the following conditions:
    ///         <code>http-request-method</code>, <code>host-header</code>, <code>path-pattern</code>, and
    ///         <code>source-ip</code>, and zero or more of the following conditions:
    ///         <code>http-header</code> and <code>query-string</code>.</p>
    public let conditions: [RuleCondition]?
    /// <p>Indicates whether this is the default rule.</p>
    public let isDefault: Bool
    /// <p>The priority.</p>
    public let priority: String?
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: String?

    public init (
        actions: [Action]? = nil,
        conditions: [RuleCondition]? = nil,
        isDefault: Bool = false,
        priority: String? = nil,
        ruleArn: String? = nil
    )
    {
        self.actions = actions
        self.conditions = conditions
        self.isDefault = isDefault
        self.priority = priority
        self.ruleArn = ruleArn
    }
}

extension RuleCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case field = "Field"
        case hostHeaderConfig = "HostHeaderConfig"
        case httpHeaderConfig = "HttpHeaderConfig"
        case httpRequestMethodConfig = "HttpRequestMethodConfig"
        case pathPatternConfig = "PathPatternConfig"
        case queryStringConfig = "QueryStringConfig"
        case sourceIpConfig = "SourceIpConfig"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let field = field {
            try container.encode(field, forKey: Key("Field"))
        }
        if let hostHeaderConfig = hostHeaderConfig {
            try container.encode(hostHeaderConfig, forKey: Key("HostHeaderConfig"))
        }
        if let httpHeaderConfig = httpHeaderConfig {
            try container.encode(httpHeaderConfig, forKey: Key("HttpHeaderConfig"))
        }
        if let httpRequestMethodConfig = httpRequestMethodConfig {
            try container.encode(httpRequestMethodConfig, forKey: Key("HttpRequestMethodConfig"))
        }
        if let pathPatternConfig = pathPatternConfig {
            try container.encode(pathPatternConfig, forKey: Key("PathPatternConfig"))
        }
        if let queryStringConfig = queryStringConfig {
            try container.encode(queryStringConfig, forKey: Key("QueryStringConfig"))
        }
        if let sourceIpConfig = sourceIpConfig {
            try container.encode(sourceIpConfig, forKey: Key("SourceIpConfig"))
        }
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .field)
        field = fieldDecoded
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
        let hostHeaderConfigDecoded = try containerValues.decodeIfPresent(HostHeaderConditionConfig.self, forKey: .hostHeaderConfig)
        hostHeaderConfig = hostHeaderConfigDecoded
        let pathPatternConfigDecoded = try containerValues.decodeIfPresent(PathPatternConditionConfig.self, forKey: .pathPatternConfig)
        pathPatternConfig = pathPatternConfigDecoded
        let httpHeaderConfigDecoded = try containerValues.decodeIfPresent(HttpHeaderConditionConfig.self, forKey: .httpHeaderConfig)
        httpHeaderConfig = httpHeaderConfigDecoded
        let queryStringConfigDecoded = try containerValues.decodeIfPresent(QueryStringConditionConfig.self, forKey: .queryStringConfig)
        queryStringConfig = queryStringConfigDecoded
        let httpRequestMethodConfigDecoded = try containerValues.decodeIfPresent(HttpRequestMethodConditionConfig.self, forKey: .httpRequestMethodConfig)
        httpRequestMethodConfig = httpRequestMethodConfigDecoded
        let sourceIpConfigDecoded = try containerValues.decodeIfPresent(SourceIpConditionConfig.self, forKey: .sourceIpConfig)
        sourceIpConfig = sourceIpConfigDecoded
    }
}

extension RuleCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleCondition(field: \(String(describing: field)), hostHeaderConfig: \(String(describing: hostHeaderConfig)), httpHeaderConfig: \(String(describing: httpHeaderConfig)), httpRequestMethodConfig: \(String(describing: httpRequestMethodConfig)), pathPatternConfig: \(String(describing: pathPatternConfig)), queryStringConfig: \(String(describing: queryStringConfig)), sourceIpConfig: \(String(describing: sourceIpConfig)), values: \(String(describing: values)))"}
}

/// <p>Information about a condition for a rule.</p>
///          <p>Each rule can optionally include up to one of each of the following conditions:
///         <code>http-request-method</code>, <code>host-header</code>, <code>path-pattern</code>, and
///         <code>source-ip</code>. Each rule can also optionally include one or more of each of the
///       following conditions: <code>http-header</code> and <code>query-string</code>.</p>
public struct RuleCondition: Equatable {
    /// <p>The field in the HTTP request. The following are the possible values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>http-header</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>http-request-method</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>host-header</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>path-pattern</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>query-string</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>source-ip</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let field: String?
    /// <p>Information for a host header condition. Specify only when <code>Field</code> is
    ///         <code>host-header</code>.</p>
    public let hostHeaderConfig: HostHeaderConditionConfig?
    /// <p>Information for an HTTP header condition. Specify only when <code>Field</code> is
    ///         <code>http-header</code>.</p>
    public let httpHeaderConfig: HttpHeaderConditionConfig?
    /// <p>Information for an HTTP method condition. Specify only when <code>Field</code> is
    ///         <code>http-request-method</code>.</p>
    public let httpRequestMethodConfig: HttpRequestMethodConditionConfig?
    /// <p>Information for a path pattern condition. Specify only when <code>Field</code> is
    ///         <code>path-pattern</code>.</p>
    public let pathPatternConfig: PathPatternConditionConfig?
    /// <p>Information for a query string condition. Specify only when <code>Field</code> is
    ///         <code>query-string</code>.</p>
    public let queryStringConfig: QueryStringConditionConfig?
    /// <p>Information for a source IP condition. Specify only when <code>Field</code> is
    ///         <code>source-ip</code>.</p>
    public let sourceIpConfig: SourceIpConditionConfig?
    /// <p>The condition value. Specify only when <code>Field</code> is <code>host-header</code> or
    ///         <code>path-pattern</code>. Alternatively, to specify multiple host names or multiple path
    ///       patterns, use <code>HostHeaderConfig</code> or <code>PathPatternConfig</code>.</p>
    ///          <p>If <code>Field</code> is <code>host-header</code> and you are not using
    ///         <code>HostHeaderConfig</code>, you can specify a single host name (for example,
    ///       my.example.com) in <code>Values</code>. A host name is case insensitive, can be up to 128
    ///       characters in length, and can contain any of the following characters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A-Z, a-z, 0-9</p>
    ///             </li>
    ///             <li>
    ///                <p>- .</p>
    ///             </li>
    ///             <li>
    ///                <p>* (matches 0 or more characters)</p>
    ///             </li>
    ///             <li>
    ///                <p>? (matches exactly 1 character)</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>Field</code> is <code>path-pattern</code> and you are not using
    ///         <code>PathPatternConfig</code>, you can specify a single path pattern (for example, /img/*)
    ///       in <code>Values</code>. A path pattern is case-sensitive, can be up to 128 characters in
    ///       length, and can contain any of the following characters.</p>
    ///          <ul>
    ///             <li>
    ///                <p>A-Z, a-z, 0-9</p>
    ///             </li>
    ///             <li>
    ///                <p>_ - . $ / ~ " ' @ : +</p>
    ///             </li>
    ///             <li>
    ///                <p>& (using &amp;)</p>
    ///             </li>
    ///             <li>
    ///                <p>* (matches 0 or more characters)</p>
    ///             </li>
    ///             <li>
    ///                <p>? (matches exactly 1 character)</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        field: String? = nil,
        hostHeaderConfig: HostHeaderConditionConfig? = nil,
        httpHeaderConfig: HttpHeaderConditionConfig? = nil,
        httpRequestMethodConfig: HttpRequestMethodConditionConfig? = nil,
        pathPatternConfig: PathPatternConditionConfig? = nil,
        queryStringConfig: QueryStringConditionConfig? = nil,
        sourceIpConfig: SourceIpConditionConfig? = nil,
        values: [String]? = nil
    )
    {
        self.field = field
        self.hostHeaderConfig = hostHeaderConfig
        self.httpHeaderConfig = httpHeaderConfig
        self.httpRequestMethodConfig = httpRequestMethodConfig
        self.pathPatternConfig = pathPatternConfig
        self.queryStringConfig = queryStringConfig
        self.sourceIpConfig = sourceIpConfig
        self.values = values
    }
}

extension RuleNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleNotFoundException(message: \(String(describing: message)))"}
}

extension RuleNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RuleNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified rule does not exist.</p>
public struct RuleNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RuleNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension RuleNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RulePriorityPair: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority = "Priority"
        case ruleArn = "RuleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let priority = priority {
            try container.encode(priority, forKey: Key("Priority"))
        }
        if let ruleArn = ruleArn {
            try container.encode(ruleArn, forKey: Key("RuleArn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension RulePriorityPair: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RulePriorityPair(priority: \(String(describing: priority)), ruleArn: \(String(describing: ruleArn)))"}
}

/// <p>Information about the priorities for the rules for a listener.</p>
public struct RulePriorityPair: Equatable {
    /// <p>The rule priority.</p>
    public let priority: Int?
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: String?

    public init (
        priority: Int? = nil,
        ruleArn: String? = nil
    )
    {
        self.priority = priority
        self.ruleArn = ruleArn
    }
}

extension SSLPolicyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSLPolicyNotFoundException(message: \(String(describing: message)))"}
}

extension SSLPolicyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SSLPolicyNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified SSL policy does not exist.</p>
public struct SSLPolicyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SSLPolicyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension SSLPolicyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SetIpAddressTypeInputBodyMiddleware: Middleware {
    public let id: String = "SetIpAddressTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIpAddressTypeOutputError>
}

extension SetIpAddressTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIpAddressTypeInput(ipAddressType: \(String(describing: ipAddressType)), loadBalancerArn: \(String(describing: loadBalancerArn)))"}
}

extension SetIpAddressTypeInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        try container.encode("SetIpAddressType", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct SetIpAddressTypeInputHeadersMiddleware: Middleware {
    public let id: String = "SetIpAddressTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIpAddressTypeOutputError>
}

public struct SetIpAddressTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIpAddressTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIpAddressTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIpAddressTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIpAddressTypeInput>
    public typealias MOutput = OperationOutput<SetIpAddressTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIpAddressTypeOutputError>
}

public struct SetIpAddressTypeInput: Equatable {
    /// <p>The IP address type. The possible values are <code>ipv4</code> (for IPv4 addresses) and
    ///         <code>dualstack</code> (for IPv4 and IPv6 addresses). Internal load balancers must use
    ///         <code>ipv4</code>. You cant specify <code>dualstack</code> for a load balancer with a UDP
    ///       or TCP_UDP listener.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?

    public init (
        ipAddressType: IpAddressType? = nil,
        loadBalancerArn: String? = nil
    )
    {
        self.ipAddressType = ipAddressType
        self.loadBalancerArn = loadBalancerArn
    }
}

extension SetIpAddressTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetIpAddressTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIpAddressTypeOutputError: Swift.Error, Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIpAddressTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIpAddressTypeOutputResponse(ipAddressType: \(String(describing: ipAddressType)))"}
}

extension SetIpAddressTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetIpAddressTypeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ipAddressType = output.ipAddressType
        } else {
            self.ipAddressType = nil
        }
    }
}

public struct SetIpAddressTypeOutputResponse: Equatable {
    /// <p>The IP address type.</p>
    public let ipAddressType: IpAddressType?

    public init (
        ipAddressType: IpAddressType? = nil
    )
    {
        self.ipAddressType = ipAddressType
    }
}

struct SetIpAddressTypeOutputResponseBody: Equatable {
    public let ipAddressType: IpAddressType?
}

extension SetIpAddressTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ipAddressType = "IpAddressType"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SetIpAddressTypeResult"))
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
    }
}

public struct SetRulePrioritiesInputBodyMiddleware: Middleware {
    public let id: String = "SetRulePrioritiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRulePrioritiesOutputError>
}

extension SetRulePrioritiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRulePrioritiesInput(rulePriorities: \(String(describing: rulePriorities)))"}
}

extension SetRulePrioritiesInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let rulePriorities = rulePriorities {
            var rulePrioritiesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("RulePriorities"))
            for (index0, ruleprioritypair0) in rulePriorities.enumerated() {
                try rulePrioritiesContainer.encode(ruleprioritypair0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetRulePriorities", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct SetRulePrioritiesInputHeadersMiddleware: Middleware {
    public let id: String = "SetRulePrioritiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRulePrioritiesOutputError>
}

public struct SetRulePrioritiesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetRulePrioritiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetRulePrioritiesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetRulePrioritiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetRulePrioritiesInput>
    public typealias MOutput = OperationOutput<SetRulePrioritiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetRulePrioritiesOutputError>
}

public struct SetRulePrioritiesInput: Equatable {
    /// <p>The rule priorities.</p>
    public let rulePriorities: [RulePriorityPair]?

    public init (
        rulePriorities: [RulePriorityPair]? = nil
    )
    {
        self.rulePriorities = rulePriorities
    }
}

extension SetRulePrioritiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetRulePrioritiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PriorityInUseException" : self = .priorityInUseException(try PriorityInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RuleNotFoundException" : self = .ruleNotFoundException(try RuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetRulePrioritiesOutputError: Swift.Error, Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case priorityInUseException(PriorityInUseException)
    case ruleNotFoundException(RuleNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetRulePrioritiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetRulePrioritiesOutputResponse(rules: \(String(describing: rules)))"}
}

extension SetRulePrioritiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetRulePrioritiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct SetRulePrioritiesOutputResponse: Equatable {
    /// <p>Information about the rules.</p>
    public let rules: [Rule]?

    public init (
        rules: [Rule]? = nil
    )
    {
        self.rules = rules
    }
}

struct SetRulePrioritiesOutputResponseBody: Equatable {
    public let rules: [Rule]?
}

extension SetRulePrioritiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SetRulePrioritiesResult"))
        if containerValues.contains(.rules) {
            struct KeyVal0{struct member{}}
            let rulesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .rules)
            if let rulesWrappedContainer = rulesWrappedContainer {
                let rulesContainer = try rulesWrappedContainer.decodeIfPresent([Rule].self, forKey: .member)
                var rulesBuffer:[Rule]? = nil
                if let rulesContainer = rulesContainer {
                    rulesBuffer = [Rule]()
                    for structureContainer0 in rulesContainer {
                        rulesBuffer?.append(structureContainer0)
                    }
                }
                rules = rulesBuffer
            } else {
                rules = []
            }
        } else {
            rules = nil
        }
    }
}

public struct SetSecurityGroupsInputBodyMiddleware: Middleware {
    public let id: String = "SetSecurityGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityGroupsOutputError>
}

extension SetSecurityGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSecurityGroupsInput(loadBalancerArn: \(String(describing: loadBalancerArn)), securityGroups: \(String(describing: securityGroups)))"}
}

extension SetSecurityGroupsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SecurityGroups"))
            for (index0, securitygroupid0) in securityGroups.enumerated() {
                try securityGroupsContainer.encode(securitygroupid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetSecurityGroups", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct SetSecurityGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "SetSecurityGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityGroupsOutputError>
}

public struct SetSecurityGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSecurityGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSecurityGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSecurityGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSecurityGroupsInput>
    public typealias MOutput = OperationOutput<SetSecurityGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSecurityGroupsOutputError>
}

public struct SetSecurityGroupsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The IDs of the security groups.</p>
    public let securityGroups: [String]?

    public init (
        loadBalancerArn: String? = nil,
        securityGroups: [String]? = nil
    )
    {
        self.loadBalancerArn = loadBalancerArn
        self.securityGroups = securityGroups
    }
}

extension SetSecurityGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSecurityGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupException" : self = .invalidSecurityGroupException(try InvalidSecurityGroupException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSecurityGroupsOutputError: Swift.Error, Equatable {
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSecurityGroupException(InvalidSecurityGroupException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSecurityGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSecurityGroupsOutputResponse(securityGroupIds: \(String(describing: securityGroupIds)))"}
}

extension SetSecurityGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetSecurityGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.securityGroupIds = output.securityGroupIds
        } else {
            self.securityGroupIds = nil
        }
    }
}

public struct SetSecurityGroupsOutputResponse: Equatable {
    /// <p>The IDs of the security groups associated with the load balancer.</p>
    public let securityGroupIds: [String]?

    public init (
        securityGroupIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
    }
}

struct SetSecurityGroupsOutputResponseBody: Equatable {
    public let securityGroupIds: [String]?
}

extension SetSecurityGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SetSecurityGroupsResult"))
        if containerValues.contains(.securityGroupIds) {
            struct KeyVal0{struct member{}}
            let securityGroupIdsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .securityGroupIds)
            if let securityGroupIdsWrappedContainer = securityGroupIdsWrappedContainer {
                let securityGroupIdsContainer = try securityGroupIdsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var securityGroupIdsBuffer:[String]? = nil
                if let securityGroupIdsContainer = securityGroupIdsContainer {
                    securityGroupIdsBuffer = [String]()
                    for stringContainer0 in securityGroupIdsContainer {
                        securityGroupIdsBuffer?.append(stringContainer0)
                    }
                }
                securityGroupIds = securityGroupIdsBuffer
            } else {
                securityGroupIds = []
            }
        } else {
            securityGroupIds = nil
        }
    }
}

public struct SetSubnetsInputBodyMiddleware: Middleware {
    public let id: String = "SetSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubnetsOutputError>
}

extension SetSubnetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSubnetsInput(ipAddressType: \(String(describing: ipAddressType)), loadBalancerArn: \(String(describing: loadBalancerArn)), subnetMappings: \(String(describing: subnetMappings)), subnets: \(String(describing: subnets)))"}
}

extension SetSubnetsInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ipAddressType = ipAddressType {
            try container.encode(ipAddressType, forKey: Key("IpAddressType"))
        }
        if let loadBalancerArn = loadBalancerArn {
            try container.encode(loadBalancerArn, forKey: Key("LoadBalancerArn"))
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SubnetMappings"))
            for (index0, subnetmapping0) in subnetMappings.enumerated() {
                try subnetMappingsContainer.encode(subnetmapping0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let subnets = subnets {
            var subnetsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Subnets"))
            for (index0, subnetid0) in subnets.enumerated() {
                try subnetsContainer.encode(subnetid0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("SetSubnets", forKey:Key("Action"))
        try container.encode("2015-12-01", forKey:Key("Version"))
    }
}

public struct SetSubnetsInputHeadersMiddleware: Middleware {
    public let id: String = "SetSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubnetsOutputError>
}

public struct SetSubnetsInputQueryItemMiddleware: Middleware {
    public let id: String = "SetSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<SetSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetSubnetsInput>
    public typealias MOutput = OperationOutput<SetSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetSubnetsOutputError>
}

public struct SetSubnetsInput: Equatable {
    /// <p>[Network Load Balancers] The type of IP addresses used by the subnets for your load
    ///       balancer. The possible values are <code>ipv4</code> (for IPv4 addresses) and
    ///         <code>dualstack</code> (for IPv4 and IPv6 addresses). You cant specify
    ///         <code>dualstack</code> for a load balancer with a UDP or TCP_UDP listener. Internal load
    ///       balancers must use <code>ipv4</code>.</p>
    public let ipAddressType: IpAddressType?
    /// <p>The Amazon Resource Name (ARN) of the load balancer.</p>
    public let loadBalancerArn: String?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones. You cannot specify Elastic IP addresses for your subnets.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability Zones. You
    ///       can specify one Elastic IP address per subnet if you need static IP addresses for your
    ///       internet-facing load balancer. For internal load balancers, you can specify one private IP
    ///       address per subnet from the IPv4 range of the subnet. For internet-facing load balancer, you
    ///       can specify one IPv6 address per subnet.</p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>The IDs of the public subnets. You can specify only one subnet per Availability Zone. You
    ///       must specify either subnets or subnet mappings.</p>
    ///          <p>[Application Load Balancers] You must specify subnets from at least two Availability
    ///       Zones.</p>
    ///          <p>[Application Load Balancers on Outposts] You must specify one Outpost subnet.</p>
    ///          <p>[Application Load Balancers on Local Zones] You can specify subnets from one or more Local
    ///       Zones.</p>
    ///          <p>[Network Load Balancers] You can specify subnets from one or more Availability
    ///       Zones.</p>
    public let subnets: [String]?

    public init (
        ipAddressType: IpAddressType? = nil,
        loadBalancerArn: String? = nil,
        subnetMappings: [SubnetMapping]? = nil,
        subnets: [String]? = nil
    )
    {
        self.ipAddressType = ipAddressType
        self.loadBalancerArn = loadBalancerArn
        self.subnetMappings = subnetMappings
        self.subnets = subnets
    }
}

extension SetSubnetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension SetSubnetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AllocationIdNotFoundException" : self = .allocationIdNotFoundException(try AllocationIdNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AvailabilityZoneNotSupportedException" : self = .availabilityZoneNotSupportedException(try AvailabilityZoneNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationRequestException" : self = .invalidConfigurationRequestException(try InvalidConfigurationRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetException" : self = .invalidSubnetException(try InvalidSubnetException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoadBalancerNotFoundException" : self = .loadBalancerNotFoundException(try LoadBalancerNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetNotFoundException" : self = .subnetNotFoundException(try SubnetNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetSubnetsOutputError: Swift.Error, Equatable {
    case allocationIdNotFoundException(AllocationIdNotFoundException)
    case availabilityZoneNotSupportedException(AvailabilityZoneNotSupportedException)
    case invalidConfigurationRequestException(InvalidConfigurationRequestException)
    case invalidSubnetException(InvalidSubnetException)
    case loadBalancerNotFoundException(LoadBalancerNotFoundException)
    case subnetNotFoundException(SubnetNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetSubnetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetSubnetsOutputResponse(availabilityZones: \(String(describing: availabilityZones)), ipAddressType: \(String(describing: ipAddressType)))"}
}

extension SetSubnetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.availabilityZones = output.availabilityZones
            self.ipAddressType = output.ipAddressType
        } else {
            self.availabilityZones = nil
            self.ipAddressType = nil
        }
    }
}

public struct SetSubnetsOutputResponse: Equatable {
    /// <p>Information about the subnets.</p>
    public let availabilityZones: [AvailabilityZone]?
    /// <p>[Network Load Balancers] The IP address type.</p>
    public let ipAddressType: IpAddressType?

    public init (
        availabilityZones: [AvailabilityZone]? = nil,
        ipAddressType: IpAddressType? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.ipAddressType = ipAddressType
    }
}

struct SetSubnetsOutputResponseBody: Equatable {
    public let availabilityZones: [AvailabilityZone]?
    public let ipAddressType: IpAddressType?
}

extension SetSubnetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case ipAddressType = "IpAddressType"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("SetSubnetsResult"))
        if containerValues.contains(.availabilityZones) {
            struct KeyVal0{struct member{}}
            let availabilityZonesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .availabilityZones)
            if let availabilityZonesWrappedContainer = availabilityZonesWrappedContainer {
                let availabilityZonesContainer = try availabilityZonesWrappedContainer.decodeIfPresent([AvailabilityZone].self, forKey: .member)
                var availabilityZonesBuffer:[AvailabilityZone]? = nil
                if let availabilityZonesContainer = availabilityZonesContainer {
                    availabilityZonesBuffer = [AvailabilityZone]()
                    for structureContainer0 in availabilityZonesContainer {
                        availabilityZonesBuffer?.append(structureContainer0)
                    }
                }
                availabilityZones = availabilityZonesBuffer
            } else {
                availabilityZones = []
            }
        } else {
            availabilityZones = nil
        }
        let ipAddressTypeDecoded = try containerValues.decodeIfPresent(IpAddressType.self, forKey: .ipAddressType)
        ipAddressType = ipAddressTypeDecoded
    }
}

extension SourceIpConditionConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let values = values {
            var valuesContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Values"))
            for (index0, stringvalue0) in values.enumerated() {
                try valuesContainer.encode(stringvalue0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.values) {
            struct KeyVal0{struct member{}}
            let valuesWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .values)
            if let valuesWrappedContainer = valuesWrappedContainer {
                let valuesContainer = try valuesWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var valuesBuffer:[String]? = nil
                if let valuesContainer = valuesContainer {
                    valuesBuffer = [String]()
                    for stringContainer0 in valuesContainer {
                        valuesBuffer?.append(stringContainer0)
                    }
                }
                values = valuesBuffer
            } else {
                values = []
            }
        } else {
            values = nil
        }
    }
}

extension SourceIpConditionConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceIpConditionConfig(values: \(String(describing: values)))"}
}

/// <p>Information about a source IP condition.</p>
///          <p>You can use this condition to route based on the IP address of the source that connects to
///       the load balancer. If a client is behind a proxy, this is the IP address of the proxy not the
///       IP address of the client.</p>
public struct SourceIpConditionConfig: Equatable {
    /// <p>One or more source IP addresses, in CIDR format. You can use both IPv4 and IPv6 addresses.
    ///       Wildcards are not supported.</p>
    ///          <p>If you specify multiple addresses, the condition is satisfied if the source IP address of
    ///       the request matches one of the CIDR blocks. This condition is not satisfied by the addresses
    ///       in the X-Forwarded-For header. To search for addresses in the X-Forwarded-For header, use
    ///         <a>HttpHeaderConditionConfig</a>.</p>
    public let values: [String]?

    public init (
        values: [String]? = nil
    )
    {
        self.values = values
    }
}

extension SslPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ciphers = "Ciphers"
        case name = "Name"
        case sslProtocols = "SslProtocols"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let ciphers = ciphers {
            var ciphersContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Ciphers"))
            for (index0, cipher0) in ciphers.enumerated() {
                try ciphersContainer.encode(cipher0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let sslProtocols = sslProtocols {
            var sslProtocolsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("SslProtocols"))
            for (index0, sslprotocol0) in sslProtocols.enumerated() {
                try sslProtocolsContainer.encode(sslprotocol0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        if containerValues.contains(.sslProtocols) {
            struct KeyVal0{struct member{}}
            let sslProtocolsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .sslProtocols)
            if let sslProtocolsWrappedContainer = sslProtocolsWrappedContainer {
                let sslProtocolsContainer = try sslProtocolsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var sslProtocolsBuffer:[String]? = nil
                if let sslProtocolsContainer = sslProtocolsContainer {
                    sslProtocolsBuffer = [String]()
                    for stringContainer0 in sslProtocolsContainer {
                        sslProtocolsBuffer?.append(stringContainer0)
                    }
                }
                sslProtocols = sslProtocolsBuffer
            } else {
                sslProtocols = []
            }
        } else {
            sslProtocols = nil
        }
        if containerValues.contains(.ciphers) {
            struct KeyVal0{struct member{}}
            let ciphersWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .ciphers)
            if let ciphersWrappedContainer = ciphersWrappedContainer {
                let ciphersContainer = try ciphersWrappedContainer.decodeIfPresent([Cipher].self, forKey: .member)
                var ciphersBuffer:[Cipher]? = nil
                if let ciphersContainer = ciphersContainer {
                    ciphersBuffer = [Cipher]()
                    for structureContainer0 in ciphersContainer {
                        ciphersBuffer?.append(structureContainer0)
                    }
                }
                ciphers = ciphersBuffer
            } else {
                ciphers = []
            }
        } else {
            ciphers = nil
        }
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension SslPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SslPolicy(ciphers: \(String(describing: ciphers)), name: \(String(describing: name)), sslProtocols: \(String(describing: sslProtocols)))"}
}

/// <p>Information about a policy used for SSL negotiation.</p>
public struct SslPolicy: Equatable {
    /// <p>The ciphers.</p>
    public let ciphers: [Cipher]?
    /// <p>The name of the policy.</p>
    public let name: String?
    /// <p>The protocols.</p>
    public let sslProtocols: [String]?

    public init (
        ciphers: [Cipher]? = nil,
        name: String? = nil,
        sslProtocols: [String]? = nil
    )
    {
        self.ciphers = ciphers
        self.name = name
        self.sslProtocols = sslProtocols
    }
}

extension SubnetMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocationId = "AllocationId"
        case iPv6Address = "IPv6Address"
        case privateIPv4Address = "PrivateIPv4Address"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let allocationId = allocationId {
            try container.encode(allocationId, forKey: Key("AllocationId"))
        }
        if let iPv6Address = iPv6Address {
            try container.encode(iPv6Address, forKey: Key("IPv6Address"))
        }
        if let privateIPv4Address = privateIPv4Address {
            try container.encode(privateIPv4Address, forKey: Key("PrivateIPv4Address"))
        }
        if let subnetId = subnetId {
            try container.encode(subnetId, forKey: Key("SubnetId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let allocationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allocationId)
        allocationId = allocationIdDecoded
        let privateIPv4AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIPv4Address)
        privateIPv4Address = privateIPv4AddressDecoded
        let iPv6AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iPv6Address)
        iPv6Address = iPv6AddressDecoded
    }
}

extension SubnetMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetMapping(allocationId: \(String(describing: allocationId)), iPv6Address: \(String(describing: iPv6Address)), privateIPv4Address: \(String(describing: privateIPv4Address)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>Information about a subnet mapping.</p>
public struct SubnetMapping: Equatable {
    /// <p>[Network Load Balancers] The allocation ID of the Elastic IP address for an
    ///       internet-facing load balancer.</p>
    public let allocationId: String?
    /// <p>[Network Load Balancers] The IPv6 address.</p>
    public let iPv6Address: String?
    /// <p>[Network Load Balancers] The private IPv4 address for an internal load balancer.</p>
    public let privateIPv4Address: String?
    /// <p>The ID of the subnet.</p>
    public let subnetId: String?

    public init (
        allocationId: String? = nil,
        iPv6Address: String? = nil,
        privateIPv4Address: String? = nil,
        subnetId: String? = nil
    )
    {
        self.allocationId = allocationId
        self.iPv6Address = iPv6Address
        self.privateIPv4Address = privateIPv4Address
        self.subnetId = subnetId
    }
}

extension SubnetNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetNotFoundException(message: \(String(describing: message)))"}
}

extension SubnetNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<SubnetNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet does not exist.</p>
public struct SubnetNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension SubnetNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a tag.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let resourceArn = resourceArn {
            try container.encode(resourceArn, forKey: Key("ResourceArn"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        if containerValues.contains(.tags) {
            struct KeyVal0{struct member{}}
            let tagsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .tags)
            if let tagsWrappedContainer = tagsWrappedContainer {
                let tagsContainer = try tagsWrappedContainer.decodeIfPresent([Tag].self, forKey: .member)
                var tagsBuffer:[Tag]? = nil
                if let tagsContainer = tagsContainer {
                    tagsBuffer = [Tag]()
                    for structureContainer0 in tagsContainer {
                        tagsBuffer?.append(structureContainer0)
                    }
                }
                tags = tagsBuffer
            } else {
                tags = []
            }
        } else {
            tags = nil
        }
    }
}

extension TagDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagDescription(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

/// <p>The tags associated with a resource.</p>
public struct TagDescription: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>Information about the tags.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TargetDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case id = "Id"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let availabilityZone = availabilityZone {
            try container.encode(availabilityZone, forKey: Key("AvailabilityZone"))
        }
        if let id = id {
            try container.encode(id, forKey: Key("Id"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
    }
}

extension TargetDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetDescription(availabilityZone: \(String(describing: availabilityZone)), id: \(String(describing: id)), port: \(String(describing: port)))"}
}

/// <p>Information about a target.</p>
public struct TargetDescription: Equatable {
    /// <p>An Availability Zone or <code>all</code>. This determines whether the target receives
    ///       traffic from the load balancer nodes in the specified Availability Zone or from all enabled
    ///       Availability Zones for the load balancer.</p>
    ///          <p>This parameter is not supported if the target type of the target group is
    ///         <code>instance</code>.</p>
    ///          <p>If the target type is <code>ip</code> and the IP address is in a subnet of the VPC for the
    ///       target group, the Availability Zone is automatically detected and this parameter is optional.
    ///       If the IP address is outside the VPC, this parameter is required.</p>
    ///          <p>With an Application Load Balancer, if the target type is <code>ip</code> and the IP
    ///       address is outside the VPC for the target group, the only supported value is
    ///       <code>all</code>.</p>
    ///          <p>If the target type is <code>lambda</code>, this parameter is optional and the only
    ///       supported value is <code>all</code>.</p>
    public let availabilityZone: String?
    /// <p>The ID of the target. If the target type of the target group is <code>instance</code>,
    ///       specify an instance ID. If the target type is <code>ip</code>, specify an IP address. If the
    ///       target type is <code>lambda</code>, specify the ARN of the Lambda function.</p>
    public let id: String?
    /// <p>The port on which the target is listening. If the target group protocol is GENEVE, the
    ///       supported port is 6081. Not used if the target is a Lambda function.</p>
    public let port: Int?

    public init (
        availabilityZone: String? = nil,
        id: String? = nil,
        port: Int? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.id = id
        self.port = port
    }
}

extension TargetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthCheckEnabled = "HealthCheckEnabled"
        case healthCheckIntervalSeconds = "HealthCheckIntervalSeconds"
        case healthCheckPath = "HealthCheckPath"
        case healthCheckPort = "HealthCheckPort"
        case healthCheckProtocol = "HealthCheckProtocol"
        case healthCheckTimeoutSeconds = "HealthCheckTimeoutSeconds"
        case healthyThresholdCount = "HealthyThresholdCount"
        case loadBalancerArns = "LoadBalancerArns"
        case matcher = "Matcher"
        case port = "Port"
        case `protocol` = "Protocol"
        case protocolVersion = "ProtocolVersion"
        case targetGroupArn = "TargetGroupArn"
        case targetGroupName = "TargetGroupName"
        case targetType = "TargetType"
        case unhealthyThresholdCount = "UnhealthyThresholdCount"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let healthCheckEnabled = healthCheckEnabled {
            try container.encode(healthCheckEnabled, forKey: Key("HealthCheckEnabled"))
        }
        if let healthCheckIntervalSeconds = healthCheckIntervalSeconds {
            try container.encode(healthCheckIntervalSeconds, forKey: Key("HealthCheckIntervalSeconds"))
        }
        if let healthCheckPath = healthCheckPath {
            try container.encode(healthCheckPath, forKey: Key("HealthCheckPath"))
        }
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: Key("HealthCheckPort"))
        }
        if let healthCheckProtocol = healthCheckProtocol {
            try container.encode(healthCheckProtocol, forKey: Key("HealthCheckProtocol"))
        }
        if let healthCheckTimeoutSeconds = healthCheckTimeoutSeconds {
            try container.encode(healthCheckTimeoutSeconds, forKey: Key("HealthCheckTimeoutSeconds"))
        }
        if let healthyThresholdCount = healthyThresholdCount {
            try container.encode(healthyThresholdCount, forKey: Key("HealthyThresholdCount"))
        }
        if let loadBalancerArns = loadBalancerArns {
            var loadBalancerArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("LoadBalancerArns"))
            for (index0, loadbalancerarn0) in loadBalancerArns.enumerated() {
                try loadBalancerArnsContainer.encode(loadbalancerarn0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let matcher = matcher {
            try container.encode(matcher, forKey: Key("Matcher"))
        }
        if let port = port {
            try container.encode(port, forKey: Key("Port"))
        }
        if let `protocol` = `protocol` {
            try container.encode(`protocol`, forKey: Key("Protocol"))
        }
        if let protocolVersion = protocolVersion {
            try container.encode(protocolVersion, forKey: Key("ProtocolVersion"))
        }
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let targetGroupName = targetGroupName {
            try container.encode(targetGroupName, forKey: Key("TargetGroupName"))
        }
        if let targetType = targetType {
            try container.encode(targetType, forKey: Key("TargetType"))
        }
        if let unhealthyThresholdCount = unhealthyThresholdCount {
            try container.encode(unhealthyThresholdCount, forKey: Key("UnhealthyThresholdCount"))
        }
        if let vpcId = vpcId {
            try container.encode(vpcId, forKey: Key("VpcId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let targetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupName)
        targetGroupName = targetGroupNameDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(ProtocolEnum.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .port)
        port = portDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let healthCheckProtocolDecoded = try containerValues.decodeIfPresent(ProtocolEnum.self, forKey: .healthCheckProtocol)
        healthCheckProtocol = healthCheckProtocolDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let healthCheckEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .healthCheckEnabled)
        healthCheckEnabled = healthCheckEnabledDecoded
        let healthCheckIntervalSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckIntervalSeconds)
        healthCheckIntervalSeconds = healthCheckIntervalSecondsDecoded
        let healthCheckTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthCheckTimeoutSeconds)
        healthCheckTimeoutSeconds = healthCheckTimeoutSecondsDecoded
        let healthyThresholdCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .healthyThresholdCount)
        healthyThresholdCount = healthyThresholdCountDecoded
        let unhealthyThresholdCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unhealthyThresholdCount)
        unhealthyThresholdCount = unhealthyThresholdCountDecoded
        let healthCheckPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPath)
        healthCheckPath = healthCheckPathDecoded
        let matcherDecoded = try containerValues.decodeIfPresent(Matcher.self, forKey: .matcher)
        matcher = matcherDecoded
        if containerValues.contains(.loadBalancerArns) {
            struct KeyVal0{struct member{}}
            let loadBalancerArnsWrappedContainer = containerValues.nestedContainerNonThrowable(keyedBy: CollectionMemberCodingKey<KeyVal0.member>.CodingKeys.self, forKey: .loadBalancerArns)
            if let loadBalancerArnsWrappedContainer = loadBalancerArnsWrappedContainer {
                let loadBalancerArnsContainer = try loadBalancerArnsWrappedContainer.decodeIfPresent([String].self, forKey: .member)
                var loadBalancerArnsBuffer:[String]? = nil
                if let loadBalancerArnsContainer = loadBalancerArnsContainer {
                    loadBalancerArnsBuffer = [String]()
                    for stringContainer0 in loadBalancerArnsContainer {
                        loadBalancerArnsBuffer?.append(stringContainer0)
                    }
                }
                loadBalancerArns = loadBalancerArnsBuffer
            } else {
                loadBalancerArns = []
            }
        } else {
            loadBalancerArns = nil
        }
        let targetTypeDecoded = try containerValues.decodeIfPresent(TargetTypeEnum.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let protocolVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .protocolVersion)
        protocolVersion = protocolVersionDecoded
    }
}

extension TargetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroup(healthCheckEnabled: \(String(describing: healthCheckEnabled)), healthCheckIntervalSeconds: \(String(describing: healthCheckIntervalSeconds)), healthCheckPath: \(String(describing: healthCheckPath)), healthCheckPort: \(String(describing: healthCheckPort)), healthCheckProtocol: \(String(describing: healthCheckProtocol)), healthCheckTimeoutSeconds: \(String(describing: healthCheckTimeoutSeconds)), healthyThresholdCount: \(String(describing: healthyThresholdCount)), loadBalancerArns: \(String(describing: loadBalancerArns)), matcher: \(String(describing: matcher)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), protocolVersion: \(String(describing: protocolVersion)), targetGroupArn: \(String(describing: targetGroupArn)), targetGroupName: \(String(describing: targetGroupName)), targetType: \(String(describing: targetType)), unhealthyThresholdCount: \(String(describing: unhealthyThresholdCount)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Information about a target group.</p>
public struct TargetGroup: Equatable {
    /// <p>The protocol to use for routing traffic to the targets.</p>
    public let `protocol`: ProtocolEnum?
    /// <p>Indicates whether health checks are enabled.</p>
    public let healthCheckEnabled: Bool?
    /// <p>The approximate amount of time, in seconds, between health checks of an individual
    ///       target.</p>
    public let healthCheckIntervalSeconds: Int?
    /// <p>The destination for health checks on the targets.</p>
    public let healthCheckPath: String?
    /// <p>The port to use to connect with the target.</p>
    public let healthCheckPort: String?
    /// <p>The protocol to use to connect with the target. The GENEVE, TLS, UDP, and TCP_UDP
    ///       protocols are not supported for health checks.</p>
    public let healthCheckProtocol: ProtocolEnum?
    /// <p>The amount of time, in seconds, during which no response means a failed health
    ///       check.</p>
    public let healthCheckTimeoutSeconds: Int?
    /// <p>The number of consecutive health checks successes required before considering an unhealthy
    ///       target healthy.</p>
    public let healthyThresholdCount: Int?
    /// <p>The Amazon Resource Names (ARN) of the load balancers that route traffic to this target
    ///       group.</p>
    public let loadBalancerArns: [String]?
    /// <p>The HTTP or gRPC codes to use when checking for a successful response from a
    ///       target.</p>
    public let matcher: Matcher?
    /// <p>The port on which the targets are listening. Not used if the target is a Lambda
    ///       function.</p>
    public let port: Int?
    /// <p>[HTTP/HTTPS protocol] The protocol version. The possible values are <code>GRPC</code>,
    ///         <code>HTTP1</code>, and <code>HTTP2</code>.</p>
    public let protocolVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The name of the target group.</p>
    public let targetGroupName: String?
    /// <p>The type of target that you must specify when registering targets with this target group.
    ///       The possible values are <code>instance</code> (register targets by instance ID),
    ///         <code>ip</code> (register targets by IP address), or <code>lambda</code> (register a single
    ///       Lambda function as a target).</p>
    public let targetType: TargetTypeEnum?
    /// <p>The number of consecutive health check failures required before considering the target
    ///       unhealthy.</p>
    public let unhealthyThresholdCount: Int?
    /// <p>The ID of the VPC for the targets.</p>
    public let vpcId: String?

    public init (
        `protocol`: ProtocolEnum? = nil,
        healthCheckEnabled: Bool? = nil,
        healthCheckIntervalSeconds: Int? = nil,
        healthCheckPath: String? = nil,
        healthCheckPort: String? = nil,
        healthCheckProtocol: ProtocolEnum? = nil,
        healthCheckTimeoutSeconds: Int? = nil,
        healthyThresholdCount: Int? = nil,
        loadBalancerArns: [String]? = nil,
        matcher: Matcher? = nil,
        port: Int? = nil,
        protocolVersion: String? = nil,
        targetGroupArn: String? = nil,
        targetGroupName: String? = nil,
        targetType: TargetTypeEnum? = nil,
        unhealthyThresholdCount: Int? = nil,
        vpcId: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.healthCheckEnabled = healthCheckEnabled
        self.healthCheckIntervalSeconds = healthCheckIntervalSeconds
        self.healthCheckPath = healthCheckPath
        self.healthCheckPort = healthCheckPort
        self.healthCheckProtocol = healthCheckProtocol
        self.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds
        self.healthyThresholdCount = healthyThresholdCount
        self.loadBalancerArns = loadBalancerArns
        self.matcher = matcher
        self.port = port
        self.protocolVersion = protocolVersion
        self.targetGroupArn = targetGroupArn
        self.targetGroupName = targetGroupName
        self.targetType = targetType
        self.unhealthyThresholdCount = unhealthyThresholdCount
        self.vpcId = vpcId
    }
}

extension TargetGroupAssociationLimitException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroupAssociationLimitException(message: \(String(describing: message)))"}
}

extension TargetGroupAssociationLimitException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TargetGroupAssociationLimitExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of load balancers per target group.</p>
public struct TargetGroupAssociationLimitException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetGroupAssociationLimitExceptionBody: Equatable {
    public let message: String?
}

extension TargetGroupAssociationLimitExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetGroupAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TargetGroupAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroupAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Information about a target group attribute.</p>
public struct TargetGroupAttribute: Equatable {
    /// <p>The name of the attribute.</p>
    ///
    ///          <p>The following attribute is supported by all load balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deregistration_delay.timeout_seconds</code> - The amount of time, in seconds,
    ///           for Elastic Load Balancing to wait before changing the state of a deregistering target
    ///           from <code>draining</code> to <code>unused</code>. The range is 0-3600 seconds. The
    ///           default value is 300 seconds. If the target is a Lambda function, this attribute is not
    ///           supported.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attributes are supported by both Application Load Balancers and Network Load
    ///       Balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>stickiness.enabled</code> - Indicates whether sticky sessions are enabled. The
    ///           value is <code>true</code> or <code>false</code>. The default is
    ///           <code>false</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stickiness.type</code> - The type of sticky sessions. The possible values are
    ///             <code>lb_cookie</code> and <code>app_cookie</code> for Application Load Balancers or
    ///             <code>source_ip</code> for Network Load Balancers.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attributes are supported only if the load balancer is an Application Load
    ///       Balancer and the target is an instance or an IP address:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>load_balancing.algorithm.type</code> - The load balancing algorithm determines
    ///           how the load balancer selects targets when routing requests. The value is
    ///             <code>round_robin</code> or <code>least_outstanding_requests</code>. The default is
    ///             <code>round_robin</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>slow_start.duration_seconds</code> - The time period, in seconds, during which a
    ///           newly registered target receives an increasing share of the traffic to the target group.
    ///           After this time period ends, the target receives its full share of traffic. The range is
    ///           30-900 seconds (15 minutes). The default is 0 seconds (disabled).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stickiness.app_cookie.cookie_name</code> - Indicates the name of the
    ///           application-based cookie. Names that start with the following names are not allowed:
    ///             <code>AWSALB</code>, <code>AWSALBAPP</code>, and <code>AWSALBTG</code>. They're reserved
    ///           for use by the load balancer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stickiness.app_cookie.duration_seconds</code> - The time period, in seconds,
    ///           during which requests from a client should be routed to the same target. After this time
    ///           period expires, the application-based cookie is considered stale. The range is 1 second to
    ///           1 week (604800 seconds). The default value is 1 day (86400 seconds).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>stickiness.lb_cookie.duration_seconds</code> - The time period, in seconds,
    ///           during which requests from a client should be routed to the same target. After this time
    ///           period expires, the load balancer-generated cookie is considered stale. The range is 1
    ///           second to 1 week (604800 seconds). The default value is 1 day (86400 seconds).</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attribute is supported only if the load balancer is an Application Load
    ///       Balancer and the target is a Lambda function:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>lambda.multi_value_headers.enabled</code> - Indicates whether the request and
    ///           response headers that are exchanged between the load balancer and the Lambda function
    ///           include arrays of values or strings. The value is <code>true</code> or <code>false</code>.
    ///           The default is <code>false</code>. If the value is <code>false</code> and the request
    ///           contains a duplicate header field name or query parameter key, the load balancer uses the
    ///           last value sent by the client.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>The following attributes are supported only by Network Load Balancers:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>deregistration_delay.connection_termination.enabled</code> - Indicates whether
    ///           the load balancer terminates connections at the end of the deregistration timeout. The
    ///           value is <code>true</code> or <code>false</code>. The default is
    ///           <code>false</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>preserve_client_ip.enabled</code> - Indicates whether client IP preservation is
    ///           enabled. The value is <code>true</code> or <code>false</code>. The default is disabled if
    ///           the target group type is IP address and the target group protocol is TCP or TLS.
    ///           Otherwise, the default is enabled. Client IP preservation cannot be disabled for UDP and
    ///           TCP_UDP target groups.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>proxy_protocol_v2.enabled</code> - Indicates whether Proxy Protocol version 2 is
    ///           enabled. The value is <code>true</code> or <code>false</code>. The default is
    ///             <code>false</code>.</p>
    ///             </li>
    ///          </ul>
    public let key: String?
    /// <p>The value of the attribute.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TargetGroupNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroupNotFoundException(message: \(String(describing: message)))"}
}

extension TargetGroupNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TargetGroupNotFoundExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified target group does not exist.</p>
public struct TargetGroupNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TargetGroupNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension TargetGroupNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TargetGroupStickinessConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationSeconds = "DurationSeconds"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let enabled = enabled {
            try container.encode(enabled, forKey: Key("Enabled"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .durationSeconds)
        durationSeconds = durationSecondsDecoded
    }
}

extension TargetGroupStickinessConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroupStickinessConfig(durationSeconds: \(String(describing: durationSeconds)), enabled: \(String(describing: enabled)))"}
}

/// <p>Information about the target group stickiness for a rule.</p>
public struct TargetGroupStickinessConfig: Equatable {
    /// <p>The time period, in seconds, during which requests from a client should be routed to the
    ///       same target group. The range is 1-604800 seconds (7 days).</p>
    public let durationSeconds: Int?
    /// <p>Indicates whether target group stickiness is enabled.</p>
    public let enabled: Bool?

    public init (
        durationSeconds: Int? = nil,
        enabled: Bool? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.enabled = enabled
    }
}

extension TargetGroupTuple: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetGroupArn = "TargetGroupArn"
        case weight = "Weight"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let targetGroupArn = targetGroupArn {
            try container.encode(targetGroupArn, forKey: Key("TargetGroupArn"))
        }
        if let weight = weight {
            try container.encode(weight, forKey: Key("Weight"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetGroupArn)
        targetGroupArn = targetGroupArnDecoded
        let weightDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension TargetGroupTuple: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetGroupTuple(targetGroupArn: \(String(describing: targetGroupArn)), weight: \(String(describing: weight)))"}
}

/// <p>Information about how traffic will be distributed between multiple target groups in a
///       forward rule.</p>
public struct TargetGroupTuple: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target group.</p>
    public let targetGroupArn: String?
    /// <p>The weight. The range is 0 to 999.</p>
    public let weight: Int?

    public init (
        targetGroupArn: String? = nil,
        weight: Int? = nil
    )
    {
        self.targetGroupArn = targetGroupArn
        self.weight = weight
    }
}

extension TargetHealth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case reason = "Reason"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let description = description {
            try container.encode(description, forKey: Key("Description"))
        }
        if let reason = reason {
            try container.encode(reason, forKey: Key("Reason"))
        }
        if let state = state {
            try container.encode(state, forKey: Key("State"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(TargetHealthStateEnum.self, forKey: .state)
        state = stateDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(TargetHealthReasonEnum.self, forKey: .reason)
        reason = reasonDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension TargetHealth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetHealth(description: \(String(describing: description)), reason: \(String(describing: reason)), state: \(String(describing: state)))"}
}

/// <p>Information about the current health of a target.</p>
public struct TargetHealth: Equatable {
    /// <p>A description of the target health that provides additional details. If the state is
    ///         <code>healthy</code>, a description is not provided.</p>
    public let description: String?
    /// <p>The reason code.</p>
    ///
    ///          <p>If the target state is <code>healthy</code>, a reason code is not provided.</p>
    ///
    ///          <p>If the target state is <code>initial</code>, the reason code can be one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Elb.RegistrationInProgress</code> - The target is in the process of being registered
    ///           with the load balancer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Elb.InitialHealthChecking</code> - The load balancer is still sending the target the
    ///           minimum number of health checks required to determine its health status.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If the target state is <code>unhealthy</code>, the reason code can be one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Target.ResponseCodeMismatch</code> - The health checks did not return an
    ///           expected HTTP code. Applies only to Application Load Balancers and Gateway Load
    ///           Balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Target.Timeout</code> - The health check requests timed out. Applies only to
    ///           Application Load Balancers and Gateway Load Balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Target.FailedHealthChecks</code> - The load balancer received an error while
    ///           establishing a connection to the target or the target response was malformed.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Elb.InternalError</code> - The health checks failed due to an internal error.
    ///           Applies only to Application Load Balancers.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If the target state is <code>unused</code>, the reason code can be one of the following
    ///       values:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Target.NotRegistered</code> - The target is not registered with the target
    ///           group.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Target.NotInUse</code> - The target group is not used by any load balancer or
    ///           the target is in an Availability Zone that is not enabled for its load balancer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Target.InvalidState</code> - The target is in the stopped or terminated
    ///           state.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Target.IpUnusable</code> - The target IP address is reserved for use by a load
    ///           balancer.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If the target state is <code>draining</code>, the reason code can be the following
    ///       value:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Target.DeregistrationInProgress</code> - The target is in the process of being
    ///           deregistered and the deregistration delay period has not expired.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>If the target state is <code>unavailable</code>, the reason code can be the following
    ///       value:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Target.HealthCheckDisabled</code> - Health checks are disabled for the target
    ///           group. Applies only to Application Load Balancers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Elb.InternalError</code> - Target health is unavailable due to an internal
    ///           error. Applies only to Network Load Balancers.</p>
    ///             </li>
    ///          </ul>
    public let reason: TargetHealthReasonEnum?
    /// <p>The state of the target.</p>
    public let state: TargetHealthStateEnum?

    public init (
        description: String? = nil,
        reason: TargetHealthReasonEnum? = nil,
        state: TargetHealthStateEnum? = nil
    )
    {
        self.description = description
        self.reason = reason
        self.state = state
    }
}

extension TargetHealthDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthCheckPort = "HealthCheckPort"
        case target = "Target"
        case targetHealth = "TargetHealth"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let healthCheckPort = healthCheckPort {
            try container.encode(healthCheckPort, forKey: Key("HealthCheckPort"))
        }
        if let target = target {
            try container.encode(target, forKey: Key("Target"))
        }
        if let targetHealth = targetHealth {
            try container.encode(targetHealth, forKey: Key("TargetHealth"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(TargetDescription.self, forKey: .target)
        target = targetDecoded
        let healthCheckPortDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthCheckPort)
        healthCheckPort = healthCheckPortDecoded
        let targetHealthDecoded = try containerValues.decodeIfPresent(TargetHealth.self, forKey: .targetHealth)
        targetHealth = targetHealthDecoded
    }
}

extension TargetHealthDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetHealthDescription(healthCheckPort: \(String(describing: healthCheckPort)), target: \(String(describing: target)), targetHealth: \(String(describing: targetHealth)))"}
}

/// <p>Information about the health of a target.</p>
public struct TargetHealthDescription: Equatable {
    /// <p>The port to use to connect with the target.</p>
    public let healthCheckPort: String?
    /// <p>The description of the target.</p>
    public let target: TargetDescription?
    /// <p>The health information for the target.</p>
    public let targetHealth: TargetHealth?

    public init (
        healthCheckPort: String? = nil,
        target: TargetDescription? = nil,
        targetHealth: TargetHealth? = nil
    )
    {
        self.healthCheckPort = healthCheckPort
        self.target = target
        self.targetHealth = targetHealth
    }
}

public enum TargetHealthReasonEnum {
    case deregistrationInProgress
    case failedHealthChecks
    case healthCheckDisabled
    case initialHealthChecking
    case internalError
    case invalidState
    case ipUnusable
    case notInUse
    case notRegistered
    case registrationInProgress
    case responseCodeMismatch
    case timeout
    case sdkUnknown(String)
}

extension TargetHealthReasonEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetHealthReasonEnum] {
        return [
            .deregistrationInProgress,
            .failedHealthChecks,
            .healthCheckDisabled,
            .initialHealthChecking,
            .internalError,
            .invalidState,
            .ipUnusable,
            .notInUse,
            .notRegistered,
            .registrationInProgress,
            .responseCodeMismatch,
            .timeout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deregistrationInProgress: return "Target.DeregistrationInProgress"
        case .failedHealthChecks: return "Target.FailedHealthChecks"
        case .healthCheckDisabled: return "Target.HealthCheckDisabled"
        case .initialHealthChecking: return "Elb.InitialHealthChecking"
        case .internalError: return "Elb.InternalError"
        case .invalidState: return "Target.InvalidState"
        case .ipUnusable: return "Target.IpUnusable"
        case .notInUse: return "Target.NotInUse"
        case .notRegistered: return "Target.NotRegistered"
        case .registrationInProgress: return "Elb.RegistrationInProgress"
        case .responseCodeMismatch: return "Target.ResponseCodeMismatch"
        case .timeout: return "Target.Timeout"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetHealthReasonEnum(rawValue: rawValue) ?? TargetHealthReasonEnum.sdkUnknown(rawValue)
    }
}

public enum TargetHealthStateEnum {
    case draining
    case healthy
    case initial
    case unavailable
    case unhealthy
    case unused
    case sdkUnknown(String)
}

extension TargetHealthStateEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetHealthStateEnum] {
        return [
            .draining,
            .healthy,
            .initial,
            .unavailable,
            .unhealthy,
            .unused,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .draining: return "draining"
        case .healthy: return "healthy"
        case .initial: return "initial"
        case .unavailable: return "unavailable"
        case .unhealthy: return "unhealthy"
        case .unused: return "unused"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetHealthStateEnum(rawValue: rawValue) ?? TargetHealthStateEnum.sdkUnknown(rawValue)
    }
}

public enum TargetTypeEnum {
    case instance
    case ip
    case lambda
    case sdkUnknown(String)
}

extension TargetTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetTypeEnum] {
        return [
            .instance,
            .ip,
            .lambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instance: return "instance"
        case .ip: return "ip"
        case .lambda: return "lambda"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetTypeEnum(rawValue: rawValue) ?? TargetTypeEnum.sdkUnknown(rawValue)
    }
}

extension TooManyActionsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyActionsException(message: \(String(describing: message)))"}
}

extension TooManyActionsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyActionsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of actions per rule.</p>
public struct TooManyActionsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyActionsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyActionsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyCertificatesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyCertificatesException(message: \(String(describing: message)))"}
}

extension TooManyCertificatesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyCertificatesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of certificates per load balancer.</p>
public struct TooManyCertificatesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyCertificatesExceptionBody: Equatable {
    public let message: String?
}

extension TooManyCertificatesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyListenersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyListenersException(message: \(String(describing: message)))"}
}

extension TooManyListenersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyListenersExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of listeners per load balancer.</p>
public struct TooManyListenersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyListenersExceptionBody: Equatable {
    public let message: String?
}

extension TooManyListenersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyLoadBalancersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyLoadBalancersException(message: \(String(describing: message)))"}
}

extension TooManyLoadBalancersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyLoadBalancersExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of load balancers for your AWS account.</p>
public struct TooManyLoadBalancersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyLoadBalancersExceptionBody: Equatable {
    public let message: String?
}

extension TooManyLoadBalancersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRegistrationsForTargetIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRegistrationsForTargetIdException(message: \(String(describing: message)))"}
}

extension TooManyRegistrationsForTargetIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyRegistrationsForTargetIdExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of times a target can be registered with a load
///       balancer.</p>
public struct TooManyRegistrationsForTargetIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRegistrationsForTargetIdExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRegistrationsForTargetIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyRulesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRulesException(message: \(String(describing: message)))"}
}

extension TooManyRulesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyRulesExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of rules per load balancer.</p>
public struct TooManyRulesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRulesExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRulesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTagsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of tags per load balancer.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTargetGroupsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTargetGroupsException(message: \(String(describing: message)))"}
}

extension TooManyTargetGroupsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTargetGroupsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of target groups for your AWS account.</p>
public struct TooManyTargetGroupsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTargetGroupsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTargetGroupsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTargetsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTargetsException(message: \(String(describing: message)))"}
}

extension TooManyTargetsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyTargetsExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of targets.</p>
public struct TooManyTargetsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTargetsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTargetsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyUniqueTargetGroupsPerLoadBalancerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyUniqueTargetGroupsPerLoadBalancerException(message: \(String(describing: message)))"}
}

extension TooManyUniqueTargetGroupsPerLoadBalancerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You've reached the limit on the number of unique target groups per load balancer across
///       all listeners. If a target group is used by multiple actions for a load balancer, it is
///       counted as only one use.</p>
public struct TooManyUniqueTargetGroupsPerLoadBalancerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody: Equatable {
    public let message: String?
}

extension TooManyUniqueTargetGroupsPerLoadBalancerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedProtocolException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedProtocolException(message: \(String(describing: message)))"}
}

extension UnsupportedProtocolException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<UnsupportedProtocolExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified protocol is not supported.</p>
public struct UnsupportedProtocolException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedProtocolExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedProtocolExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
