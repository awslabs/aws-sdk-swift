// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates the specified AttackId does not exist, or the requester does not have the appropriate permissions to access the AttackId.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessDeniedForDependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedForDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// In order to grant the necessary access to the Shield Response Team (SRT) the user submitting the request must have the iam:PassRole permission. This error indicates the user did not have the appropriate permissions. For more information, see [Granting a User Permissions to Pass a Role to an Amazon Web Services Service](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html).
public struct AccessDeniedForDependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedForDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedForDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ApplicationLayerAutomaticResponseStatus.self, forKey: .status)
        status = statusDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension ShieldClientTypes {
    /// The automatic application layer DDoS mitigation settings for a [Protection]. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
    public struct ApplicationLayerAutomaticResponseConfiguration: Swift.Equatable {
        /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
        /// This member is required.
        public var action: ShieldClientTypes.ResponseAction?
        /// Indicates whether automatic application layer DDoS mitigation is enabled for the protection.
        /// This member is required.
        public var status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus?

        public init (
            action: ShieldClientTypes.ResponseAction? = nil,
            status: ShieldClientTypes.ApplicationLayerAutomaticResponseStatus? = nil
        )
        {
            self.action = action
            self.status = status
        }
    }

}

extension ShieldClientTypes {
    public enum ApplicationLayerAutomaticResponseStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationLayerAutomaticResponseStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationLayerAutomaticResponseStatus(rawValue: rawValue) ?? ApplicationLayerAutomaticResponseStatus.sdkUnknown(rawValue)
        }
    }
}

extension AssociateDRTLogBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

extension AssociateDRTLogBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDRTLogBucketInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init (
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct AssociateDRTLogBucketInputBody: Swift.Equatable {
    let logBucket: Swift.String?
}

extension AssociateDRTLogBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension AssociateDRTLogBucketOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDRTLogBucketOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAssociatedRoleException" : self = .noAssociatedRoleException(try NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDRTLogBucketOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case noAssociatedRoleException(NoAssociatedRoleException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDRTLogBucketOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDRTLogBucketOutputResponse: Swift.Equatable {

}

extension AssociateDRTRoleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateDRTRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDRTRoleInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the role the SRT will use to access your Amazon Web Services account. Prior to making the AssociateDRTRole request, you must attach the [AWSShieldDRTAccessPolicy](https://console.aws.amazon.com/iam/home?#/policies/arn:aws:iam::aws:policy/service-role/AWSShieldDRTAccessPolicy) managed policy to this role. For more information see [Attaching and Detaching IAM Policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_manage-attach-detach.html).
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateDRTRoleInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateDRTRoleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateDRTRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDRTRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDRTRoleOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDRTRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDRTRoleOutputResponse: Swift.Equatable {

}

extension AssociateHealthCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension AssociateHealthCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateHealthCheckInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the health check to associate with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to add the health check association to.
    /// This member is required.
    public var protectionId: Swift.String?

    public init (
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct AssociateHealthCheckInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let healthCheckArn: Swift.String?
}

extension AssociateHealthCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension AssociateHealthCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateHealthCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateHealthCheckOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateHealthCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateHealthCheckOutputResponse: Swift.Equatable {

}

extension AssociateProactiveEngagementDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontactlist0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontactlist0)
            }
        }
    }
}

extension AssociateProactiveEngagementDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateProactiveEngagementDetailsInput: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you for escalations to the SRT and to initiate proactive customer support. To enable proactive engagement, the contact list must include at least one phone number. The contacts that you provide here replace any contacts that were already defined. If you already have contacts defined and want to use them, retrieve the list using DescribeEmergencyContactSettings and then provide it here.
    /// This member is required.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init (
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct AssociateProactiveEngagementDetailsInputBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension AssociateProactiveEngagementDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension AssociateProactiveEngagementDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateProactiveEngagementDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateProactiveEngagementDetailsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateProactiveEngagementDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateProactiveEngagementDetailsOutputResponse: Swift.Equatable {

}

extension ShieldClientTypes.AttackDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackCounters = "AttackCounters"
        case attackId = "AttackId"
        case attackProperties = "AttackProperties"
        case endTime = "EndTime"
        case mitigations = "Mitigations"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
        case subResources = "SubResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackCounters = attackCounters {
            var attackCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackCounters)
            for summarizedcounterlist0 in attackCounters {
                try attackCountersContainer.encode(summarizedcounterlist0)
            }
        }
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackProperties = attackProperties {
            var attackPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackProperties)
            for attackproperties0 in attackProperties {
                try attackPropertiesContainer.encode(attackproperties0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let mitigations = mitigations {
            var mitigationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mitigations)
            for mitigationlist0 in mitigations {
                try mitigationsContainer.encode(mitigationlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let subResources = subResources {
            var subResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subResources)
            for subresourcesummarylist0 in subResources {
                try subResourcesContainer.encode(subresourcesummarylist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let subResourcesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SubResourceSummary?].self, forKey: .subResources)
        var subResourcesDecoded0:[ShieldClientTypes.SubResourceSummary]? = nil
        if let subResourcesContainer = subResourcesContainer {
            subResourcesDecoded0 = [ShieldClientTypes.SubResourceSummary]()
            for structure0 in subResourcesContainer {
                if let structure0 = structure0 {
                    subResourcesDecoded0?.append(structure0)
                }
            }
        }
        subResources = subResourcesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let attackCountersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .attackCounters)
        var attackCountersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let attackCountersContainer = attackCountersContainer {
            attackCountersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in attackCountersContainer {
                if let structure0 = structure0 {
                    attackCountersDecoded0?.append(structure0)
                }
            }
        }
        attackCounters = attackCountersDecoded0
        let attackPropertiesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackProperty?].self, forKey: .attackProperties)
        var attackPropertiesDecoded0:[ShieldClientTypes.AttackProperty]? = nil
        if let attackPropertiesContainer = attackPropertiesContainer {
            attackPropertiesDecoded0 = [ShieldClientTypes.AttackProperty]()
            for structure0 in attackPropertiesContainer {
                if let structure0 = structure0 {
                    attackPropertiesDecoded0?.append(structure0)
                }
            }
        }
        attackProperties = attackPropertiesDecoded0
        let mitigationsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Mitigation?].self, forKey: .mitigations)
        var mitigationsDecoded0:[ShieldClientTypes.Mitigation]? = nil
        if let mitigationsContainer = mitigationsContainer {
            mitigationsDecoded0 = [ShieldClientTypes.Mitigation]()
            for structure0 in mitigationsContainer {
                if let structure0 = structure0 {
                    mitigationsDecoded0?.append(structure0)
                }
            }
        }
        mitigations = mitigationsDecoded0
    }
}

extension ShieldClientTypes {
    /// The details of a DDoS attack.
    public struct AttackDetail: Swift.Equatable {
        /// List of counters that describe the attack for the specified time period.
        public var attackCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The array of objects that provide details of the Shield event. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackProperties: [ShieldClientTypes.AttackProperty]?
        /// The time the attack ended, in Unix time in seconds.
        public var endTime: ClientRuntime.Date?
        /// List of mitigation actions taken for the attack.
        public var mitigations: [ShieldClientTypes.Mitigation]?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The time the attack started, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?
        /// If applicable, additional detail about the resource being attacked, for example, IP address or URL.
        public var subResources: [ShieldClientTypes.SubResourceSummary]?

        public init (
            attackCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            attackId: Swift.String? = nil,
            attackProperties: [ShieldClientTypes.AttackProperty]? = nil,
            endTime: ClientRuntime.Date? = nil,
            mitigations: [ShieldClientTypes.Mitigation]? = nil,
            resourceArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            subResources: [ShieldClientTypes.SubResourceSummary]? = nil
        )
        {
            self.attackCounters = attackCounters
            self.attackId = attackId
            self.attackProperties = attackProperties
            self.endTime = endTime
            self.mitigations = mitigations
            self.resourceArn = resourceArn
            self.startTime = startTime
            self.subResources = subResources
        }
    }

}

extension ShieldClientTypes {
    public enum AttackLayer: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case network
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackLayer] {
            return [
                .application,
                .network,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .network: return "NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttackLayer(rawValue: rawValue) ?? AttackLayer.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.AttackProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackLayer = "AttackLayer"
        case attackPropertyIdentifier = "AttackPropertyIdentifier"
        case topContributors = "TopContributors"
        case total = "Total"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackLayer = attackLayer {
            try encodeContainer.encode(attackLayer.rawValue, forKey: .attackLayer)
        }
        if let attackPropertyIdentifier = attackPropertyIdentifier {
            try encodeContainer.encode(attackPropertyIdentifier.rawValue, forKey: .attackPropertyIdentifier)
        }
        if let topContributors = topContributors {
            var topContributorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topContributors)
            for topcontributors0 in topContributors {
                try topContributorsContainer.encode(topcontributors0)
            }
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackLayerDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackLayer.self, forKey: .attackLayer)
        attackLayer = attackLayerDecoded
        let attackPropertyIdentifierDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackPropertyIdentifier.self, forKey: .attackPropertyIdentifier)
        attackPropertyIdentifier = attackPropertyIdentifierDecoded
        let topContributorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Contributor?].self, forKey: .topContributors)
        var topContributorsDecoded0:[ShieldClientTypes.Contributor]? = nil
        if let topContributorsContainer = topContributorsContainer {
            topContributorsDecoded0 = [ShieldClientTypes.Contributor]()
            for structure0 in topContributorsContainer {
                if let structure0 = structure0 {
                    topContributorsDecoded0?.append(structure0)
                }
            }
        }
        topContributors = topContributorsDecoded0
        let unitDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Unit.self, forKey: .unit)
        unit = unitDecoded
        let totalDecoded = try containerValues.decode(Swift.Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension ShieldClientTypes {
    /// Details of a Shield event. This is provided as part of an [AttackDetail].
    public struct AttackProperty: Swift.Equatable {
        /// The type of Shield event that was observed. NETWORK indicates layer 3 and layer 4 events and APPLICATION indicates layer 7 events. For infrastructure layer events (L3 and L4 events), you can view metrics for top contributors in Amazon CloudWatch metrics. For more information, see [Shield metrics and alarms](https://docs.aws.amazon.com/waf/latest/developerguide/monitoring-cloudwatch.html#set-ddos-alarms) in the WAF Developer Guide.
        public var attackLayer: ShieldClientTypes.AttackLayer?
        /// Defines the Shield event property information that is provided. The WORDPRESS_PINGBACK_REFLECTOR and WORDPRESS_PINGBACK_SOURCE values are valid only for WordPress reflective pingback events.
        public var attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier?
        /// Contributor objects for the top five contributors to a Shield event. A contributor is a source of traffic that Shield Advanced identifies as responsible for some or all of an event.
        public var topContributors: [ShieldClientTypes.Contributor]?
        /// The total contributions made to this Shield event by all contributors.
        public var total: Swift.Int
        /// The unit used for the ContributorValue property.
        public var unit: ShieldClientTypes.Unit?

        public init (
            attackLayer: ShieldClientTypes.AttackLayer? = nil,
            attackPropertyIdentifier: ShieldClientTypes.AttackPropertyIdentifier? = nil,
            topContributors: [ShieldClientTypes.Contributor]? = nil,
            total: Swift.Int = 0,
            unit: ShieldClientTypes.Unit? = nil
        )
        {
            self.attackLayer = attackLayer
            self.attackPropertyIdentifier = attackPropertyIdentifier
            self.topContributors = topContributors
            self.total = total
            self.unit = unit
        }
    }

}

extension ShieldClientTypes {
    public enum AttackPropertyIdentifier: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case destinationUrl
        case referrer
        case sourceAsn
        case sourceCountry
        case sourceIpAddress
        case sourceUserAgent
        case wordpressPingbackReflector
        case wordpressPingbackSource
        case sdkUnknown(Swift.String)

        public static var allCases: [AttackPropertyIdentifier] {
            return [
                .destinationUrl,
                .referrer,
                .sourceAsn,
                .sourceCountry,
                .sourceIpAddress,
                .sourceUserAgent,
                .wordpressPingbackReflector,
                .wordpressPingbackSource,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .destinationUrl: return "DESTINATION_URL"
            case .referrer: return "REFERRER"
            case .sourceAsn: return "SOURCE_ASN"
            case .sourceCountry: return "SOURCE_COUNTRY"
            case .sourceIpAddress: return "SOURCE_IP_ADDRESS"
            case .sourceUserAgent: return "SOURCE_USER_AGENT"
            case .wordpressPingbackReflector: return "WORDPRESS_PINGBACK_REFLECTOR"
            case .wordpressPingbackSource: return "WORDPRESS_PINGBACK_SOURCE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AttackPropertyIdentifier(rawValue: rawValue) ?? AttackPropertyIdentifier.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.AttackStatisticsDataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackCount = "AttackCount"
        case attackVolume = "AttackVolume"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attackCount != 0 {
            try encodeContainer.encode(attackCount, forKey: .attackCount)
        }
        if let attackVolume = attackVolume {
            try encodeContainer.encode(attackVolume, forKey: .attackVolume)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackVolumeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolume.self, forKey: .attackVolume)
        attackVolume = attackVolumeDecoded
        let attackCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .attackCount)
        attackCount = attackCountDecoded
    }
}

extension ShieldClientTypes {
    /// A single attack statistics data record. This is returned by [DescribeAttackStatistics] along with a time range indicating the time period that the attack statistics apply to.
    public struct AttackStatisticsDataItem: Swift.Equatable {
        /// The number of attacks detected during the time period. This is always present, but might be zero.
        /// This member is required.
        public var attackCount: Swift.Int
        /// Information about the volume of attacks during the time period. If the accompanying AttackCount is zero, this setting might be empty.
        public var attackVolume: ShieldClientTypes.AttackVolume?

        public init (
            attackCount: Swift.Int = 0,
            attackVolume: ShieldClientTypes.AttackVolume? = nil
        )
        {
            self.attackCount = attackCount
            self.attackVolume = attackVolume
        }
    }

}

extension ShieldClientTypes.AttackSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
        case attackVectors = "AttackVectors"
        case endTime = "EndTime"
        case resourceArn = "ResourceArn"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for attackvectordescriptionlist0 in attackVectors {
                try attackVectorsContainer.encode(attackvectordescriptionlist0)
            }
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackVectorDescription?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[ShieldClientTypes.AttackVectorDescription]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [ShieldClientTypes.AttackVectorDescription]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
    }
}

extension ShieldClientTypes {
    /// Summarizes all DDoS attacks for a specified time period.
    public struct AttackSummary: Swift.Equatable {
        /// The unique identifier (ID) of the attack.
        public var attackId: Swift.String?
        /// The list of attacks for a specified time period.
        public var attackVectors: [ShieldClientTypes.AttackVectorDescription]?
        /// The end time of the attack, in Unix time in seconds.
        public var endTime: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) of the resource that was attacked.
        public var resourceArn: Swift.String?
        /// The start time of the attack, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?

        public init (
            attackId: Swift.String? = nil,
            attackVectors: [ShieldClientTypes.AttackVectorDescription]? = nil,
            endTime: ClientRuntime.Date? = nil,
            resourceArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.attackId = attackId
            self.attackVectors = attackVectors
            self.endTime = endTime
            self.resourceArn = resourceArn
            self.startTime = startTime
        }
    }

}

extension ShieldClientTypes.AttackVectorDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorType = vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
    }
}

extension ShieldClientTypes {
    /// Describes the attack.
    public struct AttackVectorDescription: Swift.Equatable {
        /// The attack type. Valid values:
        ///
        /// * UDP_TRAFFIC
        ///
        /// * UDP_FRAGMENT
        ///
        /// * GENERIC_UDP_REFLECTION
        ///
        /// * DNS_REFLECTION
        ///
        /// * NTP_REFLECTION
        ///
        /// * CHARGEN_REFLECTION
        ///
        /// * SSDP_REFLECTION
        ///
        /// * PORT_MAPPER
        ///
        /// * RIP_REFLECTION
        ///
        /// * SNMP_REFLECTION
        ///
        /// * MSSQL_REFLECTION
        ///
        /// * NET_BIOS_REFLECTION
        ///
        /// * SYN_FLOOD
        ///
        /// * ACK_FLOOD
        ///
        /// * REQUEST_FLOOD
        ///
        /// * HTTP_REFLECTION
        ///
        /// * UDS_REFLECTION
        ///
        /// * MEMCACHED_REFLECTION
        /// This member is required.
        public var vectorType: Swift.String?

        public init (
            vectorType: Swift.String? = nil
        )
        {
            self.vectorType = vectorType
        }
    }

}

extension ShieldClientTypes.AttackVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bitsPerSecond = "BitsPerSecond"
        case packetsPerSecond = "PacketsPerSecond"
        case requestsPerSecond = "RequestsPerSecond"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bitsPerSecond = bitsPerSecond {
            try encodeContainer.encode(bitsPerSecond, forKey: .bitsPerSecond)
        }
        if let packetsPerSecond = packetsPerSecond {
            try encodeContainer.encode(packetsPerSecond, forKey: .packetsPerSecond)
        }
        if let requestsPerSecond = requestsPerSecond {
            try encodeContainer.encode(requestsPerSecond, forKey: .requestsPerSecond)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bitsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .bitsPerSecond)
        bitsPerSecond = bitsPerSecondDecoded
        let packetsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .packetsPerSecond)
        packetsPerSecond = packetsPerSecondDecoded
        let requestsPerSecondDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackVolumeStatistics.self, forKey: .requestsPerSecond)
        requestsPerSecond = requestsPerSecondDecoded
    }
}

extension ShieldClientTypes {
    /// Information about the volume of attacks during the time period, included in an [AttackStatisticsDataItem]. If the accompanying AttackCount in the statistics object is zero, this setting might be empty.
    public struct AttackVolume: Swift.Equatable {
        /// A statistics object that uses bits per second as the unit. This is included for network level attacks.
        public var bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses packets per second as the unit. This is included for network level attacks.
        public var packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics?
        /// A statistics object that uses requests per second as the unit. This is included for application level attacks, and is only available for accounts that are subscribed to Shield Advanced.
        public var requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics?

        public init (
            bitsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            packetsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil,
            requestsPerSecond: ShieldClientTypes.AttackVolumeStatistics? = nil
        )
        {
            self.bitsPerSecond = bitsPerSecond
            self.packetsPerSecond = packetsPerSecond
            self.requestsPerSecond = requestsPerSecond
        }
    }

}

extension ShieldClientTypes.AttackVolumeStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxDecoded = try containerValues.decode(Swift.Double.self, forKey: .max)
        max = maxDecoded
    }
}

extension ShieldClientTypes {
    /// Statistics objects for the various data types in [AttackVolume].
    public struct AttackVolumeStatistics: Swift.Equatable {
        /// The maximum attack volume observed for the given unit.
        /// This member is required.
        public var max: Swift.Double

        public init (
            max: Swift.Double = 0.0
        )
        {
            self.max = max
        }
    }

}

extension ShieldClientTypes {
    public enum AutoRenew: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRenew] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoRenew(rawValue: rawValue) ?? AutoRenew.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.BlockAction: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ShieldClientTypes {
    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. This is only used in the context of the ResponseAction setting. JSON specification: "Block": {}
    public struct BlockAction: Swift.Equatable {

    }

}

extension ShieldClientTypes.Contributor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if value != 0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decode(Swift.Int.self, forKey: .value)
        value = valueDecoded
    }
}

extension ShieldClientTypes {
    /// A contributor to the attack and their contribution.
    public struct Contributor: Swift.Equatable {
        /// The name of the contributor. The type of name that you'll find here depends on the AttackPropertyIdentifier setting in the AttackProperty where this contributor is defined. For example, if the AttackPropertyIdentifier is SOURCE_COUNTRY, the Name could be United States.
        public var name: Swift.String?
        /// The contribution of this contributor expressed in [Protection] units. For example 10,000.
        public var value: Swift.Int

        public init (
            name: Swift.String? = nil,
            value: Swift.Int = 0
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ShieldClientTypes.CountAction: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ShieldClientTypes {
    /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. This is only used in the context of the ResponseAction setting. JSON specification: "Count": {}
    public struct CountAction: Swift.Equatable {

    }

}

extension CreateProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProtectionGroupInput: Swift.Equatable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. Newly protected resources of this type are automatically added to the group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?
    /// One or more tag key-value pairs for the protection group.
    public var tags: [ShieldClientTypes.Tag]?

    public init (
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
        self.tags = tags
    }
}

struct CreateProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    let pattern: ShieldClientTypes.ProtectionGroupPattern?
    let resourceType: ShieldClientTypes.ProtectedResourceType?
    let members: [Swift.String]?
    let tags: [ShieldClientTypes.Tag]?
}

extension CreateProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProtectionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProtectionGroupOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProtectionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateProtectionGroupOutputResponse: Swift.Equatable {

}

extension CreateProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProtectionInput: Swift.Equatable {
    /// Friendly name for the Protection you are creating.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN (Amazon Resource Name) of the resource to be protected. The ARN should be in one of the following formats:
    ///
    /// * For an Application Load Balancer: arn:aws:elasticloadbalancing:region:account-id:loadbalancer/app/load-balancer-name/load-balancer-id
    ///
    /// * For an Elastic Load Balancer (Classic Load Balancer): arn:aws:elasticloadbalancing:region:account-id:loadbalancer/load-balancer-name
    ///
    /// * For an Amazon CloudFront distribution: arn:aws:cloudfront::account-id:distribution/distribution-id
    ///
    /// * For an Global Accelerator accelerator: arn:aws:globalaccelerator::account-id:accelerator/accelerator-id
    ///
    /// * For Amazon Route 53: arn:aws:route53:::hostedzone/hosted-zone-id
    ///
    /// * For an Elastic IP address: arn:aws:ec2:region:account-id:eip-allocation/allocation-id
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tag key-value pairs for the [Protection] object that is created.
    public var tags: [ShieldClientTypes.Tag]?

    public init (
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.name = name
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct CreateProtectionInputBody: Swift.Equatable {
    let name: Swift.String?
    let resourceArn: Swift.String?
    let tags: [ShieldClientTypes.Tag]?
}

extension CreateProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProtectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProtectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProtectionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProtectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProtectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protectionId = output.protectionId
        } else {
            self.protectionId = nil
        }
    }
}

public struct CreateProtectionOutputResponse: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object that is created.
    public var protectionId: Swift.String?

    public init (
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct CreateProtectionOutputResponseBody: Swift.Equatable {
    let protectionId: Swift.String?
}

extension CreateProtectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

extension CreateSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension CreateSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSubscriptionInput: Swift.Equatable {

}

struct CreateSubscriptionInputBody: Swift.Equatable {
}

extension CreateSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSubscriptionOutputResponse: Swift.Equatable {

}

extension DeleteProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension DeleteProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtectionGroupInput: Swift.Equatable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init (
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DeleteProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
}

extension DeleteProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DeleteProtectionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtectionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtectionGroupOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtectionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtectionGroupOutputResponse: Swift.Equatable {

}

extension DeleteProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension DeleteProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProtectionInput: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object to be deleted.
    /// This member is required.
    public var protectionId: Swift.String?

    public init (
        protectionId: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
    }
}

struct DeleteProtectionInputBody: Swift.Equatable {
    let protectionId: Swift.String?
}

extension DeleteProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
    }
}

extension DeleteProtectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProtectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProtectionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProtectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProtectionOutputResponse: Swift.Equatable {

}

extension DeleteSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionInput: Swift.Equatable {

}

struct DeleteSubscriptionInputBody: Swift.Equatable {
}

extension DeleteSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockedSubscriptionException" : self = .lockedSubscriptionException(try LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case lockedSubscriptionException(LockedSubscriptionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated)
public struct DeleteSubscriptionOutputResponse: Swift.Equatable {

}

extension DescribeAttackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackId = attackId {
            try encodeContainer.encode(attackId, forKey: .attackId)
        }
    }
}

extension DescribeAttackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAttackInput: Swift.Equatable {
    /// The unique identifier (ID) for the attack.
    /// This member is required.
    public var attackId: Swift.String?

    public init (
        attackId: Swift.String? = nil
    )
    {
        self.attackId = attackId
    }
}

struct DescribeAttackInputBody: Swift.Equatable {
    let attackId: Swift.String?
}

extension DescribeAttackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackId = "AttackId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attackId)
        attackId = attackIdDecoded
    }
}

extension DescribeAttackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttackOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attack = output.attack
        } else {
            self.attack = nil
        }
    }
}

public struct DescribeAttackOutputResponse: Swift.Equatable {
    /// The attack that is described.
    public var attack: ShieldClientTypes.AttackDetail?

    public init (
        attack: ShieldClientTypes.AttackDetail? = nil
    )
    {
        self.attack = attack
    }
}

struct DescribeAttackOutputResponseBody: Swift.Equatable {
    let attack: ShieldClientTypes.AttackDetail?
}

extension DescribeAttackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attack = "Attack"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AttackDetail.self, forKey: .attack)
        attack = attackDecoded
    }
}

extension DescribeAttackStatisticsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeAttackStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAttackStatisticsInput: Swift.Equatable {

}

struct DescribeAttackStatisticsInputBody: Swift.Equatable {
}

extension DescribeAttackStatisticsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAttackStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAttackStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAttackStatisticsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAttackStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAttackStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataItems = output.dataItems
            self.timeRange = output.timeRange
        } else {
            self.dataItems = nil
            self.timeRange = nil
        }
    }
}

public struct DescribeAttackStatisticsOutputResponse: Swift.Equatable {
    /// The data that describes the attacks detected during the time period.
    /// This member is required.
    public var dataItems: [ShieldClientTypes.AttackStatisticsDataItem]?
    /// The time range.
    /// This member is required.
    public var timeRange: ShieldClientTypes.TimeRange?

    public init (
        dataItems: [ShieldClientTypes.AttackStatisticsDataItem]? = nil,
        timeRange: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.dataItems = dataItems
        self.timeRange = timeRange
    }
}

struct DescribeAttackStatisticsOutputResponseBody: Swift.Equatable {
    let timeRange: ShieldClientTypes.TimeRange?
    let dataItems: [ShieldClientTypes.AttackStatisticsDataItem]?
}

extension DescribeAttackStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataItems = "DataItems"
        case timeRange = "TimeRange"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeRangeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .timeRange)
        timeRange = timeRangeDecoded
        let dataItemsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackStatisticsDataItem?].self, forKey: .dataItems)
        var dataItemsDecoded0:[ShieldClientTypes.AttackStatisticsDataItem]? = nil
        if let dataItemsContainer = dataItemsContainer {
            dataItemsDecoded0 = [ShieldClientTypes.AttackStatisticsDataItem]()
            for structure0 in dataItemsContainer {
                if let structure0 = structure0 {
                    dataItemsDecoded0?.append(structure0)
                }
            }
        }
        dataItems = dataItemsDecoded0
    }
}

extension DescribeDRTAccessInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeDRTAccessInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDRTAccessInput: Swift.Equatable {

}

struct DescribeDRTAccessInputBody: Swift.Equatable {
}

extension DescribeDRTAccessInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDRTAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDRTAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDRTAccessOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDRTAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDRTAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logBucketList = output.logBucketList
            self.roleArn = output.roleArn
        } else {
            self.logBucketList = nil
            self.roleArn = nil
        }
    }
}

public struct DescribeDRTAccessOutputResponse: Swift.Equatable {
    /// The list of Amazon S3 buckets accessed by the SRT.
    public var logBucketList: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the role the SRT used to access your Amazon Web Services account.
    public var roleArn: Swift.String?

    public init (
        logBucketList: [Swift.String]? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.logBucketList = logBucketList
        self.roleArn = roleArn
    }
}

struct DescribeDRTAccessOutputResponseBody: Swift.Equatable {
    let roleArn: Swift.String?
    let logBucketList: [Swift.String]?
}

extension DescribeDRTAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucketList = "LogBucketList"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let logBucketListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .logBucketList)
        var logBucketListDecoded0:[Swift.String]? = nil
        if let logBucketListContainer = logBucketListContainer {
            logBucketListDecoded0 = [Swift.String]()
            for string0 in logBucketListContainer {
                if let string0 = string0 {
                    logBucketListDecoded0?.append(string0)
                }
            }
        }
        logBucketList = logBucketListDecoded0
    }
}

extension DescribeEmergencyContactSettingsInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeEmergencyContactSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEmergencyContactSettingsInput: Swift.Equatable {

}

struct DescribeEmergencyContactSettingsInputBody: Swift.Equatable {
}

extension DescribeEmergencyContactSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeEmergencyContactSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEmergencyContactSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEmergencyContactSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEmergencyContactSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEmergencyContactSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.emergencyContactList = output.emergencyContactList
        } else {
            self.emergencyContactList = nil
        }
    }
}

public struct DescribeEmergencyContactSettingsOutputResponse: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init (
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct DescribeEmergencyContactSettingsOutputResponseBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension DescribeEmergencyContactSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension DescribeProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension DescribeProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProtectionGroupInput: Swift.Equatable {
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init (
        protectionGroupId: Swift.String? = nil
    )
    {
        self.protectionGroupId = protectionGroupId
    }
}

struct DescribeProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
}

extension DescribeProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
    }
}

extension DescribeProtectionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectionGroupOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProtectionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protectionGroup = output.protectionGroup
        } else {
            self.protectionGroup = nil
        }
    }
}

public struct DescribeProtectionGroupOutputResponse: Swift.Equatable {
    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    /// This member is required.
    public var protectionGroup: ShieldClientTypes.ProtectionGroup?

    public init (
        protectionGroup: ShieldClientTypes.ProtectionGroup? = nil
    )
    {
        self.protectionGroup = protectionGroup
    }
}

struct DescribeProtectionGroupOutputResponseBody: Swift.Equatable {
    let protectionGroup: ShieldClientTypes.ProtectionGroup?
}

extension DescribeProtectionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroup = "ProtectionGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroup.self, forKey: .protectionGroup)
        protectionGroup = protectionGroupDecoded
    }
}

extension DescribeProtectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DescribeProtectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeProtectionInput: Swift.Equatable {
    /// The unique identifier (ID) for the [Protection] object that is described. When submitting the DescribeProtection request you must provide either the ResourceArn or the ProtectionID, but not both.
    public var protectionId: Swift.String?
    /// The ARN (Amazon Resource Name) of the Amazon Web Services resource for the [Protection] object that is described. When submitting the DescribeProtection request you must provide either the ResourceArn or the ProtectionID, but not both.
    public var resourceArn: Swift.String?

    public init (
        protectionId: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.protectionId = protectionId
        self.resourceArn = resourceArn
    }
}

struct DescribeProtectionInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let resourceArn: Swift.String?
}

extension DescribeProtectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionId = "ProtectionId"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeProtectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProtectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProtectionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProtectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProtectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.protection = output.protection
        } else {
            self.protection = nil
        }
    }
}

public struct DescribeProtectionOutputResponse: Swift.Equatable {
    /// The [Protection] object that is described.
    public var protection: ShieldClientTypes.Protection?

    public init (
        protection: ShieldClientTypes.Protection? = nil
    )
    {
        self.protection = protection
    }
}

struct DescribeProtectionOutputResponseBody: Swift.Equatable {
    let protection: ShieldClientTypes.Protection?
}

extension DescribeProtectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protection = "Protection"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Protection.self, forKey: .protection)
        protection = protectionDecoded
    }
}

extension DescribeSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSubscriptionInput: Swift.Equatable {

}

struct DescribeSubscriptionInputBody: Swift.Equatable {
}

extension DescribeSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscription = output.subscription
        } else {
            self.subscription = nil
        }
    }
}

public struct DescribeSubscriptionOutputResponse: Swift.Equatable {
    /// The Shield Advanced subscription details for an account.
    public var subscription: ShieldClientTypes.Subscription?

    public init (
        subscription: ShieldClientTypes.Subscription? = nil
    )
    {
        self.subscription = subscription
    }
}

struct DescribeSubscriptionOutputResponseBody: Swift.Equatable {
    let subscription: ShieldClientTypes.Subscription?
}

extension DescribeSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscription = "Subscription"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.Subscription.self, forKey: .subscription)
        subscription = subscriptionDecoded
    }
}

extension DisableApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension DisableApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// The ARN (Amazon Resource Name) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DisableApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension DisableApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DisableApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableApplicationLayerAutomaticResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableApplicationLayerAutomaticResponseOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableApplicationLayerAutomaticResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableApplicationLayerAutomaticResponseOutputResponse: Swift.Equatable {

}

extension DisableProactiveEngagementInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisableProactiveEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableProactiveEngagementInput: Swift.Equatable {

}

struct DisableProactiveEngagementInputBody: Swift.Equatable {
}

extension DisableProactiveEngagementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableProactiveEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableProactiveEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableProactiveEngagementOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableProactiveEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableProactiveEngagementOutputResponse: Swift.Equatable {

}

extension DisassociateDRTLogBucketInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logBucket = logBucket {
            try encodeContainer.encode(logBucket, forKey: .logBucket)
        }
    }
}

extension DisassociateDRTLogBucketInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDRTLogBucketInput: Swift.Equatable {
    /// The Amazon S3 bucket that contains the logs that you want to share.
    /// This member is required.
    public var logBucket: Swift.String?

    public init (
        logBucket: Swift.String? = nil
    )
    {
        self.logBucket = logBucket
    }
}

struct DisassociateDRTLogBucketInputBody: Swift.Equatable {
    let logBucket: Swift.String?
}

extension DisassociateDRTLogBucketInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case logBucket = "LogBucket"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logBucket)
        logBucket = logBucketDecoded
    }
}

extension DisassociateDRTLogBucketOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDRTLogBucketOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedForDependencyException" : self = .accessDeniedForDependencyException(try AccessDeniedForDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoAssociatedRoleException" : self = .noAssociatedRoleException(try NoAssociatedRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDRTLogBucketOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedForDependencyException(AccessDeniedForDependencyException)
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case noAssociatedRoleException(NoAssociatedRoleException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDRTLogBucketOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDRTLogBucketOutputResponse: Swift.Equatable {

}

extension DisassociateDRTRoleInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisassociateDRTRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDRTRoleInput: Swift.Equatable {

}

struct DisassociateDRTRoleInputBody: Swift.Equatable {
}

extension DisassociateDRTRoleInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateDRTRoleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDRTRoleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDRTRoleOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDRTRoleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDRTRoleOutputResponse: Swift.Equatable {

}

extension DisassociateHealthCheckInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthCheckArn = healthCheckArn {
            try encodeContainer.encode(healthCheckArn, forKey: .healthCheckArn)
        }
        if let protectionId = protectionId {
            try encodeContainer.encode(protectionId, forKey: .protectionId)
        }
    }
}

extension DisassociateHealthCheckInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateHealthCheckInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the health check that is associated with the protection.
    /// This member is required.
    public var healthCheckArn: Swift.String?
    /// The unique identifier (ID) for the [Protection] object to remove the health check association from.
    /// This member is required.
    public var protectionId: Swift.String?

    public init (
        healthCheckArn: Swift.String? = nil,
        protectionId: Swift.String? = nil
    )
    {
        self.healthCheckArn = healthCheckArn
        self.protectionId = protectionId
    }
}

struct DisassociateHealthCheckInputBody: Swift.Equatable {
    let protectionId: Swift.String?
    let healthCheckArn: Swift.String?
}

extension DisassociateHealthCheckInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthCheckArn = "HealthCheckArn"
        case protectionId = "ProtectionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionId)
        protectionId = protectionIdDecoded
        let healthCheckArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthCheckArn)
        healthCheckArn = healthCheckArnDecoded
    }
}

extension DisassociateHealthCheckOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateHealthCheckOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateHealthCheckOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateHealthCheckOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateHealthCheckOutputResponse: Swift.Equatable {

}

extension ShieldClientTypes.EmergencyContact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactNotes = "ContactNotes"
        case emailAddress = "EmailAddress"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactNotes = contactNotes {
            try encodeContainer.encode(contactNotes, forKey: .contactNotes)
        }
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let contactNotesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactNotes)
        contactNotes = contactNotesDecoded
    }
}

extension ShieldClientTypes {
    /// Contact information that the SRT can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support.
    public struct EmergencyContact: Swift.Equatable {
        /// Additional notes regarding the contact.
        public var contactNotes: Swift.String?
        /// The email address for the contact.
        /// This member is required.
        public var emailAddress: Swift.String?
        /// The phone number for the contact.
        public var phoneNumber: Swift.String?

        public init (
            contactNotes: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.contactNotes = contactNotes
            self.emailAddress = emailAddress
            self.phoneNumber = phoneNumber
        }
    }

}

extension EnableApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension EnableApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

struct EnableApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let action: ShieldClientTypes.ResponseAction?
}

extension EnableApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension EnableApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableApplicationLayerAutomaticResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitsExceededException" : self = .limitsExceededException(try LimitsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableApplicationLayerAutomaticResponseOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case limitsExceededException(LimitsExceededException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableApplicationLayerAutomaticResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableApplicationLayerAutomaticResponseOutputResponse: Swift.Equatable {

}

extension EnableProactiveEngagementInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EnableProactiveEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableProactiveEngagementInput: Swift.Equatable {

}

struct EnableProactiveEngagementInputBody: Swift.Equatable {
}

extension EnableProactiveEngagementInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableProactiveEngagementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableProactiveEngagementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableProactiveEngagementOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableProactiveEngagementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableProactiveEngagementOutputResponse: Swift.Equatable {

}

extension GetSubscriptionStateInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetSubscriptionStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSubscriptionStateInput: Swift.Equatable {

}

struct GetSubscriptionStateInputBody: Swift.Equatable {
}

extension GetSubscriptionStateInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSubscriptionStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSubscriptionStateOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSubscriptionStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSubscriptionStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.subscriptionState = output.subscriptionState
        } else {
            self.subscriptionState = nil
        }
    }
}

public struct GetSubscriptionStateOutputResponse: Swift.Equatable {
    /// The status of the subscription.
    /// This member is required.
    public var subscriptionState: ShieldClientTypes.SubscriptionState?

    public init (
        subscriptionState: ShieldClientTypes.SubscriptionState? = nil
    )
    {
        self.subscriptionState = subscriptionState
    }
}

struct GetSubscriptionStateOutputResponseBody: Swift.Equatable {
    let subscriptionState: ShieldClientTypes.SubscriptionState?
}

extension GetSubscriptionStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptionState = "SubscriptionState"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionStateDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubscriptionState.self, forKey: .subscriptionState)
        subscriptionState = subscriptionStateDecoded
    }
}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that a problem occurred with the service infrastructure. You can retry the request.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the operation would not cause any change to occur.
public struct InvalidOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPaginationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the NextToken specified in the request is invalid. Submit the request using the NextToken value that was returned in the prior response.
public struct InvalidPaginationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the parameters passed to the API are invalid. If available, this exception includes details in additional properties.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Fields that caused the exception.
    public var fields: [ShieldClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Additional information about the exception.
    public var reason: ShieldClientTypes.ValidationExceptionReason?

    public init (
        fields: [ShieldClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ShieldClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ShieldClientTypes.ValidationExceptionReason?
    let fields: [ShieldClientTypes.ValidationExceptionField]?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ShieldClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ShieldClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension InvalidResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the resource is invalid. You might not have access to the resource, or the resource might not exist.
public struct InvalidResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.Limit: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case max = "Max"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if max != 0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let maxDecoded = try containerValues.decode(Swift.Int.self, forKey: .max)
        max = maxDecoded
    }
}

extension ShieldClientTypes {
    /// Specifies how many protections of a given type you can create.
    public struct Limit: Swift.Equatable {
        /// The maximum number of protections that can be created for the specified Type.
        public var max: Swift.Int
        /// The type of protection.
        public var type: Swift.String?

        public init (
            max: Swift.Int = 0,
            type: Swift.String? = nil
        )
        {
            self.max = max
            self.type = type
        }
    }

}

extension LimitsExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitsExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.message = output.message
            self.type = output.type
        } else {
            self.limit = 0
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the operation would exceed a limit.
public struct LimitsExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The threshold that would be exceeded.
    public var limit: Swift.Int
    public var message: Swift.String?
    /// The type of limit that would be exceeded.
    public var type: Swift.String?

    public init (
        limit: Swift.Int = 0,
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.limit = limit
        self.message = message
        self.type = type
    }
}

struct LimitsExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
    let limit: Swift.Int
}

extension LimitsExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case type = "Type"
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let limitDecoded = try containerValues.decode(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListAttacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for resourcearnfilterlist0 in resourceArns {
                try resourceArnsContainer.encode(resourcearnfilterlist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }
}

extension ListAttacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAttacksInput: Swift.Equatable {
    /// The end of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var endTime: ShieldClientTypes.TimeRange?
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The ARNs (Amazon Resource Names) of the resources that were attacked. If you leave this blank, all applicable resources for this account will be included.
    public var resourceArns: [Swift.String]?
    /// The start of the time period for the attacks. This is a timestamp type. The request syntax listing for this call indicates a number type, but you can provide the time in any valid [timestamp format](https://docs.aws.amazon.com/cli/latest/userguide/cli-usage-parameters-types.html#parameter-type-timestamp) setting.
    public var startTime: ShieldClientTypes.TimeRange?

    public init (
        endTime: ShieldClientTypes.TimeRange? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil,
        startTime: ShieldClientTypes.TimeRange? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArns = resourceArns
        self.startTime = startTime
    }
}

struct ListAttacksInputBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let startTime: ShieldClientTypes.TimeRange?
    let endTime: ShieldClientTypes.TimeRange?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAttacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
        case startTime = "StartTime"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.TimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAttacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAttacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAttacksOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAttacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAttacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attackSummaries = output.attackSummaries
            self.nextToken = output.nextToken
        } else {
            self.attackSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAttacksOutputResponse: Swift.Equatable {
    /// The attack information for the specified time range.
    public var attackSummaries: [ShieldClientTypes.AttackSummary]?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?

    public init (
        attackSummaries: [ShieldClientTypes.AttackSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attackSummaries = attackSummaries
        self.nextToken = nextToken
    }
}

struct ListAttacksOutputResponseBody: Swift.Equatable {
    let attackSummaries: [ShieldClientTypes.AttackSummary]?
    let nextToken: Swift.String?
}

extension ListAttacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackSummaries = "AttackSummaries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attackSummariesContainer = try containerValues.decodeIfPresent([ShieldClientTypes.AttackSummary?].self, forKey: .attackSummaries)
        var attackSummariesDecoded0:[ShieldClientTypes.AttackSummary]? = nil
        if let attackSummariesContainer = attackSummariesContainer {
            attackSummariesDecoded0 = [ShieldClientTypes.AttackSummary]()
            for structure0 in attackSummariesContainer {
                if let structure0 = structure0 {
                    attackSummariesDecoded0?.append(structure0)
                }
            }
        }
        attackSummaries = attackSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtectionGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtectionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtectionGroupsInput: Swift.Equatable {
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProtectionGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtectionGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectionGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectionGroupsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectionGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProtectionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protectionGroups = output.protectionGroups
        } else {
            self.nextToken = nil
            self.protectionGroups = nil
        }
    }
}

public struct ListProtectionGroupsOutputResponse: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    ///
    /// This member is required.
    public var protectionGroups: [ShieldClientTypes.ProtectionGroup]?

    public init (
        nextToken: Swift.String? = nil,
        protectionGroups: [ShieldClientTypes.ProtectionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectionGroups = protectionGroups
    }
}

struct ListProtectionGroupsOutputResponseBody: Swift.Equatable {
    let protectionGroups: [ShieldClientTypes.ProtectionGroup]?
    let nextToken: Swift.String?
}

extension ListProtectionGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protectionGroups = "ProtectionGroups"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.ProtectionGroup?].self, forKey: .protectionGroups)
        var protectionGroupsDecoded0:[ShieldClientTypes.ProtectionGroup]? = nil
        if let protectionGroupsContainer = protectionGroupsContainer {
            protectionGroupsDecoded0 = [ShieldClientTypes.ProtectionGroup]()
            for structure0 in protectionGroupsContainer {
                if let structure0 = structure0 {
                    protectionGroupsDecoded0?.append(structure0)
                }
            }
        }
        protectionGroups = protectionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProtectionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListProtectionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListProtectionsInput: Swift.Equatable {
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProtectionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListProtectionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListProtectionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProtectionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProtectionsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProtectionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProtectionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protections = output.protections
        } else {
            self.nextToken = nil
            self.protections = nil
        }
    }
}

public struct ListProtectionsOutputResponse: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The array of enabled [Protection] objects.
    public var protections: [ShieldClientTypes.Protection]?

    public init (
        nextToken: Swift.String? = nil,
        protections: [ShieldClientTypes.Protection]? = nil
    )
    {
        self.nextToken = nextToken
        self.protections = protections
    }
}

struct ListProtectionsOutputResponseBody: Swift.Equatable {
    let protections: [ShieldClientTypes.Protection]?
    let nextToken: Swift.String?
}

extension ListProtectionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case protections = "Protections"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Protection?].self, forKey: .protections)
        var protectionsDecoded0:[ShieldClientTypes.Protection]? = nil
        if let protectionsContainer = protectionsContainer {
            protectionsDecoded0 = [ShieldClientTypes.Protection]()
            for structure0 in protectionsContainer {
                if let structure0 = structure0 {
                    protectionsDecoded0?.append(structure0)
                }
            }
        }
        protections = protectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResourcesInProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
    }
}

extension ListResourcesInProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListResourcesInProtectionGroupInput: Swift.Equatable {
    /// The greatest number of objects that you want Shield Advanced to return to the list request. Shield Advanced might return fewer objects than you indicate in this setting, even if more objects are available. If there are more objects remaining, Shield Advanced will always also return a NextToken value in the response. The default setting is 20.
    public var maxResults: Swift.Int?
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value. On your first call to a list operation, leave this setting empty.
    public var nextToken: Swift.String?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        protectionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.protectionGroupId = protectionGroupId
    }
}

struct ListResourcesInProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListResourcesInProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case protectionGroupId = "ProtectionGroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesInProtectionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesInProtectionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesInProtectionGroupOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesInProtectionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesInProtectionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resourceArns = output.resourceArns
        } else {
            self.nextToken = nil
            self.resourceArns = nil
        }
    }
}

public struct ListResourcesInProtectionGroupOutputResponse: Swift.Equatable {
    /// When you request a list of objects from Shield Advanced, if the response does not include all of the remaining available objects, Shield Advanced includes a NextToken value in the response. You can retrieve the next batch of objects by requesting the list again and providing the token that was returned by the prior call in your request. You can indicate the maximum number of objects that you want Shield Advanced to return for a single call with the MaxResults setting. Shield Advanced will not return more than MaxResults objects, but may return fewer, even if more objects are still available. Whenever more objects remain that Shield Advanced has not yet returned to you, the response will include a NextToken value.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of the resources that are included in the protection group.
    /// This member is required.
    public var resourceArns: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        resourceArns: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceArns = resourceArns
    }
}

struct ListResourcesInProtectionGroupOutputResponseBody: Swift.Equatable {
    let resourceArns: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListResourcesInProtectionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceArns = "ResourceArns"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource to get tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag key and value pairs associated with the specified resource.
    public var tags: [ShieldClientTypes.Tag]?

    public init (
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [ShieldClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LockedSubscriptionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LockedSubscriptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are trying to update a subscription that has not yet completed the 1-year commitment. You can change the AutoRenew parameter during the last 30 days of your subscription. This exception indicates that you are attempting to change AutoRenew prior to that period.
public struct LockedSubscriptionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LockedSubscriptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LockedSubscriptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes.Mitigation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mitigationName = "MitigationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mitigationName = mitigationName {
            try encodeContainer.encode(mitigationName, forKey: .mitigationName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mitigationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mitigationName)
        mitigationName = mitigationNameDecoded
    }
}

extension ShieldClientTypes {
    /// The mitigation applied to a DDoS attack.
    public struct Mitigation: Swift.Equatable {
        /// The name of the mitigation taken for this attack.
        public var mitigationName: Swift.String?

        public init (
            mitigationName: Swift.String? = nil
        )
        {
            self.mitigationName = mitigationName
        }
    }

}

extension NoAssociatedRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NoAssociatedRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The ARN of the role that you specifed does not exist.
public struct NoAssociatedRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoAssociatedRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoAssociatedRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OptimisticLockException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OptimisticLockExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception that indicates that the resource state has been modified by another client. Retrieve the resource and then retry your request.
public struct OptimisticLockException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OptimisticLockExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OptimisticLockExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes {
    public enum ProactiveEngagementStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ProactiveEngagementStatus] {
            return [
                .disabled,
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProactiveEngagementStatus(rawValue: rawValue) ?? ProactiveEngagementStatus.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes {
    public enum ProtectedResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applicationLoadBalancer
        case classicLoadBalancer
        case cloudfrontDistribution
        case elasticIpAllocation
        case globalAccelerator
        case route53HostedZone
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedResourceType] {
            return [
                .applicationLoadBalancer,
                .classicLoadBalancer,
                .cloudfrontDistribution,
                .elasticIpAllocation,
                .globalAccelerator,
                .route53HostedZone,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applicationLoadBalancer: return "APPLICATION_LOAD_BALANCER"
            case .classicLoadBalancer: return "CLASSIC_LOAD_BALANCER"
            case .cloudfrontDistribution: return "CLOUDFRONT_DISTRIBUTION"
            case .elasticIpAllocation: return "ELASTIC_IP_ALLOCATION"
            case .globalAccelerator: return "GLOBAL_ACCELERATOR"
            case .route53HostedZone: return "ROUTE_53_HOSTED_ZONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectedResourceType(rawValue: rawValue) ?? ProtectedResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.Protection: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationLayerAutomaticResponseConfiguration = "ApplicationLayerAutomaticResponseConfiguration"
        case healthCheckIds = "HealthCheckIds"
        case id = "Id"
        case name = "Name"
        case protectionArn = "ProtectionArn"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfiguration {
            try encodeContainer.encode(applicationLayerAutomaticResponseConfiguration, forKey: .applicationLayerAutomaticResponseConfiguration)
        }
        if let healthCheckIds = healthCheckIds {
            var healthCheckIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .healthCheckIds)
            for healthcheckids0 in healthCheckIds {
                try healthCheckIdsContainer.encode(healthcheckids0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let protectionArn = protectionArn {
            try encodeContainer.encode(protectionArn, forKey: .protectionArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let healthCheckIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .healthCheckIds)
        var healthCheckIdsDecoded0:[Swift.String]? = nil
        if let healthCheckIdsContainer = healthCheckIdsContainer {
            healthCheckIdsDecoded0 = [Swift.String]()
            for string0 in healthCheckIdsContainer {
                if let string0 = string0 {
                    healthCheckIdsDecoded0?.append(string0)
                }
            }
        }
        healthCheckIds = healthCheckIdsDecoded0
        let protectionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionArn)
        protectionArn = protectionArnDecoded
        let applicationLayerAutomaticResponseConfigurationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration.self, forKey: .applicationLayerAutomaticResponseConfiguration)
        applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfigurationDecoded
    }
}

extension ShieldClientTypes {
    /// An object that represents a resource that is under DDoS protection.
    public struct Protection: Swift.Equatable {
        /// The automatic application layer DDoS mitigation settings for the protection. This configuration determines whether Shield Advanced automatically manages rules in the web ACL in order to respond to application layer events that Shield Advanced determines to be DDoS attacks.
        public var applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration?
        /// The unique identifier (ID) for the Route 53 health check that's associated with the protection.
        public var healthCheckIds: [Swift.String]?
        /// The unique identifier (ID) of the protection.
        public var id: Swift.String?
        /// The name of the protection. For example, My CloudFront distributions.
        public var name: Swift.String?
        /// The ARN (Amazon Resource Name) of the protection.
        public var protectionArn: Swift.String?
        /// The ARN (Amazon Resource Name) of the Amazon Web Services resource that is protected.
        public var resourceArn: Swift.String?

        public init (
            applicationLayerAutomaticResponseConfiguration: ShieldClientTypes.ApplicationLayerAutomaticResponseConfiguration? = nil,
            healthCheckIds: [Swift.String]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            protectionArn: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.applicationLayerAutomaticResponseConfiguration = applicationLayerAutomaticResponseConfiguration
            self.healthCheckIds = healthCheckIds
            self.id = id
            self.name = name
            self.protectionArn = protectionArn
            self.resourceArn = resourceArn
        }
    }

}

extension ShieldClientTypes.ProtectionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupArn = "ProtectionGroupArn"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupArn = protectionGroupArn {
            try encodeContainer.encode(protectionGroupArn, forKey: .protectionGroupArn)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let protectionGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupArn)
        protectionGroupArn = protectionGroupArnDecoded
    }
}

extension ShieldClientTypes {
    /// A grouping of protected resources that you and Shield Advanced can monitor as a collective. This resource grouping improves the accuracy of detection and reduces false positives.
    public struct ProtectionGroup: Swift.Equatable {
        /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
        ///
        /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
        ///
        /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
        ///
        /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
        /// This member is required.
        public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
        /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
        /// This member is required.
        public var members: [Swift.String]?
        /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
        /// This member is required.
        public var pattern: ShieldClientTypes.ProtectionGroupPattern?
        /// The ARN (Amazon Resource Name) of the protection group.
        public var protectionGroupArn: Swift.String?
        /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
        /// This member is required.
        public var protectionGroupId: Swift.String?
        /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
        public var resourceType: ShieldClientTypes.ProtectedResourceType?

        public init (
            aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
            members: [Swift.String]? = nil,
            pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
            protectionGroupArn: Swift.String? = nil,
            protectionGroupId: Swift.String? = nil,
            resourceType: ShieldClientTypes.ProtectedResourceType? = nil
        )
        {
            self.aggregation = aggregation
            self.members = members
            self.pattern = pattern
            self.protectionGroupArn = protectionGroupArn
            self.protectionGroupId = protectionGroupId
            self.resourceType = resourceType
        }
    }

}

extension ShieldClientTypes {
    public enum ProtectionGroupAggregation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case max
        case mean
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupAggregation] {
            return [
                .max,
                .mean,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .max: return "MAX"
            case .mean: return "MEAN"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectionGroupAggregation(rawValue: rawValue) ?? ProtectionGroupAggregation.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.ProtectionGroupArbitraryPatternLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxMembers = "MaxMembers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxMembers != 0 {
            try encodeContainer.encode(maxMembers, forKey: .maxMembers)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxMembersDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxMembers)
        maxMembers = maxMembersDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings on protection groups with arbitrary pattern type.
    public struct ProtectionGroupArbitraryPatternLimits: Swift.Equatable {
        /// The maximum number of resources you can specify for a single arbitrary pattern in a protection group.
        /// This member is required.
        public var maxMembers: Swift.Int

        public init (
            maxMembers: Swift.Int = 0
        )
        {
            self.maxMembers = maxMembers
        }
    }

}

extension ShieldClientTypes.ProtectionGroupLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxProtectionGroups = "MaxProtectionGroups"
        case patternTypeLimits = "PatternTypeLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxProtectionGroups != 0 {
            try encodeContainer.encode(maxProtectionGroups, forKey: .maxProtectionGroups)
        }
        if let patternTypeLimits = patternTypeLimits {
            try encodeContainer.encode(patternTypeLimits, forKey: .patternTypeLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxProtectionGroupsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxProtectionGroups)
        maxProtectionGroups = maxProtectionGroupsDecoded
        let patternTypeLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPatternTypeLimits.self, forKey: .patternTypeLimits)
        patternTypeLimits = patternTypeLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings on protection groups for your subscription.
    public struct ProtectionGroupLimits: Swift.Equatable {
        /// The maximum number of protection groups that you can have at one time.
        /// This member is required.
        public var maxProtectionGroups: Swift.Int
        /// Limits settings by pattern type in the protection groups for your subscription.
        /// This member is required.
        public var patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits?

        public init (
            maxProtectionGroups: Swift.Int = 0,
            patternTypeLimits: ShieldClientTypes.ProtectionGroupPatternTypeLimits? = nil
        )
        {
            self.maxProtectionGroups = maxProtectionGroups
            self.patternTypeLimits = patternTypeLimits
        }
    }

}

extension ShieldClientTypes {
    public enum ProtectionGroupPattern: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case arbitrary
        case byResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectionGroupPattern] {
            return [
                .all,
                .arbitrary,
                .byResourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .arbitrary: return "ARBITRARY"
            case .byResourceType: return "BY_RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectionGroupPattern(rawValue: rawValue) ?? ProtectionGroupPattern.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.ProtectionGroupPatternTypeLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arbitraryPatternLimits = "ArbitraryPatternLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arbitraryPatternLimits = arbitraryPatternLimits {
            try encodeContainer.encode(arbitraryPatternLimits, forKey: .arbitraryPatternLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arbitraryPatternLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupArbitraryPatternLimits.self, forKey: .arbitraryPatternLimits)
        arbitraryPatternLimits = arbitraryPatternLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings by pattern type in the protection groups for your subscription.
    public struct ProtectionGroupPatternTypeLimits: Swift.Equatable {
        /// Limits settings on protection groups with arbitrary pattern type.
        /// This member is required.
        public var arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits?

        public init (
            arbitraryPatternLimits: ShieldClientTypes.ProtectionGroupArbitraryPatternLimits? = nil
        )
        {
            self.arbitraryPatternLimits = arbitraryPatternLimits
        }
    }

}

extension ShieldClientTypes.ProtectionLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectedResourceTypeLimits = "ProtectedResourceTypeLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectedResourceTypeLimits = protectedResourceTypeLimits {
            var protectedResourceTypeLimitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protectedResourceTypeLimits)
            for limits0 in protectedResourceTypeLimits {
                try protectedResourceTypeLimitsContainer.encode(limits0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedResourceTypeLimitsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Limit?].self, forKey: .protectedResourceTypeLimits)
        var protectedResourceTypeLimitsDecoded0:[ShieldClientTypes.Limit]? = nil
        if let protectedResourceTypeLimitsContainer = protectedResourceTypeLimitsContainer {
            protectedResourceTypeLimitsDecoded0 = [ShieldClientTypes.Limit]()
            for structure0 in protectedResourceTypeLimitsContainer {
                if let structure0 = structure0 {
                    protectedResourceTypeLimitsDecoded0?.append(structure0)
                }
            }
        }
        protectedResourceTypeLimits = protectedResourceTypeLimitsDecoded0
    }
}

extension ShieldClientTypes {
    /// Limits settings on protections for your subscription.
    public struct ProtectionLimits: Swift.Equatable {
        /// The maximum number of resource types that you can specify in a protection.
        /// This member is required.
        public var protectedResourceTypeLimits: [ShieldClientTypes.Limit]?

        public init (
            protectedResourceTypeLimits: [ShieldClientTypes.Limit]? = nil
        )
        {
            self.protectedResourceTypeLimits = protectedResourceTypeLimits
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception indicating the specified resource already exists. If available, this exception includes details in additional properties.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The type of resource that already exists.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exception indicating the specified resource does not exist. If available, this exception includes details in additional properties.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// Type of resource.
    public var resourceType: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ShieldClientTypes.ResponseAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case block = "Block"
        case count = "Count"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let block = block {
            try encodeContainer.encode(block, forKey: .block)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.BlockAction.self, forKey: .block)
        block = blockDecoded
        let countDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.CountAction.self, forKey: .count)
        count = countDecoded
    }
}

extension ShieldClientTypes {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    public struct ResponseAction: Swift.Equatable {
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Block action. You must specify exactly one action, either Block or Count.
        public var block: ShieldClientTypes.BlockAction?
        /// Specifies that Shield Advanced should configure its WAF rules with the WAF Count action. You must specify exactly one action, either Block or Count.
        public var count: ShieldClientTypes.CountAction?

        public init (
            block: ShieldClientTypes.BlockAction? = nil,
            count: ShieldClientTypes.CountAction? = nil
        )
        {
            self.block = block
            self.count = count
        }
    }

}

extension ShieldClientTypes.SubResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attackVectors = "AttackVectors"
        case counters = "Counters"
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attackVectors = attackVectors {
            var attackVectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attackVectors)
            for summarizedattackvectorlist0 in attackVectors {
                try attackVectorsContainer.encode(summarizedattackvectorlist0)
            }
        }
        if let counters = counters {
            var countersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .counters)
            for summarizedcounterlist0 in counters {
                try countersContainer.encode(summarizedcounterlist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubResourceType.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let attackVectorsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedAttackVector?].self, forKey: .attackVectors)
        var attackVectorsDecoded0:[ShieldClientTypes.SummarizedAttackVector]? = nil
        if let attackVectorsContainer = attackVectorsContainer {
            attackVectorsDecoded0 = [ShieldClientTypes.SummarizedAttackVector]()
            for structure0 in attackVectorsContainer {
                if let structure0 = structure0 {
                    attackVectorsDecoded0?.append(structure0)
                }
            }
        }
        attackVectors = attackVectorsDecoded0
        let countersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .counters)
        var countersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let countersContainer = countersContainer {
            countersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in countersContainer {
                if let structure0 = structure0 {
                    countersDecoded0?.append(structure0)
                }
            }
        }
        counters = countersDecoded0
    }
}

extension ShieldClientTypes {
    /// The attack information for the specified SubResource.
    public struct SubResourceSummary: Swift.Equatable {
        /// The list of attack types and associated counters.
        public var attackVectors: [ShieldClientTypes.SummarizedAttackVector]?
        /// The counters that describe the details of the attack.
        public var counters: [ShieldClientTypes.SummarizedCounter]?
        /// The unique identifier (ID) of the SubResource.
        public var id: Swift.String?
        /// The SubResource type.
        public var type: ShieldClientTypes.SubResourceType?

        public init (
            attackVectors: [ShieldClientTypes.SummarizedAttackVector]? = nil,
            counters: [ShieldClientTypes.SummarizedCounter]? = nil,
            id: Swift.String? = nil,
            type: ShieldClientTypes.SubResourceType? = nil
        )
        {
            self.attackVectors = attackVectors
            self.counters = counters
            self.id = id
            self.type = type
        }
    }

}

extension ShieldClientTypes {
    public enum SubResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ip
        case url
        case sdkUnknown(Swift.String)

        public static var allCases: [SubResourceType] {
            return [
                .ip,
                .url,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ip: return "IP"
            case .url: return "URL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubResourceType(rawValue: rawValue) ?? SubResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
        case endTime = "EndTime"
        case limits = "Limits"
        case proactiveEngagementStatus = "ProactiveEngagementStatus"
        case startTime = "StartTime"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionLimits = "SubscriptionLimits"
        case timeCommitmentInSeconds = "TimeCommitmentInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let limits = limits {
            var limitsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .limits)
            for limits0 in limits {
                try limitsContainer.encode(limits0)
            }
        }
        if let proactiveEngagementStatus = proactiveEngagementStatus {
            try encodeContainer.encode(proactiveEngagementStatus.rawValue, forKey: .proactiveEngagementStatus)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionLimits = subscriptionLimits {
            try encodeContainer.encode(subscriptionLimits, forKey: .subscriptionLimits)
        }
        if timeCommitmentInSeconds != 0 {
            try encodeContainer.encode(timeCommitmentInSeconds, forKey: .timeCommitmentInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let timeCommitmentInSecondsDecoded = try containerValues.decode(Swift.Int.self, forKey: .timeCommitmentInSeconds)
        timeCommitmentInSeconds = timeCommitmentInSecondsDecoded
        let autoRenewDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
        let limitsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Limit?].self, forKey: .limits)
        var limitsDecoded0:[ShieldClientTypes.Limit]? = nil
        if let limitsContainer = limitsContainer {
            limitsDecoded0 = [ShieldClientTypes.Limit]()
            for structure0 in limitsContainer {
                if let structure0 = structure0 {
                    limitsDecoded0?.append(structure0)
                }
            }
        }
        limits = limitsDecoded0
        let proactiveEngagementStatusDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProactiveEngagementStatus.self, forKey: .proactiveEngagementStatus)
        proactiveEngagementStatus = proactiveEngagementStatusDecoded
        let subscriptionLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.SubscriptionLimits.self, forKey: .subscriptionLimits)
        subscriptionLimits = subscriptionLimitsDecoded
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension ShieldClientTypes {
    /// Information about the Shield Advanced subscription for an account.
    public struct Subscription: Swift.Equatable {
        /// If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. When you initally create a subscription, AutoRenew is set to ENABLED. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
        public var autoRenew: ShieldClientTypes.AutoRenew?
        /// The date and time your subscription will end.
        public var endTime: ClientRuntime.Date?
        /// Specifies how many protections of a given type you can create.
        public var limits: [ShieldClientTypes.Limit]?
        /// If ENABLED, the Shield Response Team (SRT) will use email and phone to notify contacts about escalations to the SRT and to initiate proactive customer support. If PENDING, you have requested proactive engagement and the request is pending. The status changes to ENABLED when your request is fully processed. If DISABLED, the SRT will not proactively notify contacts about escalations or to initiate proactive customer support.
        public var proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus?
        /// The start time of the subscription, in Unix time in seconds.
        public var startTime: ClientRuntime.Date?
        /// The ARN (Amazon Resource Name) of the subscription.
        public var subscriptionArn: Swift.String?
        /// Limits settings for your subscription.
        /// This member is required.
        public var subscriptionLimits: ShieldClientTypes.SubscriptionLimits?
        /// The length, in seconds, of the Shield Advanced subscription for the account.
        public var timeCommitmentInSeconds: Swift.Int

        public init (
            autoRenew: ShieldClientTypes.AutoRenew? = nil,
            endTime: ClientRuntime.Date? = nil,
            limits: [ShieldClientTypes.Limit]? = nil,
            proactiveEngagementStatus: ShieldClientTypes.ProactiveEngagementStatus? = nil,
            startTime: ClientRuntime.Date? = nil,
            subscriptionArn: Swift.String? = nil,
            subscriptionLimits: ShieldClientTypes.SubscriptionLimits? = nil,
            timeCommitmentInSeconds: Swift.Int = 0
        )
        {
            self.autoRenew = autoRenew
            self.endTime = endTime
            self.limits = limits
            self.proactiveEngagementStatus = proactiveEngagementStatus
            self.startTime = startTime
            self.subscriptionArn = subscriptionArn
            self.subscriptionLimits = subscriptionLimits
            self.timeCommitmentInSeconds = timeCommitmentInSeconds
        }
    }

}

extension ShieldClientTypes.SubscriptionLimits: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectionGroupLimits = "ProtectionGroupLimits"
        case protectionLimits = "ProtectionLimits"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protectionGroupLimits = protectionGroupLimits {
            try encodeContainer.encode(protectionGroupLimits, forKey: .protectionGroupLimits)
        }
        if let protectionLimits = protectionLimits {
            try encodeContainer.encode(protectionLimits, forKey: .protectionLimits)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionLimits.self, forKey: .protectionLimits)
        protectionLimits = protectionLimitsDecoded
        let protectionGroupLimitsDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupLimits.self, forKey: .protectionGroupLimits)
        protectionGroupLimits = protectionGroupLimitsDecoded
    }
}

extension ShieldClientTypes {
    /// Limits settings for your subscription.
    public struct SubscriptionLimits: Swift.Equatable {
        /// Limits settings on protection groups for your subscription.
        /// This member is required.
        public var protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits?
        /// Limits settings on protections for your subscription.
        /// This member is required.
        public var protectionLimits: ShieldClientTypes.ProtectionLimits?

        public init (
            protectionGroupLimits: ShieldClientTypes.ProtectionGroupLimits? = nil,
            protectionLimits: ShieldClientTypes.ProtectionLimits? = nil
        )
        {
            self.protectionGroupLimits = protectionGroupLimits
            self.protectionLimits = protectionLimits
        }
    }

}

extension ShieldClientTypes {
    public enum SubscriptionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionState] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionState(rawValue: rawValue) ?? SubscriptionState.sdkUnknown(rawValue)
        }
    }
}

extension ShieldClientTypes.SummarizedAttackVector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vectorCounters = "VectorCounters"
        case vectorType = "VectorType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vectorCounters = vectorCounters {
            var vectorCountersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vectorCounters)
            for summarizedcounterlist0 in vectorCounters {
                try vectorCountersContainer.encode(summarizedcounterlist0)
            }
        }
        if let vectorType = vectorType {
            try encodeContainer.encode(vectorType, forKey: .vectorType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vectorTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vectorType)
        vectorType = vectorTypeDecoded
        let vectorCountersContainer = try containerValues.decodeIfPresent([ShieldClientTypes.SummarizedCounter?].self, forKey: .vectorCounters)
        var vectorCountersDecoded0:[ShieldClientTypes.SummarizedCounter]? = nil
        if let vectorCountersContainer = vectorCountersContainer {
            vectorCountersDecoded0 = [ShieldClientTypes.SummarizedCounter]()
            for structure0 in vectorCountersContainer {
                if let structure0 = structure0 {
                    vectorCountersDecoded0?.append(structure0)
                }
            }
        }
        vectorCounters = vectorCountersDecoded0
    }
}

extension ShieldClientTypes {
    /// A summary of information about the attack.
    public struct SummarizedAttackVector: Swift.Equatable {
        /// The list of counters that describe the details of the attack.
        public var vectorCounters: [ShieldClientTypes.SummarizedCounter]?
        /// The attack type, for example, SNMP reflection or SYN flood.
        /// This member is required.
        public var vectorType: Swift.String?

        public init (
            vectorCounters: [ShieldClientTypes.SummarizedCounter]? = nil,
            vectorType: Swift.String? = nil
        )
        {
            self.vectorCounters = vectorCounters
            self.vectorType = vectorType
        }
    }

}

extension ShieldClientTypes.SummarizedCounter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average = "Average"
        case max = "Max"
        case n = "N"
        case name = "Name"
        case sum = "Sum"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if average != 0.0 {
            try encodeContainer.encode(average, forKey: .average)
        }
        if max != 0.0 {
            try encodeContainer.encode(max, forKey: .max)
        }
        if n != 0 {
            try encodeContainer.encode(n, forKey: .n)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if sum != 0.0 {
            try encodeContainer.encode(sum, forKey: .sum)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxDecoded = try containerValues.decode(Swift.Double.self, forKey: .max)
        max = maxDecoded
        let averageDecoded = try containerValues.decode(Swift.Double.self, forKey: .average)
        average = averageDecoded
        let sumDecoded = try containerValues.decode(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let nDecoded = try containerValues.decode(Swift.Int.self, forKey: .n)
        n = nDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension ShieldClientTypes {
    /// The counter that describes a DDoS attack.
    public struct SummarizedCounter: Swift.Equatable {
        /// The average value of the counter for a specified time period.
        public var average: Swift.Double
        /// The maximum value of the counter for a specified time period.
        public var max: Swift.Double
        /// The number of counters for a specified time period.
        public var n: Swift.Int
        /// The counter name.
        public var name: Swift.String?
        /// The total of counter values for a specified time period.
        public var sum: Swift.Double
        /// The unit of the counters.
        public var unit: Swift.String?

        public init (
            average: Swift.Double = 0.0,
            max: Swift.Double = 0.0,
            n: Swift.Int = 0,
            name: Swift.String? = nil,
            sum: Swift.Double = 0.0,
            unit: Swift.String? = nil
        )
        {
            self.average = average
            self.max = max
            self.n = n
            self.name = name
            self.sum = sum
            self.unit = unit
        }
    }

}

extension ShieldClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ShieldClientTypes {
    /// A tag associated with an Amazon Web Services resource. Tags are key:value pairs that you can use to categorize and manage your resources, for purposes like billing or other management. Typically, the tag key represents a category, such as "environment", and the tag value represents a specific value within that category, such as "test," "development," or "production". Or you might set the tag key to "customer" and the value to the customer name or ID. You can specify one or more tags to add to each Amazon Web Services resource, up to 50 tags for a resource.
    public struct Tag: Swift.Equatable {
        /// Part of the key:value pair that defines a tag. You can use a tag key to describe a category of information, such as "customer." Tag keys are case-sensitive.
        public var key: Swift.String?
        /// Part of the key:value pair that defines a tag. You can use a tag value to describe a specific value within a category, such as "companyA" or "companyB." Tag values are case-sensitive.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add or update tags for.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags that you want to modify or add to the resource.
    /// This member is required.
    public var tags: [ShieldClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [ShieldClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ShieldClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ShieldClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ShieldClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ShieldClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension ShieldClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromInclusive = "FromInclusive"
        case toExclusive = "ToExclusive"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromInclusive = fromInclusive {
            try encodeContainer.encode(fromInclusive.timeIntervalSince1970, forKey: .fromInclusive)
        }
        if let toExclusive = toExclusive {
            try encodeContainer.encode(toExclusive.timeIntervalSince1970, forKey: .toExclusive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromInclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .fromInclusive)
        fromInclusive = fromInclusiveDecoded
        let toExclusiveDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .toExclusive)
        toExclusive = toExclusiveDecoded
    }
}

extension ShieldClientTypes {
    /// The time range.
    public struct TimeRange: Swift.Equatable {
        /// The start time, in Unix time in seconds.
        public var fromInclusive: ClientRuntime.Date?
        /// The end time, in Unix time in seconds.
        public var toExclusive: ClientRuntime.Date?

        public init (
            fromInclusive: ClientRuntime.Date? = nil,
            toExclusive: ClientRuntime.Date? = nil
        )
        {
            self.fromInclusive = fromInclusive
            self.toExclusive = toExclusive
        }
    }

}

extension ShieldClientTypes {
    public enum Unit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bits
        case bytes
        case packets
        case requests
        case sdkUnknown(Swift.String)

        public static var allCases: [Unit] {
            return [
                .bits,
                .bytes,
                .packets,
                .requests,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bits: return "BITS"
            case .bytes: return "BYTES"
            case .packets: return "PACKETS"
            case .requests: return "REQUESTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to remove tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key for each tag that you want to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case invalidResourceException(InvalidResourceException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateApplicationLayerAutomaticResponseInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension UpdateApplicationLayerAutomaticResponseInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationLayerAutomaticResponseInput: Swift.Equatable {
    /// Specifies the action setting that Shield Advanced should use in the WAF rules that it creates on behalf of the protected resource in response to DDoS attacks. You specify this as part of the configuration for the automatic application layer DDoS mitigation feature, when you enable or update automatic mitigation. Shield Advanced creates the WAF rules in a Shield Advanced-managed rule group, inside the web ACL that you have associated with the resource.
    /// This member is required.
    public var action: ShieldClientTypes.ResponseAction?
    /// The ARN (Amazon Resource Name) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        action: ShieldClientTypes.ResponseAction? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.action = action
        self.resourceArn = resourceArn
    }
}

struct UpdateApplicationLayerAutomaticResponseInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let action: ShieldClientTypes.ResponseAction?
}

extension UpdateApplicationLayerAutomaticResponseInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ResponseAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension UpdateApplicationLayerAutomaticResponseOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationLayerAutomaticResponseOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationLayerAutomaticResponseOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidOperationException(InvalidOperationException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationLayerAutomaticResponseOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateApplicationLayerAutomaticResponseOutputResponse: Swift.Equatable {

}

extension UpdateEmergencyContactSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emergencyContactList = emergencyContactList {
            var emergencyContactListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .emergencyContactList)
            for emergencycontactlist0 in emergencyContactList {
                try emergencyContactListContainer.encode(emergencycontactlist0)
            }
        }
    }
}

extension UpdateEmergencyContactSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEmergencyContactSettingsInput: Swift.Equatable {
    /// A list of email addresses and phone numbers that the Shield Response Team (SRT) can use to contact you if you have proactive engagement enabled, for escalations to the SRT and to initiate proactive customer support. If you have proactive engagement enabled, the contact list must include at least one phone number.
    public var emergencyContactList: [ShieldClientTypes.EmergencyContact]?

    public init (
        emergencyContactList: [ShieldClientTypes.EmergencyContact]? = nil
    )
    {
        self.emergencyContactList = emergencyContactList
    }
}

struct UpdateEmergencyContactSettingsInputBody: Swift.Equatable {
    let emergencyContactList: [ShieldClientTypes.EmergencyContact]?
}

extension UpdateEmergencyContactSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case emergencyContactList = "EmergencyContactList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emergencyContactListContainer = try containerValues.decodeIfPresent([ShieldClientTypes.EmergencyContact?].self, forKey: .emergencyContactList)
        var emergencyContactListDecoded0:[ShieldClientTypes.EmergencyContact]? = nil
        if let emergencyContactListContainer = emergencyContactListContainer {
            emergencyContactListDecoded0 = [ShieldClientTypes.EmergencyContact]()
            for structure0 in emergencyContactListContainer {
                if let structure0 = structure0 {
                    emergencyContactListDecoded0?.append(structure0)
                }
            }
        }
        emergencyContactList = emergencyContactListDecoded0
    }
}

extension UpdateEmergencyContactSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmergencyContactSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmergencyContactSettingsOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmergencyContactSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateEmergencyContactSettingsOutputResponse: Swift.Equatable {

}

extension UpdateProtectionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregation = aggregation {
            try encodeContainer.encode(aggregation.rawValue, forKey: .aggregation)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for protectiongroupmembers0 in members {
                try membersContainer.encode(protectiongroupmembers0)
            }
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern.rawValue, forKey: .pattern)
        }
        if let protectionGroupId = protectionGroupId {
            try encodeContainer.encode(protectionGroupId, forKey: .protectionGroupId)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

extension UpdateProtectionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProtectionGroupInput: Swift.Equatable {
    /// Defines how Shield combines resource data for the group in order to detect, mitigate, and report events.
    ///
    /// * Sum - Use the total traffic across the group. This is a good choice for most cases. Examples include Elastic IP addresses for EC2 instances that scale manually or automatically.
    ///
    /// * Mean - Use the average of the traffic across the group. This is a good choice for resources that share traffic uniformly. Examples include accelerators and load balancers.
    ///
    /// * Max - Use the highest traffic from each resource. This is useful for resources that don't share traffic and for resources that share that traffic in a non-uniform way. Examples include Amazon CloudFront distributions and origin resources for CloudFront distributions.
    /// This member is required.
    public var aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    /// The Amazon Resource Names (ARNs) of the resources to include in the protection group. You must set this when you set Pattern to ARBITRARY and you must not set it for any other Pattern setting.
    public var members: [Swift.String]?
    /// The criteria to use to choose the protected resources for inclusion in the group. You can include all resources that have protections, provide a list of resource Amazon Resource Names (ARNs), or include all resources of a specified resource type.
    /// This member is required.
    public var pattern: ShieldClientTypes.ProtectionGroupPattern?
    /// The name of the protection group. You use this to identify the protection group in lists and to manage the protection group, for example to update, delete, or describe it.
    /// This member is required.
    public var protectionGroupId: Swift.String?
    /// The resource type to include in the protection group. All protected resources of this type are included in the protection group. You must set this when you set Pattern to BY_RESOURCE_TYPE and you must not set it for any other Pattern setting.
    public var resourceType: ShieldClientTypes.ProtectedResourceType?

    public init (
        aggregation: ShieldClientTypes.ProtectionGroupAggregation? = nil,
        members: [Swift.String]? = nil,
        pattern: ShieldClientTypes.ProtectionGroupPattern? = nil,
        protectionGroupId: Swift.String? = nil,
        resourceType: ShieldClientTypes.ProtectedResourceType? = nil
    )
    {
        self.aggregation = aggregation
        self.members = members
        self.pattern = pattern
        self.protectionGroupId = protectionGroupId
        self.resourceType = resourceType
    }
}

struct UpdateProtectionGroupInputBody: Swift.Equatable {
    let protectionGroupId: Swift.String?
    let aggregation: ShieldClientTypes.ProtectionGroupAggregation?
    let pattern: ShieldClientTypes.ProtectionGroupPattern?
    let resourceType: ShieldClientTypes.ProtectedResourceType?
    let members: [Swift.String]?
}

extension UpdateProtectionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation = "Aggregation"
        case members = "Members"
        case pattern = "Pattern"
        case protectionGroupId = "ProtectionGroupId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protectionGroupId)
        protectionGroupId = protectionGroupIdDecoded
        let aggregationDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupAggregation.self, forKey: .aggregation)
        aggregation = aggregationDecoded
        let patternDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectionGroupPattern.self, forKey: .pattern)
        pattern = patternDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.ProtectedResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
    }
}

extension UpdateProtectionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProtectionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProtectionGroupOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProtectionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProtectionGroupOutputResponse: Swift.Equatable {

}

extension UpdateSubscriptionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRenew = autoRenew {
            try encodeContainer.encode(autoRenew.rawValue, forKey: .autoRenew)
        }
    }
}

extension UpdateSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSubscriptionInput: Swift.Equatable {
    /// When you initally create a subscription, AutoRenew is set to ENABLED. If ENABLED, the subscription will be automatically renewed at the end of the existing subscription period. You can change this by submitting an UpdateSubscription request. If the UpdateSubscription request does not included a value for AutoRenew, the existing value for AutoRenew remains unchanged.
    public var autoRenew: ShieldClientTypes.AutoRenew?

    public init (
        autoRenew: ShieldClientTypes.AutoRenew? = nil
    )
    {
        self.autoRenew = autoRenew
    }
}

struct UpdateSubscriptionInputBody: Swift.Equatable {
    let autoRenew: ShieldClientTypes.AutoRenew?
}

extension UpdateSubscriptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRenew = "AutoRenew"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoRenewDecoded = try containerValues.decodeIfPresent(ShieldClientTypes.AutoRenew.self, forKey: .autoRenew)
        autoRenew = autoRenewDecoded
    }
}

extension UpdateSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LockedSubscriptionException" : self = .lockedSubscriptionException(try LockedSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OptimisticLockException" : self = .optimisticLockException(try OptimisticLockException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case lockedSubscriptionException(LockedSubscriptionException)
    case optimisticLockException(OptimisticLockException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSubscriptionOutputResponse: Swift.Equatable {

}

extension ShieldClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ShieldClientTypes {
    /// Provides information about a particular parameter passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The message describing why the parameter failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the parameter that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension ShieldClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
