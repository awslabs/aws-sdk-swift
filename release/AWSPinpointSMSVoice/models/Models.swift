// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in your request already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input you provided is invalid.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSmsVoiceClientTypes.CallInstructionsMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
    public struct CallInstructionsMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var text: Swift.String?

        public init (
            text: Swift.String? = nil
        )
        {
            self.text = text
        }
    }

}

extension PinpointSmsVoiceClientTypes.CloudWatchLogsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamRoleArn = "IamRoleArn"
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let logGroupArn = logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
    public struct CloudWatchLogsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
        public var iamRoleArn: Swift.String?
        /// The name of the Amazon CloudWatch Log Group that you want to record events in.
        public var logGroupArn: Swift.String?

        public init (
            iamRoleArn: Swift.String? = nil,
            logGroupArn: Swift.String? = nil
        )
        {
            self.iamRoleArn = iamRoleArn
            self.logGroupArn = logGroupArn
        }
    }

}

extension CreateConfigurationSetEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

extension CreateConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations"
    }
}

/// Create a new event destination in a configuration set.
public struct CreateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An object that defines a single event destination.
    public var eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition?
    /// A name that identifies the event destination.
    public var eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    let eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition?
    let eventDestinationName: Swift.String?
}

extension CreateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was created successfully.
public struct CreateConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

}

extension CreateConfigurationSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

extension CreateConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/configuration-sets"
    }
}

/// A request to create a new configuration set.
public struct CreateConfigurationSetInput: Swift.Equatable {
    /// The name that you want to give the configuration set.
    public var configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct CreateConfigurationSetInputBody: Swift.Equatable {
    let configurationSetName: Swift.String?
}

extension CreateConfigurationSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension CreateConfigurationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the configuration set was successfully created.
public struct CreateConfigurationSetOutputResponse: Swift.Equatable {

}

extension DeleteConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        guard let eventDestinationName = eventDestinationName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations/\(eventDestinationName.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// EventDestinationName
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was deleted successfully.
public struct DeleteConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

}

extension DeleteConfigurationSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationSetInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Swift.Equatable {
}

extension DeleteConfigurationSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the configuration set was deleted successfully.
public struct DeleteConfigurationSetOutputResponse: Swift.Equatable {

}

extension PinpointSmsVoiceClientTypes.EventDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSmsVoiceClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSmsVoiceClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSmsVoiceClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that defines an event destination.
    public struct EventDestination: Swift.Equatable {
        /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
        public var cloudWatchLogsDestination: PinpointSmsVoiceClientTypes.CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public var enabled: Swift.Bool?
        /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSmsVoiceClientTypes.KinesisFirehoseDestination?
        /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
        public var matchingEventTypes: [PinpointSmsVoiceClientTypes.EventType]?
        /// A name that identifies the event destination configuration.
        public var name: Swift.String?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public var snsDestination: PinpointSmsVoiceClientTypes.SnsDestination?

        public init (
            cloudWatchLogsDestination: PinpointSmsVoiceClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            kinesisFirehoseDestination: PinpointSmsVoiceClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSmsVoiceClientTypes.EventType]? = nil,
            name: Swift.String? = nil,
            snsDestination: PinpointSmsVoiceClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.name = name
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSmsVoiceClientTypes.EventDestinationDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([PinpointSmsVoiceClientTypes.EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[PinpointSmsVoiceClientTypes.EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [PinpointSmsVoiceClientTypes.EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let snsDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that defines a single event destination.
    public struct EventDestinationDefinition: Swift.Equatable {
        /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
        public var cloudWatchLogsDestination: PinpointSmsVoiceClientTypes.CloudWatchLogsDestination?
        /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
        public var enabled: Swift.Bool?
        /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
        public var kinesisFirehoseDestination: PinpointSmsVoiceClientTypes.KinesisFirehoseDestination?
        /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
        public var matchingEventTypes: [PinpointSmsVoiceClientTypes.EventType]?
        /// An object that contains information about an event destination that sends data to Amazon SNS.
        public var snsDestination: PinpointSmsVoiceClientTypes.SnsDestination?

        public init (
            cloudWatchLogsDestination: PinpointSmsVoiceClientTypes.CloudWatchLogsDestination? = nil,
            enabled: Swift.Bool? = nil,
            kinesisFirehoseDestination: PinpointSmsVoiceClientTypes.KinesisFirehoseDestination? = nil,
            matchingEventTypes: [PinpointSmsVoiceClientTypes.EventType]? = nil,
            snsDestination: PinpointSmsVoiceClientTypes.SnsDestination? = nil
        )
        {
            self.cloudWatchLogsDestination = cloudWatchLogsDestination
            self.enabled = enabled
            self.kinesisFirehoseDestination = kinesisFirehoseDestination
            self.matchingEventTypes = matchingEventTypes
            self.snsDestination = snsDestination
        }
    }

}

extension PinpointSmsVoiceClientTypes {
    /// The types of events that are sent to the event destination.
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case answered
        case busy
        case completedCall
        case failed
        case initiatedCall
        case noAnswer
        case ringing
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .answered,
                .busy,
                .completedCall,
                .failed,
                .initiatedCall,
                .noAnswer,
                .ringing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .answered: return "ANSWERED"
            case .busy: return "BUSY"
            case .completedCall: return "COMPLETED_CALL"
            case .failed: return "FAILED"
            case .initiatedCall: return "INITIATED_CALL"
            case .noAnswer: return "NO_ANSWER"
            case .ringing: return "RINGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension GetConfigurationSetEventDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations"
    }
}

public struct GetConfigurationSetEventDestinationsInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Swift.Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetEventDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetEventDestinationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetEventDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationSetEventDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// An object that contains information about an event destination.
public struct GetConfigurationSetEventDestinationsOutputResponse: Swift.Equatable {
    /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
    public var eventDestinations: [PinpointSmsVoiceClientTypes.EventDestination]?

    public init (
        eventDestinations: [PinpointSmsVoiceClientTypes.EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputResponseBody: Swift.Equatable {
    let eventDestinations: [PinpointSmsVoiceClientTypes.EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([PinpointSmsVoiceClientTypes.EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[PinpointSmsVoiceClientTypes.EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [PinpointSmsVoiceClientTypes.EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

extension InternalServiceErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServiceErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSmsVoiceClientTypes.KinesisFirehoseDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
    public struct KinesisFirehoseDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of an IAM role that can write data to an Amazon Kinesis Data Firehose stream.
        public var deliveryStreamArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose destination that you want to use in the event destination.
        public var iamRoleArn: Swift.String?

        public init (
            deliveryStreamArn: Swift.String? = nil,
            iamRoleArn: Swift.String? = nil
        )
        {
            self.deliveryStreamArn = deliveryStreamArn
            self.iamRoleArn = iamRoleArn
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many instances of the specified resource type.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let pageSize = pageSize {
            let pageSizeQueryItem = ClientRuntime.URLQueryItem(name: "PageSize".urlPercentEncoding(), value: Swift.String(pageSize).urlPercentEncoding())
            items.append(pageSizeQueryItem)
        }
        return items
    }
}

extension ListConfigurationSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/configuration-sets"
    }
}

public struct ListConfigurationSetsInput: Swift.Equatable {
    /// A token returned from a previous call to the API that indicates the position in the list of results.
    public var nextToken: Swift.String?
    /// Used to specify the number of items that should be returned in the response.
    public var pageSize: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        pageSize: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Swift.Equatable {
}

extension ListConfigurationSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// An object that contains information about the configuration sets for your account in the current region.
public struct ListConfigurationSetsOutputResponse: Swift.Equatable {
    /// An object that contains a list of configuration sets for your account in the current region.
    public var configurationSets: [Swift.String]?
    /// A token returned from a previous call to ListConfigurationSets to indicate the position in the list of configuration sets.
    public var nextToken: Swift.String?

    public init (
        configurationSets: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Swift.Equatable {
    let configurationSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListConfigurationSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[Swift.String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [Swift.String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource you attempted to access doesn't exist.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PinpointSmsVoiceClientTypes.PlainTextMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that defines a message that contains unformatted text.
    public struct PlainTextMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var languageCode: Swift.String?
        /// The plain (not SSML-formatted) text to deliver to the recipient.
        public var text: Swift.String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public var voiceId: Swift.String?

        public init (
            languageCode: Swift.String? = nil,
            text: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }
    }

}

extension PinpointSmsVoiceClientTypes.SSMLMessageType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that defines a message that contains SSML-formatted text.
    public struct SSMLMessageType: Swift.Equatable {
        /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
        public var languageCode: Swift.String?
        /// The SSML-formatted text to deliver to the recipient.
        public var text: Swift.String?
        /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
        public var voiceId: Swift.String?

        public init (
            languageCode: Swift.String? = nil,
            text: Swift.String? = nil,
            voiceId: Swift.String? = nil
        )
        {
            self.languageCode = languageCode
            self.text = text
            self.voiceId = voiceId
        }
    }

}

extension SendVoiceMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callerId = callerId {
            try encodeContainer.encode(callerId, forKey: .callerId)
        }
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destinationPhoneNumber = destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let originationPhoneNumber = originationPhoneNumber {
            try encodeContainer.encode(originationPhoneNumber, forKey: .originationPhoneNumber)
        }
    }
}

extension SendVoiceMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/sms-voice/voice/message"
    }
}

/// SendVoiceMessageRequest
public struct SendVoiceMessageInput: Swift.Equatable {
    /// The phone number that appears on recipients' devices when they receive the message.
    public var callerId: Swift.String?
    /// The name of the configuration set that you want to use to send the message.
    public var configurationSetName: Swift.String?
    /// An object that contains a voice message and information about the recipient that you want to send it to.
    public var content: PinpointSmsVoiceClientTypes.VoiceMessageContent?
    /// The phone number that you want to send the voice message to.
    public var destinationPhoneNumber: Swift.String?
    /// The phone number that Amazon Pinpoint should use to send the voice message. This isn't necessarily the phone number that appears on recipients' devices when they receive the message, because you can specify a CallerId parameter in the request.
    public var originationPhoneNumber: Swift.String?

    public init (
        callerId: Swift.String? = nil,
        configurationSetName: Swift.String? = nil,
        content: PinpointSmsVoiceClientTypes.VoiceMessageContent? = nil,
        destinationPhoneNumber: Swift.String? = nil,
        originationPhoneNumber: Swift.String? = nil
    )
    {
        self.callerId = callerId
        self.configurationSetName = configurationSetName
        self.content = content
        self.destinationPhoneNumber = destinationPhoneNumber
        self.originationPhoneNumber = originationPhoneNumber
    }
}

struct SendVoiceMessageInputBody: Swift.Equatable {
    let callerId: Swift.String?
    let configurationSetName: Swift.String?
    let content: PinpointSmsVoiceClientTypes.VoiceMessageContent?
    let destinationPhoneNumber: Swift.String?
    let originationPhoneNumber: Swift.String?
}

extension SendVoiceMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerId)
        callerId = callerIdDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.VoiceMessageContent.self, forKey: .content)
        content = contentDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationPhoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originationPhoneNumber)
        originationPhoneNumber = originationPhoneNumberDecoded
    }
}

extension SendVoiceMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendVoiceMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendVoiceMessageOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendVoiceMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendVoiceMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// An object that that contains the Message ID of a Voice message that was sent successfully.
public struct SendVoiceMessageOutputResponse: Swift.Equatable {
    /// A unique identifier for the voice message.
    public var messageId: Swift.String?

    public init (
        messageId: Swift.String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendVoiceMessageOutputResponseBody: Swift.Equatable {
    let messageId: Swift.String?
}

extension SendVoiceMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension PinpointSmsVoiceClientTypes.SnsDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public struct SnsDestination: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
        public var topicArn: Swift.String?

        public init (
            topicArn: Swift.String? = nil
        )
        {
            self.topicArn = topicArn
        }
    }

}

extension TooManyRequestsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've issued too many requests to the resource. Wait a few minutes, and then try again.
public struct TooManyRequestsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateConfigurationSetEventDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

extension UpdateConfigurationSetEventDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configurationSetName = configurationSetName else {
            return nil
        }
        guard let eventDestinationName = eventDestinationName else {
            return nil
        }
        return "/v1/sms-voice/configuration-sets/\(configurationSetName.urlPercentEncoding())/event-destinations/\(eventDestinationName.urlPercentEncoding())"
    }
}

/// UpdateConfigurationSetEventDestinationRequest
public struct UpdateConfigurationSetEventDestinationInput: Swift.Equatable {
    /// ConfigurationSetName
    /// This member is required.
    public var configurationSetName: Swift.String?
    /// An object that defines a single event destination.
    public var eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition?
    /// EventDestinationName
    /// This member is required.
    public var eventDestinationName: Swift.String?

    public init (
        configurationSetName: Swift.String? = nil,
        eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition? = nil,
        eventDestinationName: Swift.String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Swift.Equatable {
    let eventDestination: PinpointSmsVoiceClientTypes.EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventDestination = "EventDestination"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was updated successfully.
public struct UpdateConfigurationSetEventDestinationOutputResponse: Swift.Equatable {

}

extension PinpointSmsVoiceClientTypes.VoiceMessageContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case callInstructionsMessage = "CallInstructionsMessage"
        case plainTextMessage = "PlainTextMessage"
        case sSMLMessage = "SSMLMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callInstructionsMessage = callInstructionsMessage {
            try encodeContainer.encode(callInstructionsMessage, forKey: .callInstructionsMessage)
        }
        if let plainTextMessage = plainTextMessage {
            try encodeContainer.encode(plainTextMessage, forKey: .plainTextMessage)
        }
        if let sSMLMessage = sSMLMessage {
            try encodeContainer.encode(sSMLMessage, forKey: .sSMLMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callInstructionsMessageDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.CallInstructionsMessageType.self, forKey: .callInstructionsMessage)
        callInstructionsMessage = callInstructionsMessageDecoded
        let plainTextMessageDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.PlainTextMessageType.self, forKey: .plainTextMessage)
        plainTextMessage = plainTextMessageDecoded
        let sSMLMessageDecoded = try containerValues.decodeIfPresent(PinpointSmsVoiceClientTypes.SSMLMessageType.self, forKey: .sSMLMessage)
        sSMLMessage = sSMLMessageDecoded
    }
}

extension PinpointSmsVoiceClientTypes {
    /// An object that contains a voice message and information about the recipient that you want to send it to.
    public struct VoiceMessageContent: Swift.Equatable {
        /// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
        public var callInstructionsMessage: PinpointSmsVoiceClientTypes.CallInstructionsMessageType?
        /// An object that defines a message that contains unformatted text.
        public var plainTextMessage: PinpointSmsVoiceClientTypes.PlainTextMessageType?
        /// An object that defines a message that contains SSML-formatted text.
        public var sSMLMessage: PinpointSmsVoiceClientTypes.SSMLMessageType?

        public init (
            callInstructionsMessage: PinpointSmsVoiceClientTypes.CallInstructionsMessageType? = nil,
            plainTextMessage: PinpointSmsVoiceClientTypes.PlainTextMessageType? = nil,
            sSMLMessage: PinpointSmsVoiceClientTypes.SSMLMessageType? = nil
        )
        {
            self.callInstructionsMessage = callInstructionsMessage
            self.plainTextMessage = plainTextMessage
            self.sSMLMessage = sSMLMessage
        }
    }

}
