// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ActionDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case publishMetricAction = "PublishMetricAction"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let publishMetricAction = publishMetricAction {
            try encodeContainer.encode(publishMetricAction, forKey: .publishMetricAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publishMetricActionDecoded = try containerValues.decodeIfPresent(PublishMetricAction.self, forKey: .publishMetricAction)
        publishMetricAction = publishMetricActionDecoded
    }
}

extension ActionDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionDefinition(publishMetricAction: \(String(describing: publishMetricAction)))"}
}

/// <p>A custom action to use in stateless rule actions settings. This is used in <a>CustomAction</a>.</p>
public struct ActionDefinition: Equatable {
    /// <p>Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the
    ///          matching packet. This setting defines a CloudWatch dimension value to be published.</p>
    ///          <p>You can pair this custom action with any of the standard stateless rule actions. For
    ///          example, you could pair this in a rule action with the standard action that forwards the
    ///          packet for stateful inspection. Then, when a packet matches the rule, Network Firewall
    ///          publishes metrics for the packet and forwards it. </p>
    public let publishMetricAction: PublishMetricAction?

    public init (
        publishMetricAction: PublishMetricAction? = nil
    )
    {
        self.publishMetricAction = publishMetricAction
    }
}

extension Address: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressDefinition = "AddressDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressDefinition = addressDefinition {
            try encodeContainer.encode(addressDefinition, forKey: .addressDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressDefinition)
        addressDefinition = addressDefinitionDecoded
    }
}

extension Address: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Address(addressDefinition: \(String(describing: addressDefinition)))"}
}

/// <p>A single IP address specification. This is used in the <a>MatchAttributes</a>
///          source and destination specifications.</p>
public struct Address: Equatable {
    /// <p>Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let addressDefinition: String?

    public init (
        addressDefinition: String? = nil
    )
    {
        self.addressDefinition = addressDefinition
    }
}

public struct AssociateFirewallPolicyInputBodyMiddleware: Middleware {
    public let id: String = "AssociateFirewallPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<AssociateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallPolicyOutputError>
}

extension AssociateFirewallPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFirewallPolicyInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), updateToken: \(String(describing: updateToken)))"}
}

extension AssociateFirewallPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct AssociateFirewallPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateFirewallPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<AssociateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallPolicyOutputError>
}

public struct AssociateFirewallPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateFirewallPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<AssociateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateFirewallPolicyOutputError>
}

public struct AssociateFirewallPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    public let firewallPolicyArn: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        firewallPolicyArn: String? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.firewallPolicyArn = firewallPolicyArn
        self.updateToken = updateToken
    }
}

struct AssociateFirewallPolicyInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let firewallPolicyArn: String?
}

extension AssociateFirewallPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
    }
}

extension AssociateFirewallPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFirewallPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFirewallPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFirewallPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateFirewallPolicyOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), updateToken: \(String(describing: updateToken)))"}
}

extension AssociateFirewallPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateFirewallPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.firewallPolicyArn = output.firewallPolicyArn
            self.updateToken = output.updateToken
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.firewallPolicyArn = nil
            self.updateToken = nil
        }
    }
}

public struct AssociateFirewallPolicyOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    public let firewallPolicyArn: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        firewallPolicyArn: String? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.firewallPolicyArn = firewallPolicyArn
        self.updateToken = updateToken
    }
}

struct AssociateFirewallPolicyOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let firewallPolicyArn: String?
    public let updateToken: String?
}

extension AssociateFirewallPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

public struct AssociateSubnetsInputBodyMiddleware: Middleware {
    public let id: String = "AssociateSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSubnetsInput>
    public typealias MOutput = OperationOutput<AssociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSubnetsOutputError>
}

extension AssociateSubnetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSubnetsInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetMappings: \(String(describing: subnetMappings)), updateToken: \(String(describing: updateToken)))"}
}

extension AssociateSubnetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetMappings = "SubnetMappings"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetMappings)
            for subnetmappings0 in subnetMappings {
                try subnetMappingsContainer.encode(subnetmappings0)
            }
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct AssociateSubnetsInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSubnetsInput>
    public typealias MOutput = OperationOutput<AssociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSubnetsOutputError>
}

public struct AssociateSubnetsInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateSubnetsInput>
    public typealias MOutput = OperationOutput<AssociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateSubnetsOutputError>
}

public struct AssociateSubnetsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>The IDs of the subnets that you want to associate with the firewall. </p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetMappings: [SubnetMapping]? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetMappings = subnetMappings
        self.updateToken = updateToken
    }
}

struct AssociateSubnetsInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetMappings: [SubnetMapping]?
}

extension AssociateSubnetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetMappings = "SubnetMappings"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SubnetMapping?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SubnetMapping]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SubnetMapping]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
    }
}

extension AssociateSubnetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSubnetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSubnetsOutputError: Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSubnetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateSubnetsOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetMappings: \(String(describing: subnetMappings)), updateToken: \(String(describing: updateToken)))"}
}

extension AssociateSubnetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.subnetMappings = output.subnetMappings
            self.updateToken = output.updateToken
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.subnetMappings = nil
            self.updateToken = nil
        }
    }
}

public struct AssociateSubnetsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetMappings: [SubnetMapping]? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetMappings = subnetMappings
        self.updateToken = updateToken
    }
}

struct AssociateSubnetsOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetMappings: [SubnetMapping]?
    public let updateToken: String?
}

extension AssociateSubnetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetMappings = "SubnetMappings"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SubnetMapping?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SubnetMapping]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SubnetMapping]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension Attachment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointId = "EndpointId"
        case status = "Status"
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointId = endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AttachmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Attachment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attachment(endpointId: \(String(describing: endpointId)), status: \(String(describing: status)), subnetId: \(String(describing: subnetId)))"}
}

/// <p>The configuration and status for a single subnet that you've specified for use by the
///          AWS Network Firewall firewall. This is part of the <a>FirewallStatus</a>.</p>
public struct Attachment: Equatable {
    /// <p>The identifier of the firewall endpoint that Network Firewall has instantiated in the
    ///          subnet. You use this to identify the firewall endpoint in the VPC route tables, when you
    ///          redirect the VPC traffic through the endpoint. </p>
    public let endpointId: String?
    /// <p>The current status of the firewall endpoint in the subnet. This value reflects both the
    ///          instantiation of the endpoint in the VPC subnet and the sync states that are reported in
    ///          the <code>Config</code> settings. When this value is <code>READY</code>, the endpoint is
    ///          available and configured properly to handle network traffic. When the endpoint isn't
    ///          available for traffic, this value will reflect its state, for example
    ///          <code>CREATING</code>, <code>DELETING</code>, or <code>FAILED</code>.</p>
    public let status: AttachmentStatus?
    /// <p>The unique identifier of the subnet that you've specified to be used for a firewall
    ///          endpoint. </p>
    public let subnetId: String?

    public init (
        endpointId: String? = nil,
        status: AttachmentStatus? = nil,
        subnetId: String? = nil
    )
    {
        self.endpointId = endpointId
        self.status = status
        self.subnetId = subnetId
    }
}

public enum AttachmentStatus {
    case creating
    case deleting
    case ready
    case scaling
    case sdkUnknown(String)
}

extension AttachmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttachmentStatus] {
        return [
            .creating,
            .deleting,
            .ready,
            .scaling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .ready: return "READY"
        case .scaling: return "SCALING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttachmentStatus(rawValue: rawValue) ?? AttachmentStatus.sdkUnknown(rawValue)
    }
}

public enum ConfigurationSyncState {
    case inSync
    case pending
    case sdkUnknown(String)
}

extension ConfigurationSyncState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationSyncState] {
        return [
            .inSync,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inSync: return "IN_SYNC"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationSyncState(rawValue: rawValue) ?? ConfigurationSyncState.sdkUnknown(rawValue)
    }
}

public struct CreateFirewallInputBodyMiddleware: Middleware {
    public let id: String = "CreateFirewallInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallInput>
    public typealias MOutput = OperationOutput<CreateFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallOutputError>
}

extension CreateFirewallInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallInput(deleteProtection: \(String(describing: deleteProtection)), description: \(String(describing: description)), firewallName: \(String(describing: firewallName)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyChangeProtection: \(String(describing: firewallPolicyChangeProtection)), subnetChangeProtection: \(String(describing: subnetChangeProtection)), subnetMappings: \(String(describing: subnetMappings)), tags: \(String(describing: tags)), vpcId: \(String(describing: vpcId)))"}
}

extension CreateFirewallInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case description = "Description"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case subnetChangeProtection = "SubnetChangeProtection"
        case subnetMappings = "SubnetMappings"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteProtection != false {
            try encodeContainer.encode(deleteProtection, forKey: .deleteProtection)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if firewallPolicyChangeProtection != false {
            try encodeContainer.encode(firewallPolicyChangeProtection, forKey: .firewallPolicyChangeProtection)
        }
        if subnetChangeProtection != false {
            try encodeContainer.encode(subnetChangeProtection, forKey: .subnetChangeProtection)
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetMappings)
            for subnetmappings0 in subnetMappings {
                try subnetMappingsContainer.encode(subnetmappings0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }
}

public struct CreateFirewallInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFirewallInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallInput>
    public typealias MOutput = OperationOutput<CreateFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallOutputError>
}

public struct CreateFirewallInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFirewallInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallInput>
    public typealias MOutput = OperationOutput<CreateFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallOutputError>
}

public struct CreateFirewallInput: Equatable {
    /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates
    ///          that the firewall is protected against deletion. Use this setting to protect against
    ///          accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
    public let deleteProtection: Bool
    /// <p>A description of the firewall.</p>
    public let description: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>The Amazon Resource Name (ARN) of the <a>FirewallPolicy</a> that you want to
    ///          use for the firewall.</p>
    public let firewallPolicyArn: String?
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
    ///          Use this setting to protect against
    ///          accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let firewallPolicyChangeProtection: Bool
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
    ///          Use this setting to protect against
    ///          accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let subnetChangeProtection: Bool
    /// <p>The public subnets to use for your Network Firewall firewalls. Each subnet must belong to a
    ///          different Availability Zone in the VPC. Network Firewall creates a firewall endpoint in each
    ///          subnet. </p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>The key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?
    /// <p>The unique identifier of the VPC where Network Firewall should create the firewall. </p>
    ///          <p>You can't change this setting after you create the firewall. </p>
    public let vpcId: String?

    public init (
        deleteProtection: Bool = false,
        description: String? = nil,
        firewallName: String? = nil,
        firewallPolicyArn: String? = nil,
        firewallPolicyChangeProtection: Bool = false,
        subnetChangeProtection: Bool = false,
        subnetMappings: [SubnetMapping]? = nil,
        tags: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.deleteProtection = deleteProtection
        self.description = description
        self.firewallName = firewallName
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
        self.subnetChangeProtection = subnetChangeProtection
        self.subnetMappings = subnetMappings
        self.tags = tags
        self.vpcId = vpcId
    }
}

struct CreateFirewallInputBody: Equatable {
    public let firewallName: String?
    public let firewallPolicyArn: String?
    public let vpcId: String?
    public let subnetMappings: [SubnetMapping]?
    public let deleteProtection: Bool
    public let subnetChangeProtection: Bool
    public let firewallPolicyChangeProtection: Bool
    public let description: String?
    public let tags: [Tag]?
}

extension CreateFirewallInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case description = "Description"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case subnetChangeProtection = "SubnetChangeProtection"
        case subnetMappings = "SubnetMappings"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SubnetMapping?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SubnetMapping]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SubnetMapping]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
        let deleteProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deleteProtection)
        deleteProtection = deleteProtectionDecoded
        let subnetChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .subnetChangeProtection)
        subnetChangeProtection = subnetChangeProtectionDecoded
        let firewallPolicyChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .firewallPolicyChangeProtection)
        firewallPolicyChangeProtection = firewallPolicyChangeProtectionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFirewallOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallOutputError: Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallOutputResponse(firewall: \(String(describing: firewall)), firewallStatus: \(String(describing: firewallStatus)))"}
}

extension CreateFirewallOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFirewallOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewall = output.firewall
            self.firewallStatus = output.firewallStatus
        } else {
            self.firewall = nil
            self.firewallStatus = nil
        }
    }
}

public struct CreateFirewallOutputResponse: Equatable {
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    public let firewall: Firewall?
    /// <p>Detailed information about the current status of a <a>Firewall</a>. You can retrieve this for a firewall by calling <a>DescribeFirewall</a> and providing the firewall name and ARN.</p>
    public let firewallStatus: FirewallStatus?

    public init (
        firewall: Firewall? = nil,
        firewallStatus: FirewallStatus? = nil
    )
    {
        self.firewall = firewall
        self.firewallStatus = firewallStatus
    }
}

struct CreateFirewallOutputResponseBody: Equatable {
    public let firewall: Firewall?
    public let firewallStatus: FirewallStatus?
}

extension CreateFirewallOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewall = "Firewall"
        case firewallStatus = "FirewallStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDecoded = try containerValues.decodeIfPresent(Firewall.self, forKey: .firewall)
        firewall = firewallDecoded
        let firewallStatusDecoded = try containerValues.decodeIfPresent(FirewallStatus.self, forKey: .firewallStatus)
        firewallStatus = firewallStatusDecoded
    }
}

public struct CreateFirewallPolicyInputBodyMiddleware: Middleware {
    public let id: String = "CreateFirewallPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<CreateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallPolicyOutputError>
}

extension CreateFirewallPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallPolicyInput(description: \(String(describing: description)), dryRun: \(String(describing: dryRun)), firewallPolicy: \(String(describing: firewallPolicy)), firewallPolicyName: \(String(describing: firewallPolicyName)), tags: \(String(describing: tags)))"}
}

extension CreateFirewallPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyName = "FirewallPolicyName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let firewallPolicy = firewallPolicy {
            try encodeContainer.encode(firewallPolicy, forKey: .firewallPolicy)
        }
        if let firewallPolicyName = firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateFirewallPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFirewallPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<CreateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallPolicyOutputError>
}

public struct CreateFirewallPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFirewallPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<CreateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFirewallPolicyOutputError>
}

public struct CreateFirewallPolicyInput: Equatable {
    /// <p>A description of the firewall policy.</p>
    public let description: String?
    /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
    ///          <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
    ///          but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
    ///          dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
    ///          the required permissions to run the request and that your request parameters are valid. </p>
    ///          <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
    public let dryRun: Bool
    /// <p>The rule groups and policy actions to use in the firewall policy.</p>
    public let firewallPolicy: FirewallPolicy?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    public let firewallPolicyName: String?
    /// <p>The key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        dryRun: Bool = false,
        firewallPolicy: FirewallPolicy? = nil,
        firewallPolicyName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.dryRun = dryRun
        self.firewallPolicy = firewallPolicy
        self.firewallPolicyName = firewallPolicyName
        self.tags = tags
    }
}

struct CreateFirewallPolicyInputBody: Equatable {
    public let firewallPolicyName: String?
    public let firewallPolicy: FirewallPolicy?
    public let description: String?
    public let tags: [Tag]?
    public let dryRun: Bool
}

extension CreateFirewallPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyName = "FirewallPolicyName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let firewallPolicyDecoded = try containerValues.decodeIfPresent(FirewallPolicy.self, forKey: .firewallPolicy)
        firewallPolicy = firewallPolicyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateFirewallPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFirewallPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFirewallPolicyOutputError: Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFirewallPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFirewallPolicyOutputResponse(firewallPolicyResponse: \(String(describing: firewallPolicyResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension CreateFirewallPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFirewallPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallPolicyResponse = output.firewallPolicyResponse
            self.updateToken = output.updateToken
        } else {
            self.firewallPolicyResponse = nil
            self.updateToken = nil
        }
    }
}

public struct CreateFirewallPolicyOutputResponse: Equatable {
    /// <p>The high-level properties of a firewall policy. This, along with the <a>FirewallPolicy</a>, define the policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>. </p>
    public let firewallPolicyResponse: FirewallPolicyResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    ///          <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallPolicyResponse: FirewallPolicyResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallPolicyResponse = firewallPolicyResponse
        self.updateToken = updateToken
    }
}

struct CreateFirewallPolicyOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewallPolicyResponse: FirewallPolicyResponse?
}

extension CreateFirewallPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyResponse = "FirewallPolicyResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallPolicyResponseDecoded = try containerValues.decodeIfPresent(FirewallPolicyResponse.self, forKey: .firewallPolicyResponse)
        firewallPolicyResponse = firewallPolicyResponseDecoded
    }
}

public struct CreateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

extension CreateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupInput(capacity: \(String(describing: capacity)), description: \(String(describing: description)), dryRun: \(String(describing: dryRun)), ruleGroup: \(String(describing: ruleGroup)), ruleGroupName: \(String(describing: ruleGroupName)), rules: \(String(describing: rules)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
        case description = "Description"
        case dryRun = "DryRun"
        case ruleGroup = "RuleGroup"
        case ruleGroupName = "RuleGroupName"
        case rules = "Rules"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let ruleGroup = ruleGroup {
            try encodeContainer.encode(ruleGroup, forKey: .ruleGroup)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let rules = rules {
            try encodeContainer.encode(rules, forKey: .rules)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRuleGroupInput>
    public typealias MOutput = OperationOutput<CreateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRuleGroupOutputError>
}

public struct CreateRuleGroupInput: Equatable {
    /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation.
    ///       When you update a rule group, you are limited to this capacity. When you reference a rule group
    ///       from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
    ///          <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling
    ///       <a>CreateRuleGroup</a> with <code>DryRun</code> set to <code>TRUE</code>. </p>
    ///          <note>
    ///             <p>You can't change or exceed this capacity when you update the rule group, so leave
    ///             room for your rule group to grow. </p>
    ///          </note>
    ///          <p>
    ///             <b>Capacity for a stateless rule group</b>
    ///          </p>
    ///          <p>For a stateless rule group, the capacity required is the sum of the capacity
    ///          requirements of the individual rules that you expect to have in the rule group. </p>
    ///          <p>To calculate the capacity requirement of a single rule, multiply the capacity
    ///          requirement values of each of the rule's match settings:</p>
    ///          <ul>
    ///             <li>
    ///                <p>A match setting with no criteria specified has a value of 1. </p>
    ///             </li>
    ///             <li>
    ///                <p>A match setting with <code>Any</code> specified has a value of 1. </p>
    ///             </li>
    ///             <li>
    ///                <p>All other match settings have a value equal to the number of elements provided in
    ///                the setting. For example, a protocol setting ["UDP"] and a source setting
    ///                ["10.0.0.0/24"] each have a value of 1. A protocol setting ["UDP","TCP"] has a value
    ///                of 2. A source setting ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"] has a value of 3.
    ///             </p>
    ///             </li>
    ///          </ul>
    ///          <p>A rule with no criteria specified in any of its match settings has a capacity
    ///          requirement of 1. A rule with protocol setting ["UDP","TCP"], source setting
    ///          ["10.0.0.0/24","10.0.0.1/24","10.0.0.2/24"], and a single specification or no specification
    ///          for each of the other match settings has a capacity requirement of 6. </p>
    ///          <p>
    ///             <b>Capacity for a stateful rule group</b>
    ///          </p>
    ///          <p>For
    ///          a stateful rule group, the minimum capacity required is the number of individual rules that
    ///          you expect to have in the rule group. </p>
    public let capacity: Int?
    /// <p>A description of the rule group. </p>
    public let description: String?
    /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
    ///          <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
    ///          but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
    ///          dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
    ///          the required permissions to run the request and that your request parameters are valid. </p>
    ///          <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
    public let dryRun: Bool
    /// <p>An object that defines the rule group rules. </p>
    ///          <note>
    ///             <p>You must provide either this rule group setting or a <code>Rules</code> setting, but not both. </p>
    ///          </note>
    public let ruleGroup: RuleGroup?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    public let ruleGroupName: String?
    /// <p>A string containing stateful rule group rules specifications in Suricata flat format, with one rule
    /// per line. Use this to import your existing Suricata compatible rule groups. </p>
    ///          <note>
    ///             <p>You must provide either this rules setting or a populated <code>RuleGroup</code> setting, but not both. </p>
    ///          </note>
    ///          <p>You can provide your rule group specification in Suricata flat format through this setting when you create or update your rule group. The call
    /// response returns a <a>RuleGroup</a> object that Network Firewall has populated from your string. </p>
    public let rules: String?
    /// <p>The key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
    /// stateless rules. If it is stateful, it contains stateful rules. </p>
    public let type: RuleGroupType?

    public init (
        capacity: Int? = nil,
        description: String? = nil,
        dryRun: Bool = false,
        ruleGroup: RuleGroup? = nil,
        ruleGroupName: String? = nil,
        rules: String? = nil,
        tags: [Tag]? = nil,
        type: RuleGroupType? = nil
    )
    {
        self.capacity = capacity
        self.description = description
        self.dryRun = dryRun
        self.ruleGroup = ruleGroup
        self.ruleGroupName = ruleGroupName
        self.rules = rules
        self.tags = tags
        self.type = type
    }
}

struct CreateRuleGroupInputBody: Equatable {
    public let ruleGroupName: String?
    public let ruleGroup: RuleGroup?
    public let rules: String?
    public let type: RuleGroupType?
    public let description: String?
    public let capacity: Int?
    public let tags: [Tag]?
    public let dryRun: Bool
}

extension CreateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
        case description = "Description"
        case dryRun = "DryRun"
        case ruleGroup = "RuleGroup"
        case ruleGroupName = "RuleGroupName"
        case rules = "Rules"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let rulesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rules)
        rules = rulesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RuleGroupType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let capacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientCapacityException" : self = .insufficientCapacityException(try InsufficientCapacityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRuleGroupOutputError: Equatable {
    case insufficientCapacityException(InsufficientCapacityException)
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRuleGroupOutputResponse(ruleGroupResponse: \(String(describing: ruleGroupResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension CreateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleGroupResponse = output.ruleGroupResponse
            self.updateToken = output.updateToken
        } else {
            self.ruleGroupResponse = nil
            self.updateToken = nil
        }
    }
}

public struct CreateRuleGroupOutputResponse: Equatable {
    /// <p>The high-level properties of a rule group. This, along with the <a>RuleGroup</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
    public let ruleGroupResponse: RuleGroupResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    ///          <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        ruleGroupResponse: RuleGroupResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.ruleGroupResponse = ruleGroupResponse
        self.updateToken = updateToken
    }
}

struct CreateRuleGroupOutputResponseBody: Equatable {
    public let updateToken: String?
    public let ruleGroupResponse: RuleGroupResponse?
}

extension CreateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupResponse = "RuleGroupResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let ruleGroupResponseDecoded = try containerValues.decodeIfPresent(RuleGroupResponse.self, forKey: .ruleGroupResponse)
        ruleGroupResponse = ruleGroupResponseDecoded
    }
}

extension CustomAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionDefinition = "ActionDefinition"
        case actionName = "ActionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionDefinition = actionDefinition {
            try encodeContainer.encode(actionDefinition, forKey: .actionDefinition)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionDefinitionDecoded = try containerValues.decodeIfPresent(ActionDefinition.self, forKey: .actionDefinition)
        actionDefinition = actionDefinitionDecoded
    }
}

extension CustomAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomAction(actionDefinition: \(String(describing: actionDefinition)), actionName: \(String(describing: actionName)))"}
}

/// <p>An optional, non-standard action to use for stateless packet handling. You can define
///          this in addition to the standard action that you must specify. </p>
///          <p>You define and name the custom actions that you want to be able to use, and then you
///          reference them by name in your actions settings. </p>
///          <p>You can use custom actions in the following places: </p>
///          <ul>
///             <li>
///                <p>In a rule group's <a>StatelessRulesAndCustomActions</a> specification.
///                The custom actions are available for use by name inside the
///                   <code>StatelessRulesAndCustomActions</code> where you define them. You can use
///                them for your stateless rule actions to specify what to do with a packet that matches
///                the rule's match attributes. </p>
///             </li>
///             <li>
///                <p>In a <a>FirewallPolicy</a> specification, in
///                   <code>StatelessCustomActions</code>. The custom actions are available for use
///                inside the policy where you define them. You can use them for the policy's default
///                stateless actions settings to specify what to do with packets that don't match any of
///                the policy's stateless rules. </p>
///             </li>
///          </ul>
public struct CustomAction: Equatable {
    /// <p>The custom action associated with the action name.</p>
    public let actionDefinition: ActionDefinition?
    /// <p>The descriptive name of the custom action. You can't change the name of a custom action after you create it.</p>
    public let actionName: String?

    public init (
        actionDefinition: ActionDefinition? = nil,
        actionName: String? = nil
    )
    {
        self.actionDefinition = actionDefinition
        self.actionName = actionName
    }
}

public struct DeleteFirewallInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallInput>
    public typealias MOutput = OperationOutput<DeleteFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallOutputError>
}

extension DeleteFirewallInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)))"}
}

extension DeleteFirewallInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
    }
}

public struct DeleteFirewallInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallInput>
    public typealias MOutput = OperationOutput<DeleteFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallOutputError>
}

public struct DeleteFirewallInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallInput>
    public typealias MOutput = OperationOutput<DeleteFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallOutputError>
}

public struct DeleteFirewallInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
    }
}

struct DeleteFirewallInputBody: Equatable {
    public let firewallName: String?
    public let firewallArn: String?
}

extension DeleteFirewallInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
    }
}

extension DeleteFirewallOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallOutputResponse(firewall: \(String(describing: firewall)), firewallStatus: \(String(describing: firewallStatus)))"}
}

extension DeleteFirewallOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewall = output.firewall
            self.firewallStatus = output.firewallStatus
        } else {
            self.firewall = nil
            self.firewallStatus = nil
        }
    }
}

public struct DeleteFirewallOutputResponse: Equatable {
    /// <p>The firewall defines the configuration settings for an AWS Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall AWS resource. </p>
    ///          <p>The status of the firewall, for example whether it's ready to filter network traffic,
    ///          is provided in the corresponding <a>FirewallStatus</a>. You can retrieve both
    ///          objects by calling <a>DescribeFirewall</a>.</p>
    public let firewall: Firewall?
    /// <p>Detailed information about the current status of a <a>Firewall</a>. You can retrieve this for a firewall by calling <a>DescribeFirewall</a> and providing the firewall name and ARN.</p>
    public let firewallStatus: FirewallStatus?

    public init (
        firewall: Firewall? = nil,
        firewallStatus: FirewallStatus? = nil
    )
    {
        self.firewall = firewall
        self.firewallStatus = firewallStatus
    }
}

struct DeleteFirewallOutputResponseBody: Equatable {
    public let firewall: Firewall?
    public let firewallStatus: FirewallStatus?
}

extension DeleteFirewallOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewall = "Firewall"
        case firewallStatus = "FirewallStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallDecoded = try containerValues.decodeIfPresent(Firewall.self, forKey: .firewall)
        firewall = firewallDecoded
        let firewallStatusDecoded = try containerValues.decodeIfPresent(FirewallStatus.self, forKey: .firewallStatus)
        firewallStatus = firewallStatusDecoded
    }
}

public struct DeleteFirewallPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteFirewallPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DeleteFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallPolicyOutputError>
}

extension DeleteFirewallPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallPolicyInput(firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyName: \(String(describing: firewallPolicyName)))"}
}

extension DeleteFirewallPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let firewallPolicyName = firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
    }
}

public struct DeleteFirewallPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFirewallPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DeleteFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallPolicyOutputError>
}

public struct DeleteFirewallPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFirewallPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DeleteFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFirewallPolicyOutputError>
}

public struct DeleteFirewallPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyArn: String?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyName: String?

    public init (
        firewallPolicyArn: String? = nil,
        firewallPolicyName: String? = nil
    )
    {
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyName = firewallPolicyName
    }
}

struct DeleteFirewallPolicyInputBody: Equatable {
    public let firewallPolicyName: String?
    public let firewallPolicyArn: String?
}

extension DeleteFirewallPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
    }
}

extension DeleteFirewallPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFirewallPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFirewallPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFirewallPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFirewallPolicyOutputResponse(firewallPolicyResponse: \(String(describing: firewallPolicyResponse)))"}
}

extension DeleteFirewallPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteFirewallPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallPolicyResponse = output.firewallPolicyResponse
        } else {
            self.firewallPolicyResponse = nil
        }
    }
}

public struct DeleteFirewallPolicyOutputResponse: Equatable {
    /// <p>The object containing the definition of the <a>FirewallPolicyResponse</a>
    ///          that you asked to delete. </p>
    public let firewallPolicyResponse: FirewallPolicyResponse?

    public init (
        firewallPolicyResponse: FirewallPolicyResponse? = nil
    )
    {
        self.firewallPolicyResponse = firewallPolicyResponse
    }
}

struct DeleteFirewallPolicyOutputResponseBody: Equatable {
    public let firewallPolicyResponse: FirewallPolicyResponse?
}

extension DeleteFirewallPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyResponse = "FirewallPolicyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyResponseDecoded = try containerValues.decodeIfPresent(FirewallPolicyResponse.self, forKey: .firewallPolicyResponse)
        firewallPolicyResponse = firewallPolicyResponseDecoded
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group or firewall policy whose resource policy you want to delete. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DeleteResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

extension DeleteRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupInput(ruleGroupArn: \(String(describing: ruleGroupArn)), ruleGroupName: \(String(describing: ruleGroupName)), type: \(String(describing: type)))"}
}

extension DeleteRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleGroupArn = ruleGroupArn {
            try encodeContainer.encode(ruleGroupArn, forKey: .ruleGroupArn)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DeleteRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleGroupInput>
    public typealias MOutput = OperationOutput<DeleteRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleGroupOutputError>
}

public struct DeleteRuleGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupArn: String?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupName: String?
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
    /// stateless rules. If it is stateful, it contains stateful rules. </p>
    ///          <note>
    ///             <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
    ///          </note>
    public let type: RuleGroupType?

    public init (
        ruleGroupArn: String? = nil,
        ruleGroupName: String? = nil,
        type: RuleGroupType? = nil
    )
    {
        self.ruleGroupArn = ruleGroupArn
        self.ruleGroupName = ruleGroupName
        self.type = type
    }
}

struct DeleteRuleGroupInputBody: Equatable {
    public let ruleGroupName: String?
    public let ruleGroupArn: String?
    public let type: RuleGroupType?
}

extension DeleteRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let ruleGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupArn)
        ruleGroupArn = ruleGroupArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RuleGroupType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DeleteRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleGroupOutputResponse(ruleGroupResponse: \(String(describing: ruleGroupResponse)))"}
}

extension DeleteRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleGroupResponse = output.ruleGroupResponse
        } else {
            self.ruleGroupResponse = nil
        }
    }
}

public struct DeleteRuleGroupOutputResponse: Equatable {
    /// <p>The high-level properties of a rule group. This, along with the <a>RuleGroup</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
    public let ruleGroupResponse: RuleGroupResponse?

    public init (
        ruleGroupResponse: RuleGroupResponse? = nil
    )
    {
        self.ruleGroupResponse = ruleGroupResponse
    }
}

struct DeleteRuleGroupOutputResponseBody: Equatable {
    public let ruleGroupResponse: RuleGroupResponse?
}

extension DeleteRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupResponse = "RuleGroupResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupResponseDecoded = try containerValues.decodeIfPresent(RuleGroupResponse.self, forKey: .ruleGroupResponse)
        ruleGroupResponse = ruleGroupResponseDecoded
    }
}

public struct DescribeFirewallInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFirewallInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallInput>
    public typealias MOutput = OperationOutput<DescribeFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallOutputError>
}

extension DescribeFirewallInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFirewallInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)))"}
}

extension DescribeFirewallInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
    }
}

public struct DescribeFirewallInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFirewallInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallInput>
    public typealias MOutput = OperationOutput<DescribeFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallOutputError>
}

public struct DescribeFirewallInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFirewallInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallInput>
    public typealias MOutput = OperationOutput<DescribeFirewallOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallOutputError>
}

public struct DescribeFirewallInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
    }
}

struct DescribeFirewallInputBody: Equatable {
    public let firewallName: String?
    public let firewallArn: String?
}

extension DescribeFirewallInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
    }
}

extension DescribeFirewallOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFirewallOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFirewallOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFirewallOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFirewallOutputResponse(firewall: \(String(describing: firewall)), firewallStatus: \(String(describing: firewallStatus)), updateToken: \(String(describing: updateToken)))"}
}

extension DescribeFirewallOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFirewallOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewall = output.firewall
            self.firewallStatus = output.firewallStatus
            self.updateToken = output.updateToken
        } else {
            self.firewall = nil
            self.firewallStatus = nil
            self.updateToken = nil
        }
    }
}

public struct DescribeFirewallOutputResponse: Equatable {
    /// <p>The configuration settings for the firewall. These settings include the firewall policy and the subnets in your VPC to use for the firewall endpoints. </p>
    public let firewall: Firewall?
    /// <p>Detailed information about the current status of a <a>Firewall</a>. You can retrieve this for a firewall by calling <a>DescribeFirewall</a> and providing the firewall name and ARN.</p>
    public let firewallStatus: FirewallStatus?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewall: Firewall? = nil,
        firewallStatus: FirewallStatus? = nil,
        updateToken: String? = nil
    )
    {
        self.firewall = firewall
        self.firewallStatus = firewallStatus
        self.updateToken = updateToken
    }
}

struct DescribeFirewallOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewall: Firewall?
    public let firewallStatus: FirewallStatus?
}

extension DescribeFirewallOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewall = "Firewall"
        case firewallStatus = "FirewallStatus"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallDecoded = try containerValues.decodeIfPresent(Firewall.self, forKey: .firewall)
        firewall = firewallDecoded
        let firewallStatusDecoded = try containerValues.decodeIfPresent(FirewallStatus.self, forKey: .firewallStatus)
        firewallStatus = firewallStatusDecoded
    }
}

public struct DescribeFirewallPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFirewallPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DescribeFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallPolicyOutputError>
}

extension DescribeFirewallPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFirewallPolicyInput(firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyName: \(String(describing: firewallPolicyName)))"}
}

extension DescribeFirewallPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let firewallPolicyName = firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
    }
}

public struct DescribeFirewallPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFirewallPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DescribeFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallPolicyOutputError>
}

public struct DescribeFirewallPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFirewallPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFirewallPolicyInput>
    public typealias MOutput = OperationOutput<DescribeFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFirewallPolicyOutputError>
}

public struct DescribeFirewallPolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyArn: String?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyName: String?

    public init (
        firewallPolicyArn: String? = nil,
        firewallPolicyName: String? = nil
    )
    {
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyName = firewallPolicyName
    }
}

struct DescribeFirewallPolicyInputBody: Equatable {
    public let firewallPolicyName: String?
    public let firewallPolicyArn: String?
}

extension DescribeFirewallPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
    }
}

extension DescribeFirewallPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFirewallPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFirewallPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFirewallPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFirewallPolicyOutputResponse(firewallPolicy: \(String(describing: firewallPolicy)), firewallPolicyResponse: \(String(describing: firewallPolicyResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension DescribeFirewallPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFirewallPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallPolicy = output.firewallPolicy
            self.firewallPolicyResponse = output.firewallPolicyResponse
            self.updateToken = output.updateToken
        } else {
            self.firewallPolicy = nil
            self.firewallPolicyResponse = nil
            self.updateToken = nil
        }
    }
}

public struct DescribeFirewallPolicyOutputResponse: Equatable {
    /// <p>The policy for the specified firewall policy. </p>
    public let firewallPolicy: FirewallPolicy?
    /// <p>The high-level properties of a firewall policy. This, along with the <a>FirewallPolicy</a>, define the policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>. </p>
    public let firewallPolicyResponse: FirewallPolicyResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    ///          <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallPolicy: FirewallPolicy? = nil,
        firewallPolicyResponse: FirewallPolicyResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallPolicy = firewallPolicy
        self.firewallPolicyResponse = firewallPolicyResponse
        self.updateToken = updateToken
    }
}

struct DescribeFirewallPolicyOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewallPolicyResponse: FirewallPolicyResponse?
    public let firewallPolicy: FirewallPolicy?
}

extension DescribeFirewallPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyResponse = "FirewallPolicyResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallPolicyResponseDecoded = try containerValues.decodeIfPresent(FirewallPolicyResponse.self, forKey: .firewallPolicyResponse)
        firewallPolicyResponse = firewallPolicyResponseDecoded
        let firewallPolicyDecoded = try containerValues.decodeIfPresent(FirewallPolicy.self, forKey: .firewallPolicy)
        firewallPolicy = firewallPolicyDecoded
    }
}

public struct DescribeLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingConfigurationOutputError>
}

extension DescribeLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingConfigurationInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)))"}
}

extension DescribeLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
    }
}

public struct DescribeLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingConfigurationOutputError>
}

public struct DescribeLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLoggingConfigurationOutputError>
}

public struct DescribeLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
    }
}

struct DescribeLoggingConfigurationInputBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
}

extension DescribeLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
    }
}

extension DescribeLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingConfigurationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLoggingConfigurationOutputResponse(firewallArn: \(String(describing: firewallArn)), loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension DescribeLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.firewallArn = nil
            self.loggingConfiguration = nil
        }
    }
}

public struct DescribeLoggingConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>Defines how AWS Network Firewall performs logging for a <a>Firewall</a>. </p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        firewallArn: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.firewallArn = firewallArn
        self.loggingConfiguration = loggingConfiguration
    }
}

struct DescribeLoggingConfigurationOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let loggingConfiguration: LoggingConfiguration?
}

extension DescribeLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct DescribeResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePolicyInput>
    public typealias MOutput = OperationOutput<DescribeResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePolicyOutputError>
}

extension DescribeResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePolicyInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension DescribeResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DescribeResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePolicyInput>
    public typealias MOutput = OperationOutput<DescribeResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePolicyOutputError>
}

public struct DescribeResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourcePolicyInput>
    public typealias MOutput = OperationOutput<DescribeResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourcePolicyOutputError>
}

public struct DescribeResourcePolicyInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group or firewall policy whose resource policy you want to retrieve. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct DescribeResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
}

extension DescribeResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension DescribeResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourcePolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourcePolicyOutputResponse(policy: \(String(describing: policy)))"}
}

extension DescribeResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
        } else {
            self.policy = nil
        }
    }
}

public struct DescribeResourcePolicyOutputResponse: Equatable {
    /// <p>The AWS Identity and Access Management policy for the resource. </p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

struct DescribeResourcePolicyOutputResponseBody: Equatable {
    public let policy: String?
}

extension DescribeResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct DescribeRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleGroupOutputError>
}

extension DescribeRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuleGroupInput(ruleGroupArn: \(String(describing: ruleGroupArn)), ruleGroupName: \(String(describing: ruleGroupName)), type: \(String(describing: type)))"}
}

extension DescribeRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleGroupArn = ruleGroupArn {
            try encodeContainer.encode(ruleGroupArn, forKey: .ruleGroupArn)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribeRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleGroupOutputError>
}

public struct DescribeRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleGroupInput>
    public typealias MOutput = OperationOutput<DescribeRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleGroupOutputError>
}

public struct DescribeRuleGroupInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupArn: String?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupName: String?
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
    /// stateless rules. If it is stateful, it contains stateful rules. </p>
    ///          <note>
    ///             <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
    ///          </note>
    public let type: RuleGroupType?

    public init (
        ruleGroupArn: String? = nil,
        ruleGroupName: String? = nil,
        type: RuleGroupType? = nil
    )
    {
        self.ruleGroupArn = ruleGroupArn
        self.ruleGroupName = ruleGroupName
        self.type = type
    }
}

struct DescribeRuleGroupInputBody: Equatable {
    public let ruleGroupName: String?
    public let ruleGroupArn: String?
    public let type: RuleGroupType?
}

extension DescribeRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let ruleGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupArn)
        ruleGroupArn = ruleGroupArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RuleGroupType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DescribeRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuleGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuleGroupOutputResponse(ruleGroup: \(String(describing: ruleGroup)), ruleGroupResponse: \(String(describing: ruleGroupResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension DescribeRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleGroup = output.ruleGroup
            self.ruleGroupResponse = output.ruleGroupResponse
            self.updateToken = output.updateToken
        } else {
            self.ruleGroup = nil
            self.ruleGroupResponse = nil
            self.updateToken = nil
        }
    }
}

public struct DescribeRuleGroupOutputResponse: Equatable {
    /// <p>The object that defines the rules in a rule group. This, along with <a>RuleGroupResponse</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
    ///          <p>AWS Network Firewall uses a rule group to inspect and control network traffic.
    ///     You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their
    ///     traffic flow. </p>
    ///          <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from
    ///     more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
    public let ruleGroup: RuleGroup?
    /// <p>The high-level properties of a rule group. This, along with the <a>RuleGroup</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
    public let ruleGroupResponse: RuleGroupResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    ///          <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        ruleGroup: RuleGroup? = nil,
        ruleGroupResponse: RuleGroupResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.ruleGroup = ruleGroup
        self.ruleGroupResponse = ruleGroupResponse
        self.updateToken = updateToken
    }
}

struct DescribeRuleGroupOutputResponseBody: Equatable {
    public let updateToken: String?
    public let ruleGroup: RuleGroup?
    public let ruleGroupResponse: RuleGroupResponse?
}

extension DescribeRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroup = "RuleGroup"
        case ruleGroupResponse = "RuleGroupResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let ruleGroupResponseDecoded = try containerValues.decodeIfPresent(RuleGroupResponse.self, forKey: .ruleGroupResponse)
        ruleGroupResponse = ruleGroupResponseDecoded
    }
}

extension Dimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Dimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dimension(value: \(String(describing: value)))"}
}

/// <p>The value to use in an Amazon CloudWatch custom metric dimension. This is used in the
///             <code>PublishMetrics</code>
///             <a>CustomAction</a>. A CloudWatch custom metric dimension is a name/value pair that's
///          part of the identity of a metric. </p>
///          <p>AWS Network Firewall sets the dimension name to <code>CustomAction</code> and you provide the
///          dimension value. </p>
///          <p>For more information about CloudWatch custom metric dimensions, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions">Publishing Custom Metrics</a> in the <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch User
///             Guide</a>.</p>
public struct Dimension: Equatable {
    /// <p>The value to use in the custom metric dimension.</p>
    public let value: String?

    public init (
        value: String? = nil
    )
    {
        self.value = value
    }
}

public struct DisassociateSubnetsInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateSubnetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSubnetsInput>
    public typealias MOutput = OperationOutput<DisassociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSubnetsOutputError>
}

extension DisassociateSubnetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSubnetsInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetIds: \(String(describing: subnetIds)), updateToken: \(String(describing: updateToken)))"}
}

extension DisassociateSubnetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetIds = "SubnetIds"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for azsubnets0 in subnetIds {
                try subnetIdsContainer.encode(azsubnets0)
            }
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct DisassociateSubnetsInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateSubnetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSubnetsInput>
    public typealias MOutput = OperationOutput<DisassociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSubnetsOutputError>
}

public struct DisassociateSubnetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateSubnetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateSubnetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateSubnetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateSubnetsInput>
    public typealias MOutput = OperationOutput<DisassociateSubnetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateSubnetsOutputError>
}

public struct DisassociateSubnetsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>The unique identifiers for the subnets that you want to disassociate. </p>
    public let subnetIds: [String]?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetIds: [String]? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetIds = subnetIds
        self.updateToken = updateToken
    }
}

struct DisassociateSubnetsInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetIds: [String]?
}

extension DisassociateSubnetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetIds = "SubnetIds"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension DisassociateSubnetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSubnetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidOperationException" : self = .invalidOperationException(try InvalidOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSubnetsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidOperationException(InvalidOperationException)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSubnetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateSubnetsOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetMappings: \(String(describing: subnetMappings)), updateToken: \(String(describing: updateToken)))"}
}

extension DisassociateSubnetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateSubnetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.subnetMappings = output.subnetMappings
            self.updateToken = output.updateToken
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.subnetMappings = nil
            self.updateToken = nil
        }
    }
}

public struct DisassociateSubnetsOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>The IDs of the subnets that are associated with the firewall. </p>
    public let subnetMappings: [SubnetMapping]?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetMappings: [SubnetMapping]? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetMappings = subnetMappings
        self.updateToken = updateToken
    }
}

struct DisassociateSubnetsOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetMappings: [SubnetMapping]?
    public let updateToken: String?
}

extension DisassociateSubnetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetMappings = "SubnetMappings"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SubnetMapping?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SubnetMapping]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SubnetMapping]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension Firewall: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case description = "Description"
        case firewallArn = "FirewallArn"
        case firewallId = "FirewallId"
        case firewallName = "FirewallName"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case subnetChangeProtection = "SubnetChangeProtection"
        case subnetMappings = "SubnetMappings"
        case tags = "Tags"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteProtection != false {
            try encodeContainer.encode(deleteProtection, forKey: .deleteProtection)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallId = firewallId {
            try encodeContainer.encode(firewallId, forKey: .firewallId)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if firewallPolicyChangeProtection != false {
            try encodeContainer.encode(firewallPolicyChangeProtection, forKey: .firewallPolicyChangeProtection)
        }
        if subnetChangeProtection != false {
            try encodeContainer.encode(subnetChangeProtection, forKey: .subnetChangeProtection)
        }
        if let subnetMappings = subnetMappings {
            var subnetMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetMappings)
            for subnetmappings0 in subnetMappings {
                try subnetMappingsContainer.encode(subnetmappings0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetMappingsContainer = try containerValues.decodeIfPresent([SubnetMapping?].self, forKey: .subnetMappings)
        var subnetMappingsDecoded0:[SubnetMapping]? = nil
        if let subnetMappingsContainer = subnetMappingsContainer {
            subnetMappingsDecoded0 = [SubnetMapping]()
            for structure0 in subnetMappingsContainer {
                if let structure0 = structure0 {
                    subnetMappingsDecoded0?.append(structure0)
                }
            }
        }
        subnetMappings = subnetMappingsDecoded0
        let deleteProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deleteProtection)
        deleteProtection = deleteProtectionDecoded
        let subnetChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .subnetChangeProtection)
        subnetChangeProtection = subnetChangeProtectionDecoded
        let firewallPolicyChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .firewallPolicyChangeProtection)
        firewallPolicyChangeProtection = firewallPolicyChangeProtectionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let firewallIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallId)
        firewallId = firewallIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Firewall: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Firewall(deleteProtection: \(String(describing: deleteProtection)), description: \(String(describing: description)), firewallArn: \(String(describing: firewallArn)), firewallId: \(String(describing: firewallId)), firewallName: \(String(describing: firewallName)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyChangeProtection: \(String(describing: firewallPolicyChangeProtection)), subnetChangeProtection: \(String(describing: subnetChangeProtection)), subnetMappings: \(String(describing: subnetMappings)), tags: \(String(describing: tags)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The firewall defines the configuration settings for an AWS Network Firewall firewall. These settings include the firewall policy, the subnets in your VPC to use for the firewall endpoints, and any tags that are attached to the firewall AWS resource. </p>
///          <p>The status of the firewall, for example whether it's ready to filter network traffic,
///          is provided in the corresponding <a>FirewallStatus</a>. You can retrieve both
///          objects by calling <a>DescribeFirewall</a>.</p>
public struct Firewall: Equatable {
    /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates
    ///          that the firewall is protected against deletion. Use this setting to protect against
    ///          accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
    public let deleteProtection: Bool
    /// <p>A description of the firewall.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The unique identifier for the firewall. </p>
    public let firewallId: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    ///          <p>The relationship of firewall to firewall policy is many to one. Each firewall requires
    ///          one firewall policy association, and you can use the same firewall policy for multiple
    ///          firewalls. </p>
    public let firewallPolicyArn: String?
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
    ///          Use this setting to protect against
    ///          accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let firewallPolicyChangeProtection: Bool
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
    ///          Use this setting to protect against
    ///          accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let subnetChangeProtection: Bool
    /// <p>The public subnets that Network Firewall is using for the firewall. Each subnet must belong
    ///          to a different Availability Zone. </p>
    public let subnetMappings: [SubnetMapping]?
    /// <p></p>
    public let tags: [Tag]?
    /// <p>The unique identifier of the VPC where the firewall is in use. </p>
    public let vpcId: String?

    public init (
        deleteProtection: Bool = false,
        description: String? = nil,
        firewallArn: String? = nil,
        firewallId: String? = nil,
        firewallName: String? = nil,
        firewallPolicyArn: String? = nil,
        firewallPolicyChangeProtection: Bool = false,
        subnetChangeProtection: Bool = false,
        subnetMappings: [SubnetMapping]? = nil,
        tags: [Tag]? = nil,
        vpcId: String? = nil
    )
    {
        self.deleteProtection = deleteProtection
        self.description = description
        self.firewallArn = firewallArn
        self.firewallId = firewallId
        self.firewallName = firewallName
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
        self.subnetChangeProtection = subnetChangeProtection
        self.subnetMappings = subnetMappings
        self.tags = tags
        self.vpcId = vpcId
    }
}

extension FirewallMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
    }
}

extension FirewallMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallMetadata(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)))"}
}

/// <p>High-level information about a firewall, returned by operations like create and
///          describe. You can use the information provided in the metadata to retrieve and manage a
///          firewall.</p>
public struct FirewallMetadata: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
    }
}

extension FirewallPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case statefulRuleGroupReferences = "StatefulRuleGroupReferences"
        case statelessCustomActions = "StatelessCustomActions"
        case statelessDefaultActions = "StatelessDefaultActions"
        case statelessFragmentDefaultActions = "StatelessFragmentDefaultActions"
        case statelessRuleGroupReferences = "StatelessRuleGroupReferences"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let statefulRuleGroupReferences = statefulRuleGroupReferences {
            var statefulRuleGroupReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRuleGroupReferences)
            for statefulrulegroupreferences0 in statefulRuleGroupReferences {
                try statefulRuleGroupReferencesContainer.encode(statefulrulegroupreferences0)
            }
        }
        if let statelessCustomActions = statelessCustomActions {
            var statelessCustomActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessCustomActions)
            for customactions0 in statelessCustomActions {
                try statelessCustomActionsContainer.encode(customactions0)
            }
        }
        if let statelessDefaultActions = statelessDefaultActions {
            var statelessDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessDefaultActions)
            for statelessactions0 in statelessDefaultActions {
                try statelessDefaultActionsContainer.encode(statelessactions0)
            }
        }
        if let statelessFragmentDefaultActions = statelessFragmentDefaultActions {
            var statelessFragmentDefaultActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessFragmentDefaultActions)
            for statelessactions0 in statelessFragmentDefaultActions {
                try statelessFragmentDefaultActionsContainer.encode(statelessactions0)
            }
        }
        if let statelessRuleGroupReferences = statelessRuleGroupReferences {
            var statelessRuleGroupReferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRuleGroupReferences)
            for statelessrulegroupreferences0 in statelessRuleGroupReferences {
                try statelessRuleGroupReferencesContainer.encode(statelessrulegroupreferences0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statelessRuleGroupReferencesContainer = try containerValues.decodeIfPresent([StatelessRuleGroupReference?].self, forKey: .statelessRuleGroupReferences)
        var statelessRuleGroupReferencesDecoded0:[StatelessRuleGroupReference]? = nil
        if let statelessRuleGroupReferencesContainer = statelessRuleGroupReferencesContainer {
            statelessRuleGroupReferencesDecoded0 = [StatelessRuleGroupReference]()
            for structure0 in statelessRuleGroupReferencesContainer {
                if let structure0 = structure0 {
                    statelessRuleGroupReferencesDecoded0?.append(structure0)
                }
            }
        }
        statelessRuleGroupReferences = statelessRuleGroupReferencesDecoded0
        let statelessDefaultActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statelessDefaultActions)
        var statelessDefaultActionsDecoded0:[String]? = nil
        if let statelessDefaultActionsContainer = statelessDefaultActionsContainer {
            statelessDefaultActionsDecoded0 = [String]()
            for string0 in statelessDefaultActionsContainer {
                if let string0 = string0 {
                    statelessDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessDefaultActions = statelessDefaultActionsDecoded0
        let statelessFragmentDefaultActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .statelessFragmentDefaultActions)
        var statelessFragmentDefaultActionsDecoded0:[String]? = nil
        if let statelessFragmentDefaultActionsContainer = statelessFragmentDefaultActionsContainer {
            statelessFragmentDefaultActionsDecoded0 = [String]()
            for string0 in statelessFragmentDefaultActionsContainer {
                if let string0 = string0 {
                    statelessFragmentDefaultActionsDecoded0?.append(string0)
                }
            }
        }
        statelessFragmentDefaultActions = statelessFragmentDefaultActionsDecoded0
        let statelessCustomActionsContainer = try containerValues.decodeIfPresent([CustomAction?].self, forKey: .statelessCustomActions)
        var statelessCustomActionsDecoded0:[CustomAction]? = nil
        if let statelessCustomActionsContainer = statelessCustomActionsContainer {
            statelessCustomActionsDecoded0 = [CustomAction]()
            for structure0 in statelessCustomActionsContainer {
                if let structure0 = structure0 {
                    statelessCustomActionsDecoded0?.append(structure0)
                }
            }
        }
        statelessCustomActions = statelessCustomActionsDecoded0
        let statefulRuleGroupReferencesContainer = try containerValues.decodeIfPresent([StatefulRuleGroupReference?].self, forKey: .statefulRuleGroupReferences)
        var statefulRuleGroupReferencesDecoded0:[StatefulRuleGroupReference]? = nil
        if let statefulRuleGroupReferencesContainer = statefulRuleGroupReferencesContainer {
            statefulRuleGroupReferencesDecoded0 = [StatefulRuleGroupReference]()
            for structure0 in statefulRuleGroupReferencesContainer {
                if let structure0 = structure0 {
                    statefulRuleGroupReferencesDecoded0?.append(structure0)
                }
            }
        }
        statefulRuleGroupReferences = statefulRuleGroupReferencesDecoded0
    }
}

extension FirewallPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallPolicy(statefulRuleGroupReferences: \(String(describing: statefulRuleGroupReferences)), statelessCustomActions: \(String(describing: statelessCustomActions)), statelessDefaultActions: \(String(describing: statelessDefaultActions)), statelessFragmentDefaultActions: \(String(describing: statelessFragmentDefaultActions)), statelessRuleGroupReferences: \(String(describing: statelessRuleGroupReferences)))"}
}

/// <p>The firewall policy defines the behavior of a firewall using a collection of stateless
///          and stateful rule groups and other settings. You can use one firewall policy for multiple
///          firewalls. </p>
///          <p>This, along with <a>FirewallPolicyResponse</a>, define the policy.
///          You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>.</p>
public struct FirewallPolicy: Equatable {
    /// <p>References to the stateless rule groups that are used in the policy. These define the
    ///          inspection criteria in stateful rules. </p>
    public let statefulRuleGroupReferences: [StatefulRuleGroupReference]?
    /// <p>The custom action definitions that are available for use in the firewall policy's
    ///             <code>StatelessDefaultActions</code> setting. You name each custom action that you
    ///          define, and then you can use it by name in your default actions specifications.</p>
    public let statelessCustomActions: [CustomAction]?
    /// <p>The actions to take on a packet if it doesn't match any of the stateless rules in the
    ///          policy. If you want non-matching packets to be forwarded for stateful inspection, specify
    ///             <code>aws:forward_to_sfe</code>. </p>
    ///          <p>You must specify one of the standard actions: <code>aws:pass</code>,
    ///             <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>. In addition, you can specify
    ///          custom actions that are compatible with your standard section choice.</p>
    ///          <p>For example, you could specify <code>["aws:pass"]</code> or you could specify
    ///             <code>["aws:pass", “customActionName”]</code>. For information about compatibility, see
    ///          the custom action descriptions under <a>CustomAction</a>.</p>
    public let statelessDefaultActions: [String]?
    /// <p>The actions to take on a fragmented UDP packet if it doesn't match any of the stateless
    ///       rules in the policy. Network Firewall only manages UDP packet fragments and silently drops packet fragments for other protocols.
    ///       If you want non-matching fragmented UDP packets to be forwarded for
    ///          stateful inspection, specify <code>aws:forward_to_sfe</code>. </p>
    ///          <p>You must specify one of the standard actions: <code>aws:pass</code>,
    ///             <code>aws:drop</code>, or <code>aws:forward_to_sfe</code>. In addition, you can specify
    ///          custom actions that are compatible with your standard section choice.</p>
    ///          <p>For example, you could specify <code>["aws:pass"]</code> or you could specify
    ///             <code>["aws:pass", “customActionName”]</code>. For information about compatibility, see
    ///          the custom action descriptions under <a>CustomAction</a>.</p>
    public let statelessFragmentDefaultActions: [String]?
    /// <p>References to the stateless rule groups that are used in the policy. These define the
    ///          matching criteria in stateless rules. </p>
    public let statelessRuleGroupReferences: [StatelessRuleGroupReference]?

    public init (
        statefulRuleGroupReferences: [StatefulRuleGroupReference]? = nil,
        statelessCustomActions: [CustomAction]? = nil,
        statelessDefaultActions: [String]? = nil,
        statelessFragmentDefaultActions: [String]? = nil,
        statelessRuleGroupReferences: [StatelessRuleGroupReference]? = nil
    )
    {
        self.statefulRuleGroupReferences = statefulRuleGroupReferences
        self.statelessCustomActions = statelessCustomActions
        self.statelessDefaultActions = statelessDefaultActions
        self.statelessFragmentDefaultActions = statelessFragmentDefaultActions
        self.statelessRuleGroupReferences = statelessRuleGroupReferences
    }
}

extension FirewallPolicyMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FirewallPolicyMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallPolicyMetadata(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a firewall policy, returned by operations like create and
///          describe. You can use the information provided in the metadata to retrieve and manage a
///          firewall policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>. </p>
public struct FirewallPolicyMetadata: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    public let arn: String?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension FirewallPolicyResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyId = "FirewallPolicyId"
        case firewallPolicyName = "FirewallPolicyName"
        case firewallPolicyStatus = "FirewallPolicyStatus"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let firewallPolicyId = firewallPolicyId {
            try encodeContainer.encode(firewallPolicyId, forKey: .firewallPolicyId)
        }
        if let firewallPolicyName = firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
        if let firewallPolicyStatus = firewallPolicyStatus {
            try encodeContainer.encode(firewallPolicyStatus.rawValue, forKey: .firewallPolicyStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let firewallPolicyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyId)
        firewallPolicyId = firewallPolicyIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let firewallPolicyStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .firewallPolicyStatus)
        firewallPolicyStatus = firewallPolicyStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension FirewallPolicyResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallPolicyResponse(description: \(String(describing: description)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyId: \(String(describing: firewallPolicyId)), firewallPolicyName: \(String(describing: firewallPolicyName)), firewallPolicyStatus: \(String(describing: firewallPolicyStatus)), tags: \(String(describing: tags)))"}
}

/// <p>The high-level properties of a firewall policy. This, along with the <a>FirewallPolicy</a>, define the policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>. </p>
public struct FirewallPolicyResponse: Equatable {
    /// <p>A description of the firewall policy.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    ///          <note>
    ///             <p>If this response is for a create request that had <code>DryRun</code> set to
    ///                <code>TRUE</code>, then this ARN is a placeholder that isn't attached to a valid
    ///             resource.</p>
    ///          </note>
    public let firewallPolicyArn: String?
    /// <p>The unique identifier for the firewall policy. </p>
    public let firewallPolicyId: String?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    public let firewallPolicyName: String?
    /// <p>The current status of the firewall policy. You can retrieve this for a firewall policy
    ///          by calling <a>DescribeFirewallPolicy</a> and providing the firewall policy's
    ///          name or ARN.</p>
    public let firewallPolicyStatus: ResourceStatus?
    /// <p>The key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        firewallPolicyArn: String? = nil,
        firewallPolicyId: String? = nil,
        firewallPolicyName: String? = nil,
        firewallPolicyStatus: ResourceStatus? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyId = firewallPolicyId
        self.firewallPolicyName = firewallPolicyName
        self.firewallPolicyStatus = firewallPolicyStatus
        self.tags = tags
    }
}

extension FirewallStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSyncStateSummary = "ConfigurationSyncStateSummary"
        case status = "Status"
        case syncStates = "SyncStates"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSyncStateSummary = configurationSyncStateSummary {
            try encodeContainer.encode(configurationSyncStateSummary.rawValue, forKey: .configurationSyncStateSummary)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let syncStates = syncStates {
            var syncStatesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .syncStates)
            for (dictKey0, syncstates0) in syncStates {
                try syncStatesContainer.encode(syncstates0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(FirewallStatusValue.self, forKey: .status)
        status = statusDecoded
        let configurationSyncStateSummaryDecoded = try containerValues.decodeIfPresent(ConfigurationSyncState.self, forKey: .configurationSyncStateSummary)
        configurationSyncStateSummary = configurationSyncStateSummaryDecoded
        let syncStatesContainer = try containerValues.decodeIfPresent([String: SyncState?].self, forKey: .syncStates)
        var syncStatesDecoded0: [String:SyncState]? = nil
        if let syncStatesContainer = syncStatesContainer {
            syncStatesDecoded0 = [String:SyncState]()
            for (key0, syncstate0) in syncStatesContainer {
                if let syncstate0 = syncstate0 {
                    syncStatesDecoded0?[key0] = syncstate0
                }
            }
        }
        syncStates = syncStatesDecoded0
    }
}

extension FirewallStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FirewallStatus(configurationSyncStateSummary: \(String(describing: configurationSyncStateSummary)), status: \(String(describing: status)), syncStates: \(String(describing: syncStates)))"}
}

/// <p>Detailed information about the current status of a <a>Firewall</a>. You can retrieve this for a firewall by calling <a>DescribeFirewall</a> and providing the firewall name and ARN.</p>
public struct FirewallStatus: Equatable {
    /// <p>The configuration sync state for the firewall. This summarizes the sync states reported
    ///          in the <code>Config</code> settings for all of the Availability Zones where you have
    ///          configured the firewall. </p>
    ///          <p>When you create a firewall or update its configuration, for example by adding a rule
    ///          group to its firewall policy, Network Firewall distributes the configuration changes to all
    ///          zones where the firewall is in use. This summary indicates whether the configuration
    ///          changes have been applied everywhere. </p>
    ///          <p>This status must be <code>IN_SYNC</code> for the firewall to be ready for use, but it
    ///          doesn't indicate that the firewall is ready. The <code>Status</code> setting indicates
    ///          firewall readiness.</p>
    public let configurationSyncStateSummary: ConfigurationSyncState?
    /// <p>The readiness of the configured firewall to handle network traffic across all of the
    ///          Availability Zones where you've configured it. This setting is <code>READY</code> only when
    ///          the <code>ConfigurationSyncStateSummary</code> value is <code>IN_SYNC</code> and the
    ///             <code>Attachment</code>
    ///             <code>Status</code> values for all of the configured subnets are <code>READY</code>.
    ///       </p>
    public let status: FirewallStatusValue?
    /// <p>The subnets that you've configured for use by the Network Firewall firewall. This contains
    ///          one array element per Availability Zone where you've configured a subnet. These objects
    ///          provide details of the information that is summarized in the
    ///             <code>ConfigurationSyncStateSummary</code> and <code>Status</code>, broken down by zone
    ///          and configuration object. </p>
    public let syncStates: [String:SyncState]?

    public init (
        configurationSyncStateSummary: ConfigurationSyncState? = nil,
        status: FirewallStatusValue? = nil,
        syncStates: [String:SyncState]? = nil
    )
    {
        self.configurationSyncStateSummary = configurationSyncStateSummary
        self.status = status
        self.syncStates = syncStates
    }
}

public enum FirewallStatusValue {
    case deleting
    case provisioning
    case ready
    case sdkUnknown(String)
}

extension FirewallStatusValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FirewallStatusValue] {
        return [
            .deleting,
            .provisioning,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .provisioning: return "PROVISIONING"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FirewallStatusValue(rawValue: rawValue) ?? FirewallStatusValue.sdkUnknown(rawValue)
    }
}

public enum GeneratedRulesType {
    case allowlist
    case denylist
    case sdkUnknown(String)
}

extension GeneratedRulesType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GeneratedRulesType] {
        return [
            .allowlist,
            .denylist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowlist: return "ALLOWLIST"
        case .denylist: return "DENYLIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GeneratedRulesType(rawValue: rawValue) ?? GeneratedRulesType.sdkUnknown(rawValue)
    }
}

extension Header: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
        case destinationPort = "DestinationPort"
        case direction = "Direction"
        case `protocol` = "Protocol"
        case source = "Source"
        case sourcePort = "SourcePort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationPort = destinationPort {
            try encodeContainer.encode(destinationPort, forKey: .destinationPort)
        }
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourcePort = sourcePort {
            try encodeContainer.encode(sourcePort, forKey: .sourcePort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(StatefulRuleProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let sourcePortDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourcePort)
        sourcePort = sourcePortDecoded
        let directionDecoded = try containerValues.decodeIfPresent(StatefulRuleDirection.self, forKey: .direction)
        direction = directionDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationPortDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPort)
        destinationPort = destinationPortDecoded
    }
}

extension Header: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Header(destination: \(String(describing: destination)), destinationPort: \(String(describing: destinationPort)), direction: \(String(describing: direction)), protocol: \(String(describing: `protocol`)), source: \(String(describing: source)), sourcePort: \(String(describing: sourcePort)))"}
}

/// <p>The 5-tuple criteria for AWS Network Firewall to use to inspect packet headers in stateful
///          traffic flow inspection. Traffic flows that match the criteria are a match for the
///          corresponding <a>StatefulRule</a>. </p>
public struct Header: Equatable {
    /// <p>The protocol to inspect for. To specify all, you can use <code>IP</code>, because all traffic on AWS and on the internet is IP.</p>
    public let `protocol`: StatefulRuleProtocol?
    /// <p>The destination IP address or address range to inspect for, in CIDR notation.
    ///           To match with any address, specify <code>ANY</code>. </p>
    ///          <p>Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let destination: String?
    /// <p>The destination port to inspect for. You can specify an individual port, for
    ///            example <code>1994</code> and you can specify
    ///          a port range, for example <code>1990-1994</code>.
    ///           To match with any port, specify <code>ANY</code>. </p>
    public let destinationPort: String?
    /// <p>The direction of traffic flow to inspect. If set to <code>ANY</code>, the inspection
    ///          matches bidirectional traffic, both from the source to the destination and from the
    ///          destination to the source. If set to <code>FORWARD</code>, the inspection only matches
    ///          traffic going from the source to the destination. </p>
    public let direction: StatefulRuleDirection?
    /// <p>The source IP address or address range to inspect for, in CIDR notation.
    ///           To match with any address, specify <code>ANY</code>. </p>
    ///          <p>Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4. </p>
    ///          <p>Examples: </p>
    ///          <ul>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for the IP address 192.0.2.44, specify <code>192.0.2.44/32</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify <code>192.0.2.0/24</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For more information about CIDR notation, see the Wikipedia entry <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">Classless
    ///          Inter-Domain Routing</a>.</p>
    public let source: String?
    /// <p>The source port to inspect for. You can specify an individual port, for
    ///            example <code>1994</code> and you can specify a port
    ///                range, for example <code>1990-1994</code>.
    ///           To match with any port, specify <code>ANY</code>. </p>
    public let sourcePort: String?

    public init (
        `protocol`: StatefulRuleProtocol? = nil,
        destination: String? = nil,
        destinationPort: String? = nil,
        direction: StatefulRuleDirection? = nil,
        source: String? = nil,
        sourcePort: String? = nil
    )
    {
        self.`protocol` = `protocol`
        self.destination = destination
        self.destinationPort = destinationPort
        self.direction = direction
        self.source = source
        self.sourcePort = sourcePort
    }
}

extension IPSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition = "Definition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .definition)
            for variabledefinitionlist0 in definition {
                try definitionContainer.encode(variabledefinitionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .definition)
        var definitionDecoded0:[String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [String]()
            for string0 in definitionContainer {
                if let string0 = string0 {
                    definitionDecoded0?.append(string0)
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension IPSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IPSet(definition: \(String(describing: definition)))"}
}

/// <p>A list of IP addresses and address ranges, in CIDR notation. This is part of a <a>RuleVariables</a>. </p>
public struct IPSet: Equatable {
    /// <p>The list of IP addresses and address ranges, in CIDR notation.
    ///
    ///       </p>
    public let definition: [String]?

    public init (
        definition: [String]? = nil
    )
    {
        self.definition = definition
    }
}

extension InsufficientCapacityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientCapacityException(message: \(String(describing: message)))"}
}

extension InsufficientCapacityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientCapacityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS doesn't currently have enough available capacity to fulfill your request. Try your
///          request later. </p>
public struct InsufficientCapacityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientCapacityExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientCapacityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerError(message: \(String(describing: message)))"}
}

extension InternalServerError: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request is valid, but Network Firewall couldn’t perform the operation because of a
///          system problem. Retry your request. </p>
public struct InternalServerError: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorBody: Equatable {
    public let message: String?
}

extension InternalServerErrorBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidOperationException(message: \(String(describing: message)))"}
}

extension InvalidOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because it's not valid. For example, you might have tried to delete
///          a rule group or firewall policy that's in use.</p>
public struct InvalidOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidOperationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestException(message: \(String(describing: message)))"}
}

extension InvalidRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation failed because of a problem with your request. Examples include: </p>
///          <ul>
///             <li>
///                <p>You specified an unsupported parameter name or value.</p>
///             </li>
///             <li>
///                <p>You tried to update a property with a value that isn't among the available
///                types.</p>
///             </li>
///             <li>
///                <p>Your request references an ARN that is malformed, or corresponds to a resource
///                that isn't valid in the context of the request.</p>
///             </li>
///          </ul>
public struct InvalidRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Equatable {
    public let message: String?
}

extension InvalidRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourcePolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourcePolicyException(message: \(String(describing: message)))"}
}

extension InvalidResourcePolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidResourcePolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct InvalidResourcePolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourcePolicyExceptionBody: Equatable {
    public let message: String?
}

extension InvalidResourcePolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTokenException(message: \(String(describing: message)))"}
}

extension InvalidTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The token you provided is stale or isn't valid for the operation. </p>
public struct InvalidTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to perform the operation because doing so would violate a limit setting. </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListFirewallPoliciesInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallPoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallPoliciesInput>
    public typealias MOutput = OperationOutput<ListFirewallPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallPoliciesOutputError>
}

extension ListFirewallPoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallPoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallPoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFirewallPoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallPoliciesInput>
    public typealias MOutput = OperationOutput<ListFirewallPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallPoliciesOutputError>
}

public struct ListFirewallPoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallPoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallPoliciesInput>
    public typealias MOutput = OperationOutput<ListFirewallPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallPoliciesOutputError>
}

public struct ListFirewallPoliciesInput: Equatable {
    /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
    ///           objects are available, in the response, Network Firewall provides a
    ///          <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFirewallPoliciesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFirewallPoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFirewallPoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallPoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallPoliciesOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallPoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallPoliciesOutputResponse(firewallPolicies: \(String(describing: firewallPolicies)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallPoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallPolicies = output.firewallPolicies
            self.nextToken = output.nextToken
        } else {
            self.firewallPolicies = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallPoliciesOutputResponse: Equatable {
    /// <p>The metadata for the firewall policies. Depending on your setting for max results and
    ///          the number of firewall policies that you have, this might not be the full list. </p>
    public let firewallPolicies: [FirewallPolicyMetadata]?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        firewallPolicies: [FirewallPolicyMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewallPolicies = firewallPolicies
        self.nextToken = nextToken
    }
}

struct ListFirewallPoliciesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewallPolicies: [FirewallPolicyMetadata]?
}

extension ListFirewallPoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicies = "FirewallPolicies"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallPoliciesContainer = try containerValues.decodeIfPresent([FirewallPolicyMetadata?].self, forKey: .firewallPolicies)
        var firewallPoliciesDecoded0:[FirewallPolicyMetadata]? = nil
        if let firewallPoliciesContainer = firewallPoliciesContainer {
            firewallPoliciesDecoded0 = [FirewallPolicyMetadata]()
            for structure0 in firewallPoliciesContainer {
                if let structure0 = structure0 {
                    firewallPoliciesDecoded0?.append(structure0)
                }
            }
        }
        firewallPolicies = firewallPoliciesDecoded0
    }
}

public struct ListFirewallsInputBodyMiddleware: Middleware {
    public let id: String = "ListFirewallsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallsInput>
    public typealias MOutput = OperationOutput<ListFirewallsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallsOutputError>
}

extension ListFirewallsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), vpcIds: \(String(describing: vpcIds)))"}
}

extension ListFirewallsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcIds = "VpcIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let vpcIds = vpcIds {
            var vpcIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vpcIds)
            for vpcids0 in vpcIds {
                try vpcIdsContainer.encode(vpcids0)
            }
        }
    }
}

public struct ListFirewallsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFirewallsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallsInput>
    public typealias MOutput = OperationOutput<ListFirewallsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallsOutputError>
}

public struct ListFirewallsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFirewallsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFirewallsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFirewallsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFirewallsInput>
    public typealias MOutput = OperationOutput<ListFirewallsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFirewallsOutputError>
}

public struct ListFirewallsInput: Equatable {
    /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
    ///           objects are available, in the response, Network Firewall provides a
    ///          <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>The unique identifiers of the VPCs that you want Network Firewall to retrieve the firewalls
    ///          for. Leave this blank to retrieve all firewalls that you have defined.</p>
    public let vpcIds: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        vpcIds: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vpcIds = vpcIds
    }
}

struct ListFirewallsInputBody: Equatable {
    public let nextToken: String?
    public let vpcIds: [String]?
    public let maxResults: Int?
}

extension ListFirewallsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case vpcIds = "VpcIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let vpcIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .vpcIds)
        var vpcIdsDecoded0:[String]? = nil
        if let vpcIdsContainer = vpcIdsContainer {
            vpcIdsDecoded0 = [String]()
            for string0 in vpcIdsContainer {
                if let string0 = string0 {
                    vpcIdsDecoded0?.append(string0)
                }
            }
        }
        vpcIds = vpcIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFirewallsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFirewallsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFirewallsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFirewallsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFirewallsOutputResponse(firewalls: \(String(describing: firewalls)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFirewallsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFirewallsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewalls = output.firewalls
            self.nextToken = output.nextToken
        } else {
            self.firewalls = nil
            self.nextToken = nil
        }
    }
}

public struct ListFirewallsOutputResponse: Equatable {
    /// <p>The firewall metadata objects for the VPCs that you specified. Depending on your setting
    ///          for max results and the number of firewalls you have, a single call might not be the full
    ///          list. </p>
    public let firewalls: [FirewallMetadata]?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        firewalls: [FirewallMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.firewalls = firewalls
        self.nextToken = nextToken
    }
}

struct ListFirewallsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let firewalls: [FirewallMetadata]?
}

extension ListFirewallsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewalls = "Firewalls"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let firewallsContainer = try containerValues.decodeIfPresent([FirewallMetadata?].self, forKey: .firewalls)
        var firewallsDecoded0:[FirewallMetadata]? = nil
        if let firewallsContainer = firewallsContainer {
            firewallsDecoded0 = [FirewallMetadata]()
            for structure0 in firewallsContainer {
                if let structure0 = structure0 {
                    firewallsDecoded0?.append(structure0)
                }
            }
        }
        firewalls = firewallsDecoded0
    }
}

public struct ListRuleGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

extension ListRuleGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRuleGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRuleGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRuleGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleGroupsInput>
    public typealias MOutput = OperationOutput<ListRuleGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleGroupsOutputError>
}

public struct ListRuleGroupsInput: Equatable {
    /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
    ///           objects are available, in the response, Network Firewall provides a
    ///          <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRuleGroupsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRuleGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRuleGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleGroupsOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleGroupsOutputResponse(nextToken: \(String(describing: nextToken)), ruleGroups: \(String(describing: ruleGroups)))"}
}

extension ListRuleGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRuleGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.ruleGroups = output.ruleGroups
        } else {
            self.nextToken = nil
            self.ruleGroups = nil
        }
    }
}

public struct ListRuleGroupsOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>The rule group metadata objects that you've defined. Depending on your setting for max
    ///          results and the number of rule groups, this might not be the full list. </p>
    public let ruleGroups: [RuleGroupMetadata]?

    public init (
        nextToken: String? = nil,
        ruleGroups: [RuleGroupMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleGroups = ruleGroups
    }
}

struct ListRuleGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let ruleGroups: [RuleGroupMetadata]?
}

extension ListRuleGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case ruleGroups = "RuleGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let ruleGroupsContainer = try containerValues.decodeIfPresent([RuleGroupMetadata?].self, forKey: .ruleGroups)
        var ruleGroupsDecoded0:[RuleGroupMetadata]? = nil
        if let ruleGroupsContainer = ruleGroupsContainer {
            ruleGroupsDecoded0 = [RuleGroupMetadata]()
            for structure0 in ruleGroupsContainer {
                if let structure0 = structure0 {
                    ruleGroupsDecoded0?.append(structure0)
                }
            }
        }
        ruleGroups = ruleGroupsDecoded0
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of objects that you want Network Firewall to return for this request. If more
    ///           objects are available, in the response, Network Firewall provides a
    ///          <code>NextToken</code> value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int?
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>When you request a list of objects with a <code>MaxResults</code> setting, if the number of objects that are still available
    ///          for retrieval exceeds the maximum you requested, Network Firewall returns a <code>NextToken</code>
    ///          value in the response. To retrieve the next batch of objects, use the token returned from the prior request in your next request.</p>
    public let nextToken: String?
    /// <p>The tags that are associated with the resource. </p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let nextToken: String?
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LogDestinationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logDestination = "LogDestination"
        case logDestinationType = "LogDestinationType"
        case logType = "LogType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logDestination = logDestination {
            var logDestinationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logDestination)
            for (dictKey0, logdestinationmap0) in logDestination {
                try logDestinationContainer.encode(logdestinationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let logDestinationType = logDestinationType {
            try encodeContainer.encode(logDestinationType.rawValue, forKey: .logDestinationType)
        }
        if let logType = logType {
            try encodeContainer.encode(logType.rawValue, forKey: .logType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logTypeDecoded = try containerValues.decodeIfPresent(LogType.self, forKey: .logType)
        logType = logTypeDecoded
        let logDestinationTypeDecoded = try containerValues.decodeIfPresent(LogDestinationType.self, forKey: .logDestinationType)
        logDestinationType = logDestinationTypeDecoded
        let logDestinationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logDestination)
        var logDestinationDecoded0: [String:String]? = nil
        if let logDestinationContainer = logDestinationContainer {
            logDestinationDecoded0 = [String:String]()
            for (key0, hashmapvalue0) in logDestinationContainer {
                if let hashmapvalue0 = hashmapvalue0 {
                    logDestinationDecoded0?[key0] = hashmapvalue0
                }
            }
        }
        logDestination = logDestinationDecoded0
    }
}

extension LogDestinationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogDestinationConfig(logDestination: \(String(describing: logDestination)), logDestinationType: \(String(describing: logDestinationType)), logType: \(String(describing: logType)))"}
}

/// <p>Defines where AWS Network Firewall sends logs for the firewall for one log type. This is used
///          in <a>LoggingConfiguration</a>. You can send each type of log to an Amazon S3 bucket, a CloudWatch log group, or a Kinesis Data Firehose delivery stream.</p>
///          <p>Network Firewall generates logs for stateful rule groups. You can save alert and flow log
///           types. The stateful rules engine records flow logs for all network traffic that it receives.
///           It records alert logs for traffic that matches stateful rules that have the rule
///           action set to <code>DROP</code> or <code>ALERT</code>. </p>
public struct LogDestinationConfig: Equatable {
    /// <p>The named location for the logs, provided in a key:value mapping that is specific to the
    ///          chosen destination type. </p>
    ///          <ul>
    ///             <li>
    ///                <p>For an Amazon S3 bucket, provide the name of the bucket, with key <code>bucketName</code>,
    ///                and optionally provide a prefix, with key <code>prefix</code>. The following example
    ///                specifies an Amazon S3 bucket named
    ///                <code>DOC-EXAMPLE-BUCKET</code> and the prefix <code>alerts</code>: </p>
    ///                <p>
    ///                   <code>"LogDestination": { "bucketName": "DOC-EXAMPLE-BUCKET", "prefix": "alerts"
    ///                   }</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a CloudWatch log group, provide the name of the CloudWatch log group, with key
    ///                   <code>logGroup</code>. The following example specifies a log group named
    ///                   <code>alert-log-group</code>: </p>
    ///                <p>
    ///                   <code>"LogDestination": { "logGroup": "alert-log-group" }</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>For a Kinesis Data Firehose delivery stream, provide the name of the delivery stream, with key
    ///                   <code>deliveryStream</code>. The following example specifies a delivery stream
    ///                named <code>alert-delivery-stream</code>: </p>
    ///                <p>
    ///                   <code>"LogDestination": { "deliveryStream": "alert-delivery-stream"
    ///                }</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let logDestination: [String:String]?
    /// <p>The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket,
    ///          a CloudWatch log group, or a Kinesis Data Firehose delivery stream.</p>
    public let logDestinationType: LogDestinationType?
    /// <p>The type of log to send. Alert logs report traffic that matches a <a>StatefulRule</a> with an action setting that sends an alert log message. Flow logs are
    ///          standard network traffic flow logs. </p>
    public let logType: LogType?

    public init (
        logDestination: [String:String]? = nil,
        logDestinationType: LogDestinationType? = nil,
        logType: LogType? = nil
    )
    {
        self.logDestination = logDestination
        self.logDestinationType = logDestinationType
        self.logType = logType
    }
}

extension LogDestinationPermissionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogDestinationPermissionException(message: \(String(describing: message)))"}
}

extension LogDestinationPermissionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LogDestinationPermissionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to send logs to a configured logging destination. </p>
public struct LogDestinationPermissionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LogDestinationPermissionExceptionBody: Equatable {
    public let message: String?
}

extension LogDestinationPermissionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LogDestinationType {
    case cloudwatchLogs
    case kinesisDataFirehose
    case s3
    case sdkUnknown(String)
}

extension LogDestinationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogDestinationType] {
        return [
            .cloudwatchLogs,
            .kinesisDataFirehose,
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudwatchLogs: return "CloudWatchLogs"
        case .kinesisDataFirehose: return "KinesisDataFirehose"
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogDestinationType(rawValue: rawValue) ?? LogDestinationType.sdkUnknown(rawValue)
    }
}

public enum LogType {
    case alert
    case flow
    case sdkUnknown(String)
}

extension LogType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogType] {
        return [
            .alert,
            .flow,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alert: return "ALERT"
        case .flow: return "FLOW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
    }
}

extension LoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logDestinationConfigs = "LogDestinationConfigs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logDestinationConfigs = logDestinationConfigs {
            var logDestinationConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logDestinationConfigs)
            for logdestinationconfigs0 in logDestinationConfigs {
                try logDestinationConfigsContainer.encode(logdestinationconfigs0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDestinationConfigsContainer = try containerValues.decodeIfPresent([LogDestinationConfig?].self, forKey: .logDestinationConfigs)
        var logDestinationConfigsDecoded0:[LogDestinationConfig]? = nil
        if let logDestinationConfigsContainer = logDestinationConfigsContainer {
            logDestinationConfigsDecoded0 = [LogDestinationConfig]()
            for structure0 in logDestinationConfigsContainer {
                if let structure0 = structure0 {
                    logDestinationConfigsDecoded0?.append(structure0)
                }
            }
        }
        logDestinationConfigs = logDestinationConfigsDecoded0
    }
}

extension LoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfiguration(logDestinationConfigs: \(String(describing: logDestinationConfigs)))"}
}

/// <p>Defines how AWS Network Firewall performs logging for a <a>Firewall</a>. </p>
public struct LoggingConfiguration: Equatable {
    /// <p>Defines the logging destinations for the logs for a firewall. Network Firewall generates
    ///          logs for stateful rule groups. </p>
    public let logDestinationConfigs: [LogDestinationConfig]?

    public init (
        logDestinationConfigs: [LogDestinationConfig]? = nil
    )
    {
        self.logDestinationConfigs = logDestinationConfigs
    }
}

extension MatchAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationPorts = "DestinationPorts"
        case destinations = "Destinations"
        case protocols = "Protocols"
        case sourcePorts = "SourcePorts"
        case sources = "Sources"
        case tCPFlags = "TCPFlags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPorts = destinationPorts {
            var destinationPortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinationPorts)
            for portranges0 in destinationPorts {
                try destinationPortsContainer.encode(portranges0)
            }
        }
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for addresses0 in destinations {
                try destinationsContainer.encode(addresses0)
            }
        }
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for protocolnumbers0 in protocols {
                try protocolsContainer.encode(protocolnumbers0)
            }
        }
        if let sourcePorts = sourcePorts {
            var sourcePortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourcePorts)
            for portranges0 in sourcePorts {
                try sourcePortsContainer.encode(portranges0)
            }
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for addresses0 in sources {
                try sourcesContainer.encode(addresses0)
            }
        }
        if let tCPFlags = tCPFlags {
            var tCPFlagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tCPFlags)
            for tcpflags0 in tCPFlags {
                try tCPFlagsContainer.encode(tcpflags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourcesContainer = try containerValues.decodeIfPresent([Address?].self, forKey: .sources)
        var sourcesDecoded0:[Address]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Address]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
        let destinationsContainer = try containerValues.decodeIfPresent([Address?].self, forKey: .destinations)
        var destinationsDecoded0:[Address]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [Address]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let sourcePortsContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .sourcePorts)
        var sourcePortsDecoded0:[PortRange]? = nil
        if let sourcePortsContainer = sourcePortsContainer {
            sourcePortsDecoded0 = [PortRange]()
            for structure0 in sourcePortsContainer {
                if let structure0 = structure0 {
                    sourcePortsDecoded0?.append(structure0)
                }
            }
        }
        sourcePorts = sourcePortsDecoded0
        let destinationPortsContainer = try containerValues.decodeIfPresent([PortRange?].self, forKey: .destinationPorts)
        var destinationPortsDecoded0:[PortRange]? = nil
        if let destinationPortsContainer = destinationPortsContainer {
            destinationPortsDecoded0 = [PortRange]()
            for structure0 in destinationPortsContainer {
                if let structure0 = structure0 {
                    destinationPortsDecoded0?.append(structure0)
                }
            }
        }
        destinationPorts = destinationPortsDecoded0
        let protocolsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .protocols)
        var protocolsDecoded0:[Int]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [Int]()
            for integer0 in protocolsContainer {
                if let integer0 = integer0 {
                    protocolsDecoded0?.append(integer0)
                }
            }
        }
        protocols = protocolsDecoded0
        let tCPFlagsContainer = try containerValues.decodeIfPresent([TCPFlagField?].self, forKey: .tCPFlags)
        var tCPFlagsDecoded0:[TCPFlagField]? = nil
        if let tCPFlagsContainer = tCPFlagsContainer {
            tCPFlagsDecoded0 = [TCPFlagField]()
            for structure0 in tCPFlagsContainer {
                if let structure0 = structure0 {
                    tCPFlagsDecoded0?.append(structure0)
                }
            }
        }
        tCPFlags = tCPFlagsDecoded0
    }
}

extension MatchAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchAttributes(destinationPorts: \(String(describing: destinationPorts)), destinations: \(String(describing: destinations)), protocols: \(String(describing: protocols)), sourcePorts: \(String(describing: sourcePorts)), sources: \(String(describing: sources)), tCPFlags: \(String(describing: tCPFlags)))"}
}

/// <p>Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags. </p>
public struct MatchAttributes: Equatable {
    /// <p>The destination ports to inspect for. If not specified, this matches with any
    ///          destination port. This setting is only used for protocols 6 (TCP) and 17 (UDP). </p>
    ///          <p>You can specify individual ports, for example <code>1994</code> and you can specify port
    ///          ranges, for example <code>1990-1994</code>. </p>
    public let destinationPorts: [PortRange]?
    /// <p>The destination IP addresses and address ranges to inspect for, in CIDR notation. If not
    ///          specified, this matches with any destination address. </p>
    public let destinations: [Address]?
    /// <p>The protocols to inspect for, specified using each protocol's assigned internet protocol
    ///          number (IANA). If not specified, this matches with any protocol. </p>
    public let protocols: [Int]?
    /// <p>The source ports to inspect for. If not specified, this matches with any source port.
    ///          This setting is only used for protocols 6 (TCP) and 17 (UDP). </p>
    ///          <p>You can specify individual ports, for example <code>1994</code> and you can specify port
    ///          ranges, for example <code>1990-1994</code>. </p>
    public let sourcePorts: [PortRange]?
    /// <p>The source IP addresses and address ranges to inspect for, in CIDR notation. If not
    ///          specified, this matches with any source address. </p>
    public let sources: [Address]?
    /// <p>The TCP flags and masks to inspect for. If not specified, this matches with any
    ///          settings. This setting is only used for protocol 6 (TCP).</p>
    public let tCPFlags: [TCPFlagField]?

    public init (
        destinationPorts: [PortRange]? = nil,
        destinations: [Address]? = nil,
        protocols: [Int]? = nil,
        sourcePorts: [PortRange]? = nil,
        sources: [Address]? = nil,
        tCPFlags: [TCPFlagField]? = nil
    )
    {
        self.destinationPorts = destinationPorts
        self.destinations = destinations
        self.protocols = protocols
        self.sourcePorts = sourcePorts
        self.sources = sources
        self.tCPFlags = tCPFlags
    }
}

extension PerObjectStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case syncStatus = "SyncStatus"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let syncStatus = syncStatus {
            try encodeContainer.encode(syncStatus.rawValue, forKey: .syncStatus)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let syncStatusDecoded = try containerValues.decodeIfPresent(PerObjectSyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension PerObjectStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PerObjectStatus(syncStatus: \(String(describing: syncStatus)), updateToken: \(String(describing: updateToken)))"}
}

/// <p>Provides configuration status for a single policy or rule group that is used for a firewall endpoint. Network Firewall
///          provides each endpoint with the rules that are configured in the firewall policy. Each time
///          you add a subnet or modify the associated firewall policy, Network Firewall synchronizes the
///           rules in the endpoint, so it can properly filter network traffic. This is part of a <a>SyncState</a> for a firewall.</p>
public struct PerObjectStatus: Equatable {
    /// <p>Indicates whether this object is in sync with the version indicated in the update token.</p>
    public let syncStatus: PerObjectSyncStatus?
    /// <p>The current version of the object that is either in sync or pending synchronization. </p>
    public let updateToken: String?

    public init (
        syncStatus: PerObjectSyncStatus? = nil,
        updateToken: String? = nil
    )
    {
        self.syncStatus = syncStatus
        self.updateToken = updateToken
    }
}

public enum PerObjectSyncStatus {
    case inSync
    case pending
    case sdkUnknown(String)
}

extension PerObjectSyncStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PerObjectSyncStatus] {
        return [
            .inSync,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inSync: return "IN_SYNC"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PerObjectSyncStatus(rawValue: rawValue) ?? PerObjectSyncStatus.sdkUnknown(rawValue)
    }
}

extension PortRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromPort = "FromPort"
        case toPort = "ToPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if fromPort != 0 {
            try encodeContainer.encode(fromPort, forKey: .fromPort)
        }
        if toPort != 0 {
            try encodeContainer.encode(toPort, forKey: .toPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromPortDecoded = try containerValues.decode(Int.self, forKey: .fromPort)
        fromPort = fromPortDecoded
        let toPortDecoded = try containerValues.decode(Int.self, forKey: .toPort)
        toPort = toPortDecoded
    }
}

extension PortRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortRange(fromPort: \(String(describing: fromPort)), toPort: \(String(describing: toPort)))"}
}

/// <p>A single port range specification. This is used for source and destination port ranges
///          in the stateless rule <a>MatchAttributes</a>, <code>SourcePorts</code>, and
///             <code>DestinationPorts</code> settings. </p>
public struct PortRange: Equatable {
    /// <p>The lower limit of the port range. This must be less than or equal to the
    ///             <code>ToPort</code> specification. </p>
    public let fromPort: Int
    /// <p>The upper limit of the port range. This must be greater than or equal to the
    ///             <code>FromPort</code> specification. </p>
    public let toPort: Int

    public init (
        fromPort: Int = 0,
        toPort: Int = 0
    )
    {
        self.fromPort = fromPort
        self.toPort = toPort
    }
}

extension PortSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case definition = "Definition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .definition)
            for variabledefinitionlist0 in definition {
                try definitionContainer.encode(variabledefinitionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .definition)
        var definitionDecoded0:[String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [String]()
            for string0 in definitionContainer {
                if let string0 = string0 {
                    definitionDecoded0?.append(string0)
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension PortSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortSet(definition: \(String(describing: definition)))"}
}

/// <p>A set of port ranges for use in the rules in a rule group. </p>
public struct PortSet: Equatable {
    /// <p>The set of port ranges.
    ///       </p>
    public let definition: [String]?

    public init (
        definition: [String]? = nil
    )
    {
        self.definition = definition
    }
}

extension PublishMetricAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensions0 in dimensions {
                try dimensionsContainer.encode(dimensions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
    }
}

extension PublishMetricAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishMetricAction(dimensions: \(String(describing: dimensions)))"}
}

/// <p>Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the
///          matching packet. This setting defines a CloudWatch dimension value to be published.</p>
public struct PublishMetricAction: Equatable {
    /// <p></p>
    public let dimensions: [Dimension]?

    public init (
        dimensions: [Dimension]? = nil
    )
    {
        self.dimensions = dimensions
    }
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Equatable {
    /// <p>The AWS Identity and Access Management policy statement that lists the accounts that you want to share your rule group or firewall policy with
    ///            and the operations that you want the accounts to be able to perform. </p>
    ///          <p>For a rule group resource, you can specify the following operations in the Actions section of the statement:</p>
    ///          <ul>
    ///             <li>
    ///                <p>network-firewall:CreateFirewallPolicy</p>
    ///             </li>
    ///             <li>
    ///                <p>network-firewall:UpdateFirewallPolicy</p>
    ///             </li>
    ///             <li>
    ///                <p>network-firewall:ListRuleGroups</p>
    ///             </li>
    ///          </ul>
    ///          <p>For a firewall policy resource, you can specify the following operations in the Actions section of the statement:</p>
    ///          <ul>
    ///             <li>
    ///                <p>network-firewall:CreateFirewall</p>
    ///             </li>
    ///             <li>
    ///                <p>network-firewall:UpdateFirewall</p>
    ///             </li>
    ///             <li>
    ///                <p>network-firewall:AssociateFirewallPolicy</p>
    ///             </li>
    ///             <li>
    ///                <p>network-firewall:ListFirewallPolicies</p>
    ///             </li>
    ///          </ul>
    ///          <p>In the Resource section of the statement, you specify the ARNs for the rule groups and firewall policies that you want to share with the account that you specified in <code>Arn</code>.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the account that you want to share rule groups and firewall policies with.</p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourcePolicyException" : self = .invalidResourcePolicyException(try InvalidResourcePolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidResourcePolicyException(InvalidResourcePolicyException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse()"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct PutResourcePolicyOutputResponseBody: Equatable {
}

extension PutResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to locate a resource using the parameters that you provided.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceOwnerCheckException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceOwnerCheckException(message: \(String(describing: message)))"}
}

extension ResourceOwnerCheckException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceOwnerCheckExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p></p>
public struct ResourceOwnerCheckException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceOwnerCheckExceptionBody: Equatable {
    public let message: String?
}

extension ResourceOwnerCheckExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceStatus {
    case active
    case deleting
    case sdkUnknown(String)
}

extension ResourceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceStatus] {
        return [
            .active,
            .deleting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleting: return "DELETING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
    }
}

extension RuleDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case matchAttributes = "MatchAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for statelessactions0 in actions {
                try actionsContainer.encode(statelessactions0)
            }
        }
        if let matchAttributes = matchAttributes {
            try encodeContainer.encode(matchAttributes, forKey: .matchAttributes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchAttributesDecoded = try containerValues.decodeIfPresent(MatchAttributes.self, forKey: .matchAttributes)
        matchAttributes = matchAttributesDecoded
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension RuleDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleDefinition(actions: \(String(describing: actions)), matchAttributes: \(String(describing: matchAttributes)))"}
}

/// <p>The inspection criteria and action for a single stateless rule. AWS Network Firewall inspects each packet for the specified matching
///          criteria. When a packet matches the criteria, Network Firewall performs the rule's actions on
///          the packet.</p>
public struct RuleDefinition: Equatable {
    /// <p>The actions to take on a packet that matches one of the stateless rule definition's
    ///          match attributes. You must specify a standard action and you can add custom actions. </p>
    ///          <note>
    ///             <p>Network Firewall only forwards a packet for stateful rule inspection if you specify
    ///                <code>aws:forward_to_sfe</code> for a rule that the packet matches, or if the packet
    ///             doesn't match any stateless rule and you specify <code>aws:forward_to_sfe</code> for the
    ///                <code>StatelessDefaultActions</code> setting for the <a>FirewallPolicy</a>.</p>
    ///          </note>
    ///          <p>For every rule, you must specify exactly one of the following standard actions. </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>aws:pass</b> - Discontinues all inspection of
    ///                the packet and permits it to go to its intended destination.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>aws:drop</b> - Discontinues all inspection of
    ///                the packet and blocks it from going to its intended destination.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>aws:forward_to_sfe</b> - Discontinues
    ///                stateless inspection of the packet and forwards it to the stateful rule engine for
    ///                inspection. </p>
    ///             </li>
    ///          </ul>
    ///          <p>Additionally, you can specify a custom action.
    ///          To
    ///          do this, you define a custom action by name and type, then provide the name you've assigned
    ///          to the action in this <code>Actions</code> setting. For information about the options, see
    ///             <a>CustomAction</a>. </p>
    ///          <p>To provide more than one action in this setting, separate the settings with a comma. For
    ///          example, if you have a custom <code>PublishMetrics</code> action that you've named
    ///             <code>MyMetricsAction</code>, then you could specify the standard action
    ///             <code>aws:pass</code> and the custom action with <code>[“aws:pass”,
    ///             “MyMetricsAction”]</code>. </p>
    public let actions: [String]?
    /// <p>Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags. </p>
    public let matchAttributes: MatchAttributes?

    public init (
        actions: [String]? = nil,
        matchAttributes: MatchAttributes? = nil
    )
    {
        self.actions = actions
        self.matchAttributes = matchAttributes
    }
}

extension RuleGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ruleVariables = "RuleVariables"
        case rulesSource = "RulesSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ruleVariables = ruleVariables {
            try encodeContainer.encode(ruleVariables, forKey: .ruleVariables)
        }
        if let rulesSource = rulesSource {
            try encodeContainer.encode(rulesSource, forKey: .rulesSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleVariablesDecoded = try containerValues.decodeIfPresent(RuleVariables.self, forKey: .ruleVariables)
        ruleVariables = ruleVariablesDecoded
        let rulesSourceDecoded = try containerValues.decodeIfPresent(RulesSource.self, forKey: .rulesSource)
        rulesSource = rulesSourceDecoded
    }
}

extension RuleGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroup(ruleVariables: \(String(describing: ruleVariables)), rulesSource: \(String(describing: rulesSource)))"}
}

/// <p>The object that defines the rules in a rule group. This, along with <a>RuleGroupResponse</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
///          <p>AWS Network Firewall uses a rule group to inspect and control network traffic.
///     You define stateless rule groups to inspect individual packets and you define stateful rule groups to inspect packets in the context of their
///     traffic flow. </p>
///          <p>To use a rule group, you include it by reference in an Network Firewall firewall policy, then you use the policy in a firewall. You can reference a rule group from
///     more than one firewall policy, and you can use a firewall policy in more than one firewall. </p>
public struct RuleGroup: Equatable {
    /// <p>Settings that are available for use in the rules in the rule group. You can only use
    ///          these for stateful rule groups. </p>
    public let ruleVariables: RuleVariables?
    /// <p>The stateful rules or stateless rules for the rule group. </p>
    public let rulesSource: RulesSource?

    public init (
        ruleVariables: RuleVariables? = nil,
        rulesSource: RulesSource? = nil
    )
    {
        self.ruleVariables = ruleVariables
        self.rulesSource = rulesSource
    }
}

extension RuleGroupMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension RuleGroupMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupMetadata(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>High-level information about a rule group, returned by <a>ListRuleGroups</a>.
///          You can use the information provided in the metadata to retrieve and manage a
///          rule group.</p>
public struct RuleGroupMetadata: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
    public let arn: String?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension RuleGroupResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case capacity = "Capacity"
        case description = "Description"
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupId = "RuleGroupId"
        case ruleGroupName = "RuleGroupName"
        case ruleGroupStatus = "RuleGroupStatus"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capacity = capacity {
            try encodeContainer.encode(capacity, forKey: .capacity)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ruleGroupArn = ruleGroupArn {
            try encodeContainer.encode(ruleGroupArn, forKey: .ruleGroupArn)
        }
        if let ruleGroupId = ruleGroupId {
            try encodeContainer.encode(ruleGroupId, forKey: .ruleGroupId)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let ruleGroupStatus = ruleGroupStatus {
            try encodeContainer.encode(ruleGroupStatus.rawValue, forKey: .ruleGroupStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupArn)
        ruleGroupArn = ruleGroupArnDecoded
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let ruleGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupId)
        ruleGroupId = ruleGroupIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RuleGroupType.self, forKey: .type)
        type = typeDecoded
        let capacityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .capacity)
        capacity = capacityDecoded
        let ruleGroupStatusDecoded = try containerValues.decodeIfPresent(ResourceStatus.self, forKey: .ruleGroupStatus)
        ruleGroupStatus = ruleGroupStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RuleGroupResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleGroupResponse(capacity: \(String(describing: capacity)), description: \(String(describing: description)), ruleGroupArn: \(String(describing: ruleGroupArn)), ruleGroupId: \(String(describing: ruleGroupId)), ruleGroupName: \(String(describing: ruleGroupName)), ruleGroupStatus: \(String(describing: ruleGroupStatus)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>The high-level properties of a rule group. This, along with the <a>RuleGroup</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
public struct RuleGroupResponse: Equatable {
    /// <p>The maximum operating resources that this rule group can use. Rule group capacity is fixed at creation.
    ///       When you update a rule group, you are limited to this capacity. When you reference a rule group
    ///       from a firewall policy, Network Firewall reserves this capacity for the rule group. </p>
    ///          <p>You can retrieve the capacity that would be required for a rule group before you create the rule group by calling
    ///       <a>CreateRuleGroup</a> with <code>DryRun</code> set to <code>TRUE</code>. </p>
    public let capacity: Int?
    /// <p>A description of the rule group. </p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
    ///          <note>
    ///             <p>If this response is for a create request that had <code>DryRun</code> set to
    ///                <code>TRUE</code>, then this ARN is a placeholder that isn't attached to a valid
    ///             resource.</p>
    ///          </note>
    public let ruleGroupArn: String?
    /// <p>The unique identifier for the rule group. </p>
    public let ruleGroupId: String?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    public let ruleGroupName: String?
    /// <p>Detailed information about the current status of a rule group. </p>
    public let ruleGroupStatus: ResourceStatus?
    /// <p>The key:value pairs to associate with the resource.</p>
    public let tags: [Tag]?
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
    /// stateless rules. If it is stateful, it contains stateful rules. </p>
    public let type: RuleGroupType?

    public init (
        capacity: Int? = nil,
        description: String? = nil,
        ruleGroupArn: String? = nil,
        ruleGroupId: String? = nil,
        ruleGroupName: String? = nil,
        ruleGroupStatus: ResourceStatus? = nil,
        tags: [Tag]? = nil,
        type: RuleGroupType? = nil
    )
    {
        self.capacity = capacity
        self.description = description
        self.ruleGroupArn = ruleGroupArn
        self.ruleGroupId = ruleGroupId
        self.ruleGroupName = ruleGroupName
        self.ruleGroupStatus = ruleGroupStatus
        self.tags = tags
        self.type = type
    }
}

public enum RuleGroupType {
    case stateful
    case stateless
    case sdkUnknown(String)
}

extension RuleGroupType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleGroupType] {
        return [
            .stateful,
            .stateless,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .stateful: return "STATEFUL"
        case .stateless: return "STATELESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleGroupType(rawValue: rawValue) ?? RuleGroupType.sdkUnknown(rawValue)
    }
}

extension RuleOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keyword = "Keyword"
        case settings = "Settings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keyword = keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let settings = settings {
            var settingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .settings)
            for settings0 in settings {
                try settingsContainer.encode(settings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyword)
        keyword = keywordDecoded
        let settingsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .settings)
        var settingsDecoded0:[String]? = nil
        if let settingsContainer = settingsContainer {
            settingsDecoded0 = [String]()
            for string0 in settingsContainer {
                if let string0 = string0 {
                    settingsDecoded0?.append(string0)
                }
            }
        }
        settings = settingsDecoded0
    }
}

extension RuleOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleOption(keyword: \(String(describing: keyword)), settings: \(String(describing: settings)))"}
}

/// <p>Additional settings for a stateful rule. This is part of the <a>StatefulRule</a> configuration.</p>
public struct RuleOption: Equatable {
    /// <p></p>
    public let keyword: String?
    /// <p></p>
    public let settings: [String]?

    public init (
        keyword: String? = nil,
        settings: [String]? = nil
    )
    {
        self.keyword = keyword
        self.settings = settings
    }
}

extension RuleVariables: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iPSets = "IPSets"
        case portSets = "PortSets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iPSets = iPSets {
            var iPSetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .iPSets)
            for (dictKey0, ipsets0) in iPSets {
                try iPSetsContainer.encode(ipsets0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let portSets = portSets {
            var portSetsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .portSets)
            for (dictKey0, portsets0) in portSets {
                try portSetsContainer.encode(portsets0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iPSetsContainer = try containerValues.decodeIfPresent([String: IPSet?].self, forKey: .iPSets)
        var iPSetsDecoded0: [String:IPSet]? = nil
        if let iPSetsContainer = iPSetsContainer {
            iPSetsDecoded0 = [String:IPSet]()
            for (key0, ipset0) in iPSetsContainer {
                if let ipset0 = ipset0 {
                    iPSetsDecoded0?[key0] = ipset0
                }
            }
        }
        iPSets = iPSetsDecoded0
        let portSetsContainer = try containerValues.decodeIfPresent([String: PortSet?].self, forKey: .portSets)
        var portSetsDecoded0: [String:PortSet]? = nil
        if let portSetsContainer = portSetsContainer {
            portSetsDecoded0 = [String:PortSet]()
            for (key0, portset0) in portSetsContainer {
                if let portset0 = portset0 {
                    portSetsDecoded0?[key0] = portset0
                }
            }
        }
        portSets = portSetsDecoded0
    }
}

extension RuleVariables: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RuleVariables(iPSets: \(String(describing: iPSets)), portSets: \(String(describing: portSets)))"}
}

/// <p>Settings that are available for use in the rules in the <a>RuleGroup</a>
///          where this is defined. </p>
public struct RuleVariables: Equatable {
    /// <p>A list of IP addresses and address ranges, in CIDR notation. </p>
    public let iPSets: [String:IPSet]?
    /// <p>A list of port ranges. </p>
    public let portSets: [String:PortSet]?

    public init (
        iPSets: [String:IPSet]? = nil,
        portSets: [String:PortSet]? = nil
    )
    {
        self.iPSets = iPSets
        self.portSets = portSets
    }
}

extension RulesSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rulesSourceList = "RulesSourceList"
        case rulesString = "RulesString"
        case statefulRules = "StatefulRules"
        case statelessRulesAndCustomActions = "StatelessRulesAndCustomActions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rulesSourceList = rulesSourceList {
            try encodeContainer.encode(rulesSourceList, forKey: .rulesSourceList)
        }
        if let rulesString = rulesString {
            try encodeContainer.encode(rulesString, forKey: .rulesString)
        }
        if let statefulRules = statefulRules {
            var statefulRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statefulRules)
            for statefulrules0 in statefulRules {
                try statefulRulesContainer.encode(statefulrules0)
            }
        }
        if let statelessRulesAndCustomActions = statelessRulesAndCustomActions {
            try encodeContainer.encode(statelessRulesAndCustomActions, forKey: .statelessRulesAndCustomActions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rulesString)
        rulesString = rulesStringDecoded
        let rulesSourceListDecoded = try containerValues.decodeIfPresent(RulesSourceList.self, forKey: .rulesSourceList)
        rulesSourceList = rulesSourceListDecoded
        let statefulRulesContainer = try containerValues.decodeIfPresent([StatefulRule?].self, forKey: .statefulRules)
        var statefulRulesDecoded0:[StatefulRule]? = nil
        if let statefulRulesContainer = statefulRulesContainer {
            statefulRulesDecoded0 = [StatefulRule]()
            for structure0 in statefulRulesContainer {
                if let structure0 = structure0 {
                    statefulRulesDecoded0?.append(structure0)
                }
            }
        }
        statefulRules = statefulRulesDecoded0
        let statelessRulesAndCustomActionsDecoded = try containerValues.decodeIfPresent(StatelessRulesAndCustomActions.self, forKey: .statelessRulesAndCustomActions)
        statelessRulesAndCustomActions = statelessRulesAndCustomActionsDecoded
    }
}

extension RulesSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RulesSource(rulesSourceList: \(String(describing: rulesSourceList)), rulesString: \(String(describing: rulesString)), statefulRules: \(String(describing: statefulRules)), statelessRulesAndCustomActions: \(String(describing: statelessRulesAndCustomActions)))"}
}

/// <p>The stateless or stateful rules definitions for use in a single rule group. Each rule
///          group requires a single <code>RulesSource</code>. You can use an instance of this for
///          either stateless rules or stateful rules. </p>
public struct RulesSource: Equatable {
    /// <p>Stateful inspection criteria for a domain list rule group. </p>
    public let rulesSourceList: RulesSourceList?
    /// <p>Stateful inspection criteria, provided in Suricata compatible intrusion prevention
    ///          system (IPS) rules. Suricata is an open-source network IPS that includes a standard
    ///          rule-based language for network traffic inspection.</p>
    ///          <p>These rules contain the inspection criteria and the action to take for traffic that
    ///          matches the criteria, so this type of rule group doesn't have a separate action
    ///          setting.</p>
    public let rulesString: String?
    /// <p>The 5-tuple stateful inspection criteria. This contains an array of individual 5-tuple
    ///          stateful rules to be used together in a stateful rule group. </p>
    public let statefulRules: [StatefulRule]?
    /// <p>Stateless inspection criteria to be used in a stateless rule group. </p>
    public let statelessRulesAndCustomActions: StatelessRulesAndCustomActions?

    public init (
        rulesSourceList: RulesSourceList? = nil,
        rulesString: String? = nil,
        statefulRules: [StatefulRule]? = nil,
        statelessRulesAndCustomActions: StatelessRulesAndCustomActions? = nil
    )
    {
        self.rulesSourceList = rulesSourceList
        self.rulesString = rulesString
        self.statefulRules = statefulRules
        self.statelessRulesAndCustomActions = statelessRulesAndCustomActions
    }
}

extension RulesSourceList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case generatedRulesType = "GeneratedRulesType"
        case targetTypes = "TargetTypes"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedRulesType = generatedRulesType {
            try encodeContainer.encode(generatedRulesType.rawValue, forKey: .generatedRulesType)
        }
        if let targetTypes = targetTypes {
            var targetTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetTypes)
            for targettypes0 in targetTypes {
                try targetTypesContainer.encode(targettypes0.rawValue)
            }
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for ruletargets0 in targets {
                try targetsContainer.encode(ruletargets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .targets)
        var targetsDecoded0:[String]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [String]()
            for string0 in targetsContainer {
                if let string0 = string0 {
                    targetsDecoded0?.append(string0)
                }
            }
        }
        targets = targetsDecoded0
        let targetTypesContainer = try containerValues.decodeIfPresent([TargetType?].self, forKey: .targetTypes)
        var targetTypesDecoded0:[TargetType]? = nil
        if let targetTypesContainer = targetTypesContainer {
            targetTypesDecoded0 = [TargetType]()
            for string0 in targetTypesContainer {
                if let string0 = string0 {
                    targetTypesDecoded0?.append(string0)
                }
            }
        }
        targetTypes = targetTypesDecoded0
        let generatedRulesTypeDecoded = try containerValues.decodeIfPresent(GeneratedRulesType.self, forKey: .generatedRulesType)
        generatedRulesType = generatedRulesTypeDecoded
    }
}

extension RulesSourceList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RulesSourceList(generatedRulesType: \(String(describing: generatedRulesType)), targetTypes: \(String(describing: targetTypes)), targets: \(String(describing: targets)))"}
}

/// <p>Stateful inspection criteria for a domain list rule group. </p>
///          <p>For HTTPS traffic, domain filtering is SNI-based. It uses the server name indicator extension of the TLS handshake.</p>
///          <p>By default, Network Firewall domain list inspection only includes traffic coming from the VPC where you deploy the firewall. To inspect traffic from IP addresses outside of the deployment VPC, you set the <code>HOME_NET</code> rule variable to include the CIDR range of the deployment VPC plus the other CIDR ranges. For more information, see <a>RuleVariables</a> in this guide and <a href="https://docs.aws.amazon.com/network-firewall/latest/developerguide/stateful-rule-groups-domain-names.html">Stateful domain list rule groups in AWS Network Firewall</a> in the <i>Network Firewall Developer Guide</i>
///          </p>
public struct RulesSourceList: Equatable {
    /// <p>Whether you want to allow or deny access to the domains in your target list.</p>
    public let generatedRulesType: GeneratedRulesType?
    /// <p>The protocols you want to inspect. Specify <code>TLS_SNI</code> for <code>HTTPS</code>. Specity <code>HTTP_HOST</code> for <code>HTTP</code>. You can specify either or both. </p>
    public let targetTypes: [TargetType]?
    /// <p>The domains that you want to inspect for in your traffic flows. To provide multiple
    ///          domains, separate them with commas. Valid domain specifications are the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Explicit names. For example, <code>abc.example.com</code> matches only the domain <code>abc.example.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Names that use a domain wildcard, which you indicate with an initial '<code>.</code>'. For example,<code>.example.com</code> matches <code>example.com</code> and matches all subdomains of <code>example.com</code>, such as <code>abc.example.com</code> and <code>www.example.com</code>. </p>
    /// 	           </li>
    ///          </ul>
    public let targets: [String]?

    public init (
        generatedRulesType: GeneratedRulesType? = nil,
        targetTypes: [TargetType]? = nil,
        targets: [String]? = nil
    )
    {
        self.generatedRulesType = generatedRulesType
        self.targetTypes = targetTypes
        self.targets = targets
    }
}

public enum StatefulAction {
    case alert
    case drop
    case pass
    case sdkUnknown(String)
}

extension StatefulAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatefulAction] {
        return [
            .alert,
            .drop,
            .pass,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .alert: return "ALERT"
        case .drop: return "DROP"
        case .pass: return "PASS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatefulAction(rawValue: rawValue) ?? StatefulAction.sdkUnknown(rawValue)
    }
}

extension StatefulRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case header = "Header"
        case ruleOptions = "RuleOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let header = header {
            try encodeContainer.encode(header, forKey: .header)
        }
        if let ruleOptions = ruleOptions {
            var ruleOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleOptions)
            for ruleoptions0 in ruleOptions {
                try ruleOptionsContainer.encode(ruleoptions0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(StatefulAction.self, forKey: .action)
        action = actionDecoded
        let headerDecoded = try containerValues.decodeIfPresent(Header.self, forKey: .header)
        header = headerDecoded
        let ruleOptionsContainer = try containerValues.decodeIfPresent([RuleOption?].self, forKey: .ruleOptions)
        var ruleOptionsDecoded0:[RuleOption]? = nil
        if let ruleOptionsContainer = ruleOptionsContainer {
            ruleOptionsDecoded0 = [RuleOption]()
            for structure0 in ruleOptionsContainer {
                if let structure0 = structure0 {
                    ruleOptionsDecoded0?.append(structure0)
                }
            }
        }
        ruleOptions = ruleOptionsDecoded0
    }
}

extension StatefulRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatefulRule(action: \(String(describing: action)), header: \(String(describing: header)), ruleOptions: \(String(describing: ruleOptions)))"}
}

/// <p>A single 5-tuple stateful rule, for use in a stateful rule group.</p>
public struct StatefulRule: Equatable {
    /// <p>Defines what Network Firewall should do with the packets in a traffic flow when the flow
    ///          matches the stateful rule criteria. For all actions, Network Firewall performs the specified
    ///          action and discontinues stateful inspection of the traffic flow. </p>
    ///          <p>The actions for a stateful rule are defined as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>PASS</b> - Permits the packets to go to the
    ///                intended destination.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>DROP</b> - Blocks the packets from going to
    ///                the intended destination and sends an alert log message, if alert logging is configured in the <a>Firewall</a>
    ///                   <a>LoggingConfiguration</a>. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>ALERT</b> - Permits the packets to go to the
    ///                intended destination and sends an alert log message, if alert logging is configured in the <a>Firewall</a>
    ///                   <a>LoggingConfiguration</a>. </p>
    ///                <p>You can use this action to test a rule that you intend to use to drop traffic. You
    ///                can enable the rule with <code>ALERT</code> action, verify in the logs that the rule
    ///                is filtering as you want, then change the action to <code>DROP</code>.</p>
    ///             </li>
    ///          </ul>
    public let action: StatefulAction?
    /// <p>The stateful 5-tuple inspection criteria for this rule, used to inspect traffic flows.
    ///       </p>
    public let header: Header?
    /// <p></p>
    public let ruleOptions: [RuleOption]?

    public init (
        action: StatefulAction? = nil,
        header: Header? = nil,
        ruleOptions: [RuleOption]? = nil
    )
    {
        self.action = action
        self.header = header
        self.ruleOptions = ruleOptions
    }
}

public enum StatefulRuleDirection {
    case any
    case forward
    case sdkUnknown(String)
}

extension StatefulRuleDirection : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatefulRuleDirection] {
        return [
            .any,
            .forward,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .any: return "ANY"
        case .forward: return "FORWARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatefulRuleDirection(rawValue: rawValue) ?? StatefulRuleDirection.sdkUnknown(rawValue)
    }
}

extension StatefulRuleGroupReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StatefulRuleGroupReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatefulRuleGroupReference(resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>Identifier for a single stateful rule group, used in a firewall policy to refer to a
///          rule group. </p>
public struct StatefulRuleGroupReference: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the stateful rule group.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public enum StatefulRuleProtocol {
    case any
    case dcerpc
    case dhcp
    case dns
    case ftp
    case http
    case icmp
    case ikev2
    case imap
    case krb5
    case msn
    case ntp
    case smb
    case smtp
    case ssh
    case tcp
    case tftp
    case tls
    case udp
    case sdkUnknown(String)
}

extension StatefulRuleProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StatefulRuleProtocol] {
        return [
            .any,
            .dcerpc,
            .dhcp,
            .dns,
            .ftp,
            .http,
            .icmp,
            .ikev2,
            .imap,
            .krb5,
            .msn,
            .ntp,
            .smb,
            .smtp,
            .ssh,
            .tcp,
            .tftp,
            .tls,
            .udp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .any: return "IP"
        case .dcerpc: return "DCERPC"
        case .dhcp: return "DHCP"
        case .dns: return "DNS"
        case .ftp: return "FTP"
        case .http: return "HTTP"
        case .icmp: return "ICMP"
        case .ikev2: return "IKEV2"
        case .imap: return "IMAP"
        case .krb5: return "KRB5"
        case .msn: return "MSN"
        case .ntp: return "NTP"
        case .smb: return "SMB"
        case .smtp: return "SMTP"
        case .ssh: return "SSH"
        case .tcp: return "TCP"
        case .tftp: return "TFTP"
        case .tls: return "TLS"
        case .udp: return "UDP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StatefulRuleProtocol(rawValue: rawValue) ?? StatefulRuleProtocol.sdkUnknown(rawValue)
    }
}

extension StatelessRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority = "Priority"
        case ruleDefinition = "RuleDefinition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let ruleDefinition = ruleDefinition {
            try encodeContainer.encode(ruleDefinition, forKey: .ruleDefinition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDefinitionDecoded = try containerValues.decodeIfPresent(RuleDefinition.self, forKey: .ruleDefinition)
        ruleDefinition = ruleDefinitionDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension StatelessRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatelessRule(priority: \(String(describing: priority)), ruleDefinition: \(String(describing: ruleDefinition)))"}
}

/// <p>A single stateless rule. This is used in <a>StatelessRulesAndCustomActions</a>.</p>
public struct StatelessRule: Equatable {
    /// <p>A setting that indicates the order in which to run this rule relative to all of the
    ///          rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a
    ///          rule group starting with the lowest priority setting. You must ensure that the priority
    ///          settings are unique for the rule group. </p>
    ///          <p>Each stateless rule group uses exactly one <code>StatelessRulesAndCustomActions</code>
    ///          object, and each <code>StatelessRulesAndCustomActions</code> contains exactly one
    ///             <code>StatelessRules</code> object. To ensure unique priority settings for your rule
    ///          groups, set unique priorities for the stateless rules that you define inside any single
    ///             <code>StatelessRules</code> object.</p>
    ///          <p>You can change the priority settings of your rules at any time. To make it easier to
    ///          insert rules later, number them so there's a wide range in between, for example use 100,
    ///          200, and so on. </p>
    public let priority: Int
    /// <p>Defines the stateless 5-tuple packet inspection criteria and the action to take on a
    ///          packet that matches the criteria. </p>
    public let ruleDefinition: RuleDefinition?

    public init (
        priority: Int = 0,
        ruleDefinition: RuleDefinition? = nil
    )
    {
        self.priority = priority
        self.ruleDefinition = ruleDefinition
    }
}

extension StatelessRuleGroupReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case priority = "Priority"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if priority != 0 {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let priorityDecoded = try containerValues.decode(Int.self, forKey: .priority)
        priority = priorityDecoded
    }
}

extension StatelessRuleGroupReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatelessRuleGroupReference(priority: \(String(describing: priority)), resourceArn: \(String(describing: resourceArn)))"}
}

/// <p>Identifier for a single stateless rule group, used in a firewall policy to refer to the
///          rule group. </p>
public struct StatelessRuleGroupReference: Equatable {
    /// <p>An integer setting that indicates the order in which to run the stateless rule groups in
    ///          a single <a>FirewallPolicy</a>. Network Firewall applies each stateless rule group
    ///          to a packet starting with the group that has the lowest priority setting. You must ensure
    ///          that the priority settings are unique within each policy.</p>
    public let priority: Int
    /// <p>The Amazon Resource Name (ARN) of the stateless rule group.</p>
    public let resourceArn: String?

    public init (
        priority: Int = 0,
        resourceArn: String? = nil
    )
    {
        self.priority = priority
        self.resourceArn = resourceArn
    }
}

extension StatelessRulesAndCustomActions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customActions = "CustomActions"
        case statelessRules = "StatelessRules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customActions = customActions {
            var customActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .customActions)
            for customactions0 in customActions {
                try customActionsContainer.encode(customactions0)
            }
        }
        if let statelessRules = statelessRules {
            var statelessRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statelessRules)
            for statelessrules0 in statelessRules {
                try statelessRulesContainer.encode(statelessrules0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statelessRulesContainer = try containerValues.decodeIfPresent([StatelessRule?].self, forKey: .statelessRules)
        var statelessRulesDecoded0:[StatelessRule]? = nil
        if let statelessRulesContainer = statelessRulesContainer {
            statelessRulesDecoded0 = [StatelessRule]()
            for structure0 in statelessRulesContainer {
                if let structure0 = structure0 {
                    statelessRulesDecoded0?.append(structure0)
                }
            }
        }
        statelessRules = statelessRulesDecoded0
        let customActionsContainer = try containerValues.decodeIfPresent([CustomAction?].self, forKey: .customActions)
        var customActionsDecoded0:[CustomAction]? = nil
        if let customActionsContainer = customActionsContainer {
            customActionsDecoded0 = [CustomAction]()
            for structure0 in customActionsContainer {
                if let structure0 = structure0 {
                    customActionsDecoded0?.append(structure0)
                }
            }
        }
        customActions = customActionsDecoded0
    }
}

extension StatelessRulesAndCustomActions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatelessRulesAndCustomActions(customActions: \(String(describing: customActions)), statelessRules: \(String(describing: statelessRules)))"}
}

/// <p>Stateless inspection criteria. Each stateless rule group uses exactly one of these data
///          types to define its stateless rules. </p>
public struct StatelessRulesAndCustomActions: Equatable {
    /// <p>Defines an array of individual custom action definitions that are available for use by
    ///          the stateless rules in this <code>StatelessRulesAndCustomActions</code> specification. You
    ///          name each custom action that you define, and then you can use it by name in your <a>StatelessRule</a>
    ///             <a>RuleDefinition</a>
    ///             <code>Actions</code> specification.</p>
    public let customActions: [CustomAction]?
    /// <p>Defines the set of stateless rules for use in a stateless rule group. </p>
    public let statelessRules: [StatelessRule]?

    public init (
        customActions: [CustomAction]? = nil,
        statelessRules: [StatelessRule]? = nil
    )
    {
        self.customActions = customActions
        self.statelessRules = statelessRules
    }
}

extension SubnetMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetId = "SubnetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
    }
}

extension SubnetMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetMapping(subnetId: \(String(describing: subnetId)))"}
}

/// <p>The ID for a subnet that you want to associate with the firewall. This is used with
///             <a>CreateFirewall</a> and <a>AssociateSubnets</a>. AWS Network Firewall
///          creates an instance of the associated firewall in each subnet that you specify, to filter
///          traffic in the subnet's Availability Zone.</p>
public struct SubnetMapping: Equatable {
    /// <p>The unique identifier for the subnet. </p>
    public let subnetId: String?

    public init (
        subnetId: String? = nil
    )
    {
        self.subnetId = subnetId
    }
}

extension SyncState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attachment = "Attachment"
        case config = "Config"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachment = attachment {
            try encodeContainer.encode(attachment, forKey: .attachment)
        }
        if let config = config {
            var configContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .config)
            for (dictKey0, syncstateconfig0) in config {
                try configContainer.encode(syncstateconfig0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentDecoded = try containerValues.decodeIfPresent(Attachment.self, forKey: .attachment)
        attachment = attachmentDecoded
        let configContainer = try containerValues.decodeIfPresent([String: PerObjectStatus?].self, forKey: .config)
        var configDecoded0: [String:PerObjectStatus]? = nil
        if let configContainer = configContainer {
            configDecoded0 = [String:PerObjectStatus]()
            for (key0, perobjectstatus0) in configContainer {
                if let perobjectstatus0 = perobjectstatus0 {
                    configDecoded0?[key0] = perobjectstatus0
                }
            }
        }
        config = configDecoded0
    }
}

extension SyncState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SyncState(attachment: \(String(describing: attachment)), config: \(String(describing: config)))"}
}

/// <p>The status of the firewall endpoint and firewall policy configuration for a single VPC
///          subnet. </p>
///          <p>For each VPC subnet that you associate with a firewall, AWS Network Firewall does the
///          following: </p>
///          <ul>
///             <li>
///                <p>Instantiates a firewall endpoint in the subnet, ready to take traffic.</p>
///             </li>
///             <li>
///                <p>Configures the endpoint with the current firewall policy settings, to provide the
///                filtering behavior for the endpoint.</p>
///             </li>
///          </ul>
///          <p>When you update a firewall, for example to add a subnet association or change a rule
///          group in the firewall policy, the affected sync states reflect out-of-sync or not ready
///          status until the changes are complete. </p>
public struct SyncState: Equatable {
    /// <p>The attachment status of the firewall's association with a single VPC subnet. For each
    ///          configured subnet, Network Firewall creates the attachment by instantiating the firewall
    ///          endpoint in the subnet so that it's ready to take traffic. This is part of the <a>FirewallStatus</a>.</p>
    public let attachment: Attachment?
    /// <p>The configuration status of the firewall endpoint in a single VPC subnet. Network Firewall
    ///          provides each endpoint with the rules that are configured in the firewall policy. Each time
    ///          you add a subnet or modify the associated firewall policy, Network Firewall synchronizes the
    ///          rules in the endpoint, so it can properly filter network traffic. This is part of the <a>FirewallStatus</a>.</p>
    public let config: [String:PerObjectStatus]?

    public init (
        attachment: Attachment? = nil,
        config: [String:PerObjectStatus]? = nil
    )
    {
        self.attachment = attachment
        self.config = config
    }
}

public enum TCPFlag {
    case ack
    case cwr
    case ece
    case fin
    case psh
    case rst
    case syn
    case urg
    case sdkUnknown(String)
}

extension TCPFlag : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TCPFlag] {
        return [
            .ack,
            .cwr,
            .ece,
            .fin,
            .psh,
            .rst,
            .syn,
            .urg,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ack: return "ACK"
        case .cwr: return "CWR"
        case .ece: return "ECE"
        case .fin: return "FIN"
        case .psh: return "PSH"
        case .rst: return "RST"
        case .syn: return "SYN"
        case .urg: return "URG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TCPFlag(rawValue: rawValue) ?? TCPFlag.sdkUnknown(rawValue)
    }
}

extension TCPFlagField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case flags = "Flags"
        case masks = "Masks"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let flags = flags {
            var flagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flags)
            for flags0 in flags {
                try flagsContainer.encode(flags0.rawValue)
            }
        }
        if let masks = masks {
            var masksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .masks)
            for flags0 in masks {
                try masksContainer.encode(flags0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let flagsContainer = try containerValues.decodeIfPresent([TCPFlag?].self, forKey: .flags)
        var flagsDecoded0:[TCPFlag]? = nil
        if let flagsContainer = flagsContainer {
            flagsDecoded0 = [TCPFlag]()
            for string0 in flagsContainer {
                if let string0 = string0 {
                    flagsDecoded0?.append(string0)
                }
            }
        }
        flags = flagsDecoded0
        let masksContainer = try containerValues.decodeIfPresent([TCPFlag?].self, forKey: .masks)
        var masksDecoded0:[TCPFlag]? = nil
        if let masksContainer = masksContainer {
            masksDecoded0 = [TCPFlag]()
            for string0 in masksContainer {
                if let string0 = string0 {
                    masksDecoded0?.append(string0)
                }
            }
        }
        masks = masksDecoded0
    }
}

extension TCPFlagField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TCPFlagField(flags: \(String(describing: flags)), masks: \(String(describing: masks)))"}
}

/// <p>TCP flags and masks to inspect packets for, used in stateless rules <a>MatchAttributes</a> settings.</p>
public struct TCPFlagField: Equatable {
    /// <p>Used in conjunction with the <code>Masks</code> setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the <code>Masks</code> setting.</p>
    ///          <p>For the flags that are specified in the masks setting, the following must be true for the packet to match: </p>
    ///          <ul>
    ///             <li>
    ///                <p>The ones that are set in this flags setting must be set in the packet. </p>
    ///            </li>
    ///             <li>
    ///                <p>The ones that are not set in this flags setting must also not be set in the packet. </p>
    ///            </li>
    ///          </ul>
    public let flags: [TCPFlag]?
    /// <p>The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.</p>
    public let masks: [TCPFlag]?

    public init (
        flags: [TCPFlag]? = nil,
        masks: [TCPFlag]? = nil
    )
    {
        self.flags = flags
        self.masks = masks
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key:value pair associated with an AWS resource. The key:value pair can be anything you
///          define. Typically, the tag key represents a category (such as "environment") and the tag
///          value represents a specific value within that category (such as "test," "development," or
///          "production"). You can add up to 50 tags to each AWS resource. </p>
public struct Tag: Equatable {
    /// <p>The part of the key:value pair that defines a tag. You can use a tag key to describe a
    ///          category of information, such as "customer." Tag keys are case-sensitive.</p>
    public let key: String?
    /// <p>The part of the key:value pair that defines a tag. You can use a tag value to describe a
    ///          specific value within a category, such as "companyA" or "companyB." Tag values are
    ///          case-sensitive.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p></p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TargetType {
    case httpHost
    case tlsSni
    case sdkUnknown(String)
}

extension TargetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TargetType] {
        return [
            .httpHost,
            .tlsSni,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .httpHost: return "HTTP_HOST"
        case .tlsSni: return "TLS_SNI"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to process the request due to throttling limitations.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation you requested isn't supported by Network Firewall. </p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p></p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFirewallDeleteProtectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallDeleteProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDeleteProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDeleteProtectionOutputError>
}

extension UpdateFirewallDeleteProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDeleteProtectionInput(deleteProtection: \(String(describing: deleteProtection)), firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallDeleteProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deleteProtection != false {
            try encodeContainer.encode(deleteProtection, forKey: .deleteProtection)
        }
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateFirewallDeleteProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallDeleteProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDeleteProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDeleteProtectionOutputError>
}

public struct UpdateFirewallDeleteProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallDeleteProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDeleteProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDeleteProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDeleteProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDeleteProtectionOutputError>
}

public struct UpdateFirewallDeleteProtectionInput: Equatable {
    /// <p>A flag indicating whether it is possible to delete the firewall. A setting of <code>TRUE</code> indicates
    ///          that the firewall is protected against deletion. Use this setting to protect against
    ///          accidentally deleting a firewall that is in use. When you create a firewall, the operation initializes this flag to <code>TRUE</code>.</p>
    public let deleteProtection: Bool
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        deleteProtection: Bool = false,
        firewallArn: String? = nil,
        firewallName: String? = nil,
        updateToken: String? = nil
    )
    {
        self.deleteProtection = deleteProtection
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.updateToken = updateToken
    }
}

struct UpdateFirewallDeleteProtectionInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let deleteProtection: Bool
}

extension UpdateFirewallDeleteProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let deleteProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deleteProtection)
        deleteProtection = deleteProtectionDecoded
    }
}

extension UpdateFirewallDeleteProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallDeleteProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceOwnerCheckException" : self = .resourceOwnerCheckException(try ResourceOwnerCheckException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallDeleteProtectionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceOwnerCheckException(ResourceOwnerCheckException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallDeleteProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDeleteProtectionOutputResponse(deleteProtection: \(String(describing: deleteProtection)), firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallDeleteProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallDeleteProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deleteProtection = output.deleteProtection
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.updateToken = output.updateToken
        } else {
            self.deleteProtection = false
            self.firewallArn = nil
            self.firewallName = nil
            self.updateToken = nil
        }
    }
}

public struct UpdateFirewallDeleteProtectionOutputResponse: Equatable {
    /// <p></p>
    public let deleteProtection: Bool
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        deleteProtection: Bool = false,
        firewallArn: String? = nil,
        firewallName: String? = nil,
        updateToken: String? = nil
    )
    {
        self.deleteProtection = deleteProtection
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.updateToken = updateToken
    }
}

struct UpdateFirewallDeleteProtectionOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let deleteProtection: Bool
    public let updateToken: String?
}

extension UpdateFirewallDeleteProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deleteProtection = "DeleteProtection"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let deleteProtectionDecoded = try containerValues.decode(Bool.self, forKey: .deleteProtection)
        deleteProtection = deleteProtectionDecoded
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

public struct UpdateFirewallDescriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallDescriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDescriptionOutputError>
}

extension UpdateFirewallDescriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDescriptionInput(description: \(String(describing: description)), firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallDescriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateFirewallDescriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallDescriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDescriptionOutputError>
}

public struct UpdateFirewallDescriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallDescriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallDescriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallDescriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallDescriptionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallDescriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallDescriptionOutputError>
}

public struct UpdateFirewallDescriptionInput: Equatable {
    /// <p>The new description for the firewall. If you omit this setting, Network Firewall removes
    ///          the description for the firewall.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        description: String? = nil,
        firewallArn: String? = nil,
        firewallName: String? = nil,
        updateToken: String? = nil
    )
    {
        self.description = description
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.updateToken = updateToken
    }
}

struct UpdateFirewallDescriptionInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let description: String?
}

extension UpdateFirewallDescriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateFirewallDescriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallDescriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallDescriptionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallDescriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallDescriptionOutputResponse(description: \(String(describing: description)), firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallDescriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallDescriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.updateToken = output.updateToken
        } else {
            self.description = nil
            self.firewallArn = nil
            self.firewallName = nil
            self.updateToken = nil
        }
    }
}

public struct UpdateFirewallDescriptionOutputResponse: Equatable {
    /// <p>A description of the firewall.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        description: String? = nil,
        firewallArn: String? = nil,
        firewallName: String? = nil,
        updateToken: String? = nil
    )
    {
        self.description = description
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.updateToken = updateToken
    }
}

struct UpdateFirewallDescriptionOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let description: String?
    public let updateToken: String?
}

extension UpdateFirewallDescriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

public struct UpdateFirewallPolicyChangeProtectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyChangeProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyChangeProtectionOutputError>
}

extension UpdateFirewallPolicyChangeProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallPolicyChangeProtectionInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), firewallPolicyChangeProtection: \(String(describing: firewallPolicyChangeProtection)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallPolicyChangeProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if firewallPolicyChangeProtection != false {
            try encodeContainer.encode(firewallPolicyChangeProtection, forKey: .firewallPolicyChangeProtection)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateFirewallPolicyChangeProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyChangeProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyChangeProtectionOutputError>
}

public struct UpdateFirewallPolicyChangeProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyChangeProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyChangeProtectionOutputError>
}

public struct UpdateFirewallPolicyChangeProtectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
    ///          Use this setting to protect against
    ///          accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let firewallPolicyChangeProtection: Bool
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        firewallPolicyChangeProtection: Bool = false,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
        self.updateToken = updateToken
    }
}

struct UpdateFirewallPolicyChangeProtectionInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let firewallPolicyChangeProtection: Bool
}

extension UpdateFirewallPolicyChangeProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .firewallPolicyChangeProtection)
        firewallPolicyChangeProtection = firewallPolicyChangeProtectionDecoded
    }
}

extension UpdateFirewallPolicyChangeProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallPolicyChangeProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceOwnerCheckException" : self = .resourceOwnerCheckException(try ResourceOwnerCheckException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallPolicyChangeProtectionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceOwnerCheckException(ResourceOwnerCheckException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallPolicyChangeProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallPolicyChangeProtectionOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), firewallPolicyChangeProtection: \(String(describing: firewallPolicyChangeProtection)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallPolicyChangeProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallPolicyChangeProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.firewallPolicyChangeProtection = output.firewallPolicyChangeProtection
            self.updateToken = output.updateToken
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.firewallPolicyChangeProtection = false
            self.updateToken = nil
        }
    }
}

public struct UpdateFirewallPolicyChangeProtectionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>A setting indicating whether the firewall is protected against a change to the firewall policy association.
    ///          Use this setting to protect against
    ///          accidentally modifying the firewall policy for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let firewallPolicyChangeProtection: Bool
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        firewallPolicyChangeProtection: Bool = false,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.firewallPolicyChangeProtection = firewallPolicyChangeProtection
        self.updateToken = updateToken
    }
}

struct UpdateFirewallPolicyChangeProtectionOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let firewallPolicyChangeProtection: Bool
}

extension UpdateFirewallPolicyChangeProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case firewallPolicyChangeProtection = "FirewallPolicyChangeProtection"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let firewallPolicyChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .firewallPolicyChangeProtection)
        firewallPolicyChangeProtection = firewallPolicyChangeProtectionDecoded
    }
}

public struct UpdateFirewallPolicyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyOutputError>
}

extension UpdateFirewallPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallPolicyInput(description: \(String(describing: description)), dryRun: \(String(describing: dryRun)), firewallPolicy: \(String(describing: firewallPolicy)), firewallPolicyArn: \(String(describing: firewallPolicyArn)), firewallPolicyName: \(String(describing: firewallPolicyName)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let firewallPolicy = firewallPolicy {
            try encodeContainer.encode(firewallPolicy, forKey: .firewallPolicy)
        }
        if let firewallPolicyArn = firewallPolicyArn {
            try encodeContainer.encode(firewallPolicyArn, forKey: .firewallPolicyArn)
        }
        if let firewallPolicyName = firewallPolicyName {
            try encodeContainer.encode(firewallPolicyName, forKey: .firewallPolicyName)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateFirewallPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyOutputError>
}

public struct UpdateFirewallPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFirewallPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFirewallPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFirewallPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFirewallPolicyInput>
    public typealias MOutput = OperationOutput<UpdateFirewallPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFirewallPolicyOutputError>
}

public struct UpdateFirewallPolicyInput: Equatable {
    /// <p>A description of the firewall policy.</p>
    public let description: String?
    /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
    ///          <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
    ///          but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
    ///          dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
    ///          the required permissions to run the request and that your request parameters are valid. </p>
    ///          <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
    public let dryRun: Bool
    /// <p>The updated firewall policy to use for the firewall. </p>
    public let firewallPolicy: FirewallPolicy?
    /// <p>The Amazon Resource Name (ARN) of the firewall policy.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyArn: String?
    /// <p>The descriptive name of the firewall policy. You can't change the name of a firewall policy after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallPolicyName: String?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    ///          <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        description: String? = nil,
        dryRun: Bool = false,
        firewallPolicy: FirewallPolicy? = nil,
        firewallPolicyArn: String? = nil,
        firewallPolicyName: String? = nil,
        updateToken: String? = nil
    )
    {
        self.description = description
        self.dryRun = dryRun
        self.firewallPolicy = firewallPolicy
        self.firewallPolicyArn = firewallPolicyArn
        self.firewallPolicyName = firewallPolicyName
        self.updateToken = updateToken
    }
}

struct UpdateFirewallPolicyInputBody: Equatable {
    public let updateToken: String?
    public let firewallPolicyArn: String?
    public let firewallPolicyName: String?
    public let firewallPolicy: FirewallPolicy?
    public let description: String?
    public let dryRun: Bool
}

extension UpdateFirewallPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case firewallPolicy = "FirewallPolicy"
        case firewallPolicyArn = "FirewallPolicyArn"
        case firewallPolicyName = "FirewallPolicyName"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallPolicyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyArn)
        firewallPolicyArn = firewallPolicyArnDecoded
        let firewallPolicyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallPolicyName)
        firewallPolicyName = firewallPolicyNameDecoded
        let firewallPolicyDecoded = try containerValues.decodeIfPresent(FirewallPolicy.self, forKey: .firewallPolicy)
        firewallPolicy = firewallPolicyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpdateFirewallPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFirewallPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFirewallPolicyOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFirewallPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFirewallPolicyOutputResponse(firewallPolicyResponse: \(String(describing: firewallPolicyResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateFirewallPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFirewallPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallPolicyResponse = output.firewallPolicyResponse
            self.updateToken = output.updateToken
        } else {
            self.firewallPolicyResponse = nil
            self.updateToken = nil
        }
    }
}

public struct UpdateFirewallPolicyOutputResponse: Equatable {
    /// <p>The high-level properties of a firewall policy. This, along with the <a>FirewallPolicy</a>, define the policy. You can retrieve all objects for a firewall policy by calling <a>DescribeFirewallPolicy</a>. </p>
    public let firewallPolicyResponse: FirewallPolicyResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the firewall policy. The token marks the state of the policy resource at the time of the request. </p>
    ///          <p>To make changes to the policy, you provide the token in your request. Network Firewall uses the token to ensure that the policy hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall policy again to get a current copy of it with current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallPolicyResponse: FirewallPolicyResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.firewallPolicyResponse = firewallPolicyResponse
        self.updateToken = updateToken
    }
}

struct UpdateFirewallPolicyOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewallPolicyResponse: FirewallPolicyResponse?
}

extension UpdateFirewallPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallPolicyResponse = "FirewallPolicyResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallPolicyResponseDecoded = try containerValues.decodeIfPresent(FirewallPolicyResponse.self, forKey: .firewallPolicyResponse)
        firewallPolicyResponse = firewallPolicyResponseDecoded
    }
}

public struct UpdateLoggingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLoggingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggingConfigurationOutputError>
}

extension UpdateLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoggingConfigurationInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension UpdateLoggingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case loggingConfiguration = "LoggingConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
    }
}

public struct UpdateLoggingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLoggingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggingConfigurationOutputError>
}

public struct UpdateLoggingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLoggingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLoggingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLoggingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLoggingConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateLoggingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLoggingConfigurationOutputError>
}

public struct UpdateLoggingConfigurationInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>Defines how Network Firewall performs logging for a firewall. If you omit this setting,
    ///          Network Firewall disables logging for the firewall.</p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.loggingConfiguration = loggingConfiguration
    }
}

struct UpdateLoggingConfigurationInputBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let loggingConfiguration: LoggingConfiguration?
}

extension UpdateLoggingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

extension UpdateLoggingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLoggingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LogDestinationPermissionException" : self = .logDestinationPermissionException(try LogDestinationPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLoggingConfigurationOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case logDestinationPermissionException(LogDestinationPermissionException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLoggingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLoggingConfigurationOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), loggingConfiguration: \(String(describing: loggingConfiguration)))"}
}

extension UpdateLoggingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLoggingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.loggingConfiguration = output.loggingConfiguration
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.loggingConfiguration = nil
        }
    }
}

public struct UpdateLoggingConfigurationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>Defines how AWS Network Firewall performs logging for a <a>Firewall</a>. </p>
    public let loggingConfiguration: LoggingConfiguration?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        loggingConfiguration: LoggingConfiguration? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.loggingConfiguration = loggingConfiguration
    }
}

struct UpdateLoggingConfigurationOutputResponseBody: Equatable {
    public let firewallArn: String?
    public let firewallName: String?
    public let loggingConfiguration: LoggingConfiguration?
}

extension UpdateLoggingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case loggingConfiguration = "LoggingConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
    }
}

public struct UpdateRuleGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

extension UpdateRuleGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupInput(description: \(String(describing: description)), dryRun: \(String(describing: dryRun)), ruleGroup: \(String(describing: ruleGroup)), ruleGroupArn: \(String(describing: ruleGroupArn)), ruleGroupName: \(String(describing: ruleGroupName)), rules: \(String(describing: rules)), type: \(String(describing: type)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateRuleGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case ruleGroup = "RuleGroup"
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case rules = "Rules"
        case type = "Type"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let ruleGroup = ruleGroup {
            try encodeContainer.encode(ruleGroup, forKey: .ruleGroup)
        }
        if let ruleGroupArn = ruleGroupArn {
            try encodeContainer.encode(ruleGroupArn, forKey: .ruleGroupArn)
        }
        if let ruleGroupName = ruleGroupName {
            try encodeContainer.encode(ruleGroupName, forKey: .ruleGroupName)
        }
        if let rules = rules {
            try encodeContainer.encode(rules, forKey: .rules)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateRuleGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRuleGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRuleGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRuleGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRuleGroupInput>
    public typealias MOutput = OperationOutput<UpdateRuleGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRuleGroupOutputError>
}

public struct UpdateRuleGroupInput: Equatable {
    /// <p>A description of the rule group. </p>
    public let description: String?
    /// <p>Indicates whether you want Network Firewall to just check the validity of the request, rather than run the request. </p>
    ///          <p>If set to <code>TRUE</code>, Network Firewall checks whether the request can run successfully,
    ///          but doesn't actually make the requested changes. The call returns the value that the request would return if you ran it with
    ///          dry run set to <code>FALSE</code>, but doesn't make additions or changes to your resources. This option allows you to make sure that you have
    ///          the required permissions to run the request and that your request parameters are valid. </p>
    ///          <p>If set to <code>FALSE</code>, Network Firewall makes the requested changes to your resources. </p>
    public let dryRun: Bool
    /// <p>An object that defines the rule group rules. </p>
    ///          <note>
    ///             <p>You must provide either this rule group setting or a <code>Rules</code> setting, but not both. </p>
    ///          </note>
    public let ruleGroup: RuleGroup?
    /// <p>The Amazon Resource Name (ARN) of the rule group.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupArn: String?
    /// <p>The descriptive name of the rule group. You can't change the name of a rule group after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let ruleGroupName: String?
    /// <p>A string containing stateful rule group rules specifications in Suricata flat format, with one rule
    /// per line. Use this to import your existing Suricata compatible rule groups. </p>
    ///          <note>
    ///             <p>You must provide either this rules setting or a populated <code>RuleGroup</code> setting, but not both. </p>
    ///          </note>
    ///          <p>You can provide your rule group specification in Suricata flat format through this setting when you create or update your rule group. The call
    /// response returns a <a>RuleGroup</a> object that Network Firewall has populated from your string. </p>
    public let rules: String?
    /// <p>Indicates whether the rule group is stateless or stateful. If the rule group is stateless, it contains
    /// stateless rules. If it is stateful, it contains stateful rules. </p>
    ///          <note>
    ///             <p>This setting is required for requests that do not include the <code>RuleGroupARN</code>.</p>
    ///          </note>
    public let type: RuleGroupType?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    ///          <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        description: String? = nil,
        dryRun: Bool = false,
        ruleGroup: RuleGroup? = nil,
        ruleGroupArn: String? = nil,
        ruleGroupName: String? = nil,
        rules: String? = nil,
        type: RuleGroupType? = nil,
        updateToken: String? = nil
    )
    {
        self.description = description
        self.dryRun = dryRun
        self.ruleGroup = ruleGroup
        self.ruleGroupArn = ruleGroupArn
        self.ruleGroupName = ruleGroupName
        self.rules = rules
        self.type = type
        self.updateToken = updateToken
    }
}

struct UpdateRuleGroupInputBody: Equatable {
    public let updateToken: String?
    public let ruleGroupArn: String?
    public let ruleGroupName: String?
    public let ruleGroup: RuleGroup?
    public let rules: String?
    public let type: RuleGroupType?
    public let description: String?
    public let dryRun: Bool
}

extension UpdateRuleGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case dryRun = "DryRun"
        case ruleGroup = "RuleGroup"
        case ruleGroupArn = "RuleGroupArn"
        case ruleGroupName = "RuleGroupName"
        case rules = "Rules"
        case type = "Type"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let ruleGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupArn)
        ruleGroupArn = ruleGroupArnDecoded
        let ruleGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleGroupName)
        ruleGroupName = ruleGroupNameDecoded
        let ruleGroupDecoded = try containerValues.decodeIfPresent(RuleGroup.self, forKey: .ruleGroup)
        ruleGroup = ruleGroupDecoded
        let rulesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rules)
        rules = rulesDecoded
        let typeDecoded = try containerValues.decodeIfPresent(RuleGroupType.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension UpdateRuleGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRuleGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRuleGroupOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRuleGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRuleGroupOutputResponse(ruleGroupResponse: \(String(describing: ruleGroupResponse)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateRuleGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateRuleGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleGroupResponse = output.ruleGroupResponse
            self.updateToken = output.updateToken
        } else {
            self.ruleGroupResponse = nil
            self.updateToken = nil
        }
    }
}

public struct UpdateRuleGroupOutputResponse: Equatable {
    /// <p>The high-level properties of a rule group. This, along with the <a>RuleGroup</a>, define the rule group. You can retrieve all objects for a rule group by calling <a>DescribeRuleGroup</a>. </p>
    public let ruleGroupResponse: RuleGroupResponse?
    /// <p>A token used for optimistic locking. Network Firewall returns a token to your requests that access the rule group. The token marks the state of the rule group resource at the time of the request. </p>
    ///          <p>To make changes to the rule group, you provide the token in your request. Network Firewall uses the token to ensure that the rule group hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the rule group again to get a current copy of it with a current token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        ruleGroupResponse: RuleGroupResponse? = nil,
        updateToken: String? = nil
    )
    {
        self.ruleGroupResponse = ruleGroupResponse
        self.updateToken = updateToken
    }
}

struct UpdateRuleGroupOutputResponseBody: Equatable {
    public let updateToken: String?
    public let ruleGroupResponse: RuleGroupResponse?
}

extension UpdateRuleGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleGroupResponse = "RuleGroupResponse"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let ruleGroupResponseDecoded = try containerValues.decodeIfPresent(RuleGroupResponse.self, forKey: .ruleGroupResponse)
        ruleGroupResponse = ruleGroupResponseDecoded
    }
}

public struct UpdateSubnetChangeProtectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSubnetChangeProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateSubnetChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetChangeProtectionOutputError>
}

extension UpdateSubnetChangeProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubnetChangeProtectionInput(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetChangeProtection: \(String(describing: subnetChangeProtection)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateSubnetChangeProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetChangeProtection = "SubnetChangeProtection"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let firewallArn = firewallArn {
            try encodeContainer.encode(firewallArn, forKey: .firewallArn)
        }
        if let firewallName = firewallName {
            try encodeContainer.encode(firewallName, forKey: .firewallName)
        }
        if subnetChangeProtection != false {
            try encodeContainer.encode(subnetChangeProtection, forKey: .subnetChangeProtection)
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateSubnetChangeProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSubnetChangeProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateSubnetChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetChangeProtectionOutputError>
}

public struct UpdateSubnetChangeProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSubnetChangeProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetChangeProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetChangeProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetChangeProtectionInput>
    public typealias MOutput = OperationOutput<UpdateSubnetChangeProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetChangeProtectionOutputError>
}

public struct UpdateSubnetChangeProtectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    ///           <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    ///          <p>You must specify the ARN or the name, and you can specify both. </p>
    public let firewallName: String?
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
    ///          Use this setting to protect against
    ///          accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let subnetChangeProtection: Bool
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetChangeProtection: Bool = false,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetChangeProtection = subnetChangeProtection
        self.updateToken = updateToken
    }
}

struct UpdateSubnetChangeProtectionInputBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetChangeProtection: Bool
}

extension UpdateSubnetChangeProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetChangeProtection = "SubnetChangeProtection"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .subnetChangeProtection)
        subnetChangeProtection = subnetChangeProtectionDecoded
    }
}

extension UpdateSubnetChangeProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubnetChangeProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerError" : self = .internalServerError(try InternalServerError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceOwnerCheckException" : self = .resourceOwnerCheckException(try ResourceOwnerCheckException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubnetChangeProtectionOutputError: Equatable {
    case internalServerError(InternalServerError)
    case invalidRequestException(InvalidRequestException)
    case invalidTokenException(InvalidTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceOwnerCheckException(ResourceOwnerCheckException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubnetChangeProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubnetChangeProtectionOutputResponse(firewallArn: \(String(describing: firewallArn)), firewallName: \(String(describing: firewallName)), subnetChangeProtection: \(String(describing: subnetChangeProtection)), updateToken: \(String(describing: updateToken)))"}
}

extension UpdateSubnetChangeProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSubnetChangeProtectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.firewallArn = output.firewallArn
            self.firewallName = output.firewallName
            self.subnetChangeProtection = output.subnetChangeProtection
            self.updateToken = output.updateToken
        } else {
            self.firewallArn = nil
            self.firewallName = nil
            self.subnetChangeProtection = false
            self.updateToken = nil
        }
    }
}

public struct UpdateSubnetChangeProtectionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the firewall.</p>
    public let firewallArn: String?
    /// <p>The descriptive name of the firewall. You can't change the name of a firewall after you create it.</p>
    public let firewallName: String?
    /// <p>A setting indicating whether the firewall is protected against changes to the subnet associations.
    ///          Use this setting to protect against
    ///          accidentally modifying the subnet associations for a firewall that is in use. When you create a firewall, the operation initializes this setting to <code>TRUE</code>.</p>
    public let subnetChangeProtection: Bool
    /// <p>An optional token that you can use for optimistic locking. Network Firewall returns a token to your requests that access the firewall. The token marks the state of the firewall resource at the time of the request. </p>
    ///          <p>To make an unconditional change to the firewall, omit the token in your update request. Without the token, Network Firewall performs your updates regardless of whether the firewall has changed since you last retrieved it.</p>
    ///          <p>To make a conditional change to the firewall, provide the token in your update request. Network Firewall uses the token to ensure that the firewall hasn't changed since you last retrieved it. If it has changed, the operation fails with an <code>InvalidTokenException</code>. If this happens, retrieve the firewall again to get a current copy of it with a new token. Reapply your changes as needed, then try the operation again using the new token. </p>
    public let updateToken: String?

    public init (
        firewallArn: String? = nil,
        firewallName: String? = nil,
        subnetChangeProtection: Bool = false,
        updateToken: String? = nil
    )
    {
        self.firewallArn = firewallArn
        self.firewallName = firewallName
        self.subnetChangeProtection = subnetChangeProtection
        self.updateToken = updateToken
    }
}

struct UpdateSubnetChangeProtectionOutputResponseBody: Equatable {
    public let updateToken: String?
    public let firewallArn: String?
    public let firewallName: String?
    public let subnetChangeProtection: Bool
}

extension UpdateSubnetChangeProtectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case firewallArn = "FirewallArn"
        case firewallName = "FirewallName"
        case subnetChangeProtection = "SubnetChangeProtection"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
        let firewallArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallArn)
        firewallArn = firewallArnDecoded
        let firewallNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .firewallName)
        firewallName = firewallNameDecoded
        let subnetChangeProtectionDecoded = try containerValues.decode(Bool.self, forKey: .subnetChangeProtection)
        subnetChangeProtection = subnetChangeProtectionDecoded
    }
}
