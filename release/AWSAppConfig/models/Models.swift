// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppConfigClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AppConfigClientTypes {
    public struct Application: Swift.Equatable {
        /// The description of the application.
        public var description: Swift.String?
        /// The application ID.
        public var id: Swift.String?
        /// The application name.
        public var name: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension AppConfigClientTypes.BadRequestDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidconfiguration = "InvalidConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .invalidconfiguration(invalidconfiguration):
                var invalidconfigurationContainer = container.nestedUnkeyedContainer(forKey: .invalidconfiguration)
                for invalidconfigurationdetaillist0 in invalidconfiguration {
                    try invalidconfigurationContainer.encode(invalidconfigurationdetaillist0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let invalidconfigurationContainer = try values.decodeIfPresent([AppConfigClientTypes.InvalidConfigurationDetail?].self, forKey: .invalidconfiguration)
        var invalidconfigurationDecoded0:[AppConfigClientTypes.InvalidConfigurationDetail]? = nil
        if let invalidconfigurationContainer = invalidconfigurationContainer {
            invalidconfigurationDecoded0 = [AppConfigClientTypes.InvalidConfigurationDetail]()
            for structure0 in invalidconfigurationContainer {
                if let structure0 = structure0 {
                    invalidconfigurationDecoded0?.append(structure0)
                }
            }
        }
        if let invalidconfiguration = invalidconfigurationDecoded0 {
            self = .invalidconfiguration(invalidconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension AppConfigClientTypes {
    /// Detailed information about the input that failed to satisfy the constraints specified by an AWS service.
    public enum BadRequestDetails: Swift.Equatable {
        /// Detailed information about the bad request exception error when creating a hosted configuration version.
        case invalidconfiguration([AppConfigClientTypes.InvalidConfigurationDetail])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.details = output.details
            self.message = output.message
            self.reason = output.reason
        } else {
            self.details = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Detailed information about the input that failed to satisfy the constraints specified by an AWS service.
    public var details: AppConfigClientTypes.BadRequestDetails?
    public var message: Swift.String?
    public var reason: AppConfigClientTypes.BadRequestReason?

    public init (
        details: AppConfigClientTypes.BadRequestDetails? = nil,
        message: Swift.String? = nil,
        reason: AppConfigClientTypes.BadRequestReason? = nil
    )
    {
        self.details = details
        self.message = message
        self.reason = reason
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: AppConfigClientTypes.BadRequestReason?
    let details: AppConfigClientTypes.BadRequestDetails?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details = "Details"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BadRequestReason.self, forKey: .reason)
        reason = reasonDecoded
        let detailsDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BadRequestDetails.self, forKey: .details)
        details = detailsDecoded
    }
}

extension AppConfigClientTypes {
    public enum BadRequestReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [BadRequestReason] {
            return [
                .invalidConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidConfiguration: return "InvalidConfiguration"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BadRequestReason(rawValue: rawValue) ?? BadRequestReason.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes {
    public enum BytesMeasure: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kilobytes
        case sdkUnknown(Swift.String)

        public static var allCases: [BytesMeasure] {
            return [
                .kilobytes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kilobytes: return "KILOBYTES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BytesMeasure(rawValue: rawValue) ?? BytesMeasure.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.ConfigurationProfileSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case type = "Type"
        case validatorTypes = "ValidatorTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validatorTypes = validatorTypes {
            var validatorTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validatorTypes)
            for validatortypelist0 in validatorTypes {
                try validatorTypesContainer.encode(validatortypelist0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let validatorTypesContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ValidatorType?].self, forKey: .validatorTypes)
        var validatorTypesDecoded0:[AppConfigClientTypes.ValidatorType]? = nil
        if let validatorTypesContainer = validatorTypesContainer {
            validatorTypesDecoded0 = [AppConfigClientTypes.ValidatorType]()
            for string0 in validatorTypesContainer {
                if let string0 = string0 {
                    validatorTypesDecoded0?.append(string0)
                }
            }
        }
        validatorTypes = validatorTypesDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppConfigClientTypes {
    /// A summary of a configuration profile.
    public struct ConfigurationProfileSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The ID of the configuration profile.
        public var id: Swift.String?
        /// The URI location of the configuration.
        public var locationUri: Swift.String?
        /// The name of the configuration profile.
        public var name: Swift.String?
        /// The type of configurations that the configuration profile contains. A configuration can be a feature flag used for enabling or disabling new features or a free-form configuration used to introduce changes to your application.
        public var type: Swift.String?
        /// The types of validators in the configuration profile.
        public var validatorTypes: [AppConfigClientTypes.ValidatorType]?

        public init (
            applicationId: Swift.String? = nil,
            id: Swift.String? = nil,
            locationUri: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil,
            validatorTypes: [AppConfigClientTypes.ValidatorType]? = nil
        )
        {
            self.applicationId = applicationId
            self.id = id
            self.locationUri = locationUri
            self.name = name
            self.type = type
            self.validatorTypes = validatorTypes
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// A description of the application.
    public var description: Swift.String?
    /// A name for the application.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the application. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateConfigurationProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case type = "Type"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let locationUri = locationUri {
            try encodeContainer.encode(locationUri, forKey: .locationUri)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

extension CreateConfigurationProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
    }
}

public struct CreateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// A URI to locate the configuration. You can specify the AppConfig hosted configuration store, Systems Manager (SSM) document, an SSM Parameter Store parameter, or an Amazon S3 object. For the hosted configuration store and for feature flags, specify hosted. For an SSM document, specify either the document name in the format ssm-document:// or the Amazon Resource Name (ARN). For a parameter, specify either the parameter name in the format ssm-parameter:// or the ARN. For an Amazon S3 object, specify the URI in the following format: s3:/// . Here is an example: s3://my-bucket/my-app/us-east-1/my-config.json
    /// This member is required.
    public var locationUri: Swift.String?
    /// A name for the configuration profile.
    /// This member is required.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri. A retrieval role ARN is not required for configurations stored in the AppConfig hosted configuration store. It is required for all other sources that store your configuration.
    public var retrievalRoleArn: Swift.String?
    /// Metadata to assign to the configuration profile. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?
    /// The type of configurations that the configuration profile contains. A configuration can be a feature flag used for enabling or disabling new features or a free-form configuration used for distributing configurations to your application.
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.tags = tags
        self.type = type
        self.validators = validators
    }
}

struct CreateConfigurationProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let tags: [Swift.String:Swift.String]?
    let type: Swift.String?
}

extension CreateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case tags = "Tags"
        case type = "Type"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct CreateConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations that the configuration profile contains. A configuration can be a feature flag used for enabling or disabling new features or a free-form configuration used for distributing configurations to your application.
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct CreateConfigurationProfileOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
}

extension CreateConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateDeploymentStrategyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeploymentStrategyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deploymentstrategies"
    }
}

public struct CreateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    /// This member is required.
    public var deploymentDurationInMinutes: Swift.Int
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic roll back.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    /// This member is required.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types: Linear: For this type, AppConfig processes the deployment by dividing the total number of targets by the value specified for Step percentage. For example, a linear deployment that uses a Step percentage of 10 deploys the configuration to 10 percent of the hosts. After those deployments are complete, the system deploys the configuration to the next 10 percent. This continues until 100% of the targets have successfully received the configuration. Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: 2*(2^0)
    ///     2*(2^1)
    ///
    /// 2*(2^2) Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// A name for the deployment strategy.
    /// This member is required.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    /// This member is required.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?
    /// Metadata to assign to the deployment strategy. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.name = name
        self.replicateTo = replicateTo
        self.tags = tags
    }
}

struct CreateDeploymentStrategyInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let finalBakeTimeInMinutes: Swift.Int
    let growthFactor: Swift.Float
    let growthType: AppConfigClientTypes.GrowthType?
    let replicateTo: AppConfigClientTypes.ReplicateTo?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case name = "Name"
        case replicateTo = "ReplicateTo"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct CreateDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct CreateDeploymentStrategyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension CreateDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// A name for the environment.
    /// This member is required.
    public var name: Swift.String?
    /// Metadata to assign to the environment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.monitors = monitors
        self.name = name
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let monitors: [AppConfigClientTypes.Monitor]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct CreateEnvironmentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension CreateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

public struct CreateHostedConfigurationVersionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateHostedConfigurationVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let content = input.operationInput.content {
            let contentdata = content
            let contentbody = ClientRuntime.HttpBody.data(contentdata)
            input.builder.withBody(contentbody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateHostedConfigurationVersionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateHostedConfigurationVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateHostedConfigurationVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content.base64EncodedString(), forKey: .content)
        }
    }
}

extension CreateHostedConfigurationVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let description = description {
            items.add(Header(name: "Description", value: Swift.String(description)))
        }
        if latestVersionNumber != 0 {
            items.add(Header(name: "Latest-Version-Number", value: Swift.String(latestVersionNumber)))
        }
        return items
    }
}

extension CreateHostedConfigurationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
    }
}

public struct CreateHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    /// This member is required.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    /// This member is required.
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// An optional locking token used to prevent race conditions from overwriting configuration updates when creating a new version. To ensure your data is not overwritten when creating multiple hosted configuration versions in rapid succession, specify the version number of the latest hosted configuration version.
    public var latestVersionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        latestVersionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.latestVersionNumber = latestVersionNumber
    }
}

struct CreateHostedConfigurationVersionInputBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension CreateHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case payloadTooLargeException(PayloadTooLargeException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct CreateHostedConfigurationVersionOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct CreateHostedConfigurationVersionOutputResponseBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension CreateHostedConfigurationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The ID of the application to delete.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
}

extension DeleteApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

}

extension DeleteConfigurationProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct DeleteConfigurationProfileInput: Swift.Equatable {
    /// The application ID that includes the configuration profile you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile you want to delete.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct DeleteConfigurationProfileInputBody: Swift.Equatable {
}

extension DeleteConfigurationProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConfigurationProfileOutputResponse: Swift.Equatable {

}

extension DeleteDeploymentStrategyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentStrategyId = deploymentStrategyId else {
            return nil
        }
        return "/deployementstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct DeleteDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy you want to delete.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init (
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct DeleteDeploymentStrategyInputBody: Swift.Equatable {
}

extension DeleteDeploymentStrategyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeploymentStrategyOutputResponse: Swift.Equatable {

}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The application ID that includes the environment that you want to delete.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment that you want to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Swift.Equatable {

}

extension DeleteHostedConfigurationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
    }
}

public struct DeleteHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The versions number to delete.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct DeleteHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension DeleteHostedConfigurationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteHostedConfigurationVersionOutputResponse: Swift.Equatable {

}

extension AppConfigClientTypes.DeploymentEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case eventType = "EventType"
        case occurredAt = "OccurredAt"
        case triggeredBy = "TriggeredBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let occurredAt = occurredAt {
            try encodeContainer.encode(occurredAt.timeIntervalSince1970, forKey: .occurredAt)
        }
        if let triggeredBy = triggeredBy {
            try encodeContainer.encode(triggeredBy.rawValue, forKey: .triggeredBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let triggeredByDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.TriggeredBy.self, forKey: .triggeredBy)
        triggeredBy = triggeredByDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let occurredAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .occurredAt)
        occurredAt = occurredAtDecoded
    }
}

extension AppConfigClientTypes {
    /// An object that describes a deployment event.
    public struct DeploymentEvent: Swift.Equatable {
        /// A description of the deployment event. Descriptions include, but are not limited to, the user account or the Amazon CloudWatch alarm ARN that initiated a rollback, the percentage of hosts that received the deployment, or in the case of an internal error, a recommendation to attempt a new deployment.
        public var description: Swift.String?
        /// The type of deployment event. Deployment event types include the start, stop, or completion of a deployment; a percentage update; the start or stop of a bake period; and the start or completion of a rollback.
        public var eventType: AppConfigClientTypes.DeploymentEventType?
        /// The date and time the event occurred.
        public var occurredAt: ClientRuntime.Date?
        /// The entity that triggered the deployment event. Events can be triggered by a user, AppConfig, an Amazon CloudWatch alarm, or an internal error.
        public var triggeredBy: AppConfigClientTypes.TriggeredBy?

        public init (
            description: Swift.String? = nil,
            eventType: AppConfigClientTypes.DeploymentEventType? = nil,
            occurredAt: ClientRuntime.Date? = nil,
            triggeredBy: AppConfigClientTypes.TriggeredBy? = nil
        )
        {
            self.description = description
            self.eventType = eventType
            self.occurredAt = occurredAt
            self.triggeredBy = triggeredBy
        }
    }

}

extension AppConfigClientTypes {
    public enum DeploymentEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bakeTimeStarted
        case deploymentCompleted
        case deploymentStarted
        case percentageUpdated
        case rollbackCompleted
        case rollbackStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentEventType] {
            return [
                .bakeTimeStarted,
                .deploymentCompleted,
                .deploymentStarted,
                .percentageUpdated,
                .rollbackCompleted,
                .rollbackStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bakeTimeStarted: return "BAKE_TIME_STARTED"
            case .deploymentCompleted: return "DEPLOYMENT_COMPLETED"
            case .deploymentStarted: return "DEPLOYMENT_STARTED"
            case .percentageUpdated: return "PERCENTAGE_UPDATED"
            case .rollbackCompleted: return "ROLLBACK_COMPLETED"
            case .rollbackStarted: return "ROLLBACK_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentEventType(rawValue: rawValue) ?? DeploymentEventType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes {
    public enum DeploymentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case baking
        case complete
        case deploying
        case rolledBack
        case rollingBack
        case validating
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentState] {
            return [
                .baking,
                .complete,
                .deploying,
                .rolledBack,
                .rollingBack,
                .validating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .baking: return "BAKING"
            case .complete: return "COMPLETE"
            case .deploying: return "DEPLOYING"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case .validating: return "VALIDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentState(rawValue: rawValue) ?? DeploymentState.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.DeploymentStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicateTo = replicateTo {
            try encodeContainer.encode(replicateTo.rawValue, forKey: .replicateTo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension AppConfigClientTypes {
    public struct DeploymentStrategy: Swift.Equatable {
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The description of the deployment strategy.
        public var description: Swift.String?
        /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets that received a deployed configuration during each interval.
        public var growthFactor: Swift.Float
        /// The algorithm used to define how percentage grew over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The deployment strategy ID.
        public var id: Swift.String?
        /// The name of the deployment strategy.
        public var name: Swift.String?
        /// Save the deployment strategy to a Systems Manager (SSM) document.
        public var replicateTo: AppConfigClientTypes.ReplicateTo?

        public init (
            deploymentDurationInMinutes: Swift.Int = 0,
            description: Swift.String? = nil,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float = 0.0,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            replicateTo: AppConfigClientTypes.ReplicateTo? = nil
        )
        {
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.description = description
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.id = id
            self.name = name
            self.replicateTo = replicateTo
        }
    }

}

extension AppConfigClientTypes.DeploymentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completedAt = "CompletedAt"
        case configurationName = "ConfigurationName"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let configurationName = configurationName {
            try encodeContainer.encode(configurationName, forKey: .configurationName)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if deploymentNumber != 0 {
            try encodeContainer.encode(deploymentNumber, forKey: .deploymentNumber)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
        if percentageComplete != 0.0 {
            try encodeContainer.encode(percentageComplete, forKey: .percentageComplete)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about the deployment.
    public struct DeploymentSummary: Swift.Equatable {
        /// Time the deployment completed.
        public var completedAt: ClientRuntime.Date?
        /// The name of the configuration.
        public var configurationName: Swift.String?
        /// The version of the configuration.
        public var configurationVersion: Swift.String?
        /// Total amount of time the deployment lasted.
        public var deploymentDurationInMinutes: Swift.Int
        /// The sequence number of the deployment.
        public var deploymentNumber: Swift.Int
        /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
        public var finalBakeTimeInMinutes: Swift.Int
        /// The percentage of targets to receive a deployed configuration during each interval.
        public var growthFactor: Swift.Float
        /// The algorithm used to define how percentage grows over time.
        public var growthType: AppConfigClientTypes.GrowthType?
        /// The percentage of targets for which the deployment is available.
        public var percentageComplete: Swift.Float
        /// Time the deployment started.
        public var startedAt: ClientRuntime.Date?
        /// The state of the deployment.
        public var state: AppConfigClientTypes.DeploymentState?

        public init (
            completedAt: ClientRuntime.Date? = nil,
            configurationName: Swift.String? = nil,
            configurationVersion: Swift.String? = nil,
            deploymentDurationInMinutes: Swift.Int = 0,
            deploymentNumber: Swift.Int = 0,
            finalBakeTimeInMinutes: Swift.Int = 0,
            growthFactor: Swift.Float = 0.0,
            growthType: AppConfigClientTypes.GrowthType? = nil,
            percentageComplete: Swift.Float = 0.0,
            startedAt: ClientRuntime.Date? = nil,
            state: AppConfigClientTypes.DeploymentState? = nil
        )
        {
            self.completedAt = completedAt
            self.configurationName = configurationName
            self.configurationVersion = configurationVersion
            self.deploymentDurationInMinutes = deploymentDurationInMinutes
            self.deploymentNumber = deploymentNumber
            self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
            self.growthFactor = growthFactor
            self.growthType = growthType
            self.percentageComplete = percentageComplete
            self.startedAt = startedAt
            self.state = state
        }
    }

}

extension AppConfigClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension AppConfigClientTypes {
    public struct Environment: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The description of the environment.
        public var description: Swift.String?
        /// The environment ID.
        public var id: Swift.String?
        /// Amazon CloudWatch alarms monitored during the deployment.
        public var monitors: [AppConfigClientTypes.Monitor]?
        /// The name of the environment.
        public var name: Swift.String?
        /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
        public var state: AppConfigClientTypes.EnvironmentState?

        public init (
            applicationId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            monitors: [AppConfigClientTypes.Monitor]? = nil,
            name: Swift.String? = nil,
            state: AppConfigClientTypes.EnvironmentState? = nil
        )
        {
            self.applicationId = applicationId
            self.description = description
            self.id = id
            self.monitors = monitors
            self.name = name
            self.state = state
        }
    }

}

extension AppConfigClientTypes {
    public enum EnvironmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deploying
        case readyForDeployment
        case rolledBack
        case rollingBack
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .deploying,
                .readyForDeployment,
                .rolledBack,
                .rollingBack,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deploying: return "DEPLOYING"
            case .readyForDeployment: return "READY_FOR_DEPLOYMENT"
            case .rolledBack: return "ROLLED_BACK"
            case .rollingBack: return "ROLLING_BACK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentState(rawValue: rawValue) ?? EnvironmentState.sdkUnknown(rawValue)
        }
    }
}

extension GetApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct GetApplicationInput: Swift.Equatable {
    /// The ID of the application you want to get.
    /// This member is required.
    public var applicationId: Swift.String?

    public init (
        applicationId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationInputBody: Swift.Equatable {
}

extension GetApplicationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct GetApplicationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension GetApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GetConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientId = clientId {
            let clientIdQueryItem = ClientRuntime.URLQueryItem(name: "client_id".urlPercentEncoding(), value: Swift.String(clientId).urlPercentEncoding())
            items.append(clientIdQueryItem)
        }
        if let clientConfigurationVersion = clientConfigurationVersion {
            let clientConfigurationVersionQueryItem = ClientRuntime.URLQueryItem(name: "client_configuration_version".urlPercentEncoding(), value: Swift.String(clientConfigurationVersion).urlPercentEncoding())
            items.append(clientConfigurationVersionQueryItem)
        }
        return items
    }
}

extension GetConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let application = application else {
            return nil
        }
        guard let environment = environment else {
            return nil
        }
        guard let configuration = configuration else {
            return nil
        }
        return "/applications/\(application.urlPercentEncoding())/environments/\(environment.urlPercentEncoding())/configurations/\(configuration.urlPercentEncoding())"
    }
}

public struct GetConfigurationInput: Swift.Equatable {
    /// The application to get. Specify either the application name or the application ID.
    /// This member is required.
    public var application: Swift.String?
    /// The configuration version returned in the most recent GetConfiguration response. AppConfig uses the value of the ClientConfigurationVersion parameter to identify the configuration version on your clients. If you dont send ClientConfigurationVersion with each call to GetConfiguration, your clients receive the current configuration. You are charged each time your clients receive a configuration. To avoid excess charges, we recommend that you include the ClientConfigurationVersion value with every call to GetConfiguration. This value must be saved on your client. Subsequent calls to GetConfiguration must pass this value by using the ClientConfigurationVersion parameter. For more information about working with configurations, see [Retrieving the Configuration](http://docs.aws.amazon.com/appconfig/latest/userguide/appconfig-retrieving-the-configuration.html) in the AppConfig User Guide.
    public var clientConfigurationVersion: Swift.String?
    /// The clientId parameter in the following command is a unique, user-specified ID to identify the client for the configuration. This ID enables AppConfig to deploy the configuration in intervals, as defined in the deployment strategy.
    /// This member is required.
    public var clientId: Swift.String?
    /// The configuration to get. Specify either the configuration name or the configuration ID.
    /// This member is required.
    public var configuration: Swift.String?
    /// The environment to get. Specify either the environment name or the environment ID.
    /// This member is required.
    public var environment: Swift.String?

    public init (
        application: Swift.String? = nil,
        clientConfigurationVersion: Swift.String? = nil,
        clientId: Swift.String? = nil,
        configuration: Swift.String? = nil,
        environment: Swift.String? = nil
    )
    {
        self.application = application
        self.clientConfigurationVersion = clientConfigurationVersion
        self.clientId = clientId
        self.configuration = configuration
        self.environment = environment
    }
}

struct GetConfigurationInputBody: Swift.Equatable {
}

extension GetConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let configurationVersionHeaderValue = httpResponse.headers.value(for: "Configuration-Version") {
            self.configurationVersion = configurationVersionHeaderValue
        } else {
            self.configurationVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetConfigurationOutputResponse: Swift.Equatable {
    /// The configuration version.
    public var configurationVersion: Swift.String?
    /// The content of the configuration or the configuration data. Compare the configuration version numbers of the configuration cached locally on your machine and the configuration number in the the header. If the configuration numbers are the same, the content can be ignored. The Content section only appears if the system finds new or updated configuration data. If the system doesn't find new or updated configuration data, then the Content section is not returned.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?

    public init (
        configurationVersion: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.configurationVersion = configurationVersion
        self.content = content
        self.contentType = contentType
    }
}

struct GetConfigurationOutputResponseBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension GetConfigurationProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct GetConfigurationProfileInput: Swift.Equatable {
    /// The ID of the application that includes the configuration profile you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile that you want to get.
    /// This member is required.
    public var configurationProfileId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
    }
}

struct GetConfigurationProfileInputBody: Swift.Equatable {
}

extension GetConfigurationProfileInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct GetConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations that the configuration profile contains. A configuration can be a feature flag used for enabling or disabling new features or a free-form configuration used for distributing configurations to your application.
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct GetConfigurationProfileOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
}

extension GetConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GetDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
    }
}

public struct GetDeploymentInput: Swift.Equatable {
    /// The ID of the application that includes the deployment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int
    /// The ID of the environment that includes the deployment you want to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct GetDeploymentInputBody: Swift.Equatable {
}

extension GetDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct GetDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct GetDeploymentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
}

extension GetDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension GetDeploymentStrategyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentStrategyId = deploymentStrategyId else {
            return nil
        }
        return "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct GetDeploymentStrategyInput: Swift.Equatable {
    /// The ID of the deployment strategy to get.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?

    public init (
        deploymentStrategyId: Swift.String? = nil
    )
    {
        self.deploymentStrategyId = deploymentStrategyId
    }
}

struct GetDeploymentStrategyInputBody: Swift.Equatable {
}

extension GetDeploymentStrategyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct GetDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct GetDeploymentStrategyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension GetDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension GetEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the application that includes the environment you want to get.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the environment that you want to get.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct GetEnvironmentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension GetEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension GetHostedConfigurationVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions/\(versionNumber)"
    }
}

public struct GetHostedConfigurationVersionInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version.
    /// This member is required.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionInputBody: Swift.Equatable {
}

extension GetHostedConfigurationVersionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetHostedConfigurationVersionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetHostedConfigurationVersionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetHostedConfigurationVersionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetHostedConfigurationVersionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let applicationIdHeaderValue = httpResponse.headers.value(for: "Application-Id") {
            self.applicationId = applicationIdHeaderValue
        } else {
            self.applicationId = nil
        }
        if let configurationProfileIdHeaderValue = httpResponse.headers.value(for: "Configuration-Profile-Id") {
            self.configurationProfileId = configurationProfileIdHeaderValue
        } else {
            self.configurationProfileId = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let descriptionHeaderValue = httpResponse.headers.value(for: "Description") {
            self.description = descriptionHeaderValue
        } else {
            self.description = nil
        }
        if let versionNumberHeaderValue = httpResponse.headers.value(for: "Version-Number") {
            self.versionNumber = Swift.Int(versionNumberHeaderValue) ?? 0
        } else {
            self.versionNumber = 0
        }
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            self.content = data
        } else {
            self.content = nil
        }
    }
}

public struct GetHostedConfigurationVersionOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    public var configurationProfileId: Swift.String?
    /// The content of the configuration or the configuration data.
    public var content: ClientRuntime.Data?
    /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
    public var contentType: Swift.String?
    /// A description of the configuration.
    public var description: Swift.String?
    /// The configuration version.
    public var versionNumber: Swift.Int

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        content: ClientRuntime.Data? = nil,
        contentType: Swift.String? = nil,
        description: Swift.String? = nil,
        versionNumber: Swift.Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.content = content
        self.contentType = contentType
        self.description = description
        self.versionNumber = versionNumber
    }
}

struct GetHostedConfigurationVersionOutputResponseBody: Swift.Equatable {
    let content: ClientRuntime.Data?
}

extension GetHostedConfigurationVersionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .content)
        content = contentDecoded
    }
}

extension AppConfigClientTypes {
    public enum GrowthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case exponential
        case linear
        case sdkUnknown(Swift.String)

        public static var allCases: [GrowthType] {
            return [
                .exponential,
                .linear,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .exponential: return "EXPONENTIAL"
            case .linear: return "LINEAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrowthType(rawValue: rawValue) ?? GrowthType.sdkUnknown(rawValue)
        }
    }
}

extension AppConfigClientTypes.HostedConfigurationVersionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case configurationProfileId = "ConfigurationProfileId"
        case contentType = "ContentType"
        case description = "Description"
        case versionNumber = "VersionNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let contentType = contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if versionNumber != 0 {
            try encodeContainer.encode(versionNumber, forKey: .versionNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let versionNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .versionNumber)
        versionNumber = versionNumberDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
    }
}

extension AppConfigClientTypes {
    /// Information about the configuration.
    public struct HostedConfigurationVersionSummary: Swift.Equatable {
        /// The application ID.
        public var applicationId: Swift.String?
        /// The configuration profile ID.
        public var configurationProfileId: Swift.String?
        /// A standard MIME type describing the format of the configuration content. For more information, see [Content-Type](https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17).
        public var contentType: Swift.String?
        /// A description of the configuration.
        public var description: Swift.String?
        /// The configuration version.
        public var versionNumber: Swift.Int

        public init (
            applicationId: Swift.String? = nil,
            configurationProfileId: Swift.String? = nil,
            contentType: Swift.String? = nil,
            description: Swift.String? = nil,
            versionNumber: Swift.Int = 0
        )
        {
            self.applicationId = applicationId
            self.configurationProfileId = configurationProfileId
            self.contentType = contentType
            self.description = description
            self.versionNumber = versionNumber
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There was an internal failure in the AppConfig service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppConfigClientTypes.InvalidConfigurationDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraint = "Constraint"
        case location = "Location"
        case reason = "Reason"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraint = constraint {
            try encodeContainer.encode(constraint, forKey: .constraint)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraint)
        constraint = constraintDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension AppConfigClientTypes {
    /// Detailed information about the bad request exception error when creating a hosted configuration version.
    public struct InvalidConfigurationDetail: Swift.Equatable {
        /// The invalid or out-of-range validation constraint in your JSON schema that failed validation.
        public var constraint: Swift.String?
        /// Location of the validation constraint in the configuration JSON schema that failed validation.
        public var location: Swift.String?
        /// The reason for an invalid configuration error.
        public var reason: Swift.String?
        /// The type of error for an invalid configuration.
        public var type: Swift.String?

        public init (
            constraint: Swift.String? = nil,
            location: Swift.String? = nil,
            reason: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.constraint = constraint
            self.location = location
            self.reason = reason
            self.type = type
        }
    }

}

extension ListApplicationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/applications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Next token is a pagination token generated by AppConfig to describe what page the previous List call ended on. For the first List request, the nextToken should not be set. On subsequent calls, the nextToken parameter should be set to the previous responses nextToken value. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
}

extension ListApplicationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Application]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.Application]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Application?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationProfilesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let type = type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfigurationProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles"
    }
}

public struct ListConfigurationProfilesInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A filter based on the type of configurations that the configuration profile contains. A configuration can be a feature flag or a free-form configuration.
    public var type: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListConfigurationProfilesInputBody: Swift.Equatable {
}

extension ListConfigurationProfilesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListConfigurationProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationProfilesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationProfilesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.ConfigurationProfileSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListConfigurationProfilesOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.ConfigurationProfileSummary]?
    let nextToken: Swift.String?
}

extension ListConfigurationProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.ConfigurationProfileSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.ConfigurationProfileSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.ConfigurationProfileSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentStrategiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentStrategiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deploymentstrategies"
    }
}

public struct ListDeploymentStrategiesInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesInputBody: Swift.Equatable {
}

extension ListDeploymentStrategiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentStrategiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentStrategiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentStrategiesOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentStrategiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentStrategiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentStrategiesOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentStrategy]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.DeploymentStrategy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentStrategiesOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.DeploymentStrategy]?
    let nextToken: Swift.String?
}

extension ListDeploymentStrategiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentStrategy?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentStrategy]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentStrategy]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeploymentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeploymentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeploymentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeploymentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.DeploymentSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.DeploymentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.DeploymentSummary]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.DeploymentSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.DeploymentSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEnvironmentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.Environment]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.Environment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.Environment]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Environment?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.Environment]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.Environment]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListHostedConfigurationVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListHostedConfigurationVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/hostedconfigurationversions"
    }
}

public struct ListHostedConfigurationVersionsInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsInputBody: Swift.Equatable {
}

extension ListHostedConfigurationVersionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListHostedConfigurationVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListHostedConfigurationVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListHostedConfigurationVersionsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListHostedConfigurationVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListHostedConfigurationVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListHostedConfigurationVersionsOutputResponse: Swift.Equatable {
    /// The elements from this collection.
    public var items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        items: [AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListHostedConfigurationVersionsOutputResponseBody: Swift.Equatable {
    let items: [AppConfigClientTypes.HostedConfigurationVersionSummary]?
    let nextToken: Swift.String?
}

extension ListHostedConfigurationVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items = "Items"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.HostedConfigurationVersionSummary?].self, forKey: .items)
        var itemsDecoded0:[AppConfigClientTypes.HostedConfigurationVersionSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [AppConfigClientTypes.HostedConfigurationVersionSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Metadata to assign to AppConfig resources. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppConfigClientTypes.Monitor: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmArn = "AlarmArn"
        case alarmRoleArn = "AlarmRoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmArn = alarmArn {
            try encodeContainer.encode(alarmArn, forKey: .alarmArn)
        }
        if let alarmRoleArn = alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmArn)
        alarmArn = alarmArnDecoded
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
    }
}

extension AppConfigClientTypes {
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public struct Monitor: Swift.Equatable {
        /// Amazon Resource Name (ARN) of the Amazon CloudWatch alarm.
        /// This member is required.
        public var alarmArn: Swift.String?
        /// ARN of an Identity and Access Management (IAM) role for AppConfig to monitor AlarmArn.
        public var alarmRoleArn: Swift.String?

        public init (
            alarmArn: Swift.String? = nil,
            alarmRoleArn: Swift.String? = nil
        )
        {
            self.alarmArn = alarmArn
            self.alarmRoleArn = alarmRoleArn
        }
    }

}

extension PayloadTooLargeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PayloadTooLargeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.limit = output.limit
            self.measure = output.measure
            self.message = output.message
            self.size = output.size
        } else {
            self.limit = 0.0
            self.measure = nil
            self.message = nil
            self.size = 0.0
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration size is too large.
public struct PayloadTooLargeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var limit: Swift.Float
    public var measure: AppConfigClientTypes.BytesMeasure?
    public var message: Swift.String?
    public var size: Swift.Float

    public init (
        limit: Swift.Float = 0.0,
        measure: AppConfigClientTypes.BytesMeasure? = nil,
        message: Swift.String? = nil,
        size: Swift.Float = 0.0
    )
    {
        self.limit = limit
        self.measure = measure
        self.message = message
        self.size = size
    }
}

struct PayloadTooLargeExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let measure: AppConfigClientTypes.BytesMeasure?
    let limit: Swift.Float
    let size: Swift.Float
}

extension PayloadTooLargeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case limit = "Limit"
        case measure = "Measure"
        case message = "Message"
        case size = "Size"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let measureDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.BytesMeasure.self, forKey: .measure)
        measure = measureDecoded
        let limitDecoded = try containerValues.decode(Swift.Float.self, forKey: .limit)
        limit = limitDecoded
        let sizeDecoded = try containerValues.decode(Swift.Float.self, forKey: .size)
        size = sizeDecoded
    }
}

extension AppConfigClientTypes {
    public enum ReplicateTo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `none`
        case ssmDocument
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicateTo] {
            return [
                .none,
                .ssmDocument,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .ssmDocument: return "SSM_DOCUMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicateTo(rawValue: rawValue) ?? ReplicateTo.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource could not be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of hosted configuration versions exceeds the limit for the AppConfig hosted configuration store. Delete one or more versions and try again.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationProfileId = configurationProfileId {
            try encodeContainer.encode(configurationProfileId, forKey: .configurationProfileId)
        }
        if let configurationVersion = configurationVersion {
            try encodeContainer.encode(configurationVersion, forKey: .configurationVersion)
        }
        if let deploymentStrategyId = deploymentStrategyId {
            try encodeContainer.encode(deploymentStrategyId, forKey: .deploymentStrategyId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments"
    }
}

public struct StartDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The configuration version to deploy.
    /// This member is required.
    public var configurationVersion: Swift.String?
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Metadata to assign to the deployment. Tags help organize and categorize your AppConfig resources. Each tag consists of a key and an optional value, both of which you define.
    public var tags: [Swift.String:Swift.String]?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.tags = tags
    }
}

struct StartDeploymentInputBody: Swift.Equatable {
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StartDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StartDeploymentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
}

extension StartDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension StopDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())/deployments/\(deploymentNumber)"
    }
}

public struct StopDeploymentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The sequence number of the deployment.
    /// This member is required.
    public var deploymentNumber: Swift.Int
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        deploymentNumber: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.deploymentNumber = deploymentNumber
        self.environmentId = environmentId
    }
}

struct StopDeploymentInputBody: Swift.Equatable {
}

extension StopDeploymentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopDeploymentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopDeploymentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopDeploymentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopDeploymentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopDeploymentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.completedAt = output.completedAt
            self.configurationLocationUri = output.configurationLocationUri
            self.configurationName = output.configurationName
            self.configurationProfileId = output.configurationProfileId
            self.configurationVersion = output.configurationVersion
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.deploymentNumber = output.deploymentNumber
            self.deploymentStrategyId = output.deploymentStrategyId
            self.description = output.description
            self.environmentId = output.environmentId
            self.eventLog = output.eventLog
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.percentageComplete = output.percentageComplete
            self.startedAt = output.startedAt
            self.state = output.state
        } else {
            self.applicationId = nil
            self.completedAt = nil
            self.configurationLocationUri = nil
            self.configurationName = nil
            self.configurationProfileId = nil
            self.configurationVersion = nil
            self.deploymentDurationInMinutes = 0
            self.deploymentNumber = 0
            self.deploymentStrategyId = nil
            self.description = nil
            self.environmentId = nil
            self.eventLog = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.percentageComplete = 0.0
            self.startedAt = nil
            self.state = nil
        }
    }
}

public struct StopDeploymentOutputResponse: Swift.Equatable {
    /// The ID of the application that was deployed.
    public var applicationId: Swift.String?
    /// The time the deployment completed.
    public var completedAt: ClientRuntime.Date?
    /// Information about the source location of the configuration.
    public var configurationLocationUri: Swift.String?
    /// The name of the configuration.
    public var configurationName: Swift.String?
    /// The ID of the configuration profile that was deployed.
    public var configurationProfileId: Swift.String?
    /// The configuration version that was deployed.
    public var configurationVersion: Swift.String?
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The sequence number of the deployment.
    public var deploymentNumber: Swift.Int
    /// The ID of the deployment strategy that was deployed.
    public var deploymentStrategyId: Swift.String?
    /// The description of the deployment.
    public var description: Swift.String?
    /// The ID of the environment that was deployed.
    public var environmentId: Swift.String?
    /// A list containing all events related to a deployment. The most recent events are displayed first.
    public var eventLog: [AppConfigClientTypes.DeploymentEvent]?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The percentage of targets for which the deployment is available.
    public var percentageComplete: Swift.Float
    /// The time the deployment started.
    public var startedAt: ClientRuntime.Date?
    /// The state of the deployment.
    public var state: AppConfigClientTypes.DeploymentState?

    public init (
        applicationId: Swift.String? = nil,
        completedAt: ClientRuntime.Date? = nil,
        configurationLocationUri: Swift.String? = nil,
        configurationName: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil,
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentNumber: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        eventLog: [AppConfigClientTypes.DeploymentEvent]? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        percentageComplete: Swift.Float = 0.0,
        startedAt: ClientRuntime.Date? = nil,
        state: AppConfigClientTypes.DeploymentState? = nil
    )
    {
        self.applicationId = applicationId
        self.completedAt = completedAt
        self.configurationLocationUri = configurationLocationUri
        self.configurationName = configurationName
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentNumber = deploymentNumber
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.environmentId = environmentId
        self.eventLog = eventLog
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.percentageComplete = percentageComplete
        self.startedAt = startedAt
        self.state = state
    }
}

struct StopDeploymentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let environmentId: Swift.String?
    let deploymentStrategyId: Swift.String?
    let configurationProfileId: Swift.String?
    let deploymentNumber: Swift.Int
    let configurationName: Swift.String?
    let configurationLocationUri: Swift.String?
    let configurationVersion: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let state: AppConfigClientTypes.DeploymentState?
    let eventLog: [AppConfigClientTypes.DeploymentEvent]?
    let percentageComplete: Swift.Float
    let startedAt: ClientRuntime.Date?
    let completedAt: ClientRuntime.Date?
}

extension StopDeploymentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case completedAt = "CompletedAt"
        case configurationLocationUri = "ConfigurationLocationUri"
        case configurationName = "ConfigurationName"
        case configurationProfileId = "ConfigurationProfileId"
        case configurationVersion = "ConfigurationVersion"
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case deploymentNumber = "DeploymentNumber"
        case deploymentStrategyId = "DeploymentStrategyId"
        case description = "Description"
        case environmentId = "EnvironmentId"
        case eventLog = "EventLog"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case percentageComplete = "PercentageComplete"
        case startedAt = "StartedAt"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let deploymentStrategyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStrategyId)
        deploymentStrategyId = deploymentStrategyIdDecoded
        let configurationProfileIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationProfileId)
        configurationProfileId = configurationProfileIdDecoded
        let deploymentNumberDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentNumber)
        deploymentNumber = deploymentNumberDecoded
        let configurationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationName)
        configurationName = configurationNameDecoded
        let configurationLocationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationLocationUri)
        configurationLocationUri = configurationLocationUriDecoded
        let configurationVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationVersion)
        configurationVersion = configurationVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.DeploymentState.self, forKey: .state)
        state = stateDecoded
        let eventLogContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.DeploymentEvent?].self, forKey: .eventLog)
        var eventLogDecoded0:[AppConfigClientTypes.DeploymentEvent]? = nil
        if let eventLogContainer = eventLogContainer {
            eventLogDecoded0 = [AppConfigClientTypes.DeploymentEvent]()
            for structure0 in eventLogContainer {
                if let structure0 = structure0 {
                    eventLogDecoded0?.append(structure0)
                }
            }
        }
        eventLog = eventLogDecoded0
        let percentageCompleteDecoded = try containerValues.decode(Swift.Float.self, forKey: .percentageComplete)
        percentageComplete = percentageCompleteDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value string map. The valid character set is [a-zA-Z+-=._:/]. The tag key can be up to 128 characters and must not start with aws:. The tag value can be up to 256 characters.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension AppConfigClientTypes {
    public enum TriggeredBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appconfig
        case cloudwatchAlarm
        case internalError
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggeredBy] {
            return [
                .appconfig,
                .cloudwatchAlarm,
                .internalError,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appconfig: return "APPCONFIG"
            case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
            case .internalError: return "INTERNAL_ERROR"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggeredBy(rawValue: rawValue) ?? TriggeredBy.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource for which to remove tags.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the application.
    public var description: Swift.String?
    /// The name of the application.
    public var name: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// The description of the application.
    public var description: Swift.String?
    /// The application ID.
    public var id: Swift.String?
    /// The application name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfigurationProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let retrievalRoleArn = retrievalRoleArn {
            try encodeContainer.encode(retrievalRoleArn, forKey: .retrievalRoleArn)
        }
        if let validators = validators {
            var validatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .validators)
            for validatorlist0 in validators {
                try validatorsContainer.encode(validatorlist0)
            }
        }
    }
}

extension UpdateConfigurationProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())"
    }
}

public struct UpdateConfigurationProfileInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The ID of the configuration profile.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// A description of the configuration profile.
    public var description: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.description = description
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.validators = validators
    }
}

struct UpdateConfigurationProfileInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
}

extension UpdateConfigurationProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
    }
}

extension UpdateConfigurationProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationProfileOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConfigurationProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.locationUri = output.locationUri
            self.name = output.name
            self.retrievalRoleArn = output.retrievalRoleArn
            self.type = output.type
            self.validators = output.validators
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.locationUri = nil
            self.name = nil
            self.retrievalRoleArn = nil
            self.type = nil
            self.validators = nil
        }
    }
}

public struct UpdateConfigurationProfileOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The configuration profile description.
    public var description: Swift.String?
    /// The configuration profile ID.
    public var id: Swift.String?
    /// The URI location of the configuration.
    public var locationUri: Swift.String?
    /// The name of the configuration profile.
    public var name: Swift.String?
    /// The ARN of an IAM role with permission to access the configuration at the specified LocationUri.
    public var retrievalRoleArn: Swift.String?
    /// The type of configurations that the configuration profile contains. A configuration can be a feature flag used for enabling or disabling new features or a free-form configuration used for distributing configurations to your application.
    public var type: Swift.String?
    /// A list of methods for validating the configuration.
    public var validators: [AppConfigClientTypes.Validator]?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        locationUri: Swift.String? = nil,
        name: Swift.String? = nil,
        retrievalRoleArn: Swift.String? = nil,
        type: Swift.String? = nil,
        validators: [AppConfigClientTypes.Validator]? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.locationUri = locationUri
        self.name = name
        self.retrievalRoleArn = retrievalRoleArn
        self.type = type
        self.validators = validators
    }
}

struct UpdateConfigurationProfileOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let locationUri: Swift.String?
    let retrievalRoleArn: Swift.String?
    let validators: [AppConfigClientTypes.Validator]?
    let type: Swift.String?
}

extension UpdateConfigurationProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case locationUri = "LocationUri"
        case name = "Name"
        case retrievalRoleArn = "RetrievalRoleArn"
        case type = "Type"
        case validators = "Validators"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let locationUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locationUri)
        locationUri = locationUriDecoded
        let retrievalRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .retrievalRoleArn)
        retrievalRoleArn = retrievalRoleArnDecoded
        let validatorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Validator?].self, forKey: .validators)
        var validatorsDecoded0:[AppConfigClientTypes.Validator]? = nil
        if let validatorsContainer = validatorsContainer {
            validatorsDecoded0 = [AppConfigClientTypes.Validator]()
            for structure0 in validatorsContainer {
                if let structure0 = structure0 {
                    validatorsDecoded0?.append(structure0)
                }
            }
        }
        validators = validatorsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension UpdateDeploymentStrategyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if deploymentDurationInMinutes != 0 {
            try encodeContainer.encode(deploymentDurationInMinutes, forKey: .deploymentDurationInMinutes)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if finalBakeTimeInMinutes != 0 {
            try encodeContainer.encode(finalBakeTimeInMinutes, forKey: .finalBakeTimeInMinutes)
        }
        if growthFactor != 0.0 {
            try encodeContainer.encode(growthFactor, forKey: .growthFactor)
        }
        if let growthType = growthType {
            try encodeContainer.encode(growthType.rawValue, forKey: .growthType)
        }
    }
}

extension UpdateDeploymentStrategyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deploymentStrategyId = deploymentStrategyId else {
            return nil
        }
        return "/deploymentstrategies/\(deploymentStrategyId.urlPercentEncoding())"
    }
}

public struct UpdateDeploymentStrategyInput: Swift.Equatable {
    /// Total amount of time for a deployment to last.
    public var deploymentDurationInMinutes: Swift.Int
    /// The deployment strategy ID.
    /// This member is required.
    public var deploymentStrategyId: Swift.String?
    /// A description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitors for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets to receive a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grows over time. AppConfig supports the following growth types: Linear: For this type, AppConfig processes the deployment by increments of the growth factor evenly distributed over the deployment time. For example, a linear deployment that uses a growth factor of 20 initially makes the configuration available to 20 percent of the targets. After 1/5th of the deployment time has passed, the system updates the percentage to 40 percent. This continues until 100% of the targets are set to receive the deployed configuration. Exponential: For this type, AppConfig processes the deployment exponentially using the following formula: G*(2^N). In this formula, G is the growth factor specified by the user and N is the number of steps until the configuration is deployed to all targets. For example, if you specify a growth factor of 2, then the system rolls out the configuration as follows: 2*(2^0)
    ///     2*(2^1)
    ///
    /// 2*(2^2) Expressed numerically, the deployment rolls out as follows: 2% of the targets, 4% of the targets, 8% of the targets, and continues until the configuration has been deployed to all targets.
    public var growthType: AppConfigClientTypes.GrowthType?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        deploymentStrategyId: Swift.String? = nil,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.deploymentStrategyId = deploymentStrategyId
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
    }
}

struct UpdateDeploymentStrategyInputBody: Swift.Equatable {
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let finalBakeTimeInMinutes: Swift.Int
    let growthFactor: Swift.Float
    let growthType: AppConfigClientTypes.GrowthType?
}

extension UpdateDeploymentStrategyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
    }
}

extension UpdateDeploymentStrategyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeploymentStrategyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeploymentStrategyOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeploymentStrategyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDeploymentStrategyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deploymentDurationInMinutes = output.deploymentDurationInMinutes
            self.description = output.description
            self.finalBakeTimeInMinutes = output.finalBakeTimeInMinutes
            self.growthFactor = output.growthFactor
            self.growthType = output.growthType
            self.id = output.id
            self.name = output.name
            self.replicateTo = output.replicateTo
        } else {
            self.deploymentDurationInMinutes = 0
            self.description = nil
            self.finalBakeTimeInMinutes = 0
            self.growthFactor = 0.0
            self.growthType = nil
            self.id = nil
            self.name = nil
            self.replicateTo = nil
        }
    }
}

public struct UpdateDeploymentStrategyOutputResponse: Swift.Equatable {
    /// Total amount of time the deployment lasted.
    public var deploymentDurationInMinutes: Swift.Int
    /// The description of the deployment strategy.
    public var description: Swift.String?
    /// The amount of time that AppConfig monitored for alarms before considering the deployment to be complete and no longer eligible for automatic rollback.
    public var finalBakeTimeInMinutes: Swift.Int
    /// The percentage of targets that received a deployed configuration during each interval.
    public var growthFactor: Swift.Float
    /// The algorithm used to define how percentage grew over time.
    public var growthType: AppConfigClientTypes.GrowthType?
    /// The deployment strategy ID.
    public var id: Swift.String?
    /// The name of the deployment strategy.
    public var name: Swift.String?
    /// Save the deployment strategy to a Systems Manager (SSM) document.
    public var replicateTo: AppConfigClientTypes.ReplicateTo?

    public init (
        deploymentDurationInMinutes: Swift.Int = 0,
        description: Swift.String? = nil,
        finalBakeTimeInMinutes: Swift.Int = 0,
        growthFactor: Swift.Float = 0.0,
        growthType: AppConfigClientTypes.GrowthType? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        replicateTo: AppConfigClientTypes.ReplicateTo? = nil
    )
    {
        self.deploymentDurationInMinutes = deploymentDurationInMinutes
        self.description = description
        self.finalBakeTimeInMinutes = finalBakeTimeInMinutes
        self.growthFactor = growthFactor
        self.growthType = growthType
        self.id = id
        self.name = name
        self.replicateTo = replicateTo
    }
}

struct UpdateDeploymentStrategyOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let deploymentDurationInMinutes: Swift.Int
    let growthType: AppConfigClientTypes.GrowthType?
    let growthFactor: Swift.Float
    let finalBakeTimeInMinutes: Swift.Int
    let replicateTo: AppConfigClientTypes.ReplicateTo?
}

extension UpdateDeploymentStrategyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentDurationInMinutes = "DeploymentDurationInMinutes"
        case description = "Description"
        case finalBakeTimeInMinutes = "FinalBakeTimeInMinutes"
        case growthFactor = "GrowthFactor"
        case growthType = "GrowthType"
        case id = "Id"
        case name = "Name"
        case replicateTo = "ReplicateTo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let deploymentDurationInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .deploymentDurationInMinutes)
        deploymentDurationInMinutes = deploymentDurationInMinutesDecoded
        let growthTypeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.GrowthType.self, forKey: .growthType)
        growthType = growthTypeDecoded
        let growthFactorDecoded = try containerValues.decode(Swift.Float.self, forKey: .growthFactor)
        growthFactor = growthFactorDecoded
        let finalBakeTimeInMinutesDecoded = try containerValues.decode(Swift.Int.self, forKey: .finalBakeTimeInMinutes)
        finalBakeTimeInMinutes = finalBakeTimeInMinutesDecoded
        let replicateToDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ReplicateTo.self, forKey: .replicateTo)
        replicateTo = replicateToDecoded
    }
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let monitors = monitors {
            var monitorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitors)
            for monitorlist0 in monitors {
                try monitorsContainer.encode(monitorlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let environmentId = environmentId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/environments/\(environmentId.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// A description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Amazon CloudWatch alarms to monitor during the deployment process.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.environmentId = environmentId
        self.monitors = monitors
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case monitors = "Monitors"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension UpdateEnvironmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationId = output.applicationId
            self.description = output.description
            self.id = output.id
            self.monitors = output.monitors
            self.name = output.name
            self.state = output.state
        } else {
            self.applicationId = nil
            self.description = nil
            self.id = nil
            self.monitors = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Swift.Equatable {
    /// The application ID.
    public var applicationId: Swift.String?
    /// The description of the environment.
    public var description: Swift.String?
    /// The environment ID.
    public var id: Swift.String?
    /// Amazon CloudWatch alarms monitored during the deployment.
    public var monitors: [AppConfigClientTypes.Monitor]?
    /// The name of the environment.
    public var name: Swift.String?
    /// The state of the environment. An environment can be in one of the following states: READY_FOR_DEPLOYMENT, DEPLOYING, ROLLING_BACK, or ROLLED_BACK
    public var state: AppConfigClientTypes.EnvironmentState?

    public init (
        applicationId: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        monitors: [AppConfigClientTypes.Monitor]? = nil,
        name: Swift.String? = nil,
        state: AppConfigClientTypes.EnvironmentState? = nil
    )
    {
        self.applicationId = applicationId
        self.description = description
        self.id = id
        self.monitors = monitors
        self.name = name
        self.state = state
    }
}

struct UpdateEnvironmentOutputResponseBody: Swift.Equatable {
    let applicationId: Swift.String?
    let id: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let state: AppConfigClientTypes.EnvironmentState?
    let monitors: [AppConfigClientTypes.Monitor]?
}

extension UpdateEnvironmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case description = "Description"
        case id = "Id"
        case monitors = "Monitors"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.EnvironmentState.self, forKey: .state)
        state = stateDecoded
        let monitorsContainer = try containerValues.decodeIfPresent([AppConfigClientTypes.Monitor?].self, forKey: .monitors)
        var monitorsDecoded0:[AppConfigClientTypes.Monitor]? = nil
        if let monitorsContainer = monitorsContainer {
            monitorsDecoded0 = [AppConfigClientTypes.Monitor]()
            for structure0 in monitorsContainer {
                if let structure0 = structure0 {
                    monitorsDecoded0?.append(structure0)
                }
            }
        }
        monitors = monitorsDecoded0
    }
}

extension ValidateConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let configurationVersion = configurationVersion {
            let configurationVersionQueryItem = ClientRuntime.URLQueryItem(name: "configuration_version".urlPercentEncoding(), value: Swift.String(configurationVersion).urlPercentEncoding())
            items.append(configurationVersionQueryItem)
        }
        return items
    }
}

extension ValidateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationId = applicationId else {
            return nil
        }
        guard let configurationProfileId = configurationProfileId else {
            return nil
        }
        return "/applications/\(applicationId.urlPercentEncoding())/configurationprofiles/\(configurationProfileId.urlPercentEncoding())/validators"
    }
}

public struct ValidateConfigurationInput: Swift.Equatable {
    /// The application ID.
    /// This member is required.
    public var applicationId: Swift.String?
    /// The configuration profile ID.
    /// This member is required.
    public var configurationProfileId: Swift.String?
    /// The version of the configuration to validate.
    /// This member is required.
    public var configurationVersion: Swift.String?

    public init (
        applicationId: Swift.String? = nil,
        configurationProfileId: Swift.String? = nil,
        configurationVersion: Swift.String? = nil
    )
    {
        self.applicationId = applicationId
        self.configurationProfileId = configurationProfileId
        self.configurationVersion = configurationVersion
    }
}

struct ValidateConfigurationInputBody: Swift.Equatable {
}

extension ValidateConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ValidateConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ValidateConfigurationOutputResponse: Swift.Equatable {

}

extension AppConfigClientTypes.Validator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case content = "Content"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AppConfigClientTypes.ValidatorType.self, forKey: .type)
        type = typeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
    }
}

extension AppConfigClientTypes {
    /// A validator provides a syntactic or semantic check to ensure the configuration that you want to deploy functions as intended. To validate your application configuration data, you provide a schema or a Lambda function that runs against the configuration. The configuration deployment or update can only proceed when the configuration data is valid.
    public struct Validator: Swift.Equatable {
        /// Either the JSON Schema content or the Amazon Resource Name (ARN) of an Lambda function.
        /// This member is required.
        public var content: Swift.String?
        /// AppConfig supports validators of type JSON_SCHEMA and LAMBDA
        /// This member is required.
        public var type: AppConfigClientTypes.ValidatorType?

        public init (
            content: Swift.String? = nil,
            type: AppConfigClientTypes.ValidatorType? = nil
        )
        {
            self.content = content
            self.type = type
        }
    }

}

extension AppConfigClientTypes {
    public enum ValidatorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jsonSchema
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidatorType] {
            return [
                .jsonSchema,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jsonSchema: return "JSON_SCHEMA"
            case .lambda: return "LAMBDA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidatorType(rawValue: rawValue) ?? ValidatorType.sdkUnknown(rawValue)
        }
    }
}
