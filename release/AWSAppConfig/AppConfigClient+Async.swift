// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5) && canImport(_Concurrency)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension AppConfigClient {
    /// An application in AppConfig is a logical unit of code that provides capabilities for your
    ///          customers. For example, an application can be a microservice that runs on Amazon EC2 instances,
    ///          a mobile application installed by your users, a serverless application using Amazon API
    ///          Gateway and AWS Lambda, or any system you run on behalf of others.
    func createApplication(input: CreateApplicationInput) async throws -> CreateApplicationOutputResponse
    {
        typealias createApplicationContinuation = CheckedContinuation<CreateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createApplicationContinuation) in
            createApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Information that enables AppConfig to access the configuration source. Valid
    ///          configuration sources include Systems Manager (SSM) documents, SSM Parameter Store parameters, and
    ///          Amazon S3 objects. A configuration profile includes the following information.
    ///
    ///
    ///                The Uri location of the configuration data.
    ///
    ///
    ///                The AWS Identity and Access Management (IAM) role that provides access to the configuration data.
    ///
    ///
    ///                A validator for the configuration data. Available validators include either a JSON
    ///                Schema or an AWS Lambda function.
    ///
    ///
    ///          For more information, see <a href="http://docs.aws.amazon.com/systems-manager/latest/userguide/appconfig-creating-configuration-and-profile.html">Create a
    ///             Configuration and a Configuration Profile in the
    ///             AWS AppConfig User Guide.
    func createConfigurationProfile(input: CreateConfigurationProfileInput) async throws -> CreateConfigurationProfileOutputResponse
    {
        typealias createConfigurationProfileContinuation = CheckedContinuation<CreateConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createConfigurationProfileContinuation) in
            createConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// A deployment strategy defines important criteria for rolling out your configuration to
    ///          the designated targets. A deployment strategy includes: the overall duration required, a
    ///          percentage of targets to receive the deployment during each interval, an algorithm that
    ///          defines how percentage grows, and bake time.
    func createDeploymentStrategy(input: CreateDeploymentStrategyInput) async throws -> CreateDeploymentStrategyOutputResponse
    {
        typealias createDeploymentStrategyContinuation = CheckedContinuation<CreateDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createDeploymentStrategyContinuation) in
            createDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// For each application, you define one or more environments. An environment is a logical
    ///          deployment group of AppConfig targets, such as applications in a Beta or
    ///             Production environment. You can also define environments for application
    ///          subcomponents such as the Web, Mobile and Back-end
    ///          components for your application. You can configure Amazon CloudWatch alarms for each environment.
    ///          The system monitors alarms during a configuration deployment. If an alarm is triggered, the
    ///          system rolls back the configuration.
    func createEnvironment(input: CreateEnvironmentInput) async throws -> CreateEnvironmentOutputResponse
    {
        typealias createEnvironmentContinuation = CheckedContinuation<CreateEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createEnvironmentContinuation) in
            createEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Create a new configuration in the AppConfig configuration store.
    func createHostedConfigurationVersion(input: CreateHostedConfigurationVersionInput) async throws -> CreateHostedConfigurationVersionOutputResponse
    {
        typealias createHostedConfigurationVersionContinuation = CheckedContinuation<CreateHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createHostedConfigurationVersionContinuation) in
            createHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an application. Deleting an application does not delete a configuration from a
    ///          host.
    func deleteApplication(input: DeleteApplicationInput) async throws -> DeleteApplicationOutputResponse
    {
        typealias deleteApplicationContinuation = CheckedContinuation<DeleteApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteApplicationContinuation) in
            deleteApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a configuration profile. Deleting a configuration profile does not delete a
    ///          configuration from a host.
    func deleteConfigurationProfile(input: DeleteConfigurationProfileInput) async throws -> DeleteConfigurationProfileOutputResponse
    {
        typealias deleteConfigurationProfileContinuation = CheckedContinuation<DeleteConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteConfigurationProfileContinuation) in
            deleteConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a deployment strategy. Deleting a deployment strategy does not delete a
    ///          configuration from a host.
    func deleteDeploymentStrategy(input: DeleteDeploymentStrategyInput) async throws -> DeleteDeploymentStrategyOutputResponse
    {
        typealias deleteDeploymentStrategyContinuation = CheckedContinuation<DeleteDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDeploymentStrategyContinuation) in
            deleteDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete an environment. Deleting an environment does not delete a configuration from a
    ///          host.
    func deleteEnvironment(input: DeleteEnvironmentInput) async throws -> DeleteEnvironmentOutputResponse
    {
        typealias deleteEnvironmentContinuation = CheckedContinuation<DeleteEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteEnvironmentContinuation) in
            deleteEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Delete a version of a configuration from the AppConfig configuration store.
    func deleteHostedConfigurationVersion(input: DeleteHostedConfigurationVersionInput) async throws -> DeleteHostedConfigurationVersionOutputResponse
    {
        typealias deleteHostedConfigurationVersionContinuation = CheckedContinuation<DeleteHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteHostedConfigurationVersionContinuation) in
            deleteHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve information about an application.
    func getApplication(input: GetApplicationInput) async throws -> GetApplicationOutputResponse
    {
        typealias getApplicationContinuation = CheckedContinuation<GetApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getApplicationContinuation) in
            getApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Receive information about a configuration.
    ///
    ///             AWS AppConfig uses the value of the ClientConfigurationVersion parameter
    ///             to identify the configuration version on your clients. If you donâ€™t send
    ///                ClientConfigurationVersion with each call to
    ///                GetConfiguration, your clients receive the current configuration. You
    ///             are charged each time your clients receive a configuration.
    ///             To avoid excess charges, we recommend that you include the
    ///                ClientConfigurationVersion value with every call to
    ///                GetConfiguration. This value must be saved on your client. Subsequent
    ///             calls to GetConfiguration must pass this value by using the
    ///                ClientConfigurationVersion parameter.
    ///
    func getConfiguration(input: GetConfigurationInput) async throws -> GetConfigurationOutputResponse
    {
        typealias getConfigurationContinuation = CheckedContinuation<GetConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConfigurationContinuation) in
            getConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve information about a configuration profile.
    func getConfigurationProfile(input: GetConfigurationProfileInput) async throws -> GetConfigurationProfileOutputResponse
    {
        typealias getConfigurationProfileContinuation = CheckedContinuation<GetConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getConfigurationProfileContinuation) in
            getConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve information about a configuration deployment.
    func getDeployment(input: GetDeploymentInput) async throws -> GetDeploymentOutputResponse
    {
        typealias getDeploymentContinuation = CheckedContinuation<GetDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentContinuation) in
            getDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve information about a deployment strategy. A deployment strategy defines
    ///          important criteria for rolling out your configuration to the designated targets. A
    ///          deployment strategy includes: the overall duration required, a percentage of targets to
    ///          receive the deployment during each interval, an algorithm that defines how percentage
    ///          grows, and bake time.
    func getDeploymentStrategy(input: GetDeploymentStrategyInput) async throws -> GetDeploymentStrategyOutputResponse
    {
        typealias getDeploymentStrategyContinuation = CheckedContinuation<GetDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getDeploymentStrategyContinuation) in
            getDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieve information about an environment. An environment is a logical deployment group
    ///          of AppConfig applications, such as applications in a Production environment or
    ///          in an EU_Region environment. Each configuration deployment targets an
    ///          environment. You can enable one or more Amazon CloudWatch alarms for an environment. If an alarm is
    ///          triggered during a deployment, AppConfig roles back the configuration.
    func getEnvironment(input: GetEnvironmentInput) async throws -> GetEnvironmentOutputResponse
    {
        typealias getEnvironmentContinuation = CheckedContinuation<GetEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getEnvironmentContinuation) in
            getEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Get information about a specific configuration version.
    func getHostedConfigurationVersion(input: GetHostedConfigurationVersionInput) async throws -> GetHostedConfigurationVersionOutputResponse
    {
        typealias getHostedConfigurationVersionContinuation = CheckedContinuation<GetHostedConfigurationVersionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getHostedConfigurationVersionContinuation) in
            getHostedConfigurationVersion(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List all applications in your AWS account.
    func listApplications(input: ListApplicationsInput) async throws -> ListApplicationsOutputResponse
    {
        typealias listApplicationsContinuation = CheckedContinuation<ListApplicationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listApplicationsContinuation) in
            listApplications(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the configuration profiles for an application.
    func listConfigurationProfiles(input: ListConfigurationProfilesInput) async throws -> ListConfigurationProfilesOutputResponse
    {
        typealias listConfigurationProfilesContinuation = CheckedContinuation<ListConfigurationProfilesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listConfigurationProfilesContinuation) in
            listConfigurationProfiles(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List deployment strategies.
    func listDeploymentStrategies(input: ListDeploymentStrategiesInput) async throws -> ListDeploymentStrategiesOutputResponse
    {
        typealias listDeploymentStrategiesContinuation = CheckedContinuation<ListDeploymentStrategiesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentStrategiesContinuation) in
            listDeploymentStrategies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the deployments for an environment.
    func listDeployments(input: ListDeploymentsInput) async throws -> ListDeploymentsOutputResponse
    {
        typealias listDeploymentsContinuation = CheckedContinuation<ListDeploymentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listDeploymentsContinuation) in
            listDeployments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// List the environments for an application.
    func listEnvironments(input: ListEnvironmentsInput) async throws -> ListEnvironmentsOutputResponse
    {
        typealias listEnvironmentsContinuation = CheckedContinuation<ListEnvironmentsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listEnvironmentsContinuation) in
            listEnvironments(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// View a list of configurations stored in the AppConfig configuration store by
    ///          version.
    func listHostedConfigurationVersions(input: ListHostedConfigurationVersionsInput) async throws -> ListHostedConfigurationVersionsOutputResponse
    {
        typealias listHostedConfigurationVersionsContinuation = CheckedContinuation<ListHostedConfigurationVersionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listHostedConfigurationVersionsContinuation) in
            listHostedConfigurationVersions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves the list of key-value tags assigned to the resource.
    func listTagsForResource(input: ListTagsForResourceInput) async throws -> ListTagsForResourceOutputResponse
    {
        typealias listTagsForResourceContinuation = CheckedContinuation<ListTagsForResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsForResourceContinuation) in
            listTagsForResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Starts a deployment.
    func startDeployment(input: StartDeploymentInput) async throws -> StartDeploymentOutputResponse
    {
        typealias startDeploymentContinuation = CheckedContinuation<StartDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startDeploymentContinuation) in
            startDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops a deployment. This API action works only on deployments that have a status of
    ///             DEPLOYING. This action moves the deployment to a status of
    ///             ROLLED_BACK.
    func stopDeployment(input: StopDeploymentInput) async throws -> StopDeploymentOutputResponse
    {
        typealias stopDeploymentContinuation = CheckedContinuation<StopDeploymentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopDeploymentContinuation) in
            stopDeployment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Metadata to assign to an AppConfig resource. Tags help organize and categorize your
    ///          AppConfig resources. Each tag consists of a key and an optional value, both of which you
    ///          define. You can specify a maximum of 50 tags for a resource.
    func tagResource(input: TagResourceInput) async throws -> TagResourceOutputResponse
    {
        typealias tagResourceContinuation = CheckedContinuation<TagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagResourceContinuation) in
            tagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a tag key and value from an AppConfig resource.
    func untagResource(input: UntagResourceInput) async throws -> UntagResourceOutputResponse
    {
        typealias untagResourceContinuation = CheckedContinuation<UntagResourceOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagResourceContinuation) in
            untagResource(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an application.
    func updateApplication(input: UpdateApplicationInput) async throws -> UpdateApplicationOutputResponse
    {
        typealias updateApplicationContinuation = CheckedContinuation<UpdateApplicationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateApplicationContinuation) in
            updateApplication(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a configuration profile.
    func updateConfigurationProfile(input: UpdateConfigurationProfileInput) async throws -> UpdateConfigurationProfileOutputResponse
    {
        typealias updateConfigurationProfileContinuation = CheckedContinuation<UpdateConfigurationProfileOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateConfigurationProfileContinuation) in
            updateConfigurationProfile(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates a deployment strategy.
    func updateDeploymentStrategy(input: UpdateDeploymentStrategyInput) async throws -> UpdateDeploymentStrategyOutputResponse
    {
        typealias updateDeploymentStrategyContinuation = CheckedContinuation<UpdateDeploymentStrategyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateDeploymentStrategyContinuation) in
            updateDeploymentStrategy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Updates an environment.
    func updateEnvironment(input: UpdateEnvironmentInput) async throws -> UpdateEnvironmentOutputResponse
    {
        typealias updateEnvironmentContinuation = CheckedContinuation<UpdateEnvironmentOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: updateEnvironmentContinuation) in
            updateEnvironment(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Uses the validators in a configuration profile to validate a configuration.
    func validateConfiguration(input: ValidateConfigurationInput) async throws -> ValidateConfigurationOutputResponse
    {
        typealias validateConfigurationContinuation = CheckedContinuation<ValidateConfigurationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: validateConfigurationContinuation) in
            validateConfiguration(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
