// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AppStreamClientTypes.AccessEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpointType = "EndpointType"
        case vpceId = "VpceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointType = endpointType {
            try encodeContainer.encode(endpointType.rawValue, forKey: .endpointType)
        }
        if let vpceId = vpceId {
            try encodeContainer.encode(vpceId, forKey: .vpceId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AccessEndpointType.self, forKey: .endpointType)
        endpointType = endpointTypeDecoded
        let vpceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpceId)
        vpceId = vpceIdDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an interface VPC endpoint (interface endpoint) that lets you create a private connection between the virtual private cloud (VPC) that you specify and AppStream 2.0. When you specify an interface endpoint for a stack, users of the stack can connect to AppStream 2.0 only through that endpoint. When you specify an interface endpoint for an image builder, administrators can connect to the image builder only through that endpoint.
    public struct AccessEndpoint: Swift.Equatable {
        /// The type of interface endpoint.
        /// This member is required.
        public var endpointType: AppStreamClientTypes.AccessEndpointType?
        /// The identifier (ID) of the VPC in which the interface endpoint is used.
        public var vpceId: Swift.String?

        public init (
            endpointType: AppStreamClientTypes.AccessEndpointType? = nil,
            vpceId: Swift.String? = nil
        )
        {
            self.endpointType = endpointType
            self.vpceId = vpceId
        }
    }

}

extension AppStreamClientTypes {
    public enum AccessEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streaming
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessEndpointType] {
            return [
                .streaming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streaming: return "STREAMING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessEndpointType(rawValue: rawValue) ?? AccessEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum Action: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clipboardCopyFromLocalDevice
        case clipboardCopyToLocalDevice
        case domainPasswordSignin
        case domainSmartCardSignin
        case fileDownload
        case fileUpload
        case printingToLocalDevice
        case sdkUnknown(Swift.String)

        public static var allCases: [Action] {
            return [
                .clipboardCopyFromLocalDevice,
                .clipboardCopyToLocalDevice,
                .domainPasswordSignin,
                .domainSmartCardSignin,
                .fileDownload,
                .fileUpload,
                .printingToLocalDevice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clipboardCopyFromLocalDevice: return "CLIPBOARD_COPY_FROM_LOCAL_DEVICE"
            case .clipboardCopyToLocalDevice: return "CLIPBOARD_COPY_TO_LOCAL_DEVICE"
            case .domainPasswordSignin: return "DOMAIN_PASSWORD_SIGNIN"
            case .domainSmartCardSignin: return "DOMAIN_SMART_CARD_SIGNIN"
            case .fileDownload: return "FILE_DOWNLOAD"
            case .fileUpload: return "FILE_UPLOAD"
            case .printingToLocalDevice: return "PRINTING_TO_LOCAL_DEVICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.AppBlock: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let setupScriptDetails = setupScriptDetails {
            try encodeContainer.encode(setupScriptDetails, forKey: .setupScriptDetails)
        }
        if let sourceS3Location = sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
        let setupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .setupScriptDetails)
        setupScriptDetails = setupScriptDetailsDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an app block. App blocks are an Amazon AppStream 2.0 resource that stores the details about the virtual hard disk in an S3 bucket. It also stores the setup script with details about how to mount the virtual hard disk. The virtual hard disk includes the application binaries and other files necessary to launch your applications. Multiple applications can be assigned to a single app block. This is only supported for Elastic fleets.
    public struct AppBlock: Swift.Equatable {
        /// The ARN of the app block.
        /// This member is required.
        public var arn: Swift.String?
        /// The created time of the app block.
        public var createdTime: ClientRuntime.Date?
        /// The description of the app block.
        public var description: Swift.String?
        /// The display name of the app block.
        public var displayName: Swift.String?
        /// The name of the app block.
        /// This member is required.
        public var name: Swift.String?
        /// The setup script details of the app block.
        /// This member is required.
        public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
        /// The source S3 location of the app block.
        public var sourceS3Location: AppStreamClientTypes.S3Location?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            name: Swift.String? = nil,
            setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
            sourceS3Location: AppStreamClientTypes.S3Location? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.name = name
            self.setupScriptDetails = setupScriptDetails
            self.sourceS3Location = sourceS3Location
        }
    }

}

extension AppStreamClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case enabled = "Enabled"
        case iconS3Location = "IconS3Location"
        case iconURL = "IconURL"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case metadata = "Metadata"
        case name = "Name"
        case platforms = "Platforms"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let iconS3Location = iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let iconURL = iconURL {
            try encodeContainer.encode(iconURL, forKey: .iconURL)
        }
        if let instanceFamilies = instanceFamilies {
            var instanceFamiliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceFamilies)
            for stringlist0 in instanceFamilies {
                try instanceFamiliesContainer.encode(stringlist0)
            }
        }
        if let launchParameters = launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for platforms0 in platforms {
                try platformsContainer.encode(platforms0.rawValue)
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iconURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconURL)
        iconURL = iconURLDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let platformsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.PlatformType?].self, forKey: .platforms)
        var platformsDecoded0:[AppStreamClientTypes.PlatformType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [AppStreamClientTypes.PlatformType]()
            for string0 in platformsContainer {
                if let string0 = string0 {
                    platformsDecoded0?.append(string0)
                }
            }
        }
        platforms = platformsDecoded0
        let instanceFamiliesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceFamilies)
        var instanceFamiliesDecoded0:[Swift.String]? = nil
        if let instanceFamiliesContainer = instanceFamiliesContainer {
            instanceFamiliesDecoded0 = [Swift.String]()
            for string0 in instanceFamiliesContainer {
                if let string0 = string0 {
                    instanceFamiliesDecoded0?.append(string0)
                }
            }
        }
        instanceFamilies = instanceFamiliesDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an application in the application catalog.
    public struct Application: Swift.Equatable {
        /// The app block ARN of the application.
        public var appBlockArn: Swift.String?
        /// The ARN of the application.
        public var arn: Swift.String?
        /// The time at which the application was created within the app block.
        public var createdTime: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The application name to display.
        public var displayName: Swift.String?
        /// If there is a problem, the application can be disabled after image creation.
        public var enabled: Swift.Bool
        /// The S3 location of the application icon.
        public var iconS3Location: AppStreamClientTypes.S3Location?
        /// The URL for the application icon. This URL might be time-limited.
        public var iconURL: Swift.String?
        /// The instance families for the application.
        public var instanceFamilies: [Swift.String]?
        /// The arguments that are passed to the application at launch.
        public var launchParameters: Swift.String?
        /// The path to the application executable in the instance.
        public var launchPath: Swift.String?
        /// Additional attributes that describe the application.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the application.
        public var name: Swift.String?
        /// The platforms on which the application can run.
        public var platforms: [AppStreamClientTypes.PlatformType]?
        /// The working directory for the application.
        public var workingDirectory: Swift.String?

        public init (
            appBlockArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            enabled: Swift.Bool = false,
            iconS3Location: AppStreamClientTypes.S3Location? = nil,
            iconURL: Swift.String? = nil,
            instanceFamilies: [Swift.String]? = nil,
            launchParameters: Swift.String? = nil,
            launchPath: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            platforms: [AppStreamClientTypes.PlatformType]? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.appBlockArn = appBlockArn
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.enabled = enabled
            self.iconS3Location = iconS3Location
            self.iconURL = iconURL
            self.instanceFamilies = instanceFamilies
            self.launchParameters = launchParameters
            self.launchPath = launchPath
            self.metadata = metadata
            self.name = name
            self.platforms = platforms
            self.workingDirectory = workingDirectory
        }
    }

}

extension AppStreamClientTypes {
    public enum ApplicationAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launchParameters
        case workingDirectory
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationAttribute] {
            return [
                .launchParameters,
                .workingDirectory,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launchParameters: return "LAUNCH_PARAMETERS"
            case .workingDirectory: return "WORKING_DIRECTORY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationAttribute(rawValue: rawValue) ?? ApplicationAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ApplicationFleetAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the application fleet association.
    public struct ApplicationFleetAssociation: Swift.Equatable {
        /// The ARN of the application associated with the fleet.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The name of the fleet associated with the application.
        /// This member is required.
        public var fleetName: Swift.String?

        public init (
            applicationArn: Swift.String? = nil,
            fleetName: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
            self.fleetName = fleetName
        }
    }

}

extension AppStreamClientTypes.ApplicationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
    }
}

extension AppStreamClientTypes {
    /// The persistent application settings for users of a stack.
    public struct ApplicationSettings: Swift.Equatable {
        /// Enables or disables persistent application settings for users during their streaming sessions.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored. You can allow the same persistent application settings to be used across multiple stacks by specifying the same settings group for each stack.
        public var settingsGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.settingsGroup = settingsGroup
        }
    }

}

extension AppStreamClientTypes.ApplicationSettingsResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case s3BucketName = "S3BucketName"
        case settingsGroup = "SettingsGroup"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let settingsGroup = settingsGroup {
            try encodeContainer.encode(settingsGroup, forKey: .settingsGroup)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let settingsGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .settingsGroup)
        settingsGroup = settingsGroupDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the persistent application settings for users of a stack.
    public struct ApplicationSettingsResponse: Swift.Equatable {
        /// Specifies whether persistent application settings are enabled for users during their streaming sessions.
        public var enabled: Swift.Bool
        /// The S3 bucket where users’ persistent application settings are stored. When persistent application settings are enabled for the first time for an account in an AWS Region, an S3 bucket is created. The bucket is unique to the AWS account and the Region.
        public var s3BucketName: Swift.String?
        /// The path prefix for the S3 bucket where users’ persistent application settings are stored.
        public var settingsGroup: Swift.String?

        public init (
            enabled: Swift.Bool = false,
            s3BucketName: Swift.String? = nil,
            settingsGroup: Swift.String? = nil
        )
        {
            self.enabled = enabled
            self.s3BucketName = s3BucketName
            self.settingsGroup = settingsGroup
        }
    }

}

extension AssociateApplicationFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }
}

extension AssociateApplicationFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateApplicationFleetInput: Swift.Equatable {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

struct AssociateApplicationFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
}

extension AssociateApplicationFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension AssociateApplicationFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApplicationFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateApplicationFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApplicationFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateApplicationFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationFleetAssociation = output.applicationFleetAssociation
        } else {
            self.applicationFleetAssociation = nil
        }
    }
}

public struct AssociateApplicationFleetOutputResponse: Swift.Equatable {
    /// If fleet name is specified, this returns the list of applications that are associated to it. If application ARN is specified, this returns the list of fleets to which it is associated.
    public var applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation?

    public init (
        applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation? = nil
    )
    {
        self.applicationFleetAssociation = applicationFleetAssociation
    }
}

struct AssociateApplicationFleetOutputResponseBody: Swift.Equatable {
    let applicationFleetAssociation: AppStreamClientTypes.ApplicationFleetAssociation?
}

extension AssociateApplicationFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationFleetAssociation = "ApplicationFleetAssociation"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationFleetAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationFleetAssociation.self, forKey: .applicationFleetAssociation)
        applicationFleetAssociation = applicationFleetAssociationDecoded
    }
}

extension AssociateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension AssociateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct AssociateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let stackName: Swift.String?
}

extension AssociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension AssociateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateFleetOutputResponse: Swift.Equatable {

}

extension AppStreamClientTypes {
    public enum AuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case api
        case saml
        case userpool
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationType] {
            return [
                .api,
                .saml,
                .userpool,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .api: return "API"
            case .saml: return "SAML"
            case .userpool: return "USERPOOL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationType(rawValue: rawValue) ?? AuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension BatchAssociateUserStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

extension BatchAssociateUserStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchAssociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchAssociateUserStackInputBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchAssociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchAssociateUserStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateUserStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateUserStackOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateUserStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateUserStackOutputResponse: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init (
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateUserStackOutputResponseBody: Swift.Equatable {
    let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchAssociateUserStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchDisassociateUserStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userStackAssociations = userStackAssociations {
            var userStackAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userStackAssociations)
            for userstackassociationlist0 in userStackAssociations {
                try userStackAssociationsContainer.encode(userstackassociationlist0)
            }
        }
    }
}

extension BatchDisassociateUserStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchDisassociateUserStackInput: Swift.Equatable {
    /// The list of UserStackAssociation objects.
    /// This member is required.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.userStackAssociations = userStackAssociations
    }
}

struct BatchDisassociateUserStackInputBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
}

extension BatchDisassociateUserStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
    }
}

extension BatchDisassociateUserStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateUserStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateUserStackOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateUserStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateUserStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateUserStackOutputResponse: Swift.Equatable {
    /// The list of UserStackAssociationError objects.
    public var errors: [AppStreamClientTypes.UserStackAssociationError]?

    public init (
        errors: [AppStreamClientTypes.UserStackAssociationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateUserStackOutputResponseBody: Swift.Equatable {
    let errors: [AppStreamClientTypes.UserStackAssociationError]?
}

extension BatchDisassociateUserStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociationError?].self, forKey: .errors)
        var errorsDecoded0:[AppStreamClientTypes.UserStackAssociationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AppStreamClientTypes.UserStackAssociationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension AppStreamClientTypes.ComputeCapacity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredInstances = "DesiredInstances"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredInstances = desiredInstances {
            try encodeContainer.encode(desiredInstances, forKey: .desiredInstances)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredInstancesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desiredInstances)
        desiredInstances = desiredInstancesDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the capacity for a fleet.
    public struct ComputeCapacity: Swift.Equatable {
        /// The desired number of streaming instances.
        /// This member is required.
        public var desiredInstances: Swift.Int?

        public init (
            desiredInstances: Swift.Int? = nil
        )
        {
            self.desiredInstances = desiredInstances
        }
    }

}

extension AppStreamClientTypes.ComputeCapacityStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case available = "Available"
        case desired = "Desired"
        case inUse = "InUse"
        case running = "Running"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let available = available {
            try encodeContainer.encode(available, forKey: .available)
        }
        if let desired = desired {
            try encodeContainer.encode(desired, forKey: .desired)
        }
        if let inUse = inUse {
            try encodeContainer.encode(inUse, forKey: .inUse)
        }
        if let running = running {
            try encodeContainer.encode(running, forKey: .running)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let desiredDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .desired)
        desired = desiredDecoded
        let runningDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .running)
        running = runningDecoded
        let inUseDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inUse)
        inUse = inUseDecoded
        let availableDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .available)
        available = availableDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the capacity status for a fleet.
    public struct ComputeCapacityStatus: Swift.Equatable {
        /// The number of currently available instances that can be used to stream sessions.
        public var available: Swift.Int?
        /// The desired number of streaming instances.
        /// This member is required.
        public var desired: Swift.Int?
        /// The number of instances in use for streaming.
        public var inUse: Swift.Int?
        /// The total number of simultaneous streaming instances that are running.
        public var running: Swift.Int?

        public init (
            available: Swift.Int? = nil,
            desired: Swift.Int? = nil,
            inUse: Swift.Int? = nil,
            running: Swift.Int? = nil
        )
        {
            self.available = available
            self.desired = desired
            self.inUse = inUse
            self.running = running
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An API error occurred. Wait a few minutes and try again.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CopyImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationImageDescription = destinationImageDescription {
            try encodeContainer.encode(destinationImageDescription, forKey: .destinationImageDescription)
        }
        if let destinationImageName = destinationImageName {
            try encodeContainer.encode(destinationImageName, forKey: .destinationImageName)
        }
        if let destinationRegion = destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let sourceImageName = sourceImageName {
            try encodeContainer.encode(sourceImageName, forKey: .sourceImageName)
        }
    }
}

extension CopyImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CopyImageInput: Swift.Equatable {
    /// The description that the image will have when it is copied to the destination.
    public var destinationImageDescription: Swift.String?
    /// The name that the image will have when it is copied to the destination.
    /// This member is required.
    public var destinationImageName: Swift.String?
    /// The destination region to which the image will be copied. This parameter is required, even if you are copying an image within the same region.
    /// This member is required.
    public var destinationRegion: Swift.String?
    /// The name of the image to copy.
    /// This member is required.
    public var sourceImageName: Swift.String?

    public init (
        destinationImageDescription: Swift.String? = nil,
        destinationImageName: Swift.String? = nil,
        destinationRegion: Swift.String? = nil,
        sourceImageName: Swift.String? = nil
    )
    {
        self.destinationImageDescription = destinationImageDescription
        self.destinationImageName = destinationImageName
        self.destinationRegion = destinationRegion
        self.sourceImageName = sourceImageName
    }
}

struct CopyImageInputBody: Swift.Equatable {
    let sourceImageName: Swift.String?
    let destinationImageName: Swift.String?
    let destinationRegion: Swift.String?
    let destinationImageDescription: Swift.String?
}

extension CopyImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageDescription = "DestinationImageDescription"
        case destinationImageName = "DestinationImageName"
        case destinationRegion = "DestinationRegion"
        case sourceImageName = "SourceImageName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceImageName)
        sourceImageName = sourceImageNameDecoded
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
        let destinationImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageDescription)
        destinationImageDescription = destinationImageDescriptionDecoded
    }
}

extension CopyImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyImageOutputError: Swift.Error, Swift.Equatable {
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationImageName = output.destinationImageName
        } else {
            self.destinationImageName = nil
        }
    }
}

public struct CopyImageOutputResponse: Swift.Equatable {
    /// The name of the destination image.
    public var destinationImageName: Swift.String?

    public init (
        destinationImageName: Swift.String? = nil
    )
    {
        self.destinationImageName = destinationImageName
    }
}

struct CopyImageOutputResponseBody: Swift.Equatable {
    let destinationImageName: Swift.String?
}

extension CopyImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationImageName = "DestinationImageName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationImageName)
        destinationImageName = destinationImageNameDecoded
    }
}

extension CreateAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let setupScriptDetails = setupScriptDetails {
            try encodeContainer.encode(setupScriptDetails, forKey: .setupScriptDetails)
        }
        if let sourceS3Location = sourceS3Location {
            try encodeContainer.encode(sourceS3Location, forKey: .sourceS3Location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppBlockInput: Swift.Equatable {
    /// The description of the app block.
    public var description: Swift.String?
    /// The display name of the app block. This is not displayed to the user.
    public var displayName: Swift.String?
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?
    /// The setup script details of the app block.
    /// This member is required.
    public var setupScriptDetails: AppStreamClientTypes.ScriptDetails?
    /// The source S3 location of the app block.
    /// This member is required.
    public var sourceS3Location: AppStreamClientTypes.S3Location?
    /// The tags assigned to the app block.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        setupScriptDetails: AppStreamClientTypes.ScriptDetails? = nil,
        sourceS3Location: AppStreamClientTypes.S3Location? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.displayName = displayName
        self.name = name
        self.setupScriptDetails = setupScriptDetails
        self.sourceS3Location = sourceS3Location
        self.tags = tags
    }
}

struct CreateAppBlockInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let sourceS3Location: AppStreamClientTypes.S3Location?
    let setupScriptDetails: AppStreamClientTypes.ScriptDetails?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case name = "Name"
        case setupScriptDetails = "SetupScriptDetails"
        case sourceS3Location = "SourceS3Location"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let sourceS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .sourceS3Location)
        sourceS3Location = sourceS3LocationDecoded
        let setupScriptDetailsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ScriptDetails.self, forKey: .setupScriptDetails)
        setupScriptDetails = setupScriptDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppBlockOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAppBlockOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appBlock = output.appBlock
        } else {
            self.appBlock = nil
        }
    }
}

public struct CreateAppBlockOutputResponse: Swift.Equatable {
    /// The app block.
    public var appBlock: AppStreamClientTypes.AppBlock?

    public init (
        appBlock: AppStreamClientTypes.AppBlock? = nil
    )
    {
        self.appBlock = appBlock
    }
}

struct CreateAppBlockOutputResponseBody: Swift.Equatable {
    let appBlock: AppStreamClientTypes.AppBlock?
}

extension CreateAppBlockOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlock = "AppBlock"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlockDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AppBlock.self, forKey: .appBlock)
        appBlock = appBlockDecoded
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case platforms = "Platforms"
        case tags = "Tags"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let iconS3Location = iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let instanceFamilies = instanceFamilies {
            var instanceFamiliesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceFamilies)
            for stringlist0 in instanceFamilies {
                try instanceFamiliesContainer.encode(stringlist0)
            }
        }
        if let launchParameters = launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platforms = platforms {
            var platformsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platforms)
            for platforms0 in platforms {
                try platformsContainer.encode(platforms0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The app block ARN to which the application should be associated
    /// This member is required.
    public var appBlockArn: Swift.String?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The location in S3 of the application icon.
    /// This member is required.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The instance families the application supports. Valid values are GENERAL_PURPOSE and GRAPHICS_G4.
    /// This member is required.
    public var instanceFamilies: [Swift.String]?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    /// This member is required.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The platforms the application supports. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    /// This member is required.
    public var platforms: [AppStreamClientTypes.PlatformType]?
    /// The tags assigned to the application.
    public var tags: [Swift.String:Swift.String]?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init (
        appBlockArn: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        instanceFamilies: [Swift.String]? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        platforms: [AppStreamClientTypes.PlatformType]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.instanceFamilies = instanceFamilies
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.platforms = platforms
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let iconS3Location: AppStreamClientTypes.S3Location?
    let launchPath: Swift.String?
    let workingDirectory: Swift.String?
    let launchParameters: Swift.String?
    let platforms: [AppStreamClientTypes.PlatformType]?
    let instanceFamilies: [Swift.String]?
    let appBlockArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case instanceFamilies = "InstanceFamilies"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case platforms = "Platforms"
        case tags = "Tags"
        case workingDirectory = "WorkingDirectory"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let platformsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.PlatformType?].self, forKey: .platforms)
        var platformsDecoded0:[AppStreamClientTypes.PlatformType]? = nil
        if let platformsContainer = platformsContainer {
            platformsDecoded0 = [AppStreamClientTypes.PlatformType]()
            for string0 in platformsContainer {
                if let string0 = string0 {
                    platformsDecoded0?.append(string0)
                }
            }
        }
        platforms = platformsDecoded0
        let instanceFamiliesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceFamilies)
        var instanceFamiliesDecoded0:[Swift.String]? = nil
        if let instanceFamiliesContainer = instanceFamiliesContainer {
            instanceFamiliesDecoded0 = [Swift.String]()
            for string0 in instanceFamiliesContainer {
                if let string0 = string0 {
                    instanceFamiliesDecoded0?.append(string0)
                }
            }
        }
        instanceFamilies = instanceFamiliesDecoded0
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init (
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let application: AppStreamClientTypes.Application?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

extension CreateDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

extension CreateDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateDirectoryConfigInput: Swift.Equatable {
    /// The fully qualified name of the directory (for example, corp.example.com).
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    /// This member is required.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init (
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct CreateDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
    let organizationalUnitDistinguishedNames: [Swift.String]?
    let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
}

extension CreateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension CreateDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct CreateDirectoryConfigOutputResponse: Swift.Equatable {
    /// Information about the directory configuration.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init (
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct CreateDirectoryConfigOutputResponseBody: Swift.Equatable {
    let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension CreateDirectoryConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

extension CreateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case streamView = "StreamView"
        case tags = "Tags"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstrings0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstrings0)
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateFleetInput: Swift.Equatable {
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets. For Elastic fleets, specify MaxConcurrentSessions instead.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain. This is not allowed for Elastic fleets.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
    public var fleetType: AppStreamClientTypes.FleetType?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If they try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    /// This member is required.
    public var instanceType: Swift.String?
    /// The maximum concurrent sessions of the Elastic fleet. This is required for Elastic fleets, and not allowed for other fleet types.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    /// This member is required.
    public var name: Swift.String?
    /// The fleet platform. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The tags to associate with the fleet. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        fleetType: AppStreamClientTypes.FleetType? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.computeCapacity = computeCapacity
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.fleetType = fleetType
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.streamView = streamView
        self.tags = tags
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

struct CreateFleetInputBody: Swift.Equatable {
    let name: Swift.String?
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let instanceType: Swift.String?
    let fleetType: AppStreamClientTypes.FleetType?
    let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let maxUserDurationInSeconds: Swift.Int?
    let disconnectTimeoutInSeconds: Swift.Int?
    let description: Swift.String?
    let displayName: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let tags: [Swift.String:Swift.String]?
    let idleDisconnectTimeoutInSeconds: Swift.Int?
    let iamRoleArn: Swift.String?
    let streamView: AppStreamClientTypes.StreamView?
    let platform: AppStreamClientTypes.PlatformType?
    let maxConcurrentSessions: Swift.Int?
    let usbDeviceFilterStrings: [Swift.String]?
}

extension CreateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeCapacity = "ComputeCapacity"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case streamView = "StreamView"
        case tags = "Tags"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
    }
}

extension CreateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct CreateFleetOutputResponse: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init (
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct CreateFleetOutputResponseBody: Swift.Equatable {
    let fleet: AppStreamClientTypes.Fleet?
}

extension CreateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension CreateImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension CreateImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImageBuilderInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Administrators can connect to the image builder only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The description to display.
    public var description: Swift.String?
    /// The image builder name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the image builder.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the image builder.
    public var imageName: Swift.String?
    /// The instance type to use when launching the image builder. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    /// This member is required.
    public var instanceType: Swift.String?
    /// A unique name for the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to associate with the image builder. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The VPC configuration for the image builder. You can specify only one subnet.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        appstreamAgentVersion: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.appstreamAgentVersion = appstreamAgentVersion
        self.description = description
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.name = name
        self.tags = tags
        self.vpcConfig = vpcConfig
    }
}

struct CreateImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let instanceType: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let iamRoleArn: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let appstreamAgentVersion: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
}

extension CreateImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case name = "Name"
        case tags = "Tags"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension CreateImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct CreateImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct CreateImageBuilderOutputResponseBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension CreateImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension CreateImageBuilderStreamingURLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateImageBuilderStreamingURLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateImageBuilderStreamingURLInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 3600 seconds.
    public var validity: Swift.Int?

    public init (
        name: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.name = name
        self.validity = validity
    }
}

struct CreateImageBuilderStreamingURLInputBody: Swift.Equatable {
    let name: Swift.String?
    let validity: Swift.Int?
}

extension CreateImageBuilderStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
    }
}

extension CreateImageBuilderStreamingURLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageBuilderStreamingURLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageBuilderStreamingURLOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageBuilderStreamingURLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageBuilderStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateImageBuilderStreamingURLOutputResponse: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateImageBuilderStreamingURLOutputResponseBody: Swift.Equatable {
    let streamingURL: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateImageBuilderStreamingURLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

extension CreateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The tags to associate with the stack. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var tags: [Swift.String:Swift.String]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.tags = tags
        self.userSettings = userSettings
    }
}

struct CreateStackInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let displayName: Swift.String?
    let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    let redirectURL: Swift.String?
    let feedbackURL: Swift.String?
    let userSettings: [AppStreamClientTypes.UserSetting]?
    let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    let tags: [Swift.String:Swift.String]?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    let embedHostDomains: [Swift.String]?
}

extension CreateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case tags = "Tags"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension CreateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct CreateStackOutputResponse: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init (
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct CreateStackOutputResponseBody: Swift.Equatable {
    let stack: AppStreamClientTypes.Stack?
}

extension CreateStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

extension CreateStreamingURLInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let sessionContext = sessionContext {
            try encodeContainer.encode(sessionContext, forKey: .sessionContext)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let validity = validity {
            try encodeContainer.encode(validity, forKey: .validity)
        }
    }
}

extension CreateStreamingURLInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateStreamingURLInput: Swift.Equatable {
    /// The name of the application to launch after the session starts. This is the name that you specified as Name in the Image Assistant. If your fleet is enabled for the Desktop stream view, you can also choose to launch directly to the operating system desktop. To do so, specify Desktop.
    public var applicationId: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The session context. For more information, see [Session Context](https://docs.aws.amazon.com/appstream2/latest/developerguide/managing-stacks-fleets.html#managing-stacks-fleets-parameters) in the Amazon AppStream 2.0 Administration Guide.
    public var sessionContext: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?
    /// The identifier of the user.
    /// This member is required.
    public var userId: Swift.String?
    /// The time that the streaming URL will be valid, in seconds. Specify a value between 1 and 604800 seconds. The default is 60 seconds.
    public var validity: Swift.Int?

    public init (
        applicationId: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        sessionContext: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil,
        validity: Swift.Int? = nil
    )
    {
        self.applicationId = applicationId
        self.fleetName = fleetName
        self.sessionContext = sessionContext
        self.stackName = stackName
        self.userId = userId
        self.validity = validity
    }
}

struct CreateStreamingURLInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let fleetName: Swift.String?
    let userId: Swift.String?
    let applicationId: Swift.String?
    let validity: Swift.Int?
    let sessionContext: Swift.String?
}

extension CreateStreamingURLInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationId = "ApplicationId"
        case fleetName = "FleetName"
        case sessionContext = "SessionContext"
        case stackName = "StackName"
        case userId = "UserId"
        case validity = "Validity"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let validityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .validity)
        validity = validityDecoded
        let sessionContextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionContext)
        sessionContext = sessionContextDecoded
    }
}

extension CreateStreamingURLOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamingURLOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateStreamingURLOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamingURLOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateStreamingURLOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expires = output.expires
            self.streamingURL = output.streamingURL
        } else {
            self.expires = nil
            self.streamingURL = nil
        }
    }
}

public struct CreateStreamingURLOutputResponse: Swift.Equatable {
    /// The elapsed time, in seconds after the Unix epoch, when this URL expires.
    public var expires: ClientRuntime.Date?
    /// The URL to start the AppStream 2.0 streaming session.
    public var streamingURL: Swift.String?

    public init (
        expires: ClientRuntime.Date? = nil,
        streamingURL: Swift.String? = nil
    )
    {
        self.expires = expires
        self.streamingURL = streamingURL
    }
}

struct CreateStreamingURLOutputResponseBody: Swift.Equatable {
    let streamingURL: Swift.String?
    let expires: ClientRuntime.Date?
}

extension CreateStreamingURLOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expires = "Expires"
        case streamingURL = "StreamingURL"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamingURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamingURL)
        streamingURL = streamingURLDecoded
        let expiresDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .expires)
        expires = expiresDecoded
    }
}

extension CreateUpdatedImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let existingImageName = existingImageName {
            try encodeContainer.encode(existingImageName, forKey: .existingImageName)
        }
        if let newImageDescription = newImageDescription {
            try encodeContainer.encode(newImageDescription, forKey: .newImageDescription)
        }
        if let newImageDisplayName = newImageDisplayName {
            try encodeContainer.encode(newImageDisplayName, forKey: .newImageDisplayName)
        }
        if let newImageName = newImageName {
            try encodeContainer.encode(newImageName, forKey: .newImageName)
        }
        if let newImageTags = newImageTags {
            var newImageTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .newImageTags)
            for (dictKey0, tags0) in newImageTags {
                try newImageTagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateUpdatedImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUpdatedImageInput: Swift.Equatable {
    /// Indicates whether to display the status of image update availability before AppStream 2.0 initiates the process of creating a new updated image. If this value is set to true, AppStream 2.0 displays whether image updates are available. If this value is set to false, AppStream 2.0 initiates the process of creating a new updated image without displaying whether image updates are available.
    public var dryRun: Swift.Bool
    /// The name of the image to update.
    /// This member is required.
    public var existingImageName: Swift.String?
    /// The description to display for the new image.
    public var newImageDescription: Swift.String?
    /// The name to display for the new image.
    public var newImageDisplayName: Swift.String?
    /// The name of the new image. The name must be unique within the AWS account and Region.
    /// This member is required.
    public var newImageName: Swift.String?
    /// The tags to associate with the new image. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @ If you do not specify a value, the value is set to an empty string. For more information about tags, see [Tagging Your Resources](https://docs.aws.amazon.com/appstream2/latest/developerguide/tagging-basic.html) in the Amazon AppStream 2.0 Administration Guide.
    public var newImageTags: [Swift.String:Swift.String]?

    public init (
        dryRun: Swift.Bool = false,
        existingImageName: Swift.String? = nil,
        newImageDescription: Swift.String? = nil,
        newImageDisplayName: Swift.String? = nil,
        newImageName: Swift.String? = nil,
        newImageTags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dryRun = dryRun
        self.existingImageName = existingImageName
        self.newImageDescription = newImageDescription
        self.newImageDisplayName = newImageDisplayName
        self.newImageName = newImageName
        self.newImageTags = newImageTags
    }
}

struct CreateUpdatedImageInputBody: Swift.Equatable {
    let existingImageName: Swift.String?
    let newImageName: Swift.String?
    let newImageDescription: Swift.String?
    let newImageDisplayName: Swift.String?
    let newImageTags: [Swift.String:Swift.String]?
    let dryRun: Swift.Bool
}

extension CreateUpdatedImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dryRun
        case existingImageName
        case newImageDescription
        case newImageDisplayName
        case newImageName
        case newImageTags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let existingImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .existingImageName)
        existingImageName = existingImageNameDecoded
        let newImageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageName)
        newImageName = newImageNameDecoded
        let newImageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDescription)
        newImageDescription = newImageDescriptionDecoded
        let newImageDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .newImageDisplayName)
        newImageDisplayName = newImageDisplayNameDecoded
        let newImageTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .newImageTags)
        var newImageTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let newImageTagsContainer = newImageTagsContainer {
            newImageTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in newImageTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    newImageTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        newImageTags = newImageTagsDecoded0
        let dryRunDecoded = try containerValues.decode(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateUpdatedImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUpdatedImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUpdatedImageOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUpdatedImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUpdatedImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.canUpdateImage = output.canUpdateImage
            self.image = output.image
        } else {
            self.canUpdateImage = false
            self.image = nil
        }
    }
}

public struct CreateUpdatedImageOutputResponse: Swift.Equatable {
    /// Indicates whether a new image can be created.
    public var canUpdateImage: Swift.Bool
    /// Describes an image.
    public var image: AppStreamClientTypes.Image?

    public init (
        canUpdateImage: Swift.Bool = false,
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.canUpdateImage = canUpdateImage
        self.image = image
    }
}

struct CreateUpdatedImageOutputResponseBody: Swift.Equatable {
    let image: AppStreamClientTypes.Image?
    let canUpdateImage: Swift.Bool
}

extension CreateUpdatedImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case canUpdateImage
        case image
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
        let canUpdateImageDecoded = try containerValues.decode(Swift.Bool.self, forKey: .canUpdateImage)
        canUpdateImage = canUpdateImageDecoded
    }
}

extension CreateUsageReportSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension CreateUsageReportSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUsageReportSubscriptionInput: Swift.Equatable {

}

struct CreateUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension CreateUsageReportSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CreateUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUsageReportSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUsageReportSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUsageReportSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUsageReportSubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3BucketName = output.s3BucketName
            self.schedule = output.schedule
        } else {
            self.s3BucketName = nil
            self.schedule = nil
        }
    }
}

public struct CreateUsageReportSubscriptionOutputResponse: Swift.Equatable {
    /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
    public var s3BucketName: Swift.String?
    /// The schedule for generating usage reports.
    public var schedule: AppStreamClientTypes.UsageReportSchedule?

    public init (
        s3BucketName: Swift.String? = nil,
        schedule: AppStreamClientTypes.UsageReportSchedule? = nil
    )
    {
        self.s3BucketName = s3BucketName
        self.schedule = schedule
    }
}

struct CreateUsageReportSubscriptionOutputResponseBody: Swift.Equatable {
    let s3BucketName: Swift.String?
    let schedule: AppStreamClientTypes.UsageReportSchedule?
}

extension CreateUsageReportSubscriptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let messageAction = messageAction {
            try encodeContainer.encode(messageAction.rawValue, forKey: .messageAction)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The first name, or given name, of the user.
    public var firstName: Swift.String?
    /// The last name, or surname, of the user.
    public var lastName: Swift.String?
    /// The action to take for the welcome email that is sent to a user after the user is created in the user pool. If you specify SUPPRESS, no email is sent. If you specify RESEND, do not specify the first name or last name of the user. If the value is null, the email is sent. The temporary password in the welcome email is valid for only 7 days. If users don’t set their passwords within 7 days, you must send them a new welcome email.
    public var messageAction: AppStreamClientTypes.MessageAction?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        messageAction: AppStreamClientTypes.MessageAction? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.firstName = firstName
        self.lastName = lastName
        self.messageAction = messageAction
        self.userName = userName
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let messageAction: AppStreamClientTypes.MessageAction?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case firstName = "FirstName"
        case lastName = "LastName"
        case messageAction = "MessageAction"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let messageActionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.MessageAction.self, forKey: .messageAction)
        messageAction = messageActionDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {

}

extension DeleteAppBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteAppBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppBlockInput: Swift.Equatable {
    /// The name of the app block.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteAppBlockInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteAppBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAppBlockOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppBlockOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppBlockOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppBlockOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAppBlockOutputResponse: Swift.Equatable {

}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// The name of the application.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

}

extension DeleteDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
    }
}

extension DeleteDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDirectoryConfigInput: Swift.Equatable {
    /// The name of the directory configuration.
    /// This member is required.
    public var directoryName: Swift.String?

    public init (
        directoryName: Swift.String? = nil
    )
    {
        self.directoryName = directoryName
    }
}

struct DeleteDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
}

extension DeleteDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
    }
}

extension DeleteDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDirectoryConfigOutputResponse: Swift.Equatable {

}

extension DeleteFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFleetOutputResponse: Swift.Equatable {

}

extension DeleteImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct DeleteImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct DeleteImageBuilderOutputResponseBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension DeleteImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension DeleteImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImageInput: Swift.Equatable {
    /// The name of the image.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteImageInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct DeleteImageOutputResponse: Swift.Equatable {
    /// Information about the image.
    public var image: AppStreamClientTypes.Image?

    public init (
        image: AppStreamClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct DeleteImageOutputResponseBody: Swift.Equatable {
    let image: AppStreamClientTypes.Image?
}

extension DeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image = "Image"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

extension DeleteImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension DeleteImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteImagePermissionsInput: Swift.Equatable {
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which to delete image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct DeleteImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let sharedAccountId: Swift.String?
}

extension DeleteImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
    }
}

extension DeleteImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteImagePermissionsOutputResponse: Swift.Equatable {

}

extension DeleteStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension DeleteStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteStackInput: Swift.Equatable {
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteStackInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension DeleteStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStackOutputResponse: Swift.Equatable {

}

extension DeleteUsageReportSubscriptionInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteUsageReportSubscriptionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUsageReportSubscriptionInput: Swift.Equatable {

}

struct DeleteUsageReportSubscriptionInputBody: Swift.Equatable {
}

extension DeleteUsageReportSubscriptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteUsageReportSubscriptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUsageReportSubscriptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUsageReportSubscriptionOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUsageReportSubscriptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUsageReportSubscriptionOutputResponse: Swift.Equatable {

}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension DescribeAppBlocksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arnlist0 in arns {
                try arnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAppBlocksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAppBlocksInput: Swift.Equatable {
    /// The ARNs of the app blocks.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAppBlocksInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAppBlocksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAppBlocksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAppBlocksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAppBlocksOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAppBlocksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAppBlocksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.appBlocks = output.appBlocks
            self.nextToken = output.nextToken
        } else {
            self.appBlocks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAppBlocksOutputResponse: Swift.Equatable {
    /// The app blocks in the list.
    public var appBlocks: [AppStreamClientTypes.AppBlock]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        appBlocks: [AppStreamClientTypes.AppBlock]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appBlocks = appBlocks
        self.nextToken = nextToken
    }
}

struct DescribeAppBlocksOutputResponseBody: Swift.Equatable {
    let appBlocks: [AppStreamClientTypes.AppBlock]?
    let nextToken: Swift.String?
}

extension DescribeAppBlocksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlocks = "AppBlocks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appBlocksContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AppBlock?].self, forKey: .appBlocks)
        var appBlocksDecoded0:[AppStreamClientTypes.AppBlock]? = nil
        if let appBlocksContainer = appBlocksContainer {
            appBlocksDecoded0 = [AppStreamClientTypes.AppBlock]()
            for structure0 in appBlocksContainer {
                if let structure0 = structure0 {
                    appBlocksDecoded0?.append(structure0)
                }
            }
        }
        appBlocks = appBlocksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeApplicationFleetAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeApplicationFleetAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationFleetAssociationsInput: Swift.Equatable {
    /// The ARN of the application.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    public var fleetName: Swift.String?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeApplicationFleetAssociationsInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeApplicationFleetAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeApplicationFleetAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationFleetAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationFleetAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationFleetAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicationFleetAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationFleetAssociations = output.applicationFleetAssociations
            self.nextToken = output.nextToken
        } else {
            self.applicationFleetAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationFleetAssociationsOutputResponse: Swift.Equatable {
    /// The application fleet associations in the list.
    public var applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationFleetAssociations = applicationFleetAssociations
        self.nextToken = nextToken
    }
}

struct DescribeApplicationFleetAssociationsOutputResponseBody: Swift.Equatable {
    let applicationFleetAssociations: [AppStreamClientTypes.ApplicationFleetAssociation]?
    let nextToken: Swift.String?
}

extension DescribeApplicationFleetAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationFleetAssociations = "ApplicationFleetAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationFleetAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ApplicationFleetAssociation?].self, forKey: .applicationFleetAssociations)
        var applicationFleetAssociationsDecoded0:[AppStreamClientTypes.ApplicationFleetAssociation]? = nil
        if let applicationFleetAssociationsContainer = applicationFleetAssociationsContainer {
            applicationFleetAssociationsDecoded0 = [AppStreamClientTypes.ApplicationFleetAssociation]()
            for structure0 in applicationFleetAssociationsContainer {
                if let structure0 = structure0 {
                    applicationFleetAssociationsDecoded0?.append(structure0)
                }
            }
        }
        applicationFleetAssociations = applicationFleetAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arnlist0 in arns {
                try arnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationsInput: Swift.Equatable {
    /// The ARNs for the applications.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeApplicationsInputBody: Swift.Equatable {
    let arns: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationsOutputError: Swift.Error, Swift.Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeApplicationsOutputResponse: Swift.Equatable {
    /// The applications in the list.
    public var applications: [AppStreamClientTypes.Application]?
    /// The pagination token used to retrieve the next page of results for this operation.
    public var nextToken: Swift.String?

    public init (
        applications: [AppStreamClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct DescribeApplicationsOutputResponseBody: Swift.Equatable {
    let applications: [AppStreamClientTypes.Application]?
    let nextToken: Swift.String?
}

extension DescribeApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[AppStreamClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppStreamClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectoryConfigsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryNames = directoryNames {
            var directoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .directoryNames)
            for directorynamelist0 in directoryNames {
                try directoryNamesContainer.encode(directorynamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeDirectoryConfigsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeDirectoryConfigsInput: Swift.Equatable {
    /// The directory names.
    public var directoryNames: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        directoryNames: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryNames = directoryNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsInputBody: Swift.Equatable {
    let directoryNames: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryNames = "DirectoryNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .directoryNames)
        var directoryNamesDecoded0:[Swift.String]? = nil
        if let directoryNamesContainer = directoryNamesContainer {
            directoryNamesDecoded0 = [Swift.String]()
            for string0 in directoryNamesContainer {
                if let string0 = string0 {
                    directoryNamesDecoded0?.append(string0)
                }
            }
        }
        directoryNames = directoryNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDirectoryConfigsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDirectoryConfigsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDirectoryConfigsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDirectoryConfigsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDirectoryConfigsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfigs = output.directoryConfigs
            self.nextToken = output.nextToken
        } else {
            self.directoryConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeDirectoryConfigsOutputResponse: Swift.Equatable {
    /// Information about the directory configurations. Note that although the response syntax in this topic includes the account password, this password is not returned in the actual response.
    public var directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        directoryConfigs: [AppStreamClientTypes.DirectoryConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.directoryConfigs = directoryConfigs
        self.nextToken = nextToken
    }
}

struct DescribeDirectoryConfigsOutputResponseBody: Swift.Equatable {
    let directoryConfigs: [AppStreamClientTypes.DirectoryConfig]?
    let nextToken: Swift.String?
}

extension DescribeDirectoryConfigsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfigs = "DirectoryConfigs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.DirectoryConfig?].self, forKey: .directoryConfigs)
        var directoryConfigsDecoded0:[AppStreamClientTypes.DirectoryConfig]? = nil
        if let directoryConfigsContainer = directoryConfigsContainer {
            directoryConfigsDecoded0 = [AppStreamClientTypes.DirectoryConfig]()
            for structure0 in directoryConfigsContainer {
                if let structure0 = structure0 {
                    directoryConfigsDecoded0?.append(structure0)
                }
            }
        }
        directoryConfigs = directoryConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeFleetsInput: Swift.Equatable {
    /// The names of the fleets to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeFleetsInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFleetsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleets = output.fleets
            self.nextToken = output.nextToken
        } else {
            self.fleets = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeFleetsOutputResponse: Swift.Equatable {
    /// Information about the fleets.
    public var fleets: [AppStreamClientTypes.Fleet]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        fleets: [AppStreamClientTypes.Fleet]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleets = fleets
        self.nextToken = nextToken
    }
}

struct DescribeFleetsOutputResponseBody: Swift.Equatable {
    let fleets: [AppStreamClientTypes.Fleet]?
    let nextToken: Swift.String?
}

extension DescribeFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleets = "Fleets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Fleet?].self, forKey: .fleets)
        var fleetsDecoded0:[AppStreamClientTypes.Fleet]? = nil
        if let fleetsContainer = fleetsContainer {
            fleetsDecoded0 = [AppStreamClientTypes.Fleet]()
            for structure0 in fleetsContainer {
                if let structure0 = structure0 {
                    fleetsDecoded0?.append(structure0)
                }
            }
        }
        fleets = fleetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImageBuildersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeImageBuildersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageBuildersInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the image builders to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeImageBuildersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImageBuildersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageBuildersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImageBuildersOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageBuildersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImageBuildersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilders = output.imageBuilders
            self.nextToken = output.nextToken
        } else {
            self.imageBuilders = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImageBuildersOutputResponse: Swift.Equatable {
    /// Information about the image builders.
    public var imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        imageBuilders: [AppStreamClientTypes.ImageBuilder]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuilders = imageBuilders
        self.nextToken = nextToken
    }
}

struct DescribeImageBuildersOutputResponseBody: Swift.Equatable {
    let imageBuilders: [AppStreamClientTypes.ImageBuilder]?
    let nextToken: Swift.String?
}

extension DescribeImageBuildersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilders = "ImageBuilders"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ImageBuilder?].self, forKey: .imageBuilders)
        var imageBuildersDecoded0:[AppStreamClientTypes.ImageBuilder]? = nil
        if let imageBuildersContainer = imageBuildersContainer {
            imageBuildersDecoded0 = [AppStreamClientTypes.ImageBuilder]()
            for structure0 in imageBuildersContainer {
                if let structure0 = structure0 {
                    imageBuildersDecoded0?.append(structure0)
                }
            }
        }
        imageBuilders = imageBuildersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sharedAwsAccountIds = sharedAwsAccountIds {
            var sharedAwsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedAwsAccountIds)
            for awsaccountidlist0 in sharedAwsAccountIds {
                try sharedAwsAccountIdsContainer.encode(awsaccountidlist0)
            }
        }
    }
}

extension DescribeImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagePermissionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The name of the private image for which to describe permissions. The image must be one that you own.
    /// This member is required.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The 12-digit identifier of one or more AWS accounts with which the image is shared.
    public var sharedAwsAccountIds: [Swift.String]?

    public init (
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedAwsAccountIds: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.sharedAwsAccountIds = sharedAwsAccountIds
    }
}

struct DescribeImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let maxResults: Swift.Int?
    let sharedAwsAccountIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case name = "Name"
        case nextToken = "NextToken"
        case sharedAwsAccountIds = "SharedAwsAccountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sharedAwsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sharedAwsAccountIds)
        var sharedAwsAccountIdsDecoded0:[Swift.String]? = nil
        if let sharedAwsAccountIdsContainer = sharedAwsAccountIdsContainer {
            sharedAwsAccountIdsDecoded0 = [Swift.String]()
            for string0 in sharedAwsAccountIdsContainer {
                if let string0 = string0 {
                    sharedAwsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        sharedAwsAccountIds = sharedAwsAccountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagePermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.nextToken = output.nextToken
            self.sharedImagePermissionsList = output.sharedImagePermissionsList
        } else {
            self.name = nil
            self.nextToken = nil
            self.sharedImagePermissionsList = nil
        }
    }
}

public struct DescribeImagePermissionsOutputResponse: Swift.Equatable {
    /// The name of the private image.
    public var name: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The permissions for a private image that you own.
    public var sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?

    public init (
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]? = nil
    )
    {
        self.name = name
        self.nextToken = nextToken
        self.sharedImagePermissionsList = sharedImagePermissionsList
    }
}

struct DescribeImagePermissionsOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let sharedImagePermissionsList: [AppStreamClientTypes.SharedImagePermissions]?
    let nextToken: Swift.String?
}

extension DescribeImagePermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case nextToken = "NextToken"
        case sharedImagePermissionsList = "SharedImagePermissionsList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedImagePermissionsListContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.SharedImagePermissions?].self, forKey: .sharedImagePermissionsList)
        var sharedImagePermissionsListDecoded0:[AppStreamClientTypes.SharedImagePermissions]? = nil
        if let sharedImagePermissionsListContainer = sharedImagePermissionsListContainer {
            sharedImagePermissionsListDecoded0 = [AppStreamClientTypes.SharedImagePermissions]()
            for structure0 in sharedImagePermissionsListContainer {
                if let structure0 = structure0 {
                    sharedImagePermissionsListDecoded0?.append(structure0)
                }
            }
        }
        sharedImagePermissionsList = sharedImagePermissionsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for arnlist0 in arns {
                try arnsContainer.encode(arnlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension DescribeImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The ARNs of the public, private, and shared images to describe.
    public var arns: [Swift.String]?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The names of the public or private images to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The type of image (public, private, or shared) to describe.
    public var type: AppStreamClientTypes.VisibilityType?

    public init (
        arns: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        type: AppStreamClientTypes.VisibilityType? = nil
    )
    {
        self.arns = arns
        self.maxResults = maxResults
        self.names = names
        self.nextToken = nextToken
        self.type = type
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let arns: [Swift.String]?
    let type: AppStreamClientTypes.VisibilityType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns = "Arns"
        case maxResults = "MaxResults"
        case names = "Names"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .type)
        type = typeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeImagesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.images = output.images
            self.nextToken = output.nextToken
        } else {
            self.images = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutputResponse: Swift.Equatable {
    /// Information about the images.
    public var images: [AppStreamClientTypes.Image]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        images: [AppStreamClientTypes.Image]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.images = images
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputResponseBody: Swift.Equatable {
    let images: [AppStreamClientTypes.Image]?
    let nextToken: Swift.String?
}

extension DescribeImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case images = "Images"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Image?].self, forKey: .images)
        var imagesDecoded0:[AppStreamClientTypes.Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [AppStreamClientTypes.Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension DescribeSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeSessionsInput: Swift.Equatable {
    /// The authentication method. Specify API for a user authenticated using a streaming URL or SAML for a SAML federated user. The default is to authenticate users using a streaming URL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The name of the fleet. This value is case-sensitive.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The size of each page of results. The default value is 20 and the maximum value is 50.
    public var limit: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack. This value is case-sensitive.
    /// This member is required.
    public var stackName: Swift.String?
    /// The user identifier (ID). If you specify a user ID, you must also specify the authentication type.
    public var userId: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        fleetName: Swift.String? = nil,
        limit: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.fleetName = fleetName
        self.limit = limit
        self.nextToken = nextToken
        self.stackName = stackName
        self.userId = userId
    }
}

struct DescribeSessionsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let fleetName: Swift.String?
    let userId: Swift.String?
    let nextToken: Swift.String?
    let limit: Swift.Int?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DescribeSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case fleetName = "FleetName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .limit)
        limit = limitDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DescribeSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSessionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.sessions = output.sessions
        } else {
            self.nextToken = nil
            self.sessions = nil
        }
    }
}

public struct DescribeSessionsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the streaming sessions.
    public var sessions: [AppStreamClientTypes.Session]?

    public init (
        nextToken: Swift.String? = nil,
        sessions: [AppStreamClientTypes.Session]? = nil
    )
    {
        self.nextToken = nextToken
        self.sessions = sessions
    }
}

struct DescribeSessionsOutputResponseBody: Swift.Equatable {
    let sessions: [AppStreamClientTypes.Session]?
    let nextToken: Swift.String?
}

extension DescribeSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case sessions = "Sessions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Session?].self, forKey: .sessions)
        var sessionsDecoded0:[AppStreamClientTypes.Session]? = nil
        if let sessionsContainer = sessionsContainer {
            sessionsDecoded0 = [AppStreamClientTypes.Session]()
            for structure0 in sessionsContainer {
                if let structure0 = structure0 {
                    sessionsDecoded0?.append(structure0)
                }
            }
        }
        sessions = sessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for stringlist0 in names {
                try namesContainer.encode(stringlist0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeStacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeStacksInput: Swift.Equatable {
    /// The names of the stacks to describe.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct DescribeStacksInputBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension DescribeStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeStacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStacksOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.stacks = output.stacks
        } else {
            self.nextToken = nil
            self.stacks = nil
        }
    }
}

public struct DescribeStacksOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the stacks.
    public var stacks: [AppStreamClientTypes.Stack]?

    public init (
        nextToken: Swift.String? = nil,
        stacks: [AppStreamClientTypes.Stack]? = nil
    )
    {
        self.nextToken = nextToken
        self.stacks = stacks
    }
}

struct DescribeStacksOutputResponseBody: Swift.Equatable {
    let stacks: [AppStreamClientTypes.Stack]?
    let nextToken: Swift.String?
}

extension DescribeStacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stacks = "Stacks"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stacksContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Stack?].self, forKey: .stacks)
        var stacksDecoded0:[AppStreamClientTypes.Stack]? = nil
        if let stacksContainer = stacksContainer {
            stacksDecoded0 = [AppStreamClientTypes.Stack]()
            for structure0 in stacksContainer {
                if let structure0 = structure0 {
                    stacksDecoded0?.append(structure0)
                }
            }
        }
        stacks = stacksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsageReportSubscriptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeUsageReportSubscriptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUsageReportSubscriptionsInput: Swift.Equatable {
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsageReportSubscriptionsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsageReportSubscriptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsageReportSubscriptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsageReportSubscriptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsageReportSubscriptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsageReportSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageReportSubscriptions = output.usageReportSubscriptions
        } else {
            self.nextToken = nil
            self.usageReportSubscriptions = nil
        }
    }
}

public struct DescribeUsageReportSubscriptionsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about the usage report subscription.
    public var usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?

    public init (
        nextToken: Swift.String? = nil,
        usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.usageReportSubscriptions = usageReportSubscriptions
    }
}

struct DescribeUsageReportSubscriptionsOutputResponseBody: Swift.Equatable {
    let usageReportSubscriptions: [AppStreamClientTypes.UsageReportSubscription]?
    let nextToken: Swift.String?
}

extension DescribeUsageReportSubscriptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case usageReportSubscriptions = "UsageReportSubscriptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageReportSubscriptionsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UsageReportSubscription?].self, forKey: .usageReportSubscriptions)
        var usageReportSubscriptionsDecoded0:[AppStreamClientTypes.UsageReportSubscription]? = nil
        if let usageReportSubscriptionsContainer = usageReportSubscriptionsContainer {
            usageReportSubscriptionsDecoded0 = [AppStreamClientTypes.UsageReportSubscription]()
            for structure0 in usageReportSubscriptionsContainer {
                if let structure0 = structure0 {
                    usageReportSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        usageReportSubscriptions = usageReportSubscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUserStackAssociationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DescribeUserStackAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUserStackAssociationsInput: Swift.Equatable {
    /// The authentication type for the user who is associated with the stack. You must specify USERPOOL.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack that is associated with the user.
    public var stackName: Swift.String?
    /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stackName = stackName
        self.userName = userName
    }
}

struct DescribeUserStackAssociationsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUserStackAssociationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserStackAssociationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserStackAssociationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserStackAssociationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserStackAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.userStackAssociations = output.userStackAssociations
        } else {
            self.nextToken = nil
            self.userStackAssociations = nil
        }
    }
}

public struct DescribeUserStackAssociationsOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// The UserStackAssociation objects.
    public var userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?

    public init (
        nextToken: Swift.String? = nil,
        userStackAssociations: [AppStreamClientTypes.UserStackAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.userStackAssociations = userStackAssociations
    }
}

struct DescribeUserStackAssociationsOutputResponseBody: Swift.Equatable {
    let userStackAssociations: [AppStreamClientTypes.UserStackAssociation]?
    let nextToken: Swift.String?
}

extension DescribeUserStackAssociationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case userStackAssociations = "UserStackAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserStackAssociation?].self, forKey: .userStackAssociations)
        var userStackAssociationsDecoded0:[AppStreamClientTypes.UserStackAssociation]? = nil
        if let userStackAssociationsContainer = userStackAssociationsContainer {
            userStackAssociationsDecoded0 = [AppStreamClientTypes.UserStackAssociation]()
            for structure0 in userStackAssociationsContainer {
                if let structure0 = structure0 {
                    userStackAssociationsDecoded0?.append(structure0)
                }
            }
        }
        userStackAssociations = userStackAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeUsersInput: Swift.Equatable {
    /// The authentication type for the users in the user pool to describe. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The maximum size of each page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeUsersInputBody: Swift.Equatable {
    let authenticationType: AppStreamClientTypes.AuthenticationType?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUsersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct DescribeUsersOutputResponse: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?
    /// Information about users in the user pool.
    public var users: [AppStreamClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [AppStreamClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct DescribeUsersOutputResponseBody: Swift.Equatable {
    let users: [AppStreamClientTypes.User]?
    let nextToken: Swift.String?
}

extension DescribeUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[AppStreamClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [AppStreamClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AppStreamClientTypes.DirectoryConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DirectoryConfig: Swift.Equatable {
        /// The time the directory configuration was created.
        public var createdTime: ClientRuntime.Date?
        /// The fully qualified name of the directory (for example, corp.example.com).
        /// This member is required.
        public var directoryName: Swift.String?
        /// The distinguished names of the organizational units for computer accounts.
        public var organizationalUnitDistinguishedNames: [Swift.String]?
        /// The credentials for the service account used by the fleet or image builder to connect to the directory.
        public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedNames: [Swift.String]? = nil,
            serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
        )
        {
            self.createdTime = createdTime
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
            self.serviceAccountCredentials = serviceAccountCredentials
        }
    }

}

extension DisableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension DisableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct DisableUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension DisableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension DisableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableUserOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableUserOutputResponse: Swift.Equatable {

}

extension DisassociateApplicationFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
    }
}

extension DisassociateApplicationFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateApplicationFleetInput: Swift.Equatable {
    /// The ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?

    public init (
        applicationArn: Swift.String? = nil,
        fleetName: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.fleetName = fleetName
    }
}

struct DisassociateApplicationFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let applicationArn: Swift.String?
}

extension DisassociateApplicationFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case fleetName = "FleetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension DisassociateApplicationFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApplicationFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateApplicationFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApplicationFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApplicationFleetOutputResponse: Swift.Equatable {

}

extension DisassociateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension DisassociateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.stackName = stackName
    }
}

struct DisassociateFleetInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let stackName: Swift.String?
}

extension DisassociateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DisassociateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFleetOutputResponse: Swift.Equatable {

}

extension AppStreamClientTypes.DomainJoinInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedName = "OrganizationalUnitDistinguishedName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedName = organizationalUnitDistinguishedName {
            try encodeContainer.encode(organizationalUnitDistinguishedName, forKey: .organizationalUnitDistinguishedName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationalUnitDistinguishedName)
        organizationalUnitDistinguishedName = organizationalUnitDistinguishedNameDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the configuration information required to join fleets and image builders to Microsoft Active Directory domains.
    public struct DomainJoinInfo: Swift.Equatable {
        /// The fully qualified name of the directory (for example, corp.example.com).
        public var directoryName: Swift.String?
        /// The distinguished name of the organizational unit for computer accounts.
        public var organizationalUnitDistinguishedName: Swift.String?

        public init (
            directoryName: Swift.String? = nil,
            organizationalUnitDistinguishedName: Swift.String? = nil
        )
        {
            self.directoryName = directoryName
            self.organizationalUnitDistinguishedName = organizationalUnitDistinguishedName
        }
    }

}

extension EnableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }
}

extension EnableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableUserInput: Swift.Equatable {
    /// The authentication type for the user. You must specify USERPOOL.
    /// This member is required.
    public var authenticationType: AppStreamClientTypes.AuthenticationType?
    /// The email address of the user. Users' email addresses are case-sensitive. During login, if they specify an email address that doesn't use the same capitalization as the email address specified when their user pool account was created, a "user does not exist" error message displays.
    /// This member is required.
    public var userName: Swift.String?

    public init (
        authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
        userName: Swift.String? = nil
    )
    {
        self.authenticationType = authenticationType
        self.userName = userName
    }
}

struct EnableUserInputBody: Swift.Equatable {
    let userName: Swift.String?
    let authenticationType: AppStreamClientTypes.AuthenticationType?
}

extension EnableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case userName = "UserName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension EnableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableUserOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableUserOutputResponse: Swift.Equatable {

}

extension ExpireSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sessionId = sessionId {
            try encodeContainer.encode(sessionId, forKey: .sessionId)
        }
    }
}

extension ExpireSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExpireSessionInput: Swift.Equatable {
    /// The identifier of the streaming session.
    /// This member is required.
    public var sessionId: Swift.String?

    public init (
        sessionId: Swift.String? = nil
    )
    {
        self.sessionId = sessionId
    }
}

struct ExpireSessionInputBody: Swift.Equatable {
    let sessionId: Swift.String?
}

extension ExpireSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sessionId = "SessionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension ExpireSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExpireSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExpireSessionOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ExpireSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ExpireSessionOutputResponse: Swift.Equatable {

}

extension AppStreamClientTypes.Fleet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case computeCapacityStatus = "ComputeCapacityStatus"
        case createdTime = "CreatedTime"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case fleetErrors = "FleetErrors"
        case fleetType = "FleetType"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case state = "State"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computeCapacityStatus = computeCapacityStatus {
            try encodeContainer.encode(computeCapacityStatus, forKey: .computeCapacityStatus)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let fleetErrors = fleetErrors {
            var fleetErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fleetErrors)
            for fleeterrors0 in fleetErrors {
                try fleetErrorsContainer.encode(fleeterrors0)
            }
        }
        if let fleetType = fleetType {
            try encodeContainer.encode(fleetType.rawValue, forKey: .fleetType)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstrings0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstrings0)
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let fleetTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetType.self, forKey: .fleetType)
        fleetType = fleetTypeDecoded
        let computeCapacityStatusDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacityStatus.self, forKey: .computeCapacityStatus)
        computeCapacityStatus = computeCapacityStatusDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetState.self, forKey: .state)
        state = stateDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let fleetErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetError?].self, forKey: .fleetErrors)
        var fleetErrorsDecoded0:[AppStreamClientTypes.FleetError]? = nil
        if let fleetErrorsContainer = fleetErrorsContainer {
            fleetErrorsDecoded0 = [AppStreamClientTypes.FleetError]()
            for structure0 in fleetErrorsContainer {
                if let structure0 = structure0 {
                    fleetErrorsDecoded0?.append(structure0)
                }
            }
        }
        fleetErrors = fleetErrorsDecoded0
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet.
    public struct Fleet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) for the fleet.
        /// This member is required.
        public var arn: Swift.String?
        /// The capacity status for the fleet.
        /// This member is required.
        public var computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus?
        /// The time the fleet was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The amount of time that a streaming session remains active after users disconnect. If they try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
        public var disconnectTimeoutInSeconds: Swift.Int?
        /// The fleet name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Indicates whether default internet access is enabled for the fleet.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The fleet errors.
        public var fleetErrors: [AppStreamClientTypes.FleetError]?
        /// The fleet type. ALWAYS_ON Provides users with instant-on access to their apps. You are charged for all running instances in your fleet, even if no users are streaming apps. ON_DEMAND Provide users with access to applications after they connect, which takes one to two minutes. You are charged for instance streaming when users are connected and a small hourly fee for instances that are not streaming apps.
        public var fleetType: AppStreamClientTypes.FleetType?
        /// The ARN of the IAM role that is applied to the fleet. To assume a role, the fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
        public var idleDisconnectTimeoutInSeconds: Swift.Int?
        /// The ARN for the public, private, or shared image.
        public var imageArn: Swift.String?
        /// The name of the image used to create the fleet.
        public var imageName: Swift.String?
        /// The instance type to use when launching fleet instances. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        /// This member is required.
        public var instanceType: Swift.String?
        /// The maximum number of concurrent sessions for the fleet.
        public var maxConcurrentSessions: Swift.Int?
        /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
        public var maxUserDurationInSeconds: Swift.Int?
        /// The name of the fleet.
        /// This member is required.
        public var name: Swift.String?
        /// The platform of the fleet.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The current state for the fleet.
        /// This member is required.
        public var state: AppStreamClientTypes.FleetState?
        /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
        public var streamView: AppStreamClientTypes.StreamView?
        /// The USB device filter strings associated with the fleet.
        public var usbDeviceFilterStrings: [Swift.String]?
        /// The VPC configuration for the fleet.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init (
            arn: Swift.String? = nil,
            computeCapacityStatus: AppStreamClientTypes.ComputeCapacityStatus? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            disconnectTimeoutInSeconds: Swift.Int? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            fleetErrors: [AppStreamClientTypes.FleetError]? = nil,
            fleetType: AppStreamClientTypes.FleetType? = nil,
            iamRoleArn: Swift.String? = nil,
            idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
            imageArn: Swift.String? = nil,
            imageName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            maxConcurrentSessions: Swift.Int? = nil,
            maxUserDurationInSeconds: Swift.Int? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            state: AppStreamClientTypes.FleetState? = nil,
            streamView: AppStreamClientTypes.StreamView? = nil,
            usbDeviceFilterStrings: [Swift.String]? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.arn = arn
            self.computeCapacityStatus = computeCapacityStatus
            self.createdTime = createdTime
            self.description = description
            self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.fleetErrors = fleetErrors
            self.fleetType = fleetType
            self.iamRoleArn = iamRoleArn
            self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
            self.imageArn = imageArn
            self.imageName = imageName
            self.instanceType = instanceType
            self.maxConcurrentSessions = maxConcurrentSessions
            self.maxUserDurationInSeconds = maxUserDurationInSeconds
            self.name = name
            self.platform = platform
            self.state = state
            self.streamView = streamView
            self.usbDeviceFilterStrings = usbDeviceFilterStrings
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    /// The fleet attribute.
    public enum FleetAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinInfo
        case iamRoleArn
        case usbDeviceFilterStrings
        case vpcConfiguration
        case vpcConfigurationSecurityGroupIds
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetAttribute] {
            return [
                .domainJoinInfo,
                .iamRoleArn,
                .usbDeviceFilterStrings,
                .vpcConfiguration,
                .vpcConfigurationSecurityGroupIds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinInfo: return "DOMAIN_JOIN_INFO"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .usbDeviceFilterStrings: return "USB_DEVICE_FILTER_STRINGS"
            case .vpcConfiguration: return "VPC_CONFIGURATION"
            case .vpcConfigurationSecurityGroupIds: return "VPC_CONFIGURATION_SECURITY_GROUP_IDS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetAttribute(rawValue: rawValue) ?? FleetAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.FleetError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a fleet error.
    public struct FleetError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum FleetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case domainJoinErrorAccessDenied
        case domainJoinErrorDsMachineAccountQuotaExceeded
        case domainJoinErrorFileNotFound
        case domainJoinErrorInvalidParameter
        case domainJoinErrorLogonFailure
        case domainJoinErrorMoreData
        case domainJoinErrorNotSupported
        case domainJoinErrorNoSuchDomain
        case domainJoinInternalServiceError
        case domainJoinNerrInvalidWorkgroupName
        case domainJoinNerrPasswordExpired
        case domainJoinNerrWorkstationNotStarted
        case fleetInstanceProvisioningFailure
        case fleetStopped
        case iamServiceRoleIsMissing
        case iamServiceRoleMissingDescribeSecurityGroupsAction
        case iamServiceRoleMissingDescribeSubnetAction
        case iamServiceRoleMissingEniCreateAction
        case iamServiceRoleMissingEniDeleteAction
        case iamServiceRoleMissingEniDescribeAction
        case igwNotAttached
        case imageNotFound
        case internalServiceError
        case invalidSubnetConfiguration
        case machineRoleIsMissing
        case networkInterfaceLimitExceeded
        case securityGroupsNotFound
        case stsDisabledInRegion
        case subnetHasInsufficientIpAddresses
        case subnetNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetErrorCode] {
            return [
                .domainJoinErrorAccessDenied,
                .domainJoinErrorDsMachineAccountQuotaExceeded,
                .domainJoinErrorFileNotFound,
                .domainJoinErrorInvalidParameter,
                .domainJoinErrorLogonFailure,
                .domainJoinErrorMoreData,
                .domainJoinErrorNotSupported,
                .domainJoinErrorNoSuchDomain,
                .domainJoinInternalServiceError,
                .domainJoinNerrInvalidWorkgroupName,
                .domainJoinNerrPasswordExpired,
                .domainJoinNerrWorkstationNotStarted,
                .fleetInstanceProvisioningFailure,
                .fleetStopped,
                .iamServiceRoleIsMissing,
                .iamServiceRoleMissingDescribeSecurityGroupsAction,
                .iamServiceRoleMissingDescribeSubnetAction,
                .iamServiceRoleMissingEniCreateAction,
                .iamServiceRoleMissingEniDeleteAction,
                .iamServiceRoleMissingEniDescribeAction,
                .igwNotAttached,
                .imageNotFound,
                .internalServiceError,
                .invalidSubnetConfiguration,
                .machineRoleIsMissing,
                .networkInterfaceLimitExceeded,
                .securityGroupsNotFound,
                .stsDisabledInRegion,
                .subnetHasInsufficientIpAddresses,
                .subnetNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .domainJoinErrorAccessDenied: return "DOMAIN_JOIN_ERROR_ACCESS_DENIED"
            case .domainJoinErrorDsMachineAccountQuotaExceeded: return "DOMAIN_JOIN_ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED"
            case .domainJoinErrorFileNotFound: return "DOMAIN_JOIN_ERROR_FILE_NOT_FOUND"
            case .domainJoinErrorInvalidParameter: return "DOMAIN_JOIN_ERROR_INVALID_PARAMETER"
            case .domainJoinErrorLogonFailure: return "DOMAIN_JOIN_ERROR_LOGON_FAILURE"
            case .domainJoinErrorMoreData: return "DOMAIN_JOIN_ERROR_MORE_DATA"
            case .domainJoinErrorNotSupported: return "DOMAIN_JOIN_ERROR_NOT_SUPPORTED"
            case .domainJoinErrorNoSuchDomain: return "DOMAIN_JOIN_ERROR_NO_SUCH_DOMAIN"
            case .domainJoinInternalServiceError: return "DOMAIN_JOIN_INTERNAL_SERVICE_ERROR"
            case .domainJoinNerrInvalidWorkgroupName: return "DOMAIN_JOIN_NERR_INVALID_WORKGROUP_NAME"
            case .domainJoinNerrPasswordExpired: return "DOMAIN_JOIN_NERR_PASSWORD_EXPIRED"
            case .domainJoinNerrWorkstationNotStarted: return "DOMAIN_JOIN_NERR_WORKSTATION_NOT_STARTED"
            case .fleetInstanceProvisioningFailure: return "FLEET_INSTANCE_PROVISIONING_FAILURE"
            case .fleetStopped: return "FLEET_STOPPED"
            case .iamServiceRoleIsMissing: return "IAM_SERVICE_ROLE_IS_MISSING"
            case .iamServiceRoleMissingDescribeSecurityGroupsAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SECURITY_GROUPS_ACTION"
            case .iamServiceRoleMissingDescribeSubnetAction: return "IAM_SERVICE_ROLE_MISSING_DESCRIBE_SUBNET_ACTION"
            case .iamServiceRoleMissingEniCreateAction: return "IAM_SERVICE_ROLE_MISSING_ENI_CREATE_ACTION"
            case .iamServiceRoleMissingEniDeleteAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DELETE_ACTION"
            case .iamServiceRoleMissingEniDescribeAction: return "IAM_SERVICE_ROLE_MISSING_ENI_DESCRIBE_ACTION"
            case .igwNotAttached: return "IGW_NOT_ATTACHED"
            case .imageNotFound: return "IMAGE_NOT_FOUND"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .invalidSubnetConfiguration: return "INVALID_SUBNET_CONFIGURATION"
            case .machineRoleIsMissing: return "MACHINE_ROLE_IS_MISSING"
            case .networkInterfaceLimitExceeded: return "NETWORK_INTERFACE_LIMIT_EXCEEDED"
            case .securityGroupsNotFound: return "SECURITY_GROUPS_NOT_FOUND"
            case .stsDisabledInRegion: return "STS_DISABLED_IN_REGION"
            case .subnetHasInsufficientIpAddresses: return "SUBNET_HAS_INSUFFICIENT_IP_ADDRESSES"
            case .subnetNotFound: return "SUBNET_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetErrorCode(rawValue: rawValue) ?? FleetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case running
        case starting
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetState] {
            return [
                .running,
                .starting,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetState(rawValue: rawValue) ?? FleetState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum FleetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alwaysOn
        case elastic
        case onDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [FleetType] {
            return [
                .alwaysOn,
                .elastic,
                .onDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alwaysOn: return "ALWAYS_ON"
            case .elastic: return "ELASTIC"
            case .onDemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FleetType(rawValue: rawValue) ?? FleetType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case baseImageArn = "BaseImageArn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case imageBuilderName = "ImageBuilderName"
        case imageBuilderSupported = "ImageBuilderSupported"
        case imageErrors = "ImageErrors"
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case platform = "Platform"
        case publicBaseImageReleasedDate = "PublicBaseImageReleasedDate"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applications = applications {
            var applicationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applications)
            for applications0 in applications {
                try applicationsContainer.encode(applications0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baseImageArn = baseImageArn {
            try encodeContainer.encode(baseImageArn, forKey: .baseImageArn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let imageBuilderName = imageBuilderName {
            try encodeContainer.encode(imageBuilderName, forKey: .imageBuilderName)
        }
        if imageBuilderSupported != false {
            try encodeContainer.encode(imageBuilderSupported, forKey: .imageBuilderSupported)
        }
        if let imageErrors = imageErrors {
            var imageErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageErrors)
            for resourceerrors0 in imageErrors {
                try imageErrorsContainer.encode(resourceerrors0)
            }
        }
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let publicBaseImageReleasedDate = publicBaseImageReleasedDate {
            try encodeContainer.encode(publicBaseImageReleasedDate.timeIntervalSince1970, forKey: .publicBaseImageReleasedDate)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let visibility = visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let baseImageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .baseImageArn)
        baseImageArn = baseImageArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VisibilityType.self, forKey: .visibility)
        visibility = visibilityDecoded
        let imageBuilderSupportedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .imageBuilderSupported)
        imageBuilderSupported = imageBuilderSupportedDecoded
        let imageBuilderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuilderName)
        imageBuilderName = imageBuilderNameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let applicationsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[AppStreamClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [AppStreamClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let publicBaseImageReleasedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .publicBaseImageReleasedDate)
        publicBaseImageReleasedDate = publicBaseImageReleasedDateDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
        let imageErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageErrors)
        var imageErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageErrorsContainer = imageErrorsContainer {
            imageErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageErrorsContainer {
                if let structure0 = structure0 {
                    imageErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageErrors = imageErrorsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes an image.
    public struct Image: Swift.Equatable {
        /// The applications associated with the image.
        public var applications: [AppStreamClientTypes.Application]?
        /// The version of the AppStream 2.0 agent to use for instances that are launched from this image.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN of the image.
        public var arn: Swift.String?
        /// The ARN of the image from which this image was created.
        public var baseImageArn: Swift.String?
        /// The time the image was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image name to display.
        public var displayName: Swift.String?
        /// The name of the image builder that was used to create the private image. If the image is shared, this value is null.
        public var imageBuilderName: Swift.String?
        /// Indicates whether an image builder can be launched from this image.
        public var imageBuilderSupported: Swift.Bool
        /// Describes the errors that are returned when a new image can't be created.
        public var imageErrors: [AppStreamClientTypes.ResourceError]?
        /// The permissions to provide to the destination AWS account for the specified image.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The name of the image.
        /// This member is required.
        public var name: Swift.String?
        /// The operating system platform of the image.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The release date of the public base image. For private images, this date is the release date of the base image from which the image was created.
        public var publicBaseImageReleasedDate: ClientRuntime.Date?
        /// The image starts in the PENDING state. If image creation succeeds, the state is AVAILABLE. If image creation fails, the state is FAILED.
        public var state: AppStreamClientTypes.ImageState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageStateChangeReason?
        /// Indicates whether the image is public or private.
        public var visibility: AppStreamClientTypes.VisibilityType?

        public init (
            applications: [AppStreamClientTypes.Application]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            baseImageArn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            imageBuilderName: Swift.String? = nil,
            imageBuilderSupported: Swift.Bool = false,
            imageErrors: [AppStreamClientTypes.ResourceError]? = nil,
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            name: Swift.String? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            publicBaseImageReleasedDate: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.ImageState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageStateChangeReason? = nil,
            visibility: AppStreamClientTypes.VisibilityType? = nil
        )
        {
            self.applications = applications
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.baseImageArn = baseImageArn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.imageBuilderName = imageBuilderName
            self.imageBuilderSupported = imageBuilderSupported
            self.imageErrors = imageErrors
            self.imagePermissions = imagePermissions
            self.name = name
            self.platform = platform
            self.publicBaseImageReleasedDate = publicBaseImageReleasedDate
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.visibility = visibility
        }
    }

}

extension AppStreamClientTypes.ImageBuilder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case imageArn = "ImageArn"
        case imageBuilderErrors = "ImageBuilderErrors"
        case instanceType = "InstanceType"
        case name = "Name"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case platform = "Platform"
        case state = "State"
        case stateChangeReason = "StateChangeReason"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageBuilderErrors = imageBuilderErrors {
            var imageBuilderErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageBuilderErrors)
            for resourceerrors0 in imageBuilderErrors {
                try imageBuilderErrorsContainer.encode(resourceerrors0)
            }
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangeReason = stateChangeReason {
            try encodeContainer.encode(stateChangeReason, forKey: .stateChangeReason)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderState.self, forKey: .state)
        state = stateDecoded
        let stateChangeReasonDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReason.self, forKey: .stateChangeReason)
        stateChangeReason = stateChangeReasonDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
        let imageBuilderErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ResourceError?].self, forKey: .imageBuilderErrors)
        var imageBuilderErrorsDecoded0:[AppStreamClientTypes.ResourceError]? = nil
        if let imageBuilderErrorsContainer = imageBuilderErrorsContainer {
            imageBuilderErrorsDecoded0 = [AppStreamClientTypes.ResourceError]()
            for structure0 in imageBuilderErrorsContainer {
                if let structure0 = structure0 {
                    imageBuilderErrorsDecoded0?.append(structure0)
                }
            }
        }
        imageBuilderErrors = imageBuilderErrorsDecoded0
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a virtual machine that is used to create an image.
    public struct ImageBuilder: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Administrators can connect to the image builder only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The version of the AppStream 2.0 agent that is currently being used by the image builder.
        public var appstreamAgentVersion: Swift.String?
        /// The ARN for the image builder.
        public var arn: Swift.String?
        /// The time stamp when the image builder was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The image builder name to display.
        public var displayName: Swift.String?
        /// The name of the directory and organizational unit (OU) to use to join the image builder to a Microsoft Active Directory domain.
        public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
        /// Enables or disables default internet access for the image builder.
        public var enableDefaultInternetAccess: Swift.Bool?
        /// The ARN of the IAM role that is applied to the image builder. To assume a role, the image builder calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
        public var iamRoleArn: Swift.String?
        /// The ARN of the image from which this builder was created.
        public var imageArn: Swift.String?
        /// The image builder errors.
        public var imageBuilderErrors: [AppStreamClientTypes.ResourceError]?
        /// The instance type for the image builder. The following instance types are available:
        ///
        /// * stream.standard.small
        ///
        /// * stream.standard.medium
        ///
        /// * stream.standard.large
        ///
        /// * stream.compute.large
        ///
        /// * stream.compute.xlarge
        ///
        /// * stream.compute.2xlarge
        ///
        /// * stream.compute.4xlarge
        ///
        /// * stream.compute.8xlarge
        ///
        /// * stream.memory.large
        ///
        /// * stream.memory.xlarge
        ///
        /// * stream.memory.2xlarge
        ///
        /// * stream.memory.4xlarge
        ///
        /// * stream.memory.8xlarge
        ///
        /// * stream.memory.z1d.large
        ///
        /// * stream.memory.z1d.xlarge
        ///
        /// * stream.memory.z1d.2xlarge
        ///
        /// * stream.memory.z1d.3xlarge
        ///
        /// * stream.memory.z1d.6xlarge
        ///
        /// * stream.memory.z1d.12xlarge
        ///
        /// * stream.graphics-design.large
        ///
        /// * stream.graphics-design.xlarge
        ///
        /// * stream.graphics-design.2xlarge
        ///
        /// * stream.graphics-design.4xlarge
        ///
        /// * stream.graphics-desktop.2xlarge
        ///
        /// * stream.graphics.g4dn.xlarge
        ///
        /// * stream.graphics.g4dn.2xlarge
        ///
        /// * stream.graphics.g4dn.4xlarge
        ///
        /// * stream.graphics.g4dn.8xlarge
        ///
        /// * stream.graphics.g4dn.12xlarge
        ///
        /// * stream.graphics.g4dn.16xlarge
        ///
        /// * stream.graphics-pro.4xlarge
        ///
        /// * stream.graphics-pro.8xlarge
        ///
        /// * stream.graphics-pro.16xlarge
        public var instanceType: Swift.String?
        /// The name of the image builder.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the network details of the fleet or image builder instance.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The operating system platform of the image builder.
        public var platform: AppStreamClientTypes.PlatformType?
        /// The state of the image builder.
        public var state: AppStreamClientTypes.ImageBuilderState?
        /// The reason why the last state change occurred.
        public var stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason?
        /// The VPC configuration of the image builder.
        public var vpcConfig: AppStreamClientTypes.VpcConfig?

        public init (
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            appstreamAgentVersion: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
            enableDefaultInternetAccess: Swift.Bool? = nil,
            iamRoleArn: Swift.String? = nil,
            imageArn: Swift.String? = nil,
            imageBuilderErrors: [AppStreamClientTypes.ResourceError]? = nil,
            instanceType: Swift.String? = nil,
            name: Swift.String? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            platform: AppStreamClientTypes.PlatformType? = nil,
            state: AppStreamClientTypes.ImageBuilderState? = nil,
            stateChangeReason: AppStreamClientTypes.ImageBuilderStateChangeReason? = nil,
            vpcConfig: AppStreamClientTypes.VpcConfig? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.appstreamAgentVersion = appstreamAgentVersion
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.domainJoinInfo = domainJoinInfo
            self.enableDefaultInternetAccess = enableDefaultInternetAccess
            self.iamRoleArn = iamRoleArn
            self.imageArn = imageArn
            self.imageBuilderErrors = imageBuilderErrors
            self.instanceType = instanceType
            self.name = name
            self.networkAccessConfiguration = networkAccessConfiguration
            self.platform = platform
            self.state = state
            self.stateChangeReason = stateChangeReason
            self.vpcConfig = vpcConfig
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case pending
        case pendingQualification
        case rebooting
        case running
        case snapshotting
        case stopped
        case stopping
        case updating
        case updatingAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderState] {
            return [
                .deleting,
                .failed,
                .pending,
                .pendingQualification,
                .rebooting,
                .running,
                .snapshotting,
                .stopped,
                .stopping,
                .updating,
                .updatingAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .pendingQualification: return "PENDING_QUALIFICATION"
            case .rebooting: return "REBOOTING"
            case .running: return "RUNNING"
            case .snapshotting: return "SNAPSHOTTING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .updating: return "UPDATING"
            case .updatingAgent: return "UPDATING_AGENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderState(rawValue: rawValue) ?? ImageBuilderState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageBuilderStateChangeReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilderStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image builder state change occurred.
    public struct ImageBuilderStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init (
            code: AppStreamClientTypes.ImageBuilderStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageBuilderStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageUnavailable
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageBuilderStateChangeReasonCode] {
            return [
                .imageUnavailable,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageUnavailable: return "IMAGE_UNAVAILABLE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageBuilderStateChangeReasonCode(rawValue: rawValue) ?? ImageBuilderStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImagePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowFleet
        case allowImageBuilder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowFleet = allowFleet {
            try encodeContainer.encode(allowFleet, forKey: .allowFleet)
        }
        if let allowImageBuilder = allowImageBuilder {
            try encodeContainer.encode(allowImageBuilder, forKey: .allowImageBuilder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowFleetDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowFleet)
        allowFleet = allowFleetDecoded
        let allowImageBuilderDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowImageBuilder)
        allowImageBuilder = allowImageBuilderDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions for an image.
    public struct ImagePermissions: Swift.Equatable {
        /// Indicates whether the image can be used for a fleet.
        public var allowFleet: Swift.Bool?
        /// Indicates whether the image can be used for an image builder.
        public var allowImageBuilder: Swift.Bool?

        public init (
            allowFleet: Swift.Bool? = nil,
            allowImageBuilder: Swift.Bool? = nil
        )
        {
            self.allowFleet = allowFleet
            self.allowImageBuilder = allowImageBuilder
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case copying
        case creating
        case deleting
        case failed
        case importing
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageState] {
            return [
                .available,
                .copying,
                .creating,
                .deleting,
                .failed,
                .importing,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .copying: return "COPYING"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .importing: return "IMPORTING"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageState(rawValue: rawValue) ?? ImageState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.ImageStateChangeReason: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageStateChangeReasonCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the reason why the last image state change occurred.
    public struct ImageStateChangeReason: Swift.Equatable {
        /// The state change reason code.
        public var code: AppStreamClientTypes.ImageStateChangeReasonCode?
        /// The state change reason message.
        public var message: Swift.String?

        public init (
            code: AppStreamClientTypes.ImageStateChangeReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension AppStreamClientTypes {
    public enum ImageStateChangeReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imageBuilderNotAvailable
        case imageCopyFailure
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStateChangeReasonCode] {
            return [
                .imageBuilderNotAvailable,
                .imageCopyFailure,
                .internalError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imageBuilderNotAvailable: return "IMAGE_BUILDER_NOT_AVAILABLE"
            case .imageCopyFailure: return "IMAGE_COPY_FAILURE"
            case .internalError: return "INTERNAL_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStateChangeReasonCode(rawValue: rawValue) ?? ImageStateChangeReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension IncompatibleImageException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IncompatibleImageExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The image can't be updated because it's not compatible for updates.
public struct IncompatibleImageException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IncompatibleImageExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IncompatibleImageExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAccountStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAccountStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be created because your AWS account is suspended. For assistance, contact AWS Support.
public struct InvalidAccountStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAccountStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidAccountStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Indicates an incorrect combination of parameters, or a missing parameter.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRoleException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRoleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified role is invalid.
public struct InvalidRoleException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRoleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRoleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.LastReportGenerationExecutionError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportExecutionErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a usage report can't be generated.
    public struct LastReportGenerationExecutionError: Swift.Equatable {
        /// The error code for the error that is returned when a usage report can't be generated.
        public var errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode?
        /// The error message for the error that is returned when a usage report can't be generated.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.UsageReportExecutionErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested limit exceeds the permitted limit for an account.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAssociatedFleetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }
}

extension ListAssociatedFleetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedFleetsInput: Swift.Equatable {
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var stackName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        stackName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.stackName = stackName
    }
}

struct ListAssociatedFleetsInputBody: Swift.Equatable {
    let stackName: Swift.String?
    let nextToken: Swift.String?
}

extension ListAssociatedFleetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case stackName = "StackName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedFleetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedFleetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedFleetsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedFleetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedFleetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedFleetsOutputResponse: Swift.Equatable {
    /// The name of the fleet.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedFleetsOutputResponseBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedFleetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedStacksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAssociatedStacksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAssociatedStacksInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var fleetName: Swift.String?
    /// The pagination token to use to retrieve the next page of results for this operation. If this value is null, it retrieves the first page.
    public var nextToken: Swift.String?

    public init (
        fleetName: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.fleetName = fleetName
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksInputBody: Swift.Equatable {
    let fleetName: Swift.String?
    let nextToken: Swift.String?
}

extension ListAssociatedStacksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleetName = "FleetName"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedStacksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedStacksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedStacksOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedStacksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedStacksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.names = output.names
            self.nextToken = output.nextToken
        } else {
            self.names = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedStacksOutputResponse: Swift.Equatable {
    /// The name of the stack.
    public var names: [Swift.String]?
    /// The pagination token to use to retrieve the next page of results for this operation. If there are no more pages, this value is null.
    public var nextToken: Swift.String?

    public init (
        names: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.names = names
        self.nextToken = nextToken
    }
}

struct ListAssociatedStacksOutputResponseBody: Swift.Equatable {
    let names: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAssociatedStacksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names = "Names"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AppStreamClientTypes {
    public enum MessageAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resend
        case suppress
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageAction] {
            return [
                .resend,
                .suppress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resend: return "RESEND"
            case .suppress: return "SUPPRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageAction(rawValue: rawValue) ?? MessageAction.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.NetworkAccessConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eniId = "EniId"
        case eniPrivateIpAddress = "EniPrivateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eniId = eniId {
            try encodeContainer.encode(eniId, forKey: .eniId)
        }
        if let eniPrivateIpAddress = eniPrivateIpAddress {
            try encodeContainer.encode(eniPrivateIpAddress, forKey: .eniPrivateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eniPrivateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniPrivateIpAddress)
        eniPrivateIpAddress = eniPrivateIpAddressDecoded
        let eniIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eniId)
        eniId = eniIdDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the network details of the fleet or image builder instance.
    public struct NetworkAccessConfiguration: Swift.Equatable {
        /// The resource identifier of the elastic network interface that is attached to instances in your VPC. All network interfaces have the eni-xxxxxxxx resource identifier.
        public var eniId: Swift.String?
        /// The private IP address of the elastic network interface that is attached to instances in your VPC.
        public var eniPrivateIpAddress: Swift.String?

        public init (
            eniId: Swift.String? = nil,
            eniPrivateIpAddress: Swift.String? = nil
        )
        {
            self.eniId = eniId
            self.eniPrivateIpAddress = eniPrivateIpAddress
        }
    }

}

extension OperationNotPermittedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The attempted operation is not permitted.
public struct OperationNotPermittedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum PlatformType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux2
        case windows
        case windowsServer2016
        case windowsServer2019
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformType] {
            return [
                .amazonLinux2,
                .windows,
                .windowsServer2016,
                .windowsServer2019,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux2: return "AMAZON_LINUX2"
            case .windows: return "WINDOWS"
            case .windowsServer2016: return "WINDOWS_SERVER_2016"
            case .windowsServer2019: return "WINDOWS_SERVER_2019"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PlatformType(rawValue: rawValue) ?? PlatformType.sdkUnknown(rawValue)
        }
    }
}

extension RequestLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// AppStream 2.0 can’t process the request right now because the Describe calls from your AWS account are being throttled by Amazon EC2. Try again later.
public struct RequestLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.ResourceError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case errorTimestamp = "ErrorTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorTimestamp = errorTimestamp {
            try encodeContainer.encode(errorTimestamp.timeIntervalSince1970, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.FleetErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTimestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a resource error.
    public struct ResourceError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.FleetErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?
        /// The time the error occurred.
        public var errorTimestamp: ClientRuntime.Date?

        public init (
            errorCode: AppStreamClientTypes.FleetErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotAvailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource exists and is not in use, but isn't available.
public struct ResourceNotAvailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotAvailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message in the exception.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AppStreamClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the S3 location.
    public struct S3Location: Swift.Equatable {
        /// The S3 bucket of the S3 object.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The S3 key of the S3 object.
        /// This member is required.
        public var s3Key: Swift.String?

        public init (
            s3Bucket: Swift.String? = nil,
            s3Key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3Key = s3Key
        }
    }

}

extension AppStreamClientTypes.ScriptDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executableParameters = "ExecutableParameters"
        case executablePath = "ExecutablePath"
        case scriptS3Location = "ScriptS3Location"
        case timeoutInSeconds = "TimeoutInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executableParameters = executableParameters {
            try encodeContainer.encode(executableParameters, forKey: .executableParameters)
        }
        if let executablePath = executablePath {
            try encodeContainer.encode(executablePath, forKey: .executablePath)
        }
        if let scriptS3Location = scriptS3Location {
            try encodeContainer.encode(scriptS3Location, forKey: .scriptS3Location)
        }
        if let timeoutInSeconds = timeoutInSeconds {
            try encodeContainer.encode(timeoutInSeconds, forKey: .timeoutInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scriptS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .scriptS3Location)
        scriptS3Location = scriptS3LocationDecoded
        let executablePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executablePath)
        executablePath = executablePathDecoded
        let executableParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executableParameters)
        executableParameters = executableParametersDecoded
        let timeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutInSeconds)
        timeoutInSeconds = timeoutInSecondsDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the details of the script.
    public struct ScriptDetails: Swift.Equatable {
        /// The runtime parameters passed to the run path for the script.
        public var executableParameters: Swift.String?
        /// The run path for the script.
        /// This member is required.
        public var executablePath: Swift.String?
        /// The S3 object location for the script.
        /// This member is required.
        public var scriptS3Location: AppStreamClientTypes.S3Location?
        /// The run timeout, in seconds, for the script.
        /// This member is required.
        public var timeoutInSeconds: Swift.Int?

        public init (
            executableParameters: Swift.String? = nil,
            executablePath: Swift.String? = nil,
            scriptS3Location: AppStreamClientTypes.S3Location? = nil,
            timeoutInSeconds: Swift.Int? = nil
        )
        {
            self.executableParameters = executableParameters
            self.executablePath = executablePath
            self.scriptS3Location = scriptS3Location
            self.timeoutInSeconds = timeoutInSeconds
        }
    }

}

extension AppStreamClientTypes.ServiceAccountCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountName = "AccountName"
        case accountPassword = "AccountPassword"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountName = accountName {
            try encodeContainer.encode(accountName, forKey: .accountName)
        }
        if let accountPassword = accountPassword {
            try encodeContainer.encode(accountPassword, forKey: .accountPassword)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountName)
        accountName = accountNameDecoded
        let accountPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountPassword)
        accountPassword = accountPasswordDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the credentials for the service account used by the fleet or image builder to connect to the directory.
    public struct ServiceAccountCredentials: Swift.Equatable {
        /// The user name of the account. This account must have the following privileges: create computer objects, join computers to the domain, and change/reset the password on descendant computer objects for the organizational units specified.
        /// This member is required.
        public var accountName: Swift.String?
        /// The password for the account.
        /// This member is required.
        public var accountPassword: Swift.String?

        public init (
            accountName: Swift.String? = nil,
            accountPassword: Swift.String? = nil
        )
        {
            self.accountName = accountName
            self.accountPassword = accountPassword
        }
    }

}

extension AppStreamClientTypes.Session: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case connectionState = "ConnectionState"
        case fleetName = "FleetName"
        case id = "Id"
        case maxExpirationTime = "MaxExpirationTime"
        case networkAccessConfiguration = "NetworkAccessConfiguration"
        case stackName = "StackName"
        case startTime = "StartTime"
        case state = "State"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let fleetName = fleetName {
            try encodeContainer.encode(fleetName, forKey: .fleetName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maxExpirationTime = maxExpirationTime {
            try encodeContainer.encode(maxExpirationTime.timeIntervalSince1970, forKey: .maxExpirationTime)
        }
        if let networkAccessConfiguration = networkAccessConfiguration {
            try encodeContainer.encode(networkAccessConfiguration, forKey: .networkAccessConfiguration)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let fleetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fleetName)
        fleetName = fleetNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionState.self, forKey: .state)
        state = stateDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.SessionConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let maxExpirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .maxExpirationTime)
        maxExpirationTime = maxExpirationTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let networkAccessConfigurationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.NetworkAccessConfiguration.self, forKey: .networkAccessConfiguration)
        networkAccessConfiguration = networkAccessConfigurationDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a streaming session.
    public struct Session: Swift.Equatable {
        /// The authentication method. The user is authenticated using a streaming URL (API) or SAML 2.0 federation (SAML).
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a user is connected to the streaming session.
        public var connectionState: AppStreamClientTypes.SessionConnectionState?
        /// The name of the fleet for the streaming session.
        /// This member is required.
        public var fleetName: Swift.String?
        /// The identifier of the streaming session.
        /// This member is required.
        public var id: Swift.String?
        /// The time when the streaming session is set to expire. This time is based on the MaxUserDurationinSeconds value, which determines the maximum length of time that a streaming session can run. A streaming session might end earlier than the time specified in SessionMaxExpirationTime, when the DisconnectTimeOutInSeconds elapses or the user chooses to end his or her session. If the DisconnectTimeOutInSeconds elapses, or the user chooses to end his or her session, the streaming instance is terminated and the streaming session ends.
        public var maxExpirationTime: ClientRuntime.Date?
        /// The network details for the streaming session.
        public var networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration?
        /// The name of the stack for the streaming session.
        /// This member is required.
        public var stackName: Swift.String?
        /// The time when a streaming instance is dedicated for the user.
        public var startTime: ClientRuntime.Date?
        /// The current state of the streaming session.
        /// This member is required.
        public var state: AppStreamClientTypes.SessionState?
        /// The identifier of the user for whom the session was created.
        /// This member is required.
        public var userId: Swift.String?

        public init (
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            connectionState: AppStreamClientTypes.SessionConnectionState? = nil,
            fleetName: Swift.String? = nil,
            id: Swift.String? = nil,
            maxExpirationTime: ClientRuntime.Date? = nil,
            networkAccessConfiguration: AppStreamClientTypes.NetworkAccessConfiguration? = nil,
            stackName: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: AppStreamClientTypes.SessionState? = nil,
            userId: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.connectionState = connectionState
            self.fleetName = fleetName
            self.id = id
            self.maxExpirationTime = maxExpirationTime
            self.networkAccessConfiguration = networkAccessConfiguration
            self.stackName = stackName
            self.startTime = startTime
            self.state = state
            self.userId = userId
        }
    }

}

extension AppStreamClientTypes {
    public enum SessionConnectionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connected
        case notConnected
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionConnectionState] {
            return [
                .connected,
                .notConnected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connected: return "CONNECTED"
            case .notConnected: return "NOT_CONNECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionConnectionState(rawValue: rawValue) ?? SessionConnectionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    /// Possible values for the state of a streaming session.
    public enum SessionState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case expired
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [SessionState] {
            return [
                .active,
                .expired,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SessionState(rawValue: rawValue) ?? SessionState.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.SharedImagePermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions
        case sharedAccountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the permissions that are available to the specified AWS account for a shared image.
    public struct SharedImagePermissions: Swift.Equatable {
        /// Describes the permissions for a shared image.
        /// This member is required.
        public var imagePermissions: AppStreamClientTypes.ImagePermissions?
        /// The 12-digit identifier of the AWS account with which the image is shared.
        /// This member is required.
        public var sharedAccountId: Swift.String?

        public init (
            imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
            sharedAccountId: Swift.String? = nil
        )
        {
            self.imagePermissions = imagePermissions
            self.sharedAccountId = sharedAccountId
        }
    }

}

extension AppStreamClientTypes.Stack: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case stackErrors = "StackErrors"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let stackErrors = stackErrors {
            var stackErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackErrors)
            for stackerrors0 in stackErrors {
                try stackErrorsContainer.encode(stackerrors0)
            }
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let stackErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackError?].self, forKey: .stackErrors)
        var stackErrorsDecoded0:[AppStreamClientTypes.StackError]? = nil
        if let stackErrorsContainer = stackErrorsContainer {
            stackErrorsDecoded0 = [AppStreamClientTypes.StackError]()
            for structure0 in stackErrorsContainer {
                if let structure0 = structure0 {
                    stackErrorsDecoded0?.append(structure0)
                }
            }
        }
        stackErrors = stackErrorsDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettingsResponse.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a stack.
    public struct Stack: Swift.Equatable {
        /// The list of virtual private cloud (VPC) interface endpoint objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
        public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
        /// The persistent application settings for users of the stack.
        public var applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse?
        /// The ARN of the stack.
        public var arn: Swift.String?
        /// The time the stack was created.
        public var createdTime: ClientRuntime.Date?
        /// The description to display.
        public var description: Swift.String?
        /// The stack name to display.
        public var displayName: Swift.String?
        /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
        public var embedHostDomains: [Swift.String]?
        /// The URL that users are redirected to after they click the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
        public var feedbackURL: Swift.String?
        /// The name of the stack.
        /// This member is required.
        public var name: Swift.String?
        /// The URL that users are redirected to after their streaming session ends.
        public var redirectURL: Swift.String?
        /// The errors for the stack.
        public var stackErrors: [AppStreamClientTypes.StackError]?
        /// The storage connectors to enable.
        public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
        /// The actions that are enabled or disabled for users during their streaming sessions. By default these actions are enabled.
        public var userSettings: [AppStreamClientTypes.UserSetting]?

        public init (
            accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
            applicationSettings: AppStreamClientTypes.ApplicationSettingsResponse? = nil,
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            embedHostDomains: [Swift.String]? = nil,
            feedbackURL: Swift.String? = nil,
            name: Swift.String? = nil,
            redirectURL: Swift.String? = nil,
            stackErrors: [AppStreamClientTypes.StackError]? = nil,
            storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
            userSettings: [AppStreamClientTypes.UserSetting]? = nil
        )
        {
            self.accessEndpoints = accessEndpoints
            self.applicationSettings = applicationSettings
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.embedHostDomains = embedHostDomains
            self.feedbackURL = feedbackURL
            self.name = name
            self.redirectURL = redirectURL
            self.stackErrors = stackErrors
            self.storageConnectors = storageConnectors
            self.userSettings = userSettings
        }
    }

}

extension AppStreamClientTypes {
    public enum StackAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessEndpoints
        case embedHostDomains
        case feedbackUrl
        case iamRoleArn
        case redirectUrl
        case storageConnectors
        case storageConnectorGoogleDrive
        case storageConnectorHomefolders
        case storageConnectorOneDrive
        case themeName
        case userSettings
        case sdkUnknown(Swift.String)

        public static var allCases: [StackAttribute] {
            return [
                .accessEndpoints,
                .embedHostDomains,
                .feedbackUrl,
                .iamRoleArn,
                .redirectUrl,
                .storageConnectors,
                .storageConnectorGoogleDrive,
                .storageConnectorHomefolders,
                .storageConnectorOneDrive,
                .themeName,
                .userSettings,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessEndpoints: return "ACCESS_ENDPOINTS"
            case .embedHostDomains: return "EMBED_HOST_DOMAINS"
            case .feedbackUrl: return "FEEDBACK_URL"
            case .iamRoleArn: return "IAM_ROLE_ARN"
            case .redirectUrl: return "REDIRECT_URL"
            case .storageConnectors: return "STORAGE_CONNECTORS"
            case .storageConnectorGoogleDrive: return "STORAGE_CONNECTOR_GOOGLE_DRIVE"
            case .storageConnectorHomefolders: return "STORAGE_CONNECTOR_HOMEFOLDERS"
            case .storageConnectorOneDrive: return "STORAGE_CONNECTOR_ONE_DRIVE"
            case .themeName: return "THEME_NAME"
            case .userSettings: return "USER_SETTINGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackAttribute(rawValue: rawValue) ?? StackAttribute.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.StackError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StackErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a stack error.
    public struct StackError: Swift.Equatable {
        /// The error code.
        public var errorCode: AppStreamClientTypes.StackErrorCode?
        /// The error message.
        public var errorMessage: Swift.String?

        public init (
            errorCode: AppStreamClientTypes.StackErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension AppStreamClientTypes {
    public enum StackErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalServiceError
        case storageConnectorError
        case sdkUnknown(Swift.String)

        public static var allCases: [StackErrorCode] {
            return [
                .internalServiceError,
                .storageConnectorError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .storageConnectorError: return "STORAGE_CONNECTOR_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackErrorCode(rawValue: rawValue) ?? StackErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension StartFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StartFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StartFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartFleetOutputResponse: Swift.Equatable {

}

extension StartImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appstreamAgentVersion = appstreamAgentVersion {
            try encodeContainer.encode(appstreamAgentVersion, forKey: .appstreamAgentVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StartImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImageBuilderInput: Swift.Equatable {
    /// The version of the AppStream 2.0 agent to use for this image builder. To use the latest version of the AppStream 2.0 agent, specify [LATEST].
    public var appstreamAgentVersion: Swift.String?
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        appstreamAgentVersion: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appstreamAgentVersion = appstreamAgentVersion
        self.name = name
    }
}

struct StartImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
    let appstreamAgentVersion: Swift.String?
}

extension StartImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appstreamAgentVersion = "AppstreamAgentVersion"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appstreamAgentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appstreamAgentVersion)
        appstreamAgentVersion = appstreamAgentVersionDecoded
    }
}

extension StartImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StartImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StartImageBuilderOutputResponseBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StartImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension StopFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopFleetInput: Swift.Equatable {
    /// The name of the fleet.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopFleetInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopFleetOutputResponse: Swift.Equatable {

}

extension StopImageBuilderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension StopImageBuilderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopImageBuilderInput: Swift.Equatable {
    /// The name of the image builder.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct StopImageBuilderInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension StopImageBuilderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopImageBuilderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopImageBuilderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopImageBuilderOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopImageBuilderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopImageBuilderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuilder = output.imageBuilder
        } else {
            self.imageBuilder = nil
        }
    }
}

public struct StopImageBuilderOutputResponse: Swift.Equatable {
    /// Information about the image builder.
    public var imageBuilder: AppStreamClientTypes.ImageBuilder?

    public init (
        imageBuilder: AppStreamClientTypes.ImageBuilder? = nil
    )
    {
        self.imageBuilder = imageBuilder
    }
}

struct StopImageBuilderOutputResponseBody: Swift.Equatable {
    let imageBuilder: AppStreamClientTypes.ImageBuilder?
}

extension StopImageBuilderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuilder = "ImageBuilder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuilderDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImageBuilder.self, forKey: .imageBuilder)
        imageBuilder = imageBuilderDecoded
    }
}

extension AppStreamClientTypes.StorageConnector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorType = "ConnectorType"
        case domains = "Domains"
        case resourceIdentifier = "ResourceIdentifier"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorType = connectorType {
            try encodeContainer.encode(connectorType.rawValue, forKey: .connectorType)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domainlist0 in domains {
                try domainsContainer.encode(domainlist0)
            }
        }
        if let resourceIdentifier = resourceIdentifier {
            try encodeContainer.encode(resourceIdentifier, forKey: .resourceIdentifier)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StorageConnectorType.self, forKey: .connectorType)
        connectorType = connectorTypeDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .domains)
        var domainsDecoded0:[Swift.String]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Swift.String]()
            for string0 in domainsContainer {
                if let string0 = string0 {
                    domainsDecoded0?.append(string0)
                }
            }
        }
        domains = domainsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes a connector that enables persistent storage for users.
    public struct StorageConnector: Swift.Equatable {
        /// The type of storage connector.
        /// This member is required.
        public var connectorType: AppStreamClientTypes.StorageConnectorType?
        /// The names of the domains for the account.
        public var domains: [Swift.String]?
        /// The ARN of the storage connector.
        public var resourceIdentifier: Swift.String?

        public init (
            connectorType: AppStreamClientTypes.StorageConnectorType? = nil,
            domains: [Swift.String]? = nil,
            resourceIdentifier: Swift.String? = nil
        )
        {
            self.connectorType = connectorType
            self.domains = domains
            self.resourceIdentifier = resourceIdentifier
        }
    }

}

extension AppStreamClientTypes {
    /// The type of storage connector.
    public enum StorageConnectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case googleDrive
        case homefolders
        case oneDrive
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageConnectorType] {
            return [
                .googleDrive,
                .homefolders,
                .oneDrive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .googleDrive: return "GOOGLE_DRIVE"
            case .homefolders: return "HOMEFOLDERS"
            case .oneDrive: return "ONE_DRIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageConnectorType(rawValue: rawValue) ?? StorageConnectorType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum StreamView: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app
        case desktop
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamView] {
            return [
                .app,
                .desktop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app: return "APP"
            case .desktop: return "DESKTOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamView(rawValue: rawValue) ?? StreamView.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to associate. A tag is a key-value pair, and the value is optional. For example, Environment=Test. If you do not specify a value, Environment=. If you do not specify a value, the value is set to an empty string. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following special characters: _ . : / = + \ - @
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidAccountStatusException(InvalidAccountStatusException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys for the tags to disassociate.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appBlockArn = appBlockArn {
            try encodeContainer.encode(appBlockArn, forKey: .appBlockArn)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for applicationattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(applicationattributes0.rawValue)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let iconS3Location = iconS3Location {
            try encodeContainer.encode(iconS3Location, forKey: .iconS3Location)
        }
        if let launchParameters = launchParameters {
            try encodeContainer.encode(launchParameters, forKey: .launchParameters)
        }
        if let launchPath = launchPath {
            try encodeContainer.encode(launchPath, forKey: .launchPath)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// The ARN of the app block.
    public var appBlockArn: Swift.String?
    /// The attributes to delete for an application.
    public var attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]?
    /// The description of the application.
    public var description: Swift.String?
    /// The display name of the application. This name is visible to users in the application catalog.
    public var displayName: Swift.String?
    /// The icon S3 location of the application.
    public var iconS3Location: AppStreamClientTypes.S3Location?
    /// The launch parameters of the application.
    public var launchParameters: Swift.String?
    /// The launch path of the application.
    public var launchPath: Swift.String?
    /// The name of the application. This name is visible to users when display name is not specified.
    /// This member is required.
    public var name: Swift.String?
    /// The working directory of the application.
    public var workingDirectory: Swift.String?

    public init (
        appBlockArn: Swift.String? = nil,
        attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        iconS3Location: AppStreamClientTypes.S3Location? = nil,
        launchParameters: Swift.String? = nil,
        launchPath: Swift.String? = nil,
        name: Swift.String? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.appBlockArn = appBlockArn
        self.attributesToDelete = attributesToDelete
        self.description = description
        self.displayName = displayName
        self.iconS3Location = iconS3Location
        self.launchParameters = launchParameters
        self.launchPath = launchPath
        self.name = name
        self.workingDirectory = workingDirectory
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let displayName: Swift.String?
    let description: Swift.String?
    let iconS3Location: AppStreamClientTypes.S3Location?
    let launchPath: Swift.String?
    let workingDirectory: Swift.String?
    let launchParameters: Swift.String?
    let appBlockArn: Swift.String?
    let attributesToDelete: [AppStreamClientTypes.ApplicationAttribute]?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appBlockArn = "AppBlockArn"
        case attributesToDelete = "AttributesToDelete"
        case description = "Description"
        case displayName = "DisplayName"
        case iconS3Location = "IconS3Location"
        case launchParameters = "LaunchParameters"
        case launchPath = "LaunchPath"
        case name = "Name"
        case workingDirectory = "WorkingDirectory"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let iconS3LocationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.S3Location.self, forKey: .iconS3Location)
        iconS3Location = iconS3LocationDecoded
        let launchPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchPath)
        launchPath = launchPathDecoded
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let launchParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchParameters)
        launchParameters = launchParametersDecoded
        let appBlockArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appBlockArn)
        appBlockArn = appBlockArnDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.ApplicationAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.ApplicationAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.ApplicationAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.application = output.application
        } else {
            self.application = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// Describes an application in the application catalog.
    public var application: AppStreamClientTypes.Application?

    public init (
        application: AppStreamClientTypes.Application? = nil
    )
    {
        self.application = application
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let application: AppStreamClientTypes.Application?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "Application"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Application.self, forKey: .application)
        application = applicationDecoded
    }
}

extension UpdateDirectoryConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let directoryName = directoryName {
            try encodeContainer.encode(directoryName, forKey: .directoryName)
        }
        if let organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames {
            var organizationalUnitDistinguishedNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitDistinguishedNames)
            for organizationalunitdistinguishednameslist0 in organizationalUnitDistinguishedNames {
                try organizationalUnitDistinguishedNamesContainer.encode(organizationalunitdistinguishednameslist0)
            }
        }
        if let serviceAccountCredentials = serviceAccountCredentials {
            try encodeContainer.encode(serviceAccountCredentials, forKey: .serviceAccountCredentials)
        }
    }
}

extension UpdateDirectoryConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDirectoryConfigInput: Swift.Equatable {
    /// The name of the Directory Config object.
    /// This member is required.
    public var directoryName: Swift.String?
    /// The distinguished names of the organizational units for computer accounts.
    public var organizationalUnitDistinguishedNames: [Swift.String]?
    /// The credentials for the service account used by the fleet or image builder to connect to the directory.
    public var serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?

    public init (
        directoryName: Swift.String? = nil,
        organizationalUnitDistinguishedNames: [Swift.String]? = nil,
        serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials? = nil
    )
    {
        self.directoryName = directoryName
        self.organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNames
        self.serviceAccountCredentials = serviceAccountCredentials
    }
}

struct UpdateDirectoryConfigInputBody: Swift.Equatable {
    let directoryName: Swift.String?
    let organizationalUnitDistinguishedNames: [Swift.String]?
    let serviceAccountCredentials: AppStreamClientTypes.ServiceAccountCredentials?
}

extension UpdateDirectoryConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryName = "DirectoryName"
        case organizationalUnitDistinguishedNames = "OrganizationalUnitDistinguishedNames"
        case serviceAccountCredentials = "ServiceAccountCredentials"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryName)
        directoryName = directoryNameDecoded
        let organizationalUnitDistinguishedNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitDistinguishedNames)
        var organizationalUnitDistinguishedNamesDecoded0:[Swift.String]? = nil
        if let organizationalUnitDistinguishedNamesContainer = organizationalUnitDistinguishedNamesContainer {
            organizationalUnitDistinguishedNamesDecoded0 = [Swift.String]()
            for string0 in organizationalUnitDistinguishedNamesContainer {
                if let string0 = string0 {
                    organizationalUnitDistinguishedNamesDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitDistinguishedNames = organizationalUnitDistinguishedNamesDecoded0
        let serviceAccountCredentialsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ServiceAccountCredentials.self, forKey: .serviceAccountCredentials)
        serviceAccountCredentials = serviceAccountCredentialsDecoded
    }
}

extension UpdateDirectoryConfigOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDirectoryConfigOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDirectoryConfigOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidRoleException(InvalidRoleException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDirectoryConfigOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDirectoryConfigOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.directoryConfig = output.directoryConfig
        } else {
            self.directoryConfig = nil
        }
    }
}

public struct UpdateDirectoryConfigOutputResponse: Swift.Equatable {
    /// Information about the Directory Config object.
    public var directoryConfig: AppStreamClientTypes.DirectoryConfig?

    public init (
        directoryConfig: AppStreamClientTypes.DirectoryConfig? = nil
    )
    {
        self.directoryConfig = directoryConfig
    }
}

struct UpdateDirectoryConfigOutputResponseBody: Swift.Equatable {
    let directoryConfig: AppStreamClientTypes.DirectoryConfig?
}

extension UpdateDirectoryConfigOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case directoryConfig = "DirectoryConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DirectoryConfig.self, forKey: .directoryConfig)
        directoryConfig = directoryConfigDecoded
    }
}

extension UpdateFleetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for fleetattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(fleetattributes0.rawValue)
            }
        }
        if let computeCapacity = computeCapacity {
            try encodeContainer.encode(computeCapacity, forKey: .computeCapacity)
        }
        if deleteVpcConfig != false {
            try encodeContainer.encode(deleteVpcConfig, forKey: .deleteVpcConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let disconnectTimeoutInSeconds = disconnectTimeoutInSeconds {
            try encodeContainer.encode(disconnectTimeoutInSeconds, forKey: .disconnectTimeoutInSeconds)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let domainJoinInfo = domainJoinInfo {
            try encodeContainer.encode(domainJoinInfo, forKey: .domainJoinInfo)
        }
        if let enableDefaultInternetAccess = enableDefaultInternetAccess {
            try encodeContainer.encode(enableDefaultInternetAccess, forKey: .enableDefaultInternetAccess)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds {
            try encodeContainer.encode(idleDisconnectTimeoutInSeconds, forKey: .idleDisconnectTimeoutInSeconds)
        }
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let imageName = imageName {
            try encodeContainer.encode(imageName, forKey: .imageName)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let maxConcurrentSessions = maxConcurrentSessions {
            try encodeContainer.encode(maxConcurrentSessions, forKey: .maxConcurrentSessions)
        }
        if let maxUserDurationInSeconds = maxUserDurationInSeconds {
            try encodeContainer.encode(maxUserDurationInSeconds, forKey: .maxUserDurationInSeconds)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let streamView = streamView {
            try encodeContainer.encode(streamView.rawValue, forKey: .streamView)
        }
        if let usbDeviceFilterStrings = usbDeviceFilterStrings {
            var usbDeviceFilterStringsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usbDeviceFilterStrings)
            for usbdevicefilterstrings0 in usbDeviceFilterStrings {
                try usbDeviceFilterStringsContainer.encode(usbdevicefilterstrings0)
            }
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

extension UpdateFleetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateFleetInput: Swift.Equatable {
    /// The fleet attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    /// The desired capacity for the fleet. This is not allowed for Elastic fleets.
    public var computeCapacity: AppStreamClientTypes.ComputeCapacity?
    /// Deletes the VPC association for the specified fleet.
    @available(*, deprecated)
    public var deleteVpcConfig: Swift.Bool
    /// The description to display.
    public var description: Swift.String?
    /// The amount of time that a streaming session remains active after users disconnect. If users try to reconnect to the streaming session after a disconnection or network interruption within this time interval, they are connected to their previous session. Otherwise, they are connected to a new session with a new streaming instance. Specify a value between 60 and 360000.
    public var disconnectTimeoutInSeconds: Swift.Int?
    /// The fleet name to display.
    public var displayName: Swift.String?
    /// The name of the directory and organizational unit (OU) to use to join the fleet to a Microsoft Active Directory domain.
    public var domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    /// Enables or disables default internet access for the fleet.
    public var enableDefaultInternetAccess: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the IAM role to apply to the fleet. To assume a role, a fleet instance calls the AWS Security Token Service (STS) AssumeRole API operation and passes the ARN of the role to use. The operation creates a new session with temporary credentials. AppStream 2.0 retrieves the temporary credentials and creates the appstream_machine_role credential profile on the instance. For more information, see [Using an IAM Role to Grant Permissions to Applications and Scripts Running on AppStream 2.0 Streaming Instances](https://docs.aws.amazon.com/appstream2/latest/developerguide/using-iam-roles-to-grant-permissions-to-applications-scripts-streaming-instances.html) in the Amazon AppStream 2.0 Administration Guide.
    public var iamRoleArn: Swift.String?
    /// The amount of time that users can be idle (inactive) before they are disconnected from their streaming session and the DisconnectTimeoutInSeconds time interval begins. Users are notified before they are disconnected due to inactivity. If users try to reconnect to the streaming session before the time interval specified in DisconnectTimeoutInSeconds elapses, they are connected to their previous session. Users are considered idle when they stop providing keyboard or mouse input during their streaming session. File uploads and downloads, audio in, audio out, and pixels changing do not qualify as user activity. If users continue to be idle after the time interval in IdleDisconnectTimeoutInSeconds elapses, they are disconnected. To prevent users from being disconnected due to inactivity, specify a value of 0. Otherwise, specify a value between 60 and 3600. The default value is 0. If you enable this feature, we recommend that you specify a value that corresponds exactly to a whole number of minutes (for example, 60, 120, and 180). If you don't do this, the value is rounded to the nearest minute. For example, if you specify a value of 70, users are disconnected after 1 minute of inactivity. If you specify a value that is at the midpoint between two different minutes, the value is rounded up. For example, if you specify a value of 90, users are disconnected after 2 minutes of inactivity.
    public var idleDisconnectTimeoutInSeconds: Swift.Int?
    /// The ARN of the public, private, or shared image to use.
    public var imageArn: Swift.String?
    /// The name of the image used to create the fleet.
    public var imageName: Swift.String?
    /// The instance type to use when launching fleet instances. The following instance types are available:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    ///
    /// * stream.standard.large
    ///
    /// * stream.compute.large
    ///
    /// * stream.compute.xlarge
    ///
    /// * stream.compute.2xlarge
    ///
    /// * stream.compute.4xlarge
    ///
    /// * stream.compute.8xlarge
    ///
    /// * stream.memory.large
    ///
    /// * stream.memory.xlarge
    ///
    /// * stream.memory.2xlarge
    ///
    /// * stream.memory.4xlarge
    ///
    /// * stream.memory.8xlarge
    ///
    /// * stream.memory.z1d.large
    ///
    /// * stream.memory.z1d.xlarge
    ///
    /// * stream.memory.z1d.2xlarge
    ///
    /// * stream.memory.z1d.3xlarge
    ///
    /// * stream.memory.z1d.6xlarge
    ///
    /// * stream.memory.z1d.12xlarge
    ///
    /// * stream.graphics-design.large
    ///
    /// * stream.graphics-design.xlarge
    ///
    /// * stream.graphics-design.2xlarge
    ///
    /// * stream.graphics-design.4xlarge
    ///
    /// * stream.graphics-desktop.2xlarge
    ///
    /// * stream.graphics.g4dn.xlarge
    ///
    /// * stream.graphics.g4dn.2xlarge
    ///
    /// * stream.graphics.g4dn.4xlarge
    ///
    /// * stream.graphics.g4dn.8xlarge
    ///
    /// * stream.graphics.g4dn.12xlarge
    ///
    /// * stream.graphics.g4dn.16xlarge
    ///
    /// * stream.graphics-pro.4xlarge
    ///
    /// * stream.graphics-pro.8xlarge
    ///
    /// * stream.graphics-pro.16xlarge
    ///
    ///
    /// The following instance types are available for Elastic fleets:
    ///
    /// * stream.standard.small
    ///
    /// * stream.standard.medium
    public var instanceType: Swift.String?
    /// The maximum number of concurrent sessions for a fleet.
    public var maxConcurrentSessions: Swift.Int?
    /// The maximum amount of time that a streaming session can remain active, in seconds. If users are still connected to a streaming instance five minutes before this limit is reached, they are prompted to save any open documents before being disconnected. After this time elapses, the instance is terminated and replaced by a new instance. Specify a value between 600 and 360000.
    public var maxUserDurationInSeconds: Swift.Int?
    /// A unique name for the fleet.
    public var name: Swift.String?
    /// The platform of the fleet. WINDOWS_SERVER_2019 and AMAZON_LINUX2 are supported for Elastic fleets.
    public var platform: AppStreamClientTypes.PlatformType?
    /// The AppStream 2.0 view that is displayed to your users when they stream from the fleet. When APP is specified, only the windows of applications opened by users display. When DESKTOP is specified, the standard desktop that is provided by the operating system displays. The default value is APP.
    public var streamView: AppStreamClientTypes.StreamView?
    /// The USB device filter strings that specify which USB devices a user can redirect to the fleet streaming session, when using the Windows native client. This is allowed but not required for Elastic fleets.
    public var usbDeviceFilterStrings: [Swift.String]?
    /// The VPC configuration for the fleet. This is required for Elastic fleets, but not required for other fleet types. Elastic fleets require that you specify at least two subnets in different availability zones.
    public var vpcConfig: AppStreamClientTypes.VpcConfig?

    public init (
        attributesToDelete: [AppStreamClientTypes.FleetAttribute]? = nil,
        computeCapacity: AppStreamClientTypes.ComputeCapacity? = nil,
        deleteVpcConfig: Swift.Bool = false,
        description: Swift.String? = nil,
        disconnectTimeoutInSeconds: Swift.Int? = nil,
        displayName: Swift.String? = nil,
        domainJoinInfo: AppStreamClientTypes.DomainJoinInfo? = nil,
        enableDefaultInternetAccess: Swift.Bool? = nil,
        iamRoleArn: Swift.String? = nil,
        idleDisconnectTimeoutInSeconds: Swift.Int? = nil,
        imageArn: Swift.String? = nil,
        imageName: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        maxConcurrentSessions: Swift.Int? = nil,
        maxUserDurationInSeconds: Swift.Int? = nil,
        name: Swift.String? = nil,
        platform: AppStreamClientTypes.PlatformType? = nil,
        streamView: AppStreamClientTypes.StreamView? = nil,
        usbDeviceFilterStrings: [Swift.String]? = nil,
        vpcConfig: AppStreamClientTypes.VpcConfig? = nil
    )
    {
        self.attributesToDelete = attributesToDelete
        self.computeCapacity = computeCapacity
        self.deleteVpcConfig = deleteVpcConfig
        self.description = description
        self.disconnectTimeoutInSeconds = disconnectTimeoutInSeconds
        self.displayName = displayName
        self.domainJoinInfo = domainJoinInfo
        self.enableDefaultInternetAccess = enableDefaultInternetAccess
        self.iamRoleArn = iamRoleArn
        self.idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSeconds
        self.imageArn = imageArn
        self.imageName = imageName
        self.instanceType = instanceType
        self.maxConcurrentSessions = maxConcurrentSessions
        self.maxUserDurationInSeconds = maxUserDurationInSeconds
        self.name = name
        self.platform = platform
        self.streamView = streamView
        self.usbDeviceFilterStrings = usbDeviceFilterStrings
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFleetInputBody: Swift.Equatable {
    let imageName: Swift.String?
    let imageArn: Swift.String?
    let name: Swift.String?
    let instanceType: Swift.String?
    let computeCapacity: AppStreamClientTypes.ComputeCapacity?
    let vpcConfig: AppStreamClientTypes.VpcConfig?
    let maxUserDurationInSeconds: Swift.Int?
    let disconnectTimeoutInSeconds: Swift.Int?
    let deleteVpcConfig: Swift.Bool
    let description: Swift.String?
    let displayName: Swift.String?
    let enableDefaultInternetAccess: Swift.Bool?
    let domainJoinInfo: AppStreamClientTypes.DomainJoinInfo?
    let idleDisconnectTimeoutInSeconds: Swift.Int?
    let attributesToDelete: [AppStreamClientTypes.FleetAttribute]?
    let iamRoleArn: Swift.String?
    let streamView: AppStreamClientTypes.StreamView?
    let platform: AppStreamClientTypes.PlatformType?
    let maxConcurrentSessions: Swift.Int?
    let usbDeviceFilterStrings: [Swift.String]?
}

extension UpdateFleetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributesToDelete = "AttributesToDelete"
        case computeCapacity = "ComputeCapacity"
        case deleteVpcConfig = "DeleteVpcConfig"
        case description = "Description"
        case disconnectTimeoutInSeconds = "DisconnectTimeoutInSeconds"
        case displayName = "DisplayName"
        case domainJoinInfo = "DomainJoinInfo"
        case enableDefaultInternetAccess = "EnableDefaultInternetAccess"
        case iamRoleArn = "IamRoleArn"
        case idleDisconnectTimeoutInSeconds = "IdleDisconnectTimeoutInSeconds"
        case imageArn = "ImageArn"
        case imageName = "ImageName"
        case instanceType = "InstanceType"
        case maxConcurrentSessions = "MaxConcurrentSessions"
        case maxUserDurationInSeconds = "MaxUserDurationInSeconds"
        case name = "Name"
        case platform = "Platform"
        case streamView = "StreamView"
        case usbDeviceFilterStrings = "UsbDeviceFilterStrings"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageName)
        imageName = imageNameDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let computeCapacityDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ComputeCapacity.self, forKey: .computeCapacity)
        computeCapacity = computeCapacityDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let maxUserDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxUserDurationInSeconds)
        maxUserDurationInSeconds = maxUserDurationInSecondsDecoded
        let disconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .disconnectTimeoutInSeconds)
        disconnectTimeoutInSeconds = disconnectTimeoutInSecondsDecoded
        let deleteVpcConfigDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteVpcConfig)
        deleteVpcConfig = deleteVpcConfigDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let enableDefaultInternetAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableDefaultInternetAccess)
        enableDefaultInternetAccess = enableDefaultInternetAccessDecoded
        let domainJoinInfoDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.DomainJoinInfo.self, forKey: .domainJoinInfo)
        domainJoinInfo = domainJoinInfoDecoded
        let idleDisconnectTimeoutInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .idleDisconnectTimeoutInSeconds)
        idleDisconnectTimeoutInSeconds = idleDisconnectTimeoutInSecondsDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.FleetAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.FleetAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.FleetAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let streamViewDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.StreamView.self, forKey: .streamView)
        streamView = streamViewDecoded
        let platformDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.PlatformType.self, forKey: .platform)
        platform = platformDecoded
        let maxConcurrentSessionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxConcurrentSessions)
        maxConcurrentSessions = maxConcurrentSessionsDecoded
        let usbDeviceFilterStringsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usbDeviceFilterStrings)
        var usbDeviceFilterStringsDecoded0:[Swift.String]? = nil
        if let usbDeviceFilterStringsContainer = usbDeviceFilterStringsContainer {
            usbDeviceFilterStringsDecoded0 = [Swift.String]()
            for string0 in usbDeviceFilterStringsContainer {
                if let string0 = string0 {
                    usbDeviceFilterStringsDecoded0?.append(string0)
                }
            }
        }
        usbDeviceFilterStrings = usbDeviceFilterStringsDecoded0
    }
}

extension UpdateFleetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFleetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestLimitExceededException" : self = .requestLimitExceededException(try RequestLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFleetOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case requestLimitExceededException(RequestLimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFleetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateFleetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.fleet = output.fleet
        } else {
            self.fleet = nil
        }
    }
}

public struct UpdateFleetOutputResponse: Swift.Equatable {
    /// Information about the fleet.
    public var fleet: AppStreamClientTypes.Fleet?

    public init (
        fleet: AppStreamClientTypes.Fleet? = nil
    )
    {
        self.fleet = fleet
    }
}

struct UpdateFleetOutputResponseBody: Swift.Equatable {
    let fleet: AppStreamClientTypes.Fleet?
}

extension UpdateFleetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fleet = "Fleet"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Fleet.self, forKey: .fleet)
        fleet = fleetDecoded
    }
}

extension UpdateImagePermissionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imagePermissions = imagePermissions {
            try encodeContainer.encode(imagePermissions, forKey: .imagePermissions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sharedAccountId = sharedAccountId {
            try encodeContainer.encode(sharedAccountId, forKey: .sharedAccountId)
        }
    }
}

extension UpdateImagePermissionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateImagePermissionsInput: Swift.Equatable {
    /// The permissions for the image.
    /// This member is required.
    public var imagePermissions: AppStreamClientTypes.ImagePermissions?
    /// The name of the private image.
    /// This member is required.
    public var name: Swift.String?
    /// The 12-digit identifier of the AWS account for which you want add or update image permissions.
    /// This member is required.
    public var sharedAccountId: Swift.String?

    public init (
        imagePermissions: AppStreamClientTypes.ImagePermissions? = nil,
        name: Swift.String? = nil,
        sharedAccountId: Swift.String? = nil
    )
    {
        self.imagePermissions = imagePermissions
        self.name = name
        self.sharedAccountId = sharedAccountId
    }
}

struct UpdateImagePermissionsInputBody: Swift.Equatable {
    let name: Swift.String?
    let sharedAccountId: Swift.String?
    let imagePermissions: AppStreamClientTypes.ImagePermissions?
}

extension UpdateImagePermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePermissions = "ImagePermissions"
        case name = "Name"
        case sharedAccountId = "SharedAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sharedAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sharedAccountId)
        sharedAccountId = sharedAccountIdDecoded
        let imagePermissionsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ImagePermissions.self, forKey: .imagePermissions)
        imagePermissions = imagePermissionsDecoded
    }
}

extension UpdateImagePermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotAvailableException" : self = .resourceNotAvailableException(try ResourceNotAvailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateImagePermissionsOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotAvailableException(ResourceNotAvailableException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateImagePermissionsOutputResponse: Swift.Equatable {

}

extension UpdateStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessEndpoints = accessEndpoints {
            var accessEndpointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessEndpoints)
            for accessendpointlist0 in accessEndpoints {
                try accessEndpointsContainer.encode(accessendpointlist0)
            }
        }
        if let applicationSettings = applicationSettings {
            try encodeContainer.encode(applicationSettings, forKey: .applicationSettings)
        }
        if let attributesToDelete = attributesToDelete {
            var attributesToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributesToDelete)
            for stackattributes0 in attributesToDelete {
                try attributesToDeleteContainer.encode(stackattributes0.rawValue)
            }
        }
        if deleteStorageConnectors != false {
            try encodeContainer.encode(deleteStorageConnectors, forKey: .deleteStorageConnectors)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let embedHostDomains = embedHostDomains {
            var embedHostDomainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .embedHostDomains)
            for embedhostdomains0 in embedHostDomains {
                try embedHostDomainsContainer.encode(embedhostdomains0)
            }
        }
        if let feedbackURL = feedbackURL {
            try encodeContainer.encode(feedbackURL, forKey: .feedbackURL)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let redirectURL = redirectURL {
            try encodeContainer.encode(redirectURL, forKey: .redirectURL)
        }
        if let storageConnectors = storageConnectors {
            var storageConnectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storageConnectors)
            for storageconnectorlist0 in storageConnectors {
                try storageConnectorsContainer.encode(storageconnectorlist0)
            }
        }
        if let userSettings = userSettings {
            var userSettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userSettings)
            for usersettinglist0 in userSettings {
                try userSettingsContainer.encode(usersettinglist0)
            }
        }
    }
}

extension UpdateStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateStackInput: Swift.Equatable {
    /// The list of interface VPC endpoint (interface endpoint) objects. Users of the stack can connect to AppStream 2.0 only through the specified endpoints.
    public var accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    /// The persistent application settings for users of a stack. When these settings are enabled, changes that users make to applications and Windows settings are automatically saved after each session and applied to the next session.
    public var applicationSettings: AppStreamClientTypes.ApplicationSettings?
    /// The stack attributes to delete.
    public var attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    /// Deletes the storage connectors currently enabled for the stack.
    @available(*, deprecated)
    public var deleteStorageConnectors: Swift.Bool
    /// The description to display.
    public var description: Swift.String?
    /// The stack name to display.
    public var displayName: Swift.String?
    /// The domains where AppStream 2.0 streaming sessions can be embedded in an iframe. You must approve the domains that you want to host embedded AppStream 2.0 streaming sessions.
    public var embedHostDomains: [Swift.String]?
    /// The URL that users are redirected to after they choose the Send Feedback link. If no URL is specified, no Send Feedback link is displayed.
    public var feedbackURL: Swift.String?
    /// The name of the stack.
    /// This member is required.
    public var name: Swift.String?
    /// The URL that users are redirected to after their streaming session ends.
    public var redirectURL: Swift.String?
    /// The storage connectors to enable.
    public var storageConnectors: [AppStreamClientTypes.StorageConnector]?
    /// The actions that are enabled or disabled for users during their streaming sessions. By default, these actions are enabled.
    public var userSettings: [AppStreamClientTypes.UserSetting]?

    public init (
        accessEndpoints: [AppStreamClientTypes.AccessEndpoint]? = nil,
        applicationSettings: AppStreamClientTypes.ApplicationSettings? = nil,
        attributesToDelete: [AppStreamClientTypes.StackAttribute]? = nil,
        deleteStorageConnectors: Swift.Bool = false,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        embedHostDomains: [Swift.String]? = nil,
        feedbackURL: Swift.String? = nil,
        name: Swift.String? = nil,
        redirectURL: Swift.String? = nil,
        storageConnectors: [AppStreamClientTypes.StorageConnector]? = nil,
        userSettings: [AppStreamClientTypes.UserSetting]? = nil
    )
    {
        self.accessEndpoints = accessEndpoints
        self.applicationSettings = applicationSettings
        self.attributesToDelete = attributesToDelete
        self.deleteStorageConnectors = deleteStorageConnectors
        self.description = description
        self.displayName = displayName
        self.embedHostDomains = embedHostDomains
        self.feedbackURL = feedbackURL
        self.name = name
        self.redirectURL = redirectURL
        self.storageConnectors = storageConnectors
        self.userSettings = userSettings
    }
}

struct UpdateStackInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let description: Swift.String?
    let name: Swift.String?
    let storageConnectors: [AppStreamClientTypes.StorageConnector]?
    let deleteStorageConnectors: Swift.Bool
    let redirectURL: Swift.String?
    let feedbackURL: Swift.String?
    let attributesToDelete: [AppStreamClientTypes.StackAttribute]?
    let userSettings: [AppStreamClientTypes.UserSetting]?
    let applicationSettings: AppStreamClientTypes.ApplicationSettings?
    let accessEndpoints: [AppStreamClientTypes.AccessEndpoint]?
    let embedHostDomains: [Swift.String]?
}

extension UpdateStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessEndpoints = "AccessEndpoints"
        case applicationSettings = "ApplicationSettings"
        case attributesToDelete = "AttributesToDelete"
        case deleteStorageConnectors = "DeleteStorageConnectors"
        case description = "Description"
        case displayName = "DisplayName"
        case embedHostDomains = "EmbedHostDomains"
        case feedbackURL = "FeedbackURL"
        case name = "Name"
        case redirectURL = "RedirectURL"
        case storageConnectors = "StorageConnectors"
        case userSettings = "UserSettings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let storageConnectorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StorageConnector?].self, forKey: .storageConnectors)
        var storageConnectorsDecoded0:[AppStreamClientTypes.StorageConnector]? = nil
        if let storageConnectorsContainer = storageConnectorsContainer {
            storageConnectorsDecoded0 = [AppStreamClientTypes.StorageConnector]()
            for structure0 in storageConnectorsContainer {
                if let structure0 = structure0 {
                    storageConnectorsDecoded0?.append(structure0)
                }
            }
        }
        storageConnectors = storageConnectorsDecoded0
        let deleteStorageConnectorsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteStorageConnectors)
        deleteStorageConnectors = deleteStorageConnectorsDecoded
        let redirectURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectURL)
        redirectURL = redirectURLDecoded
        let feedbackURLDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .feedbackURL)
        feedbackURL = feedbackURLDecoded
        let attributesToDeleteContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.StackAttribute?].self, forKey: .attributesToDelete)
        var attributesToDeleteDecoded0:[AppStreamClientTypes.StackAttribute]? = nil
        if let attributesToDeleteContainer = attributesToDeleteContainer {
            attributesToDeleteDecoded0 = [AppStreamClientTypes.StackAttribute]()
            for string0 in attributesToDeleteContainer {
                if let string0 = string0 {
                    attributesToDeleteDecoded0?.append(string0)
                }
            }
        }
        attributesToDelete = attributesToDeleteDecoded0
        let userSettingsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.UserSetting?].self, forKey: .userSettings)
        var userSettingsDecoded0:[AppStreamClientTypes.UserSetting]? = nil
        if let userSettingsContainer = userSettingsContainer {
            userSettingsDecoded0 = [AppStreamClientTypes.UserSetting]()
            for structure0 in userSettingsContainer {
                if let structure0 = structure0 {
                    userSettingsDecoded0?.append(structure0)
                }
            }
        }
        userSettings = userSettingsDecoded0
        let applicationSettingsDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.ApplicationSettings.self, forKey: .applicationSettings)
        applicationSettings = applicationSettingsDecoded
        let accessEndpointsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.AccessEndpoint?].self, forKey: .accessEndpoints)
        var accessEndpointsDecoded0:[AppStreamClientTypes.AccessEndpoint]? = nil
        if let accessEndpointsContainer = accessEndpointsContainer {
            accessEndpointsDecoded0 = [AppStreamClientTypes.AccessEndpoint]()
            for structure0 in accessEndpointsContainer {
                if let structure0 = structure0 {
                    accessEndpointsDecoded0?.append(structure0)
                }
            }
        }
        accessEndpoints = accessEndpointsDecoded0
        let embedHostDomainsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .embedHostDomains)
        var embedHostDomainsDecoded0:[Swift.String]? = nil
        if let embedHostDomainsContainer = embedHostDomainsContainer {
            embedHostDomainsDecoded0 = [Swift.String]()
            for string0 in embedHostDomainsContainer {
                if let string0 = string0 {
                    embedHostDomainsDecoded0?.append(string0)
                }
            }
        }
        embedHostDomains = embedHostDomainsDecoded0
    }
}

extension UpdateStackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IncompatibleImageException" : self = .incompatibleImageException(try IncompatibleImageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidAccountStatusException" : self = .invalidAccountStatusException(try InvalidAccountStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRoleException" : self = .invalidRoleException(try InvalidRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateStackOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case incompatibleImageException(IncompatibleImageException)
    case invalidAccountStatusException(InvalidAccountStatusException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRoleException(InvalidRoleException)
    case limitExceededException(LimitExceededException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateStackOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stack = output.stack
        } else {
            self.stack = nil
        }
    }
}

public struct UpdateStackOutputResponse: Swift.Equatable {
    /// Information about the stack.
    public var stack: AppStreamClientTypes.Stack?

    public init (
        stack: AppStreamClientTypes.Stack? = nil
    )
    {
        self.stack = stack
    }
}

struct UpdateStackOutputResponseBody: Swift.Equatable {
    let stack: AppStreamClientTypes.Stack?
}

extension UpdateStackOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stack = "Stack"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Stack.self, forKey: .stack)
        stack = stackDecoded
    }
}

extension AppStreamClientTypes {
    public enum UsageReportExecutionErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalServiceError
        case resourceNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportExecutionErrorCode] {
            return [
                .accessDenied,
                .internalServiceError,
                .resourceNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalServiceError: return "INTERNAL_SERVICE_ERROR"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportExecutionErrorCode(rawValue: rawValue) ?? UsageReportExecutionErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum UsageReportSchedule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case daily
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageReportSchedule] {
            return [
                .daily,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageReportSchedule(rawValue: rawValue) ?? UsageReportSchedule.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.UsageReportSubscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastGeneratedReportDate = "LastGeneratedReportDate"
        case s3BucketName = "S3BucketName"
        case schedule = "Schedule"
        case subscriptionErrors = "SubscriptionErrors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastGeneratedReportDate = lastGeneratedReportDate {
            try encodeContainer.encode(lastGeneratedReportDate.timeIntervalSince1970, forKey: .lastGeneratedReportDate)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule.rawValue, forKey: .schedule)
        }
        if let subscriptionErrors = subscriptionErrors {
            var subscriptionErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionErrors)
            for lastreportgenerationexecutionerrors0 in subscriptionErrors {
                try subscriptionErrorsContainer.encode(lastreportgenerationexecutionerrors0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UsageReportSchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let lastGeneratedReportDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastGeneratedReportDate)
        lastGeneratedReportDate = lastGeneratedReportDateDecoded
        let subscriptionErrorsContainer = try containerValues.decodeIfPresent([AppStreamClientTypes.LastReportGenerationExecutionError?].self, forKey: .subscriptionErrors)
        var subscriptionErrorsDecoded0:[AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        if let subscriptionErrorsContainer = subscriptionErrorsContainer {
            subscriptionErrorsDecoded0 = [AppStreamClientTypes.LastReportGenerationExecutionError]()
            for structure0 in subscriptionErrorsContainer {
                if let structure0 = structure0 {
                    subscriptionErrorsDecoded0?.append(structure0)
                }
            }
        }
        subscriptionErrors = subscriptionErrorsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes information about the usage report subscription.
    public struct UsageReportSubscription: Swift.Equatable {
        /// The time when the last usage report was generated.
        public var lastGeneratedReportDate: ClientRuntime.Date?
        /// The Amazon S3 bucket where generated reports are stored. If you enabled on-instance session scripts and Amazon S3 logging for your session script configuration, AppStream 2.0 created an S3 bucket to store the script output. The bucket is unique to your account and Region. When you enable usage reporting in this case, AppStream 2.0 uses the same bucket to store your usage reports. If you haven't already enabled on-instance session scripts, when you enable usage reports, AppStream 2.0 creates a new S3 bucket.
        public var s3BucketName: Swift.String?
        /// The schedule for generating usage reports.
        public var schedule: AppStreamClientTypes.UsageReportSchedule?
        /// The errors that were returned if usage reports couldn't be generated.
        public var subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]?

        public init (
            lastGeneratedReportDate: ClientRuntime.Date? = nil,
            s3BucketName: Swift.String? = nil,
            schedule: AppStreamClientTypes.UsageReportSchedule? = nil,
            subscriptionErrors: [AppStreamClientTypes.LastReportGenerationExecutionError]? = nil
        )
        {
            self.lastGeneratedReportDate = lastGeneratedReportDate
            self.s3BucketName = s3BucketName
            self.schedule = schedule
            self.subscriptionErrors = subscriptionErrors
        }
    }

}

extension AppStreamClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case authenticationType = "AuthenticationType"
        case createdTime = "CreatedTime"
        case enabled = "Enabled"
        case firstName = "FirstName"
        case lastName = "LastName"
        case status = "Status"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool.
    public struct User: Swift.Equatable {
        /// The ARN of the user.
        public var arn: Swift.String?
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// The date and time the user was created in the user pool.
        public var createdTime: ClientRuntime.Date?
        /// Specifies whether the user in the user pool is enabled.
        public var enabled: Swift.Bool
        /// The first name, or given name, of the user.
        public var firstName: Swift.String?
        /// The last name, or surname, of the user.
        public var lastName: Swift.String?
        /// The status of the user in the user pool. The status can be one of the following:
        ///
        /// * UNCONFIRMED – The user is created but not confirmed.
        ///
        /// * CONFIRMED – The user is confirmed.
        ///
        /// * ARCHIVED – The user is no longer active.
        ///
        /// * COMPROMISED – The user is disabled because of a potential security threat.
        ///
        /// * UNKNOWN – The user status is not known.
        public var status: Swift.String?
        /// The email address of the user. Users' email addresses are case-sensitive.
        public var userName: Swift.String?

        public init (
            arn: Swift.String? = nil,
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            createdTime: ClientRuntime.Date? = nil,
            enabled: Swift.Bool = false,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            status: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.authenticationType = authenticationType
            self.createdTime = createdTime
            self.enabled = enabled
            self.firstName = firstName
            self.lastName = lastName
            self.status = status
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case permission = "Permission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes an action and whether the action is enabled or disabled for users during their streaming sessions.
    public struct UserSetting: Swift.Equatable {
        /// The action that is enabled or disabled.
        /// This member is required.
        public var action: AppStreamClientTypes.Action?
        /// Indicates whether the action is enabled or disabled.
        /// This member is required.
        public var permission: AppStreamClientTypes.Permission?

        public init (
            action: AppStreamClientTypes.Action? = nil,
            permission: AppStreamClientTypes.Permission? = nil
        )
        {
            self.action = action
            self.permission = permission
        }
    }

}

extension AppStreamClientTypes.UserStackAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationType = "AuthenticationType"
        case sendEmailNotification = "SendEmailNotification"
        case stackName = "StackName"
        case userName = "UserName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationType = authenticationType {
            try encodeContainer.encode(authenticationType.rawValue, forKey: .authenticationType)
        }
        if sendEmailNotification != false {
            try encodeContainer.encode(sendEmailNotification, forKey: .sendEmailNotification)
        }
        if let stackName = stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let userName = userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let authenticationTypeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.AuthenticationType.self, forKey: .authenticationType)
        authenticationType = authenticationTypeDecoded
        let sendEmailNotificationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .sendEmailNotification)
        sendEmailNotification = sendEmailNotificationDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes a user in the user pool and the associated stack.
    public struct UserStackAssociation: Swift.Equatable {
        /// The authentication type for the user.
        /// This member is required.
        public var authenticationType: AppStreamClientTypes.AuthenticationType?
        /// Specifies whether a welcome email is sent to a user after the user is created in the user pool.
        public var sendEmailNotification: Swift.Bool
        /// The name of the stack that is associated with the user.
        /// This member is required.
        public var stackName: Swift.String?
        /// The email address of the user who is associated with the stack. Users' email addresses are case-sensitive.
        /// This member is required.
        public var userName: Swift.String?

        public init (
            authenticationType: AppStreamClientTypes.AuthenticationType? = nil,
            sendEmailNotification: Swift.Bool = false,
            stackName: Swift.String? = nil,
            userName: Swift.String? = nil
        )
        {
            self.authenticationType = authenticationType
            self.sendEmailNotification = sendEmailNotification
            self.stackName = stackName
            self.userName = userName
        }
    }

}

extension AppStreamClientTypes.UserStackAssociationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case userStackAssociation = "UserStackAssociation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let userStackAssociation = userStackAssociation {
            try encodeContainer.encode(userStackAssociation, forKey: .userStackAssociation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userStackAssociationDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociation.self, forKey: .userStackAssociation)
        userStackAssociation = userStackAssociationDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(AppStreamClientTypes.UserStackAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AppStreamClientTypes {
    /// Describes the error that is returned when a user can’t be associated with or disassociated from a stack.
    public struct UserStackAssociationError: Swift.Equatable {
        /// The error code for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorCode: AppStreamClientTypes.UserStackAssociationErrorCode?
        /// The error message for the error that is returned when a user can’t be associated with or disassociated from a stack.
        public var errorMessage: Swift.String?
        /// Information about the user and associated stack.
        public var userStackAssociation: AppStreamClientTypes.UserStackAssociation?

        public init (
            errorCode: AppStreamClientTypes.UserStackAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            userStackAssociation: AppStreamClientTypes.UserStackAssociation? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.userStackAssociation = userStackAssociation
        }
    }

}

extension AppStreamClientTypes {
    public enum UserStackAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directoryNotFound
        case internalError
        case stackNotFound
        case userNameNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStackAssociationErrorCode] {
            return [
                .directoryNotFound,
                .internalError,
                .stackNotFound,
                .userNameNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directoryNotFound: return "DIRECTORY_NOT_FOUND"
            case .internalError: return "INTERNAL_ERROR"
            case .stackNotFound: return "STACK_NOT_FOUND"
            case .userNameNotFound: return "USER_NAME_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStackAssociationErrorCode(rawValue: rawValue) ?? UserStackAssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes {
    public enum VisibilityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [VisibilityType] {
            return [
                .private,
                .public,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VisibilityType(rawValue: rawValue) ?? VisibilityType.sdkUnknown(rawValue)
        }
    }
}

extension AppStreamClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidlist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension AppStreamClientTypes {
    /// Describes VPC configuration information for fleets and image builders.
    public struct VpcConfig: Swift.Equatable {
        /// The identifiers of the security groups for the fleet or image builder.
        public var securityGroupIds: [Swift.String]?
        /// The identifiers of the subnets to which a network interface is attached from the fleet instance or image builder instance. Fleet instances use one or more subnets. Image builder instances use one subnet.
        public var subnetIds: [Swift.String]?

        public init (
            securityGroupIds: [Swift.String]? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.securityGroupIds = securityGroupIds
            self.subnetIds = subnetIds
        }
    }

}
