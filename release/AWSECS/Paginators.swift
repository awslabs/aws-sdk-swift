// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListAccountSettingsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAccountSettingsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAccountSettingsOutputResponse`
extension EcsClient {
    public func listAccountSettingsPaginated(input: ListAccountSettingsInput) -> ClientRuntime.PaginatorSequence<ListAccountSettingsInput, ListAccountSettingsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAccountSettingsInput, ListAccountSettingsOutputResponse>(input: input, inputKey: \ListAccountSettingsInput.nextToken, outputKey: \ListAccountSettingsOutputResponse.nextToken, paginationFunction: self.listAccountSettings(input:))
    }
}

extension ListAccountSettingsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountSettingsInput {
        return ListAccountSettingsInput(
            effectiveSettings: self.effectiveSettings,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            principalArn: self.principalArn,
            value: self.value
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAccountSettingsPaginated`
/// to access the nested member `[EcsClientTypes.Setting]`
/// - Returns: `[EcsClientTypes.Setting]`
extension PaginatorSequence where Input == ListAccountSettingsInput, Output == ListAccountSettingsOutputResponse {
    public func settings() async throws -> [EcsClientTypes.Setting] {
        return try await self.asyncCompactMap { item in item.settings }
    }
}

/// Paginate over `[ListAttributesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListAttributesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListAttributesOutputResponse`
extension EcsClient {
    public func listAttributesPaginated(input: ListAttributesInput) -> ClientRuntime.PaginatorSequence<ListAttributesInput, ListAttributesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListAttributesInput, ListAttributesOutputResponse>(input: input, inputKey: \ListAttributesInput.nextToken, outputKey: \ListAttributesOutputResponse.nextToken, paginationFunction: self.listAttributes(input:))
    }
}

extension ListAttributesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAttributesInput {
        return ListAttributesInput(
            attributeName: self.attributeName,
            attributeValue: self.attributeValue,
            cluster: self.cluster,
            maxResults: self.maxResults,
            nextToken: token,
            targetType: self.targetType
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listAttributesPaginated`
/// to access the nested member `[EcsClientTypes.Attribute]`
/// - Returns: `[EcsClientTypes.Attribute]`
extension PaginatorSequence where Input == ListAttributesInput, Output == ListAttributesOutputResponse {
    public func attributes() async throws -> [EcsClientTypes.Attribute] {
        return try await self.asyncCompactMap { item in item.attributes }
    }
}

/// Paginate over `[ListClustersOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListClustersInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListClustersOutputResponse`
extension EcsClient {
    public func listClustersPaginated(input: ListClustersInput) -> ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListClustersInput, ListClustersOutputResponse>(input: input, inputKey: \ListClustersInput.nextToken, outputKey: \ListClustersOutputResponse.nextToken, paginationFunction: self.listClusters(input:))
    }
}

extension ListClustersInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListClustersInput {
        return ListClustersInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listClustersPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListClustersInput, Output == ListClustersOutputResponse {
    public func clusterArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.clusterArns }
    }
}

/// Paginate over `[ListContainerInstancesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListContainerInstancesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListContainerInstancesOutputResponse`
extension EcsClient {
    public func listContainerInstancesPaginated(input: ListContainerInstancesInput) -> ClientRuntime.PaginatorSequence<ListContainerInstancesInput, ListContainerInstancesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListContainerInstancesInput, ListContainerInstancesOutputResponse>(input: input, inputKey: \ListContainerInstancesInput.nextToken, outputKey: \ListContainerInstancesOutputResponse.nextToken, paginationFunction: self.listContainerInstances(input:))
    }
}

extension ListContainerInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListContainerInstancesInput {
        return ListContainerInstancesInput(
            cluster: self.cluster,
            filter: self.filter,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listContainerInstancesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListContainerInstancesInput, Output == ListContainerInstancesOutputResponse {
    public func containerInstanceArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.containerInstanceArns }
    }
}

/// Paginate over `[ListServicesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListServicesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListServicesOutputResponse`
extension EcsClient {
    public func listServicesPaginated(input: ListServicesInput) -> ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListServicesInput, ListServicesOutputResponse>(input: input, inputKey: \ListServicesInput.nextToken, outputKey: \ListServicesOutputResponse.nextToken, paginationFunction: self.listServices(input:))
    }
}

extension ListServicesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListServicesInput {
        return ListServicesInput(
            cluster: self.cluster,
            launchType: self.launchType,
            maxResults: self.maxResults,
            nextToken: token,
            schedulingStrategy: self.schedulingStrategy
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listServicesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListServicesInput, Output == ListServicesOutputResponse {
    public func serviceArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.serviceArns }
    }
}

/// Paginate over `[ListTaskDefinitionFamiliesOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTaskDefinitionFamiliesInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTaskDefinitionFamiliesOutputResponse`
extension EcsClient {
    public func listTaskDefinitionFamiliesPaginated(input: ListTaskDefinitionFamiliesInput) -> ClientRuntime.PaginatorSequence<ListTaskDefinitionFamiliesInput, ListTaskDefinitionFamiliesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTaskDefinitionFamiliesInput, ListTaskDefinitionFamiliesOutputResponse>(input: input, inputKey: \ListTaskDefinitionFamiliesInput.nextToken, outputKey: \ListTaskDefinitionFamiliesOutputResponse.nextToken, paginationFunction: self.listTaskDefinitionFamilies(input:))
    }
}

extension ListTaskDefinitionFamiliesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTaskDefinitionFamiliesInput {
        return ListTaskDefinitionFamiliesInput(
            familyPrefix: self.familyPrefix,
            maxResults: self.maxResults,
            nextToken: token,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTaskDefinitionFamiliesPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListTaskDefinitionFamiliesInput, Output == ListTaskDefinitionFamiliesOutputResponse {
    public func families() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.families }
    }
}

/// Paginate over `[ListTaskDefinitionsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTaskDefinitionsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTaskDefinitionsOutputResponse`
extension EcsClient {
    public func listTaskDefinitionsPaginated(input: ListTaskDefinitionsInput) -> ClientRuntime.PaginatorSequence<ListTaskDefinitionsInput, ListTaskDefinitionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTaskDefinitionsInput, ListTaskDefinitionsOutputResponse>(input: input, inputKey: \ListTaskDefinitionsInput.nextToken, outputKey: \ListTaskDefinitionsOutputResponse.nextToken, paginationFunction: self.listTaskDefinitions(input:))
    }
}

extension ListTaskDefinitionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTaskDefinitionsInput {
        return ListTaskDefinitionsInput(
            familyPrefix: self.familyPrefix,
            maxResults: self.maxResults,
            nextToken: token,
            sort: self.sort,
            status: self.status
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTaskDefinitionsPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListTaskDefinitionsInput, Output == ListTaskDefinitionsOutputResponse {
    public func taskDefinitionArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.taskDefinitionArns }
    }
}

/// Paginate over `[ListTasksOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListTasksInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListTasksOutputResponse`
extension EcsClient {
    public func listTasksPaginated(input: ListTasksInput) -> ClientRuntime.PaginatorSequence<ListTasksInput, ListTasksOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTasksInput, ListTasksOutputResponse>(input: input, inputKey: \ListTasksInput.nextToken, outputKey: \ListTasksOutputResponse.nextToken, paginationFunction: self.listTasks(input:))
    }
}

extension ListTasksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTasksInput {
        return ListTasksInput(
            cluster: self.cluster,
            containerInstance: self.containerInstance,
            desiredStatus: self.desiredStatus,
            family: self.family,
            launchType: self.launchType,
            maxResults: self.maxResults,
            nextToken: token,
            serviceName: self.serviceName,
            startedBy: self.startedBy
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listTasksPaginated`
/// to access the nested member `[Swift.String]`
/// - Returns: `[Swift.String]`
extension PaginatorSequence where Input == ListTasksInput, Output == ListTasksOutputResponse {
    public func taskArns() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.taskArns }
    }
}
