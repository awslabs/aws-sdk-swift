// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ImagebuilderClientTypes.AdditionalInstanceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case systemsManagerAgent
        case userDataOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let systemsManagerAgent = systemsManagerAgent {
            try encodeContainer.encode(systemsManagerAgent, forKey: .systemsManagerAgent)
        }
        if let userDataOverride = userDataOverride {
            try encodeContainer.encode(userDataOverride, forKey: .userDataOverride)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemsManagerAgentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SystemsManagerAgent.self, forKey: .systemsManagerAgent)
        systemsManagerAgent = systemsManagerAgentDecoded
        let userDataOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userDataOverride)
        userDataOverride = userDataOverrideDecoded
    }
}

extension ImagebuilderClientTypes.AdditionalInstanceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AdditionalInstanceConfiguration(systemsManagerAgent: \(Swift.String(describing: systemsManagerAgent)), userDataOverride: \(Swift.String(describing: userDataOverride)))"}
}

extension ImagebuilderClientTypes {
    /// In addition to your infrastruction configuration, these settings provide an extra layer of
    /// 			control over your build instances. For instances where Image Builder installs the Systems Manager agent,
    /// 			you can choose whether to keep it for the AMI that you create. You can also specify commands
    /// 			to run on launch for all of your build instances.
    public struct AdditionalInstanceConfiguration: Swift.Equatable {
        /// Contains settings for the Systems Manager agent on your build instance.
        public var systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch
        /// 			your build instance.
        /// 		
        /// 			         The userDataOverride property replaces any commands that Image Builder might have added to ensure
        /// 				that Systems Manager is installed on your Linux build instance. If you override the user data,
        /// 				make sure that you add commands to install Systems Manager, if it is not pre-installed on your
        /// 				base image.
        /// 		
        public var userDataOverride: Swift.String?

        public init (
            systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent? = nil,
            userDataOverride: Swift.String? = nil
        )
        {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }
    }

}

extension ImagebuilderClientTypes.Ami: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case description
        case image
        case name
        case region
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ImagebuilderClientTypes.Ami: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Ami(accountId: \(Swift.String(describing: accountId)), description: \(Swift.String(describing: description)), image: \(Swift.String(describing: image)), name: \(Swift.String(describing: name)), region: \(Swift.String(describing: region)), state: \(Swift.String(describing: state)))"}
}

extension ImagebuilderClientTypes {
    ///  Details of an Amazon EC2 AMI.
    public struct Ami: Swift.Equatable {
        /// The account ID of the owner of the AMI.
        public var accountId: Swift.String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The AMI ID of the Amazon EC2 AMI.
        public var image: Swift.String?
        /// The name of the Amazon EC2 AMI.
        public var name: Swift.String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public var region: Swift.String?
        ///  Image state shows the image status and the reason for that status.
        public var state: ImagebuilderClientTypes.ImageState?

        public init (
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            image: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.AmiDistributionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiTags
        case description
        case kmsKeyId
        case launchPermission
        case name
        case targetAccountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiTags = amiTags {
            var amiTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .amiTags)
            for (dictKey0, tagmap0) in amiTags {
                try amiTagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let launchPermission = launchPermission {
            try encodeContainer.encode(launchPermission, forKey: .launchPermission)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAccountIds = targetAccountIds {
            var targetAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccountIds)
            for accountlist0 in targetAccountIds {
                try targetAccountIdsContainer.encode(accountlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetAccountIds)
        var targetAccountIdsDecoded0:[Swift.String]? = nil
        if let targetAccountIdsContainer = targetAccountIdsContainer {
            targetAccountIdsDecoded0 = [Swift.String]()
            for string0 in targetAccountIdsContainer {
                if let string0 = string0 {
                    targetAccountIdsDecoded0?.append(string0)
                }
            }
        }
        targetAccountIds = targetAccountIdsDecoded0
        let amiTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .amiTags)
        var amiTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let amiTagsContainer = amiTagsContainer {
            amiTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in amiTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    amiTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        amiTags = amiTagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let launchPermissionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LaunchPermissionConfiguration.self, forKey: .launchPermission)
        launchPermission = launchPermissionDecoded
    }
}

extension ImagebuilderClientTypes.AmiDistributionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AmiDistributionConfiguration(amiTags: \(Swift.String(describing: amiTags)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), launchPermission: \(Swift.String(describing: launchPermission)), name: \(Swift.String(describing: name)), targetAccountIds: \(Swift.String(describing: targetAccountIds)))"}
}

extension ImagebuilderClientTypes {
    ///  Define and configure the output AMIs of the pipeline.
    public struct AmiDistributionConfiguration: Swift.Equatable {
        /// The tags to apply to AMIs distributed to this Region.
        public var amiTags: [Swift.String:Swift.String]?
        /// The description of the distribution configuration. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The KMS key identifier used to encrypt the distributed image.
        public var kmsKeyId: Swift.String?
        ///  Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to launch
        /// 			instances.
        public var launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public var name: Swift.String?
        /// The ID of an account to which you want to distribute an image.
        public var targetAccountIds: [Swift.String]?

        public init (
            amiTags: [Swift.String:Swift.String]? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration? = nil,
            name: Swift.String? = nil,
            targetAccountIds: [Swift.String]? = nil
        )
        {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }
    }

}

extension CallRateLimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CallRateLimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension CallRateLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CallRateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the permitted request rate for the specific operation.
public struct CallRateLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CallRateLimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension CallRateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CancelImageCreationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelImageCreationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelImageCreationOutputError>
}

extension CancelImageCreationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelImageCreationInput(clientToken: \(Swift.String(describing: clientToken)), imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)))"}
}

extension CancelImageCreationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageBuildVersionArn = imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
    }
}

public struct CancelImageCreationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelImageCreationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelImageCreationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelImageCreationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelImageCreationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelImageCreationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelImageCreationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelImageCreationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelImageCreationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelImageCreationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CancelImageCreation"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelImageCreationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelImageCreationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelImageCreationOutputError>
}

public struct CancelImageCreationInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image whose creation you want to cancel.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct CancelImageCreationInputBody: Swift.Equatable {
    public let imageBuildVersionArn: Swift.String?
    public let clientToken: Swift.String?
}

extension CancelImageCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelImageCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelImageCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelImageCreationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelImageCreationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelImageCreationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CancelImageCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CancelImageCreationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CancelImageCreationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image whose creation has been cancelled.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CancelImageCreationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imageBuildVersionArn: Swift.String?
}

extension CancelImageCreationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ClientException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ClientException(message: \(Swift.String(describing: message)))"}
}

extension ClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// These errors are usually caused by a client action, such as using an action or resource on
/// 			behalf of a user that doesn't have permissions to use the action or resource, or specifying an
/// 			invalid resource identifier.
public struct ClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Component: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case data
        case dateCreated
        case description
        case encrypted
        case kmsKeyId
        case name
        case owner
        case parameters
        case platform
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameterdetaillist0 in parameters {
                try parametersContainer.encode(componentparameterdetaillist0)
            }
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameterDetail?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameterDetail]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameterDetail]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.Component: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Component(arn: \(Swift.String(describing: arn)), changeDescription: \(Swift.String(describing: changeDescription)), data: \(Swift.String(describing: data)), dateCreated: \(Swift.String(describing: dateCreated)), description: \(Swift.String(describing: description)), encrypted: \(Swift.String(describing: encrypted)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parameters: \(Swift.String(describing: parameters)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), supportedOsVersions: \(Swift.String(describing: supportedOsVersions)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// A detailed view of a component.
    public struct Component: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description of the component.
        public var changeDescription: Swift.String?
        /// The data of the component.
        public var data: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The encryption status of the component.
        public var encrypted: Swift.Bool?
        /// The KMS key identifier used to encrypt the component.
        public var kmsKeyId: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// Contains parameter details for each of the parameters that are defined for the component.
        public var parameters: [ImagebuilderClientTypes.ComponentParameterDetail]?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Describes the current status of the component. This is used for
        /// 			components that are no longer active.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags associated with the component.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            data: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameterDetail]? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ComponentConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameterlist0 in parameters {
                try parametersContainer.encode(componentparameterlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ImagebuilderClientTypes.ComponentConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentConfiguration(componentArn: \(Swift.String(describing: componentArn)), parameters: \(Swift.String(describing: parameters)))"}
}

extension ImagebuilderClientTypes {
    ///  Configuration details of the component.
    public struct ComponentConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var componentArn: Swift.String?
        /// A group of parameter settings that are used to configure the component for a specific recipe.
        public var parameters: [ImagebuilderClientTypes.ComponentParameter]?

        public init (
            componentArn: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameter]? = nil
        )
        {
            self.componentArn = componentArn
            self.parameters = parameters
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shell
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentFormat] {
            return [
                .shell,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shell: return "SHELL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentFormat(rawValue: rawValue) ?? ComponentFormat.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for componentparametervaluelist0 in value {
                try valueContainer.encode(componentparametervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension ImagebuilderClientTypes.ComponentParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentParameter(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension ImagebuilderClientTypes {
    /// Contains a key/value pair that sets the named component parameter.
    public struct ComponentParameter: Swift.Equatable {
        /// The name of the component parameter to set.
        /// This member is required.
        public var name: Swift.String?
        /// Sets the value for the named component parameter.
        /// This member is required.
        public var value: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ImagebuilderClientTypes.ComponentParameterDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            var defaultValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValue)
            for componentparametervaluelist0 in defaultValue {
                try defaultValueContainer.encode(componentparametervaluelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let defaultValueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultValue)
        var defaultValueDecoded0:[Swift.String]? = nil
        if let defaultValueContainer = defaultValueContainer {
            defaultValueDecoded0 = [Swift.String]()
            for string0 in defaultValueContainer {
                if let string0 = string0 {
                    defaultValueDecoded0?.append(string0)
                }
            }
        }
        defaultValue = defaultValueDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ImagebuilderClientTypes.ComponentParameterDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentParameterDetail(defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ImagebuilderClientTypes {
    /// Defines a parameter that is used to provide configuration details for the component.
    public struct ComponentParameterDetail: Swift.Equatable {
        /// The default value of this parameter if no input is provided.
        public var defaultValue: [Swift.String]?
        /// Describes this parameter.
        public var description: Swift.String?
        /// The name of this input parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of input this parameter provides. The currently supported value is "string".
        /// This member is required.
        public var type: Swift.String?

        public init (
            defaultValue: [Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension ImagebuilderClientTypes.ComponentState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes.ComponentState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentState(reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension ImagebuilderClientTypes {
    /// A group of fields that describe the current status of components
    /// 			that are no longer active.
    public struct ComponentState: Swift.Equatable {
        /// Describes how or why the component changed state.
        public var reason: Swift.String?
        /// The current state of the component.
        public var status: ImagebuilderClientTypes.ComponentStatus?

        public init (
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ComponentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentStatus(rawValue: rawValue) ?? ComponentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case dateCreated
        case description
        case name
        case owner
        case platform
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.ComponentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentSummary(arn: \(Swift.String(describing: arn)), changeDescription: \(Swift.String(describing: changeDescription)), dateCreated: \(Swift.String(describing: dateCreated)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), supportedOsVersions: \(Swift.String(describing: supportedOsVersions)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// A high-level summary of a component.
    public struct ComponentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description of the component.
        public var changeDescription: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Describes the current status of the component.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags associated with the component.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .build,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case description
        case name
        case owner
        case platform
        case supportedOsVersions
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ImagebuilderClientTypes.ComponentVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ComponentVersion(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), supportedOsVersions: \(Swift.String(describing: supportedOsVersions)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Amazon Web Services TOE component.
    public struct ComponentVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// 		
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        /// 	           <ol>
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        /// 		
        ///
        /// 			               Version ARNs have only the first three nodes: <major>.<minor>.<patch>
        /// 		
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        /// 		
        ///             </ol>
        /// 		
        public var arn: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// he operating system (OS) version supported by the component. If the OS information is
        /// 			available, a prefix match is performed against the base image OS version during image recipe
        /// 			creation.
        public var supportedOsVersions: [Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only
        /// 			to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The semantic version of the component.
        /// 		
        /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			
        ///                Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			
        ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			
        ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        /// 		
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.Container: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUris
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUris = imageUris {
            var imageUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageUris)
            for stringlist0 in imageUris {
                try imageUrisContainer.encode(stringlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageUris)
        var imageUrisDecoded0:[Swift.String]? = nil
        if let imageUrisContainer = imageUrisContainer {
            imageUrisDecoded0 = [Swift.String]()
            for string0 in imageUrisContainer {
                if let string0 = string0 {
                    imageUrisDecoded0?.append(string0)
                }
            }
        }
        imageUris = imageUrisDecoded0
    }
}

extension ImagebuilderClientTypes.Container: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Container(imageUris: \(Swift.String(describing: imageUris)), region: \(Swift.String(describing: region)))"}
}

extension ImagebuilderClientTypes {
    /// A container encapsulates the runtime environment for an application.
    public struct Container: Swift.Equatable {
        /// A list of URIs for containers created in the context Region.
        public var imageUris: [Swift.String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public var region: Swift.String?

        public init (
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.imageUris = imageUris
            self.region = region
        }
    }

}

extension ImagebuilderClientTypes.ContainerDistributionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerTags
        case description
        case targetRepository
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerTags = containerTags {
            var containerTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerTags)
            for stringlist0 in containerTags {
                try containerTagsContainer.encode(stringlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let containerTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .containerTags)
        var containerTagsDecoded0:[Swift.String]? = nil
        if let containerTagsContainer = containerTagsContainer {
            containerTagsDecoded0 = [Swift.String]()
            for string0 in containerTagsContainer {
                if let string0 = string0 {
                    containerTagsDecoded0?.append(string0)
                }
            }
        }
        containerTags = containerTagsDecoded0
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes.ContainerDistributionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContainerDistributionConfiguration(containerTags: \(Swift.String(describing: containerTags)), description: \(Swift.String(describing: description)), targetRepository: \(Swift.String(describing: targetRepository)))"}
}

extension ImagebuilderClientTypes {
    /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
    public struct ContainerDistributionConfiguration: Swift.Equatable {
        /// Tags that are attached to the container distribution configuration.
        public var containerTags: [Swift.String]?
        /// The description of the container distribution configuration.
        public var description: Swift.String?
        /// The destination repository for the container distribution configuration.
        /// This member is required.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?

        public init (
            containerTags: [Swift.String]? = nil,
            description: Swift.String? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil
        )
        {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipe: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case components
        case containerType
        case dateCreated
        case description
        case dockerfileTemplateData
        case encrypted
        case instanceConfiguration
        case kmsKeyId
        case name
        case owner
        case parentImage
        case platform
        case tags
        case targetRepository
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes.ContainerRecipe: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContainerRecipe(arn: \(Swift.String(describing: arn)), components: \(Swift.String(describing: components)), containerType: \(Swift.String(describing: containerType)), dateCreated: \(Swift.String(describing: dateCreated)), description: \(Swift.String(describing: description)), dockerfileTemplateData: \(Swift.String(describing: dockerfileTemplateData)), encrypted: \(Swift.String(describing: encrypted)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parentImage: \(Swift.String(describing: parentImage)), platform: \(Swift.String(describing: platform)), tags: \(Swift.String(describing: tags)), targetRepository: \(Swift.String(describing: targetRepository)), version: \(Swift.String(describing: version)), workingDirectory: \(Swift.String(describing: workingDirectory)))"}
}

extension ImagebuilderClientTypes {
    /// A container recipe.
    public struct ContainerRecipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe.
        /// 		
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        /// 	           <ol>
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        /// 		
        ///
        /// 			               Version ARNs have only the first three nodes: <major>.<minor>.<patch>
        /// 		
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        /// 		
        ///             </ol>
        /// 		
        public var arn: Swift.String?
        /// Components for build and test that are included in the container recipe.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the container recipe.
        public var description: Swift.String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public var dockerfileTemplateData: Swift.String?
        /// A flag that indicates if the target container is encrypted.
        public var encrypted: Swift.Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public var kmsKeyId: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?
        /// The destination repository for the container image.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
        /// The semantic version of the container recipe.
        /// 		
        /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			
        ///                Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			
        ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			
        ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        /// 		
        public var version: Swift.String?
        /// The working directory for use during build and test workflows.
        public var workingDirectory: Swift.String?

        public init (
            arn: Swift.String? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            dockerfileTemplateData: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipeSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerType
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.ContainerRecipeSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ContainerRecipeSummary(arn: \(Swift.String(describing: arn)), containerType: \(Swift.String(describing: containerType)), dateCreated: \(Swift.String(describing: dateCreated)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parentImage: \(Swift.String(describing: parentImage)), platform: \(Swift.String(describing: platform)), tags: \(Swift.String(describing: tags)))"}
}

extension ImagebuilderClientTypes {
    /// A summary of a container recipe
    public struct ContainerRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public var arn: Swift.String?
        /// Specifies the type of container, such as "Docker".
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ContainerRepositoryService: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerRepositoryService] {
            return [
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerRepositoryService(rawValue: rawValue) ?? ContainerRepositoryService.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum ContainerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentOutputError>
}

extension CreateComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComponentInput(changeDescription: \(Swift.String(describing: changeDescription)), clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), description: \(Swift.String(describing: description)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), semanticVersion: \(Swift.String(describing: semanticVersion)), supportedOsVersions: \(Swift.String(describing: supportedOsVersions)), tags: \(Swift.String(describing: tags)), uri: \(Swift.String(describing: uri)))"}
}

extension CreateComponentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversionlist0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct CreateComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentOutputError>
}

public struct CreateComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentOutputError>
}

public struct CreateComponentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentOutputError>
}

public struct CreateComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateComponent"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateComponentOutputError>
}

public struct CreateComponentInput: Swift.Equatable {
    /// The change description of the component. Describes what change has been made in this
    /// 			version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// The idempotency token of the component.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data of the component. Used to specify the data inline. Either data or
    /// 			uri can be used to specify the data within the component.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Assignment: For the first three nodes you can assign any positive integer value, including
    /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
    /// 	build number to the fourth node.
    /// 			
    ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
    /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
    /// 	a date, such as 2021.01.01.
    /// 		
    /// This member is required.
    public var semanticVersion: Swift.String?
    ///  The operating system (OS) version supported by the component. If the OS information is
    /// 			available, a prefix match is performed against the base image OS version during image recipe
    /// 			creation.
    public var supportedOsVersions: [Swift.String]?
    /// The tags of the component.
    public var tags: [Swift.String:Swift.String]?
    /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to
    /// 			access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service
    /// 			quota. Either data or uri can be used to specify the data within the
    /// 			component.
    public var uri: Swift.String?

    public init (
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        supportedOsVersions: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.uri = uri
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let semanticVersion: Swift.String?
    public let description: Swift.String?
    public let changeDescription: Swift.String?
    public let platform: ImagebuilderClientTypes.Platform?
    public let supportedOsVersions: [Swift.String]?
    public let data: Swift.String?
    public let uri: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateComponentOutputResponse(clientToken: \(Swift.String(describing: clientToken)), componentBuildVersionArn: \(Swift.String(describing: componentBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateComponentOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the component that was created by this request.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateComponentOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let componentBuildVersionArn: Swift.String?
}

extension CreateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

public struct CreateContainerRecipeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContainerRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContainerRecipeOutputError>
}

extension CreateContainerRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContainerRecipeInput(clientToken: \(Swift.String(describing: clientToken)), components: \(Swift.String(describing: components)), containerType: \(Swift.String(describing: containerType)), description: \(Swift.String(describing: description)), dockerfileTemplateData: \(Swift.String(describing: dockerfileTemplateData)), dockerfileTemplateUri: \(Swift.String(describing: dockerfileTemplateUri)), imageOsVersionOverride: \(Swift.String(describing: imageOsVersionOverride)), instanceConfiguration: \(Swift.String(describing: instanceConfiguration)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), parentImage: \(Swift.String(describing: parentImage)), platformOverride: \(Swift.String(describing: platformOverride)), semanticVersion: \(Swift.String(describing: semanticVersion)), tags: \(Swift.String(describing: tags)), targetRepository: \(Swift.String(describing: targetRepository)), workingDirectory: \(Swift.String(describing: workingDirectory)))"}
}

extension CreateContainerRecipeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let containerType = containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let dockerfileTemplateUri = dockerfileTemplateUri {
            try encodeContainer.encode(dockerfileTemplateUri, forKey: .dockerfileTemplateUri)
        }
        if let imageOsVersionOverride = imageOsVersionOverride {
            try encodeContainer.encode(imageOsVersionOverride, forKey: .imageOsVersionOverride)
        }
        if let instanceConfiguration = instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platformOverride = platformOverride {
            try encodeContainer.encode(platformOverride.rawValue, forKey: .platformOverride)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

public struct CreateContainerRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContainerRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateContainerRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateContainerRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateContainerRecipeOutputError>
}

public struct CreateContainerRecipeInput: Swift.Equatable {
    /// The client token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Components for build and test that are included in the container recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The type of container to create.
    /// This member is required.
    public var containerType: ImagebuilderClientTypes.ContainerType?
    /// The description of the container recipe.
    public var description: Swift.String?
    /// The Dockerfile template used to build your image as an inline data blob.
    public var dockerfileTemplateData: Swift.String?
    /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
    public var dockerfileTemplateUri: Swift.String?
    /// Specifies the operating system version for the base image.
    public var imageOsVersionOverride: Swift.String?
    /// A group of options that can be used to configure an instance for building and testing container images.
    public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    /// Identifies which KMS key is used to encrypt the container image.
    public var kmsKeyId: Swift.String?
    /// The name of the container recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image for the container recipe.
    /// This member is required.
    public var parentImage: Swift.String?
    /// Specifies the operating system platform when you use a custom base image.
    public var platformOverride: ImagebuilderClientTypes.Platform?
    /// The semantic version of the container recipe. This version follows the semantic version syntax.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Assignment: For the first three nodes you can assign any positive integer value, including
    /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
    /// 	build number to the fourth node.
    /// 			
    ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
    /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
    /// 	a date, such as 2021.01.01.
    /// 		
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the container recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The destination repository for the container image.
    /// This member is required.
    public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    /// The working directory for use during build and test workflows.
    public var workingDirectory: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        containerType: ImagebuilderClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        dockerfileTemplateData: Swift.String? = nil,
        dockerfileTemplateUri: Swift.String? = nil,
        imageOsVersionOverride: Swift.String? = nil,
        instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        platformOverride: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.containerType = containerType
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.dockerfileTemplateUri = dockerfileTemplateUri
        self.imageOsVersionOverride = imageOsVersionOverride
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.parentImage = parentImage
        self.platformOverride = platformOverride
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.targetRepository = targetRepository
        self.workingDirectory = workingDirectory
    }
}

struct CreateContainerRecipeInputBody: Swift.Equatable {
    public let containerType: ImagebuilderClientTypes.ContainerType?
    public let name: Swift.String?
    public let description: Swift.String?
    public let semanticVersion: Swift.String?
    public let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    public let instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    public let dockerfileTemplateData: Swift.String?
    public let dockerfileTemplateUri: Swift.String?
    public let platformOverride: ImagebuilderClientTypes.Platform?
    public let imageOsVersionOverride: Swift.String?
    public let parentImage: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let workingDirectory: Swift.String?
    public let targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    public let kmsKeyId: Swift.String?
    public let clientToken: Swift.String?
}

extension CreateContainerRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let dockerfileTemplateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateUri)
        dockerfileTemplateUri = dockerfileTemplateUriDecoded
        let platformOverrideDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platformOverride)
        platformOverride = platformOverrideDecoded
        let imageOsVersionOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOsVersionOverride)
        imageOsVersionOverride = imageOsVersionOverrideDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContainerRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateContainerRecipeOutputResponse(clientToken: \(Swift.String(describing: clientToken)), containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateContainerRecipeOutputResponse: Swift.Equatable {
    /// The client token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct CreateContainerRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let containerRecipeArn: Swift.String?
}

extension CreateContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

public struct CreateDistributionConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionConfigurationOutputError>
}

extension CreateDistributionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), distributions: \(Swift.String(describing: distributions)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDistributionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDistributionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDistributionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateDistributionConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDistributionConfigurationOutputError>
}

public struct CreateDistributionConfigurationInput: Swift.Equatable {
    ///  The idempotency token of the distribution configuration.
    /// This member is required.
    public var clientToken: Swift.String?
    ///  The description of the distribution configuration.
    public var description: Swift.String?
    ///  The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?
    ///  The name of the distribution configuration.
    /// This member is required.
    public var name: Swift.String?
    ///  The tags of the distribution configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
    }
}

struct CreateDistributionConfigurationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let distributions: [ImagebuilderClientTypes.Distribution]?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDistributionConfigurationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateDistributionConfigurationOutputResponse: Swift.Equatable {
    ///  The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    ///  The Amazon Resource Name (ARN) of the distribution configuration that was created by this
    /// 			request.
    public var distributionConfigurationArn: Swift.String?
    ///  The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct CreateDistributionConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let distributionConfigurationArn: Swift.String?
}

extension CreateDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

public struct CreateImageInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageOutputError>
}

extension CreateImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageInput(clientToken: \(Swift.String(describing: clientToken)), containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(Swift.String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), imageTestsConfiguration: \(Swift.String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateImageInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageOutputError>
}

public struct CreateImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageOutputError>
}

public struct CreateImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageOutputError>
}

public struct CreateImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateImage"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageOutputError>
}

public struct CreateImageInput: Swift.Equatable {
    ///  The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
    public var containerRecipeArn: Swift.String?
    ///  The Amazon Resource Name (ARN) of the distribution configuration that defines and
    /// 			configures the outputs of your pipeline.
    public var distributionConfigurationArn: Swift.String?
    ///  Collects additional information about the image being created, including the operating
    /// 			system (OS) version and package list. This information is used to enhance the overall
    /// 			experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    ///  The Amazon Resource Name (ARN) of the image recipe that defines how images are
    /// 			configured, tested, and assessed.
    public var imageRecipeArn: Swift.String?
    ///  The image tests configuration of the image.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    ///  The Amazon Resource Name (ARN) of the infrastructure configuration that defines the
    /// 			environment in which your image will be built and tested.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    ///  The tags of the image.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.tags = tags
    }
}

struct CreateImageInputBody: Swift.Equatable {
    public let imageRecipeArn: Swift.String?
    public let containerRecipeArn: Swift.String?
    public let distributionConfigurationArn: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
    public let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Swift.Bool?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageOutputResponse: Swift.Equatable {
    ///  The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    ///  The Amazon Resource Name (ARN) of the image that was created by this request.
    public var imageBuildVersionArn: Swift.String?
    ///  The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateImageOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imageBuildVersionArn: Swift.String?
}

extension CreateImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

public struct CreateImagePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImagePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImagePipelineOutputError>
}

extension CreateImagePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImagePipelineInput(clientToken: \(Swift.String(describing: clientToken)), containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), description: \(Swift.String(describing: description)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(Swift.String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), imageTestsConfiguration: \(Swift.String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), name: \(Swift.String(describing: name)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateImagePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateImagePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImagePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImagePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateImagePipeline"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImagePipelineOutputError>
}

public struct CreateImagePipelineInput: Swift.Equatable {
    ///  The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
    public var containerRecipeArn: Swift.String?
    ///  The description of the image pipeline.
    public var description: Swift.String?
    ///  The Amazon Resource Name (ARN) of the distribution configuration that will be used to
    /// 			configure and distribute images created by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    ///  Collects additional information about the image being created, including the operating
    /// 			system (OS) version and package list. This information is used to enhance the overall
    /// 			experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    ///  The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
    /// 			created by this image pipeline.
    public var imageRecipeArn: Swift.String?
    ///  The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    ///  The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
    /// 			build images created by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    ///  The name of the image pipeline.
    /// This member is required.
    public var name: Swift.String?
    ///  The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    ///  The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?
    ///  The tags of the image pipeline.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

struct CreateImagePipelineInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let imageRecipeArn: Swift.String?
    public let containerRecipeArn: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
    public let distributionConfigurationArn: Swift.String?
    public let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Swift.Bool?
    public let schedule: ImagebuilderClientTypes.Schedule?
    public let status: ImagebuilderClientTypes.PipelineStatus?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImagePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImagePipelineOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imagePipelineArn: \(Swift.String(describing: imagePipelineArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImagePipelineOutputResponse: Swift.Equatable {
    ///  The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    ///  The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
    public var imagePipelineArn: Swift.String?
    ///  The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct CreateImagePipelineOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imagePipelineArn: Swift.String?
}

extension CreateImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

public struct CreateImageRecipeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageRecipeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageRecipeOutputError>
}

extension CreateImageRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageRecipeInput(additionalInstanceConfiguration: \(Swift.String(describing: additionalInstanceConfiguration)), blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), clientToken: \(Swift.String(describing: clientToken)), components: \(Swift.String(describing: components)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), parentImage: \(Swift.String(describing: parentImage)), semanticVersion: \(Swift.String(describing: semanticVersion)), tags: \(Swift.String(describing: tags)), workingDirectory: \(Swift.String(describing: workingDirectory)))"}
}

extension CreateImageRecipeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

public struct CreateImageRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateImageRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateImageRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateImageRecipeOutputError>
}

public struct CreateImageRecipeInput: Swift.Equatable {
    /// Specify additional settings and launch scripts for your build instances.
    public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    /// The block device mappings of the image recipe.
    public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The components of the image recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    ///  The description of the image recipe.
    public var description: Swift.String?
    ///  The name of the image recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image of the image recipe. The value of the string can be the ARN of the base
    /// 			image or an AMI ID. The format for the ARN follows this example:
    /// 			arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x.
    /// 			You can provide the specific version that you want to use, or you can use a wildcard in
    /// 			all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI,
    /// 			and the AMI must be in the same Region in which you are using Image Builder.
    /// This member is required.
    public var parentImage: Swift.String?
    /// The semantic version of the image recipe. This version follows the semantic version syntax.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Assignment: For the first three nodes you can assign any positive integer value, including
    /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
    /// 	build number to the fourth node.
    /// 			
    ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
    /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
    /// 	a date, such as 2021.01.01.
    /// 		
    /// This member is required.
    public var semanticVersion: Swift.String?
    ///  The tags of the image recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The working directory used during build and test workflows.
    public var workingDirectory: Swift.String?

    public init (
        additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
        blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.additionalInstanceConfiguration = additionalInstanceConfiguration
        self.blockDeviceMappings = blockDeviceMappings
        self.clientToken = clientToken
        self.components = components
        self.description = description
        self.name = name
        self.parentImage = parentImage
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateImageRecipeInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let semanticVersion: Swift.String?
    public let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    public let parentImage: Swift.String?
    public let blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    public let tags: [Swift.String:Swift.String]?
    public let workingDirectory: Swift.String?
    public let additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    public let clientToken: Swift.String?
}

extension CreateImageRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateImageRecipeOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageRecipeOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct CreateImageRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imageRecipeArn: Swift.String?
}

extension CreateImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

public struct CreateInfrastructureConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInfrastructureConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInfrastructureConfigurationOutputError>
}

extension CreateInfrastructureConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInfrastructureConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), instanceMetadataOptions: \(Swift.String(describing: instanceMetadataOptions)), instanceProfileName: \(Swift.String(describing: instanceProfileName)), instanceTypes: \(Swift.String(describing: instanceTypes)), keyPair: \(Swift.String(describing: keyPair)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), resourceTags: \(Swift.String(describing: resourceTags)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), subnetId: \(Swift.String(describing: subnetId)), tags: \(Swift.String(describing: tags)), terminateInstanceOnFailure: \(Swift.String(describing: terminateInstanceOnFailure)))"}
}

extension CreateInfrastructureConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

public struct CreateInfrastructureConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInfrastructureConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateInfrastructureConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/CreateInfrastructureConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateInfrastructureConfigurationOutputError>
}

public struct CreateInfrastructureConfigurationInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that
    /// 			pipeline builds use to launch EC2 build and test instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more
    /// 			instance types to use for this build. The service will pick one of these instance types based
    /// 			on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug
    /// 			the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The name of the infrastructure configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The SNS topic on which to send image build events.
    public var snsTopicArn: Swift.String?
    /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
    public var subnetId: Swift.String?
    /// The tags of the infrastructure configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to
    /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build
    /// 			or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct CreateInfrastructureConfigurationInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let description: Swift.String?
    public let instanceTypes: [Swift.String]?
    public let instanceProfileName: Swift.String?
    public let securityGroupIds: [Swift.String]?
    public let subnetId: Swift.String?
    public let logging: ImagebuilderClientTypes.Logging?
    public let keyPair: Swift.String?
    public let terminateInstanceOnFailure: Swift.Bool?
    public let snsTopicArn: Swift.String?
    public let resourceTags: [Swift.String:Swift.String]?
    public let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension CreateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInfrastructureConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateInfrastructureConfigurationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension CreateInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by
    /// 			this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct CreateInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
}

extension CreateInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension DeleteComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteComponentInput(componentBuildVersionArn: \(Swift.String(describing: componentBuildVersionArn)))"}
}

extension DeleteComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentBuildVersionArn = input.operationInput.componentBuildVersionArn {
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(componentBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteComponentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteComponent"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component build version to delete.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteComponentOutputResponse(componentBuildVersionArn: \(Swift.String(describing: componentBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component build version that was deleted.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteComponentOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let componentBuildVersionArn: Swift.String?
}

extension DeleteComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension DeleteContainerRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContainerRecipeInput(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)))"}
}

extension DeleteContainerRecipeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteContainerRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContainerRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteContainerRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteContainerRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteContainerRecipeOutputError>
}

public struct DeleteContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to delete.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct DeleteContainerRecipeInputBody: Swift.Equatable {
}

extension DeleteContainerRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteContainerRecipeOutputResponse(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteContainerRecipeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct DeleteContainerRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let containerRecipeArn: Swift.String?
}

extension DeleteContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

extension DeleteDistributionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionConfigurationInput(distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)))"}
}

extension DeleteDistributionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDistributionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigurationArn = input.operationInput.distributionConfigurationArn {
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(distributionConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDistributionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteDistributionConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDistributionConfigurationOutputError>
}

public struct DeleteDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct DeleteDistributionConfigurationInputBody: Swift.Equatable {
}

extension DeleteDistributionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDistributionConfigurationOutputResponse(distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteDistributionConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let distributionConfigurationArn: Swift.String?
}

extension DeleteDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

extension DeleteImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageInput(imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)))"}
}

extension DeleteImageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageBuildVersionArn = input.operationInput.imageBuildVersionArn {
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(imageBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteImage"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageOutputError>
}

public struct DeleteImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct DeleteImageInputBody: Swift.Equatable {
}

extension DeleteImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageOutputResponse(imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource that was deleted.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteImageOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageBuildVersionArn: Swift.String?
}

extension DeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension DeleteImagePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImagePipelineInput(imagePipelineArn: \(Swift.String(describing: imagePipelineArn)))"}
}

extension DeleteImagePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteImagePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imagePipelineArn = input.operationInput.imagePipelineArn {
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            input.builder.withQueryItem(imagePipelineArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImagePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteImagePipeline"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImagePipelineOutputError>
}

public struct DeleteImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline to delete.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct DeleteImagePipelineInputBody: Swift.Equatable {
}

extension DeleteImagePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImagePipelineOutputResponse(imagePipelineArn: \(Swift.String(describing: imagePipelineArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImagePipelineOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct DeleteImagePipelineOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imagePipelineArn: Swift.String?
}

extension DeleteImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

extension DeleteImageRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageRecipeInput(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)))"}
}

extension DeleteImageRecipeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteImageRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteImageRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteImageRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteImageRecipeOutputError>
}

public struct DeleteImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe to delete.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct DeleteImageRecipeInputBody: Swift.Equatable {
}

extension DeleteImageRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteImageRecipeOutputResponse(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageRecipeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct DeleteImageRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageRecipeArn: Swift.String?
}

extension DeleteImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension DeleteInfrastructureConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInfrastructureConfigurationInput(infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)))"}
}

extension DeleteInfrastructureConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteInfrastructureConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let infrastructureConfigurationArn = input.operationInput.infrastructureConfigurationArn {
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(infrastructureConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInfrastructureConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteInfrastructureConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/DeleteInfrastructureConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteInfrastructureConfigurationOutputError>
}

public struct DeleteInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct DeleteInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension DeleteInfrastructureConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInfrastructureConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteInfrastructureConfigurationOutputResponse(infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension DeleteInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
}

extension DeleteInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension ImagebuilderClientTypes.Distribution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiDistributionConfiguration
        case containerDistributionConfiguration
        case launchTemplateConfigurations
        case licenseConfigurationArns
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiDistributionConfiguration = amiDistributionConfiguration {
            try encodeContainer.encode(amiDistributionConfiguration, forKey: .amiDistributionConfiguration)
        }
        if let containerDistributionConfiguration = containerDistributionConfiguration {
            try encodeContainer.encode(containerDistributionConfiguration, forKey: .containerDistributionConfiguration)
        }
        if let launchTemplateConfigurations = launchTemplateConfigurations {
            var launchTemplateConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchTemplateConfigurations)
            for launchtemplateconfigurationlist0 in launchTemplateConfigurations {
                try launchTemplateConfigurationsContainer.encode(launchtemplateconfigurationlist0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for licenseconfigurationarnlist0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(licenseconfigurationarnlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let amiDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AmiDistributionConfiguration.self, forKey: .amiDistributionConfiguration)
        amiDistributionConfiguration = amiDistributionConfigurationDecoded
        let containerDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerDistributionConfiguration.self, forKey: .containerDistributionConfiguration)
        containerDistributionConfiguration = containerDistributionConfigurationDecoded
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let launchTemplateConfigurationsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LaunchTemplateConfiguration?].self, forKey: .launchTemplateConfigurations)
        var launchTemplateConfigurationsDecoded0:[ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil
        if let launchTemplateConfigurationsContainer = launchTemplateConfigurationsContainer {
            launchTemplateConfigurationsDecoded0 = [ImagebuilderClientTypes.LaunchTemplateConfiguration]()
            for structure0 in launchTemplateConfigurationsContainer {
                if let structure0 = structure0 {
                    launchTemplateConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        launchTemplateConfigurations = launchTemplateConfigurationsDecoded0
    }
}

extension ImagebuilderClientTypes.Distribution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Distribution(amiDistributionConfiguration: \(Swift.String(describing: amiDistributionConfiguration)), containerDistributionConfiguration: \(Swift.String(describing: containerDistributionConfiguration)), launchTemplateConfigurations: \(Swift.String(describing: launchTemplateConfigurations)), licenseConfigurationArns: \(Swift.String(describing: licenseConfigurationArns)), region: \(Swift.String(describing: region)))"}
}

extension ImagebuilderClientTypes {
    ///  Defines the settings for a specific Region.
    public struct Distribution: Swift.Equatable {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public var amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing
        /// 			in a specific Region.
        public var containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration?
        /// A group of launchTemplateConfiguration settings that apply to image distribution
        /// 			for specified accounts.
        public var launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified
        /// 			Region.
        public var licenseConfigurationArns: [Swift.String]?
        /// The target Region.
        /// This member is required.
        public var region: Swift.String?

        public init (
            amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration? = nil,
            containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration? = nil,
            launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil,
            licenseConfigurationArns: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case distributions
        case name
        case tags
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeoutMinutes = timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.DistributionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfiguration(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), dateUpdated: \(Swift.String(describing: dateUpdated)), description: \(Swift.String(describing: description)), distributions: \(Swift.String(describing: distributions)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), timeoutMinutes: \(Swift.String(describing: timeoutMinutes)))"}
}

extension ImagebuilderClientTypes {
    /// A distribution configuration.
    public struct DistributionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which this distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which this distribution configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The distribution objects that apply Region-specific
        /// 			settings for the deployment of the image to targeted Regions.
        public var distributions: [ImagebuilderClientTypes.Distribution]?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// The tags of the distribution configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The maximum duration in minutes for this distribution configuration.
        /// This member is required.
        public var timeoutMinutes: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributions: [ImagebuilderClientTypes.Distribution]? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case name
        case regions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension ImagebuilderClientTypes.DistributionConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DistributionConfigurationSummary(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), dateUpdated: \(Swift.String(describing: dateUpdated)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), regions: \(Swift.String(describing: regions)), tags: \(Swift.String(describing: tags)))"}
}

extension ImagebuilderClientTypes {
    /// A high-level overview of a distribution configuration.
    public struct DistributionConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which the distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the distribution configuration was updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// A list of Regions where the container image is distributed to.
        public var regions: [Swift.String]?
        /// The tags associated with the distribution configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let encrypted = encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotId = snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let throughput = throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeSize = volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EbsInstanceBlockDeviceSpecification(deleteOnTermination: \(Swift.String(describing: deleteOnTermination)), encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), snapshotId: \(Swift.String(describing: snapshotId)), throughput: \(Swift.String(describing: throughput)), volumeSize: \(Swift.String(describing: volumeSize)), volumeType: \(Swift.String(describing: volumeType)))"}
}

extension ImagebuilderClientTypes {
    /// Amazon EBS-specific block device mapping specifications.
    public struct EbsInstanceBlockDeviceSpecification: Swift.Equatable {
        /// Use to configure delete on termination of the associated device.
        public var deleteOnTermination: Swift.Bool?
        /// Use to configure device encryption.
        public var encrypted: Swift.Bool?
        /// Use to configure device IOPS.
        public var iops: Swift.Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public var kmsKeyId: Swift.String?
        /// The snapshot that defines the device contents.
        public var snapshotId: Swift.String?
        ///
        ///             For GP3 volumes only 
        /// 			The throughput in MiB/s that the volume supports.
        public var throughput: Swift.Int?
        /// Use to override the device's volume size.
        public var volumeSize: Swift.Int?
        /// Use to override the device's volume type.
        public var volumeType: ImagebuilderClientTypes.EbsVolumeType?

        public init (
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: ImagebuilderClientTypes.EbsVolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension ImagebuilderClientTypes {
    public enum EbsVolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsVolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EbsVolumeType(rawValue: rawValue) ?? EbsVolumeType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.Filter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalues0 in values {
                try valuesContainer.encode(filtervalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ImagebuilderClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(name: \(Swift.String(describing: name)), values: \(Swift.String(describing: values)))"}
}

extension ImagebuilderClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results from a
    /// 			list operation. Filters can be used to match a set of resources by specific criteria, such as
    /// 			tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForbiddenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForbiddenException(message: \(Swift.String(describing: message)))"}
}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform the requested operation.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentInput(componentBuildVersionArn: \(Swift.String(describing: componentBuildVersionArn)))"}
}

extension GetComponentInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentBuildVersionArn = input.operationInput.componentBuildVersionArn {
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(componentBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetComponent"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentOutputError>
}

public struct GetComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires
    /// 			"/\d+$" suffix.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentOutputResponse(component: \(Swift.String(describing: component)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
            self.requestId = output.requestId
        } else {
            self.component = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    /// The component object associated with the specified ARN.
    public var component: ImagebuilderClientTypes.Component?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        component: ImagebuilderClientTypes.Component? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.component = component
        self.requestId = requestId
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let component: ImagebuilderClientTypes.Component?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetComponentPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentPolicyInput(componentArn: \(Swift.String(describing: componentArn)))"}
}

extension GetComponentPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetComponentPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetComponentPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let componentArn = input.operationInput.componentArn {
            let componentArnQueryItem = ClientRuntime.URLQueryItem(name: "componentArn".urlPercentEncoding(), value: Swift.String(componentArn).urlPercentEncoding())
            input.builder.withQueryItem(componentArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetComponentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetComponentPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetComponentPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetComponentPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetComponentPolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetComponentPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetComponentPolicyOutputError>
}

public struct GetComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
    /// This member is required.
    public var componentArn: Swift.String?

    public init (
        componentArn: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

struct GetComponentPolicyInputBody: Swift.Equatable {
}

extension GetComponentPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentPolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetComponentPolicyOutputResponse(policy: \(Swift.String(describing: policy)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetComponentPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentPolicyOutputResponse: Swift.Equatable {
    /// The component policy.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetComponentPolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let policy: Swift.String?
}

extension GetComponentPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetContainerRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContainerRecipeInput(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)))"}
}

extension GetContainerRecipeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetContainerRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContainerRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContainerRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetContainerRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetContainerRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContainerRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipeOutputError>
}

public struct GetContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipeInputBody: Swift.Equatable {
}

extension GetContainerRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContainerRecipeOutputResponse(containerRecipe: \(Swift.String(describing: containerRecipe)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipe = output.containerRecipe
            self.requestId = output.requestId
        } else {
            self.containerRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipeOutputResponse: Swift.Equatable {
    /// The container recipe object that is returned.
    public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipe = containerRecipe
        self.requestId = requestId
    }
}

struct GetContainerRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
}

extension GetContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipe
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
    }
}

extension GetContainerRecipePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContainerRecipePolicyInput(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)))"}
}

extension GetContainerRecipePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetContainerRecipePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContainerRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let containerRecipeArn = input.operationInput.containerRecipeArn {
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(containerRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetContainerRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetContainerRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContainerRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetContainerRecipePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetContainerRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetContainerRecipePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetContainerRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetContainerRecipePolicyOutputError>
}

public struct GetContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipePolicyInputBody: Swift.Equatable {
}

extension GetContainerRecipePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContainerRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetContainerRecipePolicyOutputResponse(policy: \(Swift.String(describing: policy)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetContainerRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipePolicyOutputResponse: Swift.Equatable {
    /// The container recipe policy object that is returned.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetContainerRecipePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let policy: Swift.String?
}

extension GetContainerRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetDistributionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigurationInput(distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)))"}
}

extension GetDistributionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetDistributionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let distributionConfigurationArn = input.operationInput.distributionConfigurationArn {
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(distributionConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDistributionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetDistributionConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDistributionConfigurationOutputError>
}

public struct GetDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to
    /// 			retrieve.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct GetDistributionConfigurationInputBody: Swift.Equatable {
}

extension GetDistributionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDistributionConfigurationOutputResponse(distributionConfiguration: \(Swift.String(describing: distributionConfiguration)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfiguration = output.distributionConfiguration
            self.requestId = output.requestId
        } else {
            self.distributionConfiguration = nil
            self.requestId = nil
        }
    }
}

public struct GetDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The distribution configuration object.
    public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfiguration = distributionConfiguration
        self.requestId = requestId
    }
}

struct GetDistributionConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
}

extension GetDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfiguration
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
    }
}

extension GetImageInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageInput(imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)))"}
}

extension GetImageInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetImageInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageOutputError>
}

public struct GetImageInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageBuildVersionArn = input.operationInput.imageBuildVersionArn {
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            input.builder.withQueryItem(imageBuildVersionArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageOutputError>
}

public struct GetImageInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageOutputError>
}

public struct GetImageInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetImageInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetImage"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageOutputError>
}

public struct GetImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that you want to retrieve.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct GetImageInputBody: Swift.Equatable {
}

extension GetImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageOutputResponse(image: \(Swift.String(describing: image)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
            self.requestId = output.requestId
        } else {
            self.image = nil
            self.requestId = nil
        }
    }
}

public struct GetImageOutputResponse: Swift.Equatable {
    /// The image object.
    public var image: ImagebuilderClientTypes.Image?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        image: ImagebuilderClientTypes.Image? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.image = image
        self.requestId = requestId
    }
}

struct GetImageOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let image: ImagebuilderClientTypes.Image?
}

extension GetImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

extension GetImagePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImagePipelineInput(imagePipelineArn: \(Swift.String(describing: imagePipelineArn)))"}
}

extension GetImagePipelineInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetImagePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imagePipelineArn = input.operationInput.imagePipelineArn {
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            input.builder.withQueryItem(imagePipelineArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetImagePipeline"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePipelineOutputError>
}

public struct GetImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct GetImagePipelineInputBody: Swift.Equatable {
}

extension GetImagePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImagePipelineOutputResponse(imagePipeline: \(Swift.String(describing: imagePipeline)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipeline = output.imagePipeline
            self.requestId = output.requestId
        } else {
            self.imagePipeline = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePipelineOutputResponse: Swift.Equatable {
    /// The image pipeline object.
    public var imagePipeline: ImagebuilderClientTypes.ImagePipeline?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipeline: ImagebuilderClientTypes.ImagePipeline? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipeline = imagePipeline
        self.requestId = requestId
    }
}

struct GetImagePipelineOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imagePipeline: ImagebuilderClientTypes.ImagePipeline?
}

extension GetImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipeline
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImagePipeline.self, forKey: .imagePipeline)
        imagePipeline = imagePipelineDecoded
    }
}

extension GetImagePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImagePolicyInput(imageArn: \(Swift.String(describing: imageArn)))"}
}

extension GetImagePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetImagePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImagePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImagePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImagePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageArn = input.operationInput.imageArn {
            let imageArnQueryItem = ClientRuntime.URLQueryItem(name: "imageArn".urlPercentEncoding(), value: Swift.String(imageArn).urlPercentEncoding())
            input.builder.withQueryItem(imageArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImagePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetImagePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImagePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImagePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetImagePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetImagePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImagePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImagePolicyOutputError>
}

public struct GetImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
    /// This member is required.
    public var imageArn: Swift.String?

    public init (
        imageArn: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
    }
}

struct GetImagePolicyInputBody: Swift.Equatable {
}

extension GetImagePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImagePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImagePolicyOutputResponse(policy: \(Swift.String(describing: policy)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetImagePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePolicyOutputResponse: Swift.Equatable {
    /// The image policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImagePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let policy: Swift.String?
}

extension GetImagePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetImageRecipeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageRecipeInput(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)))"}
}

extension GetImageRecipeInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetImageRecipeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageRecipeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageRecipeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipeInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipeInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetImageRecipeInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetImageRecipe"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageRecipeInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipeOutputError>
}

public struct GetImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipeInputBody: Swift.Equatable {
}

extension GetImageRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageRecipeOutputResponse(imageRecipe: \(Swift.String(describing: imageRecipe)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipe = output.imageRecipe
            self.requestId = output.requestId
        } else {
            self.imageRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipeOutputResponse: Swift.Equatable {
    /// The image recipe object.
    public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipe = imageRecipe
        self.requestId = requestId
    }
}

struct GetImageRecipeOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageRecipe: ImagebuilderClientTypes.ImageRecipe?
}

extension GetImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipe
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
    }
}

extension GetImageRecipePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageRecipePolicyInput(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)))"}
}

extension GetImageRecipePolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetImageRecipePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetImageRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let imageRecipeArn = input.operationInput.imageRecipeArn {
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            input.builder.withQueryItem(imageRecipeArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetImageRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetImageRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetImageRecipePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetImageRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetImageRecipePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetImageRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetImageRecipePolicyOutputError>
}

public struct GetImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipePolicyInputBody: Swift.Equatable {
}

extension GetImageRecipePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImageRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetImageRecipePolicyOutputResponse(policy: \(Swift.String(describing: policy)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetImageRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipePolicyOutputResponse: Swift.Equatable {
    /// The image recipe policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImageRecipePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let policy: Swift.String?
}

extension GetImageRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetInfrastructureConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInfrastructureConfigurationInput(infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)))"}
}

extension GetInfrastructureConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetInfrastructureConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInfrastructureConfigurationOutputError>
}

public struct GetInfrastructureConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let infrastructureConfigurationArn = input.operationInput.infrastructureConfigurationArn {
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            input.builder.withQueryItem(infrastructureConfigurationArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInfrastructureConfigurationOutputError>
}

public struct GetInfrastructureConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInfrastructureConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInfrastructureConfigurationOutputError>
}

public struct GetInfrastructureConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInfrastructureConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/GetInfrastructureConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInfrastructureConfigurationOutputError>
}

///  GetInfrastructureConfiguration request object.
public struct GetInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    /// 			retrieve.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct GetInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension GetInfrastructureConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInfrastructureConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInfrastructureConfigurationOutputResponse(infrastructureConfiguration: \(Swift.String(describing: infrastructureConfiguration)), requestId: \(Swift.String(describing: requestId)))"}
}

extension GetInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfiguration = output.infrastructureConfiguration
            self.requestId = output.requestId
        } else {
            self.infrastructureConfiguration = nil
            self.requestId = nil
        }
    }
}

/// GetInfrastructureConfiguration response object.
public struct GetInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The infrastructure configuration object.
    public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfiguration = infrastructureConfiguration
        self.requestId = requestId
    }
}

struct GetInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
}

extension GetInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfiguration
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
    }
}

extension IdempotentParameterMismatchException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IdempotentParameterMismatchException(message: \(Swift.String(describing: message)))"}
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a client token for an operation using parameter values that differ from
/// 			a previous request that used the same client token.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Image: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerRecipe
        case dateCreated
        case distributionConfiguration
        case enhancedImageMetadataEnabled
        case imageRecipe
        case imageTestsConfiguration
        case infrastructureConfiguration
        case name
        case osVersion
        case outputResources
        case platform
        case sourcePipelineArn
        case sourcePipelineName
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipe = containerRecipe {
            try encodeContainer.encode(containerRecipe, forKey: .containerRecipe)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let distributionConfiguration = distributionConfiguration {
            try encodeContainer.encode(distributionConfiguration, forKey: .distributionConfiguration)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipe = imageRecipe {
            try encodeContainer.encode(imageRecipe, forKey: .imageRecipe)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfiguration = infrastructureConfiguration {
            try encodeContainer.encode(infrastructureConfiguration, forKey: .infrastructureConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sourcePipelineArn = sourcePipelineArn {
            try encodeContainer.encode(sourcePipelineArn, forKey: .sourcePipelineArn)
        }
        if let sourcePipelineName = sourcePipelineName {
            try encodeContainer.encode(sourcePipelineName, forKey: .sourcePipelineName)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
        let sourcePipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineName)
        sourcePipelineName = sourcePipelineNameDecoded
        let sourcePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineArn)
        sourcePipelineArn = sourcePipelineArnDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.Image: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Image(arn: \(Swift.String(describing: arn)), containerRecipe: \(Swift.String(describing: containerRecipe)), dateCreated: \(Swift.String(describing: dateCreated)), distributionConfiguration: \(Swift.String(describing: distributionConfiguration)), enhancedImageMetadataEnabled: \(Swift.String(describing: enhancedImageMetadataEnabled)), imageRecipe: \(Swift.String(describing: imageRecipe)), imageTestsConfiguration: \(Swift.String(describing: imageTestsConfiguration)), infrastructureConfiguration: \(Swift.String(describing: infrastructureConfiguration)), name: \(Swift.String(describing: name)), osVersion: \(Swift.String(describing: osVersion)), outputResources: \(Swift.String(describing: outputResources)), platform: \(Swift.String(describing: platform)), sourcePipelineArn: \(Swift.String(describing: sourcePipelineArn)), sourcePipelineName: \(Swift.String(describing: sourcePipelineName)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// An Image Builder image. You must specify exactly one recipe for the image  either
    /// 			a container recipe (containerRecipe), which creates a container
    /// 			image, or an image recipe (imageRecipe), which creates an AMI.
    public struct Image: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image.
        /// 		
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        /// 	           <ol>
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        /// 		
        ///
        /// 			               Version ARNs have only the first three nodes: <major>.<minor>.<patch>
        /// 		
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        /// 		
        ///             </ol>
        /// 		
        public var arn: Swift.String?
        /// The recipe that is used to create an Image Builder container image.
        public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
        /// The date on which this image was created.
        public var dateCreated: Swift.String?
        /// The distribution configuration used when creating this image.
        public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The image recipe used when creating the image.
        public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
        /// The image tests configuration used when creating this image.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The infrastructure used when creating this image.
        public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources produced when creating this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The platform of the image.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public var sourcePipelineArn: Swift.String?
        /// The name of the image pipeline that created this image.
        public var sourcePipelineName: Swift.String?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags of the image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this is an AMI or container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The semantic version of the image.
        /// 		
        /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			
        ///                Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			
        ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			
        ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        /// 		
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
            dateCreated: Swift.String? = nil,
            distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            sourcePipelineArn: Swift.String? = nil,
            sourcePipelineName: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImagePackage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName
        case packageVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension ImagebuilderClientTypes.ImagePackage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImagePackage(packageName: \(Swift.String(describing: packageName)), packageVersion: \(Swift.String(describing: packageVersion)))"}
}

extension ImagebuilderClientTypes {
    /// Represents a package installed on an Image Builder image.
    public struct ImagePackage: Swift.Equatable {
        /// The name of the package as reported to the operating system package manager.
        public var packageName: Swift.String?
        /// The version of the package as reported to the operating system package manager.
        public var packageVersion: Swift.String?

        public init (
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }

}

extension ImagebuilderClientTypes.ImagePipeline: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerRecipeArn
        case dateCreated
        case dateLastRun
        case dateNextRun
        case dateUpdated
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case platform
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateLastRun = dateLastRun {
            try encodeContainer.encode(dateLastRun, forKey: .dateLastRun)
        }
        if let dateNextRun = dateNextRun {
            try encodeContainer.encode(dateNextRun, forKey: .dateNextRun)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let dateNextRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateNextRun)
        dateNextRun = dateNextRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.ImagePipeline: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImagePipeline(arn: \(Swift.String(describing: arn)), containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), dateCreated: \(Swift.String(describing: dateCreated)), dateLastRun: \(Swift.String(describing: dateLastRun)), dateNextRun: \(Swift.String(describing: dateNextRun)), dateUpdated: \(Swift.String(describing: dateUpdated)), description: \(Swift.String(describing: description)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(Swift.String(describing: enhancedImageMetadataEnabled)), imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), imageTestsConfiguration: \(Swift.String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)), tags: \(Swift.String(describing: tags)))"}
}

extension ImagebuilderClientTypes {
    /// Details of an image pipeline.
    public struct ImagePipeline: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public var containerRecipeArn: Swift.String?
        /// The date on which this image pipeline was created.
        public var dateCreated: Swift.String?
        /// The date on which this image pipeline was last run.
        public var dateLastRun: Swift.String?
        /// The date on which this image pipeline will next be run.
        public var dateNextRun: Swift.String?
        /// The date on which this image pipeline was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the image pipeline.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this
        /// 			image pipeline.
        public var distributionConfigurationArn: Swift.String?
        ///  Collects additional information about the image being created, including the operating
        /// 			system (OS) version and package list. This information is used to enhance the overall
        /// 			experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image
        /// 			pipeline.
        public var imageRecipeArn: Swift.String?
        /// The image tests configuration of the image pipeline.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this
        /// 			image pipeline.
        public var infrastructureConfigurationArn: Swift.String?
        /// The name of the image pipeline.
        public var name: Swift.String?
        /// The platform of the image pipeline.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The schedule of the image pipeline.
        public var schedule: ImagebuilderClientTypes.Schedule?
        /// The status of the image pipeline.
        public var status: ImagebuilderClientTypes.PipelineStatus?
        /// The tags of this image pipeline.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerRecipeArn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateLastRun: Swift.String? = nil,
            dateNextRun: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributionConfigurationArn: Swift.String? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipeArn: Swift.String? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfigurationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            schedule: ImagebuilderClientTypes.Schedule? = nil,
            status: ImagebuilderClientTypes.PipelineStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipe: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case arn
        case blockDeviceMappings
        case components
        case dateCreated
        case description
        case name
        case owner
        case parentImage
        case platform
        case tags
        case type
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfigurationlist0 in components {
                try componentsContainer.encode(componentconfigurationlist0)
            }
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
    }
}

extension ImagebuilderClientTypes.ImageRecipe: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageRecipe(additionalInstanceConfiguration: \(Swift.String(describing: additionalInstanceConfiguration)), arn: \(Swift.String(describing: arn)), blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), components: \(Swift.String(describing: components)), dateCreated: \(Swift.String(describing: dateCreated)), description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parentImage: \(Swift.String(describing: parentImage)), platform: \(Swift.String(describing: platform)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)), workingDirectory: \(Swift.String(describing: workingDirectory)))"}
}

extension ImagebuilderClientTypes {
    /// An image recipe.
    public struct ImageRecipe: Swift.Equatable {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to
        /// 			build and test your image configuration. Instance configuration adds a layer
        /// 			of control over those instances. You can define settings and add scripts to
        /// 			run when an instance is launched from your AMI.
        public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The block device mappings to apply when creating images from this recipe.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The components of the image recipe.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the image recipe.
        public var description: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies which type of image is created by the recipe - an AMI or a
        /// 			container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image recipe.
        public var version: Swift.String?
        /// The working directory to be used during build and test workflows.
        public var workingDirectory: Swift.String?

        public init (
            additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
            arn: Swift.String? = nil,
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipeSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.ImageRecipeSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageRecipeSummary(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), parentImage: \(Swift.String(describing: parentImage)), platform: \(Swift.String(describing: platform)), tags: \(Swift.String(describing: tags)))"}
}

extension ImagebuilderClientTypes {
    /// A summary of an image recipe.
    public struct ImageRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImageState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes.ImageState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageState(reason: \(Swift.String(describing: reason)), status: \(Swift.String(describing: status)))"}
}

extension ImagebuilderClientTypes {
    ///  Image state shows the image status and the reason for that status.
    public struct ImageState: Swift.Equatable {
        /// The reason for the image's status.
        public var reason: Swift.String?
        /// The status of the image.
        public var status: ImagebuilderClientTypes.ImageStatus?

        public init (
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case building
        case cancelled
        case creating
        case deleted
        case deprecated
        case distributing
        case failed
        case integrating
        case pending
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStatus] {
            return [
                .available,
                .building,
                .cancelled,
                .creating,
                .deleted,
                .deprecated,
                .distributing,
                .failed,
                .integrating,
                .pending,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .distributing: return "DISTRIBUTING"
            case .failed: return "FAILED"
            case .integrating: return "INTEGRATING"
            case .pending: return "PENDING"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStatus(rawValue: rawValue) ?? ImageStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case name
        case osVersion
        case outputResources
        case owner
        case platform
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.ImageSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageSummary(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), name: \(Swift.String(describing: name)), osVersion: \(Swift.String(describing: osVersion)), outputResources: \(Swift.String(describing: outputResources)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), state: \(Swift.String(describing: state)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// An image summary.
    public struct ImageSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image.
        public var arn: Swift.String?
        /// The date on which this image was created.
        public var dateCreated: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources produced when creating this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The owner of the image.
        public var owner: Swift.String?
        /// The platform of the image.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags of the image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this is an AMI or container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImageTestsConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTestsEnabled
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTestsEnabled = imageTestsEnabled {
            try encodeContainer.encode(imageTestsEnabled, forKey: .imageTestsEnabled)
        }
        if let timeoutMinutes = timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTestsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageTestsEnabled)
        imageTestsEnabled = imageTestsEnabledDecoded
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
    }
}

extension ImagebuilderClientTypes.ImageTestsConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageTestsConfiguration(imageTestsEnabled: \(Swift.String(describing: imageTestsEnabled)), timeoutMinutes: \(Swift.String(describing: timeoutMinutes)))"}
}

extension ImagebuilderClientTypes {
    /// Image tests configuration.
    public struct ImageTestsConfiguration: Swift.Equatable {
        /// Defines if tests should be executed when building this image.
        public var imageTestsEnabled: Swift.Bool?
        /// The maximum time in minutes that tests are permitted to run.
        public var timeoutMinutes: Swift.Int?

        public init (
            imageTestsEnabled: Swift.Bool? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ami
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .ami,
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ami: return "AMI"
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageVersion: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case name
        case osVersion
        case owner
        case platform
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ImagebuilderClientTypes.ImageVersion: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageVersion(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), name: \(Swift.String(describing: name)), osVersion: \(Swift.String(describing: osVersion)), owner: \(Swift.String(describing: owner)), platform: \(Swift.String(describing: platform)), type: \(Swift.String(describing: type)), version: \(Swift.String(describing: version)))"}
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Image Builder image.
    public struct ImageVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image.
        /// 		
        /// 			         Semantic versioning is included in each object's Amazon Resource Name (ARN),
        /// 	at the level that applies to that object as follows:
        /// 	           <ol>
        ///
        /// 			               Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are
        /// 				either left off entirely, or they are specified as wildcards, for example: x.x.x.
        /// 		
        ///
        /// 			               Version ARNs have only the first three nodes: <major>.<minor>.<patch>
        /// 		
        ///
        /// 			               Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        /// 		
        ///             </ol>
        /// 		
        public var arn: Swift.String?
        /// The date on which this specific version of the Image Builder image was created.
        public var dateCreated: Swift.String?
        /// The name of this specific version of an Image Builder image.
        public var name: Swift.String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2, Ubuntu 18, or
        /// 			Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The owner of the image version.
        public var owner: Swift.String?
        /// The platform of the image version, for example "Windows" or "Linux".
        public var platform: ImagebuilderClientTypes.Platform?
        /// Specifies whether this image is an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic version syntax.
        /// 		
        /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
        /// 	You can assign values for the first three, and can filter on all of them.
        /// 			
        ///                Assignment: For the first three nodes you can assign any positive integer value, including
        /// 	zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the
        /// 	build number to the fourth node.
        /// 			
        ///                Patterns: You can use any numeric pattern that adheres to the assignment requirements for
        /// 	the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or
        /// 	a date, such as 2021.01.01.
        /// 			
        ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
        /// 	to specify the most recent versions or nodes when selecting the base image or components for your
        /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
        /// 	wildcards.
        /// 		
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }
    }

}

public struct ImportComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportComponentOutputError>
}

extension ImportComponentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportComponentInput(changeDescription: \(Swift.String(describing: changeDescription)), clientToken: \(Swift.String(describing: clientToken)), data: \(Swift.String(describing: data)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), kmsKeyId: \(Swift.String(describing: kmsKeyId)), name: \(Swift.String(describing: name)), platform: \(Swift.String(describing: platform)), semanticVersion: \(Swift.String(describing: semanticVersion)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), uri: \(Swift.String(describing: uri)))"}
}

extension ImportComponentInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

public struct ImportComponentInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportComponentOutputError>
}

public struct ImportComponentInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportComponentInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportComponentOutputError>
}

public struct ImportComponentInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportComponentInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ImportComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportComponentOutputError>
}

public struct ImportComponentInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportComponentInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ImportComponentInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ImportComponent"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportComponentInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportComponentOutputError>
}

public struct ImportComponentInput: Swift.Equatable {
    /// The change description of the component. Describes what change has been made in this
    /// 			version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// The idempotency token of the component.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data of the component. Used to specify the data inline. Either data or
    /// 			uri can be used to specify the data within the component.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The format of the resource that you want to import as a component.
    /// This member is required.
    public var format: ImagebuilderClientTypes.ComponentFormat?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    ///  The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// 		
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the component.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the component denotes whether the component is used to build the image, or only
    /// 			to test it.
    /// This member is required.
    public var type: ImagebuilderClientTypes.ComponentType?
    /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to
    /// 			access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service
    /// 			quota. Either data or uri can be used to specify the data within the
    /// 			component.
    public var uri: Swift.String?

    public init (
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        format: ImagebuilderClientTypes.ComponentFormat? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: ImagebuilderClientTypes.ComponentType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

struct ImportComponentInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let semanticVersion: Swift.String?
    public let description: Swift.String?
    public let changeDescription: Swift.String?
    public let type: ImagebuilderClientTypes.ComponentType?
    public let format: ImagebuilderClientTypes.ComponentFormat?
    public let platform: ImagebuilderClientTypes.Platform?
    public let data: Swift.String?
    public let uri: Swift.String?
    public let kmsKeyId: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let clientToken: Swift.String?
}

extension ImportComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentFormat.self, forKey: .format)
        format = formatDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportComponentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportComponentOutputResponse(clientToken: \(Swift.String(describing: clientToken)), componentBuildVersionArn: \(Swift.String(describing: componentBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ImportComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportComponentOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported component.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct ImportComponentOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let componentBuildVersionArn: Swift.String?
}

extension ImportComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension ImagebuilderClientTypes.InfrastructureConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.InfrastructureConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InfrastructureConfiguration(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), dateUpdated: \(Swift.String(describing: dateUpdated)), description: \(Swift.String(describing: description)), instanceMetadataOptions: \(Swift.String(describing: instanceMetadataOptions)), instanceProfileName: \(Swift.String(describing: instanceProfileName)), instanceTypes: \(Swift.String(describing: instanceTypes)), keyPair: \(Swift.String(describing: keyPair)), logging: \(Swift.String(describing: logging)), name: \(Swift.String(describing: name)), resourceTags: \(Swift.String(describing: resourceTags)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), subnetId: \(Swift.String(describing: subnetId)), tags: \(Swift.String(describing: tags)), terminateInstanceOnFailure: \(Swift.String(describing: terminateInstanceOnFailure)))"}
}

extension ImagebuilderClientTypes {
    /// Details of the infrastructure configuration.
    public struct InfrastructureConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance metadata option settings for the infrastructure configuration.
        public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public var keyPair: Swift.String?
        /// The logging configuration of the infrastructure configuration.
        public var logging: ImagebuilderClientTypes.Logging?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the resource created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The security group IDs of the infrastructure configuration.
        public var securityGroupIds: [Swift.String]?
        /// The SNS topic Amazon Resource Name (ARN) of the infrastructure configuration.
        public var snsTopicArn: Swift.String?
        /// The subnet ID of the infrastructure configuration.
        public var subnetId: Swift.String?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The terminate instance on failure configuration of the infrastructure
        /// 			configuration.
        public var terminateInstanceOnFailure: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            keyPair: Swift.String? = nil,
            logging: ImagebuilderClientTypes.Logging? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateInstanceOnFailure: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }
    }

}

extension ImagebuilderClientTypes.InfrastructureConfigurationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceProfileName
        case instanceTypes
        case name
        case resourceTags
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension ImagebuilderClientTypes.InfrastructureConfigurationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InfrastructureConfigurationSummary(arn: \(Swift.String(describing: arn)), dateCreated: \(Swift.String(describing: dateCreated)), dateUpdated: \(Swift.String(describing: dateUpdated)), description: \(Swift.String(describing: description)), instanceProfileName: \(Swift.String(describing: instanceProfileName)), instanceTypes: \(Swift.String(describing: instanceTypes)), name: \(Swift.String(describing: name)), resourceTags: \(Swift.String(describing: resourceTags)), tags: \(Swift.String(describing: tags)))"}
}

extension ImagebuilderClientTypes {
    /// The infrastructure used when building Amazon EC2 AMIs.
    public struct InfrastructureConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the image created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.InstanceBlockDeviceMapping: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification.self, forKey: .ebs)
        ebs = ebsDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
    }
}

extension ImagebuilderClientTypes.InstanceBlockDeviceMapping: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceBlockDeviceMapping(deviceName: \(Swift.String(describing: deviceName)), ebs: \(Swift.String(describing: ebs)), noDevice: \(Swift.String(describing: noDevice)), virtualName: \(Swift.String(describing: virtualName)))"}
}

extension ImagebuilderClientTypes {
    /// Defines block device mappings for the instance used to configure your image.
    public struct InstanceBlockDeviceMapping: Swift.Equatable {
        /// The device to which these mappings apply.
        public var deviceName: Swift.String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public var ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public var noDevice: Swift.String?
        /// Use to manage instance ephemeral devices.
        public var virtualName: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension ImagebuilderClientTypes.InstanceConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings
        case image
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemappings0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemappings0)
            }
        }
        if let image = image {
            try encodeContainer.encode(image, forKey: .image)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
    }
}

extension ImagebuilderClientTypes.InstanceConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceConfiguration(blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), image: \(Swift.String(describing: image)))"}
}

extension ImagebuilderClientTypes {
    /// Defines a custom base AMI and block device mapping configurations of an instance
    /// 			used for building and testing container images.
    public struct InstanceConfiguration: Swift.Equatable {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified,
        /// 			Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public var image: Swift.String?

        public init (
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            image: Swift.String? = nil
        )
        {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }
    }

}

extension ImagebuilderClientTypes.InstanceMetadataOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPutResponseHopLimit
        case httpTokens
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPutResponseHopLimit = httpPutResponseHopLimit {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit)
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
    }
}

extension ImagebuilderClientTypes.InstanceMetadataOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceMetadataOptions(httpPutResponseHopLimit: \(Swift.String(describing: httpPutResponseHopLimit)), httpTokens: \(Swift.String(describing: httpTokens)))"}
}

extension ImagebuilderClientTypes {
    /// The instance metadata options that apply to the HTTP requests that
    /// 			pipeline builds use to launch EC2 build and test instances. For more
    /// 			information about instance metadata options, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html">Configure
    /// 				the instance metadata options in the
    ///                Amazon EC2 User Guide
    ///
    /// 			for Linux instances, or <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html">Configure
    /// 				the instance metadata options in the
    ///                Amazon EC2 Windows Guide
    ///
    /// 			for Windows instances.
    public struct InstanceMetadataOptions: Swift.Equatable {
        /// Limit the number of hops that an instance metadata request can traverse to reach its
        /// 			destination.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval requests.
        /// 			The values affect the response as follows:
        /// 		
        ///
        /// 				
        ///                   required  When you retrieve the
        /// 					IAM role credentials, version 2.0 credentials are returned in all cases.
        /// 			
        ///
        /// 				
        ///                   optional  You can include a signed token header
        /// 					in your request to retrieve instance metadata, or you can leave it out. If you
        /// 					include it, version 2.0 credentials are returned for the IAM role. Otherwise,
        /// 					version 1.0 credentials are returned.
        /// 			
        ///
        /// 		       The default setting is optional.
        public var httpTokens: Swift.String?

        public init (
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }

}

extension InvalidPaginationTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPaginationTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPaginationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have provided an invalid pagination token in your request.
public struct InvalidPaginationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterCombinationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified two or more mutually exclusive parameters. Review the error message for
/// 			details.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API
/// 			request.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterValueException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value that you provided for the specified parameter is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have made a request for an action that is not supported by the service.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVersionNumberException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidVersionNumberException(message: \(Swift.String(describing: message)))"}
}

extension InvalidVersionNumberException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidVersionNumberExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your version number is out of bounds or does not follow the required syntax.
public struct InvalidVersionNumberException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVersionNumberExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidVersionNumberExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.LaunchPermissionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userGroups
        case userIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userGroups = userGroups {
            var userGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userGroups)
            for stringlist0 in userGroups {
                try userGroupsContainer.encode(stringlist0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for accountlist0 in userIds {
                try userIdsContainer.encode(accountlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let userGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userGroups)
        var userGroupsDecoded0:[Swift.String]? = nil
        if let userGroupsContainer = userGroupsContainer {
            userGroupsDecoded0 = [Swift.String]()
            for string0 in userGroupsContainer {
                if let string0 = string0 {
                    userGroupsDecoded0?.append(string0)
                }
            }
        }
        userGroups = userGroupsDecoded0
    }
}

extension ImagebuilderClientTypes.LaunchPermissionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchPermissionConfiguration(userGroups: \(Swift.String(describing: userGroups)), userIds: \(Swift.String(describing: userIds)))"}
}

extension ImagebuilderClientTypes {
    /// Describes the configuration for a launch permission. The launch permission modification request is sent to the
    /// 			<a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html">Amazon EC2 ModifyImageAttribute
    /// 			API on behalf of the user for each Region they have selected to distribute the AMI. To make an AMI public,
    /// 			set the launch permission authorized accounts to all. See the examples for making an AMI public at
    /// 			<a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html">Amazon EC2 ModifyImageAttribute.
    public struct LaunchPermissionConfiguration: Swift.Equatable {
        /// The name of the group.
        public var userGroups: [Swift.String]?
        /// The Amazon Web Services account ID.
        public var userIds: [Swift.String]?

        public init (
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }

}

extension ImagebuilderClientTypes.LaunchTemplateConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case launchTemplateId
        case setDefaultVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let launchTemplateId = launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if setDefaultVersion != false {
            try encodeContainer.encode(setDefaultVersion, forKey: .setDefaultVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let setDefaultVersionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .setDefaultVersion)
        setDefaultVersion = setDefaultVersionDecoded
    }
}

extension ImagebuilderClientTypes.LaunchTemplateConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchTemplateConfiguration(accountId: \(Swift.String(describing: accountId)), launchTemplateId: \(Swift.String(describing: launchTemplateId)), setDefaultVersion: \(Swift.String(describing: setDefaultVersion)))"}
}

extension ImagebuilderClientTypes {
    /// Identifies an Amazon EC2 launch template to use for a specific account.
    public struct LaunchTemplateConfiguration: Swift.Equatable {
        /// The account ID that this configuration applies to.
        public var accountId: Swift.String?
        /// Identifies the Amazon EC2 launch template to use.
        /// This member is required.
        public var launchTemplateId: Swift.String?
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public var setDefaultVersion: Swift.Bool

        public init (
            accountId: Swift.String? = nil,
            launchTemplateId: Swift.String? = nil,
            setDefaultVersion: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }
    }

}

public struct ListComponentBuildVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentBuildVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentBuildVersionsOutputError>
}

extension ListComponentBuildVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentBuildVersionsInput(componentVersionArn: \(Swift.String(describing: componentVersionArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListComponentBuildVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersionArn = componentVersionArn {
            try encodeContainer.encode(componentVersionArn, forKey: .componentVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListComponentBuildVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentBuildVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentBuildVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentBuildVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListComponentBuildVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentBuildVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentBuildVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListComponentBuildVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListComponentBuildVersions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentBuildVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentBuildVersionsOutputError>
}

public struct ListComponentBuildVersionsInput: Swift.Equatable {
    /// The component version Amazon Resource Name (ARN) whose versions you want to list.
    /// This member is required.
    public var componentVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        componentVersionArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersionArn = componentVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentBuildVersionsInputBody: Swift.Equatable {
    public let componentVersionArn: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListComponentBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersionArn)
        componentVersionArn = componentVersionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentBuildVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentBuildVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentBuildVersionsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentBuildVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentBuildVersionsOutputResponse(componentSummaryList: \(Swift.String(describing: componentSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListComponentBuildVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentSummaryList = output.componentSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentBuildVersionsOutputResponse: Swift.Equatable {
    /// The list of component summaries for the specified semantic version.
    public var componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentSummaryList = componentSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentBuildVersionsOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    public let nextToken: Swift.String?
}

extension ListComponentBuildVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentSummary?].self, forKey: .componentSummaryList)
        var componentSummaryListDecoded0:[ImagebuilderClientTypes.ComponentSummary]? = nil
        if let componentSummaryListContainer = componentSummaryListContainer {
            componentSummaryListDecoded0 = [ImagebuilderClientTypes.ComponentSummary]()
            for structure0 in componentSummaryListContainer {
                if let structure0 = structure0 {
                    componentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        componentSummaryList = componentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComponentsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

extension ListComponentsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentsInput(byName: \(Swift.String(describing: byName)), filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), owner: \(Swift.String(describing: owner)))"}
}

extension ListComponentsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListComponentsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListComponentsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListComponentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListComponentsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListComponentsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListComponents"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListComponentsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListComponentsOutputError>
}

public struct ListComponentsInput: Swift.Equatable {
    /// Returns the list of component build versions for the specified name.
    public var byName: Swift.Bool
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   description
    ///
    ///
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   platform
    ///
    ///
    ///
    ///
    ///                   supportedOsVersion
    ///
    ///
    ///
    ///
    ///                   type
    ///
    ///
    ///
    ///
    ///                   version
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which components you want to list. By default, this request will only
    /// 			show components owned by your account. You can use this field to specify if you want to view
    /// 			components owned by yourself, by Amazon, or those components that have been shared with you by
    /// 			other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        byName: Swift.Bool = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    public let owner: ImagebuilderClientTypes.Ownership?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let byName: Swift.Bool
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decode(Swift.Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListComponentsOutputResponse(componentVersionList: \(Swift.String(describing: componentVersionList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentVersionList = output.componentVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// The list of component semantic versions.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 		
    public var componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentVersionList: [ImagebuilderClientTypes.ComponentVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentVersionList = componentVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    public let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentVersion?].self, forKey: .componentVersionList)
        var componentVersionListDecoded0:[ImagebuilderClientTypes.ComponentVersion]? = nil
        if let componentVersionListContainer = componentVersionListContainer {
            componentVersionListDecoded0 = [ImagebuilderClientTypes.ComponentVersion]()
            for structure0 in componentVersionListContainer {
                if let structure0 = structure0 {
                    componentVersionListDecoded0?.append(structure0)
                }
            }
        }
        componentVersionList = componentVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListContainerRecipesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContainerRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContainerRecipesOutputError>
}

extension ListContainerRecipesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContainerRecipesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), owner: \(Swift.String(describing: owner)))"}
}

extension ListContainerRecipesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListContainerRecipesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContainerRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContainerRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListContainerRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListContainerRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContainerRecipesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListContainerRecipesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListContainerRecipesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListContainerRecipesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListContainerRecipesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListContainerRecipes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListContainerRecipesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListContainerRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListContainerRecipesOutputError>
}

public struct ListContainerRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   containerType
    ///
    ///
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   parentImage
    ///
    ///
    ///
    ///
    ///                   platform
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum number of results to return in the list.
    public var maxResults: Swift.Int
    /// Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.
    public var nextToken: Swift.String?
    /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListContainerRecipesInputBody: Swift.Equatable {
    public let owner: ImagebuilderClientTypes.Ownership?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListContainerRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContainerRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContainerRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListContainerRecipesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContainerRecipesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListContainerRecipesOutputResponse(containerRecipeSummaryList: \(Swift.String(describing: containerRecipeSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListContainerRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListContainerRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeSummaryList = output.containerRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.containerRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListContainerRecipesOutputResponse: Swift.Equatable {
    /// The list of container recipes returned for the request.
    public var containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    /// The next token field is used for paginated responses. When this is not empty, there are additional container recipes that the service has not included in this response. Use this token with the next request to retrieve additional list items.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeSummaryList = containerRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListContainerRecipesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    public let nextToken: Swift.String?
}

extension ListContainerRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ContainerRecipeSummary?].self, forKey: .containerRecipeSummaryList)
        var containerRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ContainerRecipeSummary]? = nil
        if let containerRecipeSummaryListContainer = containerRecipeSummaryListContainer {
            containerRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ContainerRecipeSummary]()
            for structure0 in containerRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    containerRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        containerRecipeSummaryList = containerRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListDistributionConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionConfigurationsOutputError>
}

extension ListDistributionConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionConfigurationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDistributionConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListDistributionConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDistributionConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListDistributionConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDistributionConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListDistributionConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListDistributionConfigurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDistributionConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDistributionConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDistributionConfigurationsOutputError>
}

public struct ListDistributionConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributionConfigurationsInputBody: Swift.Equatable {
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListDistributionConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDistributionConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDistributionConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDistributionConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDistributionConfigurationsOutputResponse(distributionConfigurationSummaryList: \(Swift.String(describing: distributionConfigurationSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListDistributionConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDistributionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationSummaryList = output.distributionConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListDistributionConfigurationsOutputResponse: Swift.Equatable {
    /// The list of distributions.
    public var distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListDistributionConfigurationsOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListDistributionConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.DistributionConfigurationSummary?].self, forKey: .distributionConfigurationSummaryList)
        var distributionConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil
        if let distributionConfigurationSummaryListContainer = distributionConfigurationSummaryListContainer {
            distributionConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.DistributionConfigurationSummary]()
            for structure0 in distributionConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    distributionConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        distributionConfigurationSummaryList = distributionConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImageBuildVersionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageBuildVersionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageBuildVersionsOutputError>
}

extension ListImageBuildVersionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImageBuildVersionsInput(filters: \(Swift.String(describing: filters)), imageVersionArn: \(Swift.String(describing: imageVersionArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListImageBuildVersionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let imageVersionArn = imageVersionArn {
            try encodeContainer.encode(imageVersionArn, forKey: .imageVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImageBuildVersionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageBuildVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageBuildVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageBuildVersionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageBuildVersionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImageBuildVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImageBuildVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageBuildVersionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImageBuildVersionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImageBuildVersions"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImageBuildVersionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageBuildVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageBuildVersionsOutputError>
}

public struct ListImageBuildVersionsInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   osVersion
    ///
    ///
    ///
    ///
    ///                   platform
    ///
    ///
    ///
    ///
    ///                   type
    ///
    ///
    ///
    ///
    ///                   version
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
    /// This member is required.
    public var imageVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imageVersionArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imageVersionArn = imageVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageBuildVersionsInputBody: Swift.Equatable {
    public let imageVersionArn: Swift.String?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListImageBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersionArn)
        imageVersionArn = imageVersionArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageBuildVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageBuildVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImageBuildVersionsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageBuildVersionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImageBuildVersionsOutputResponse(imageSummaryList: \(Swift.String(describing: imageSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImageBuildVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImageBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageBuildVersionsOutputResponse: Swift.Equatable {
    /// The list of image build versions.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageBuildVersionsOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    public let nextToken: Swift.String?
}

extension ListImageBuildVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePackagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePackagesOutputError>
}

extension ListImagePackagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePackagesInput(imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListImagePackagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePackagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePackagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePackagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePackagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImagePackagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePackagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePackagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImagePackagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImagePackages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePackagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePackagesOutputError>
}

public struct ListImagePackagesInput: Swift.Equatable {
    /// Filter results for the ListImagePackages request by the Image Build Version ARN
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maxiumum number of results to return from the ListImagePackages request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePackagesInputBody: Swift.Equatable {
    public let imageBuildVersionArn: Swift.String?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListImagePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePackagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePackagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePackagesOutputResponse(imagePackageList: \(Swift.String(describing: imagePackageList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImagePackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImagePackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePackageList = output.imagePackageList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePackageList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePackagesOutputResponse: Swift.Equatable {
    /// The list of Image Packages returned in the response.
    public var imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePackageList: [ImagebuilderClientTypes.ImagePackage]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePackageList = imagePackageList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePackagesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    public let nextToken: Swift.String?
}

extension ListImagePackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePackageList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePackageListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePackage?].self, forKey: .imagePackageList)
        var imagePackageListDecoded0:[ImagebuilderClientTypes.ImagePackage]? = nil
        if let imagePackageListContainer = imagePackageListContainer {
            imagePackageListDecoded0 = [ImagebuilderClientTypes.ImagePackage]()
            for structure0 in imagePackageListContainer {
                if let structure0 = structure0 {
                    imagePackageListDecoded0?.append(structure0)
                }
            }
        }
        imagePackageList = imagePackageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePipelineImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelineImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelineImagesOutputError>
}

extension ListImagePipelineImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePipelineImagesInput(filters: \(Swift.String(describing: filters)), imagePipelineArn: \(Swift.String(describing: imagePipelineArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListImagePipelineImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePipelineImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelineImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelineImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelineImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelineImagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImagePipelineImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePipelineImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelineImagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImagePipelineImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImagePipelineImages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePipelineImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelineImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelineImagesOutputError>
}

public struct ListImagePipelineImagesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   version
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imagePipelineArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imagePipelineArn = imagePipelineArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelineImagesInputBody: Swift.Equatable {
    public let imagePipelineArn: Swift.String?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListImagePipelineImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelineImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelineImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePipelineImagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelineImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePipelineImagesOutputResponse(imageSummaryList: \(Swift.String(describing: imageSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImagePipelineImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImagePipelineImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelineImagesOutputResponse: Swift.Equatable {
    /// The list of images built by this pipeline.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelineImagesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    public let nextToken: Swift.String?
}

extension ListImagePipelineImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagePipelinesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelinesOutputError>
}

extension ListImagePipelinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePipelinesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListImagePipelinesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListImagePipelinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagePipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagePipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelinesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImagePipelinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePipelinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagePipelinesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImagePipelinesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImagePipelines"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagePipelinesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagePipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagePipelinesOutputError>
}

public struct ListImagePipelinesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   description
    ///
    ///
    ///
    ///
    ///                   distributionConfigurationArn
    ///
    ///
    ///
    ///
    ///                   imageRecipeArn
    ///
    ///
    ///
    ///
    ///                   infrastructureConfigurationArn
    ///
    ///
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   status
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelinesInputBody: Swift.Equatable {
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListImagePipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagePipelinesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagePipelinesOutputResponse(imagePipelineList: \(Swift.String(describing: imagePipelineList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImagePipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImagePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineList = output.imagePipelineList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePipelineList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelinesOutputResponse: Swift.Equatable {
    /// The list of image pipelines.
    public var imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineList = imagePipelineList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelinesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    public let nextToken: Swift.String?
}

extension ListImagePipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePipeline?].self, forKey: .imagePipelineList)
        var imagePipelineListDecoded0:[ImagebuilderClientTypes.ImagePipeline]? = nil
        if let imagePipelineListContainer = imagePipelineListContainer {
            imagePipelineListDecoded0 = [ImagebuilderClientTypes.ImagePipeline]()
            for structure0 in imagePipelineListContainer {
                if let structure0 = structure0 {
                    imagePipelineListDecoded0?.append(structure0)
                }
            }
        }
        imagePipelineList = imagePipelineListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImageRecipesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageRecipesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageRecipesOutputError>
}

extension ListImageRecipesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImageRecipesInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), owner: \(Swift.String(describing: owner)))"}
}

extension ListImageRecipesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListImageRecipesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageRecipesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageRecipesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImageRecipesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImageRecipesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageRecipesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImageRecipesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImageRecipesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImageRecipesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImageRecipesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImageRecipes"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImageRecipesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImageRecipesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImageRecipesOutputError>
}

public struct ListImageRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   parentImage
    ///
    ///
    ///
    ///
    ///                   platform
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which image recipes you want to list. By default, this request will only
    /// 			show image recipes owned by your account. You can use this field to specify if you want to
    /// 			view image recipes owned by yourself, by Amazon, or those image recipes that have been shared
    /// 			with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImageRecipesInputBody: Swift.Equatable {
    public let owner: ImagebuilderClientTypes.Ownership?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListImageRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImageRecipesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageRecipesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImageRecipesOutputResponse(imageRecipeSummaryList: \(Swift.String(describing: imageRecipeSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImageRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImageRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeSummaryList = output.imageRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageRecipesOutputResponse: Swift.Equatable {
    /// The list of image pipelines.
    public var imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeSummaryList = imageRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageRecipesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    public let nextToken: Swift.String?
}

extension ListImageRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageRecipeSummary?].self, forKey: .imageRecipeSummaryList)
        var imageRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ImageRecipeSummary]? = nil
        if let imageRecipeSummaryListContainer = imageRecipeSummaryListContainer {
            imageRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ImageRecipeSummary]()
            for structure0 in imageRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    imageRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageRecipeSummaryList = imageRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListImagesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

extension ListImagesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagesInput(byName: \(Swift.String(describing: byName)), filters: \(Swift.String(describing: filters)), includeDeprecated: \(Swift.String(describing: includeDeprecated)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), owner: \(Swift.String(describing: owner)))"}
}

extension ListImagesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let includeDeprecated = includeDeprecated {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

public struct ListImagesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListImagesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListImagesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListImagesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListImagesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListImages"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListImagesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListImagesOutputError>
}

public struct ListImagesInput: Swift.Equatable {
    /// Requests a list of images with a specific recipe name.
    public var byName: Swift.Bool
    /// Use the following filters to streamline results:
    /// 		
    ///
    ///
    ///                   name
    ///
    ///
    ///
    ///
    ///                   osVersion
    ///
    ///
    ///
    ///
    ///                   platform
    ///
    ///
    ///
    ///
    ///                   type
    ///
    ///
    ///
    ///
    ///                   version
    ///
    ///
    ///
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// Includes deprecated images in the response list.
    public var includeDeprecated: Swift.Bool?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which images you want to list. By default, this request will only show
    /// 			images owned by your account. You can use this field to specify if you want to view images
    /// 			owned by yourself, by Amazon, or those images that have been shared with you by other
    /// 			customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        byName: Swift.Bool = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        includeDeprecated: Swift.Bool? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImagesInputBody: Swift.Equatable {
    public let owner: ImagebuilderClientTypes.Ownership?
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let byName: Swift.Bool
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
    public let includeDeprecated: Swift.Bool?
}

extension ListImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decode(Swift.Bool.self, forKey: .byName)
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListImagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListImagesOutputResponse(imageVersionList: \(Swift.String(describing: imageVersionList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageVersionList = output.imageVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagesOutputResponse: Swift.Equatable {
    /// The list of image semantic versions.
    /// 		
    /// 			         The semantic version has four nodes: <major>.<minor>.<patch>/<build>.
    /// 	You can assign values for the first three, and can filter on all of them.
    /// 			
    ///                Filtering: With semantic versioning, you have the flexibility to use wildcards (x)
    /// 	to specify the most recent versions or nodes when selecting the base image or components for your
    /// 	recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be
    /// 	wildcards.
    /// 		
    public var imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageVersionList: [ImagebuilderClientTypes.ImageVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageVersionList = imageVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagesOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    public let nextToken: Swift.String?
}

extension ListImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageVersion?].self, forKey: .imageVersionList)
        var imageVersionListDecoded0:[ImagebuilderClientTypes.ImageVersion]? = nil
        if let imageVersionListContainer = imageVersionListContainer {
            imageVersionListDecoded0 = [ImagebuilderClientTypes.ImageVersion]()
            for structure0 in imageVersionListContainer {
                if let structure0 = structure0 {
                    imageVersionListDecoded0?.append(structure0)
                }
            }
        }
        imageVersionList = imageVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListInfrastructureConfigurationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInfrastructureConfigurationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInfrastructureConfigurationsOutputError>
}

extension ListInfrastructureConfigurationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInfrastructureConfigurationsInput(filters: \(Swift.String(describing: filters)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListInfrastructureConfigurationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListInfrastructureConfigurationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInfrastructureConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInfrastructureConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListInfrastructureConfigurationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInfrastructureConfigurationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListInfrastructureConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInfrastructureConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListInfrastructureConfigurationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListInfrastructureConfigurationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/ListInfrastructureConfigurations"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListInfrastructureConfigurationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListInfrastructureConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListInfrastructureConfigurationsOutputError>
}

public struct ListInfrastructureConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int
    /// A token to specify where to start paginating. This is the NextToken from a previously
    /// 			truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInfrastructureConfigurationsInputBody: Swift.Equatable {
    public let filters: [ImagebuilderClientTypes.Filter]?
    public let maxResults: Swift.Int
    public let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInfrastructureConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInfrastructureConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListInfrastructureConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInfrastructureConfigurationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInfrastructureConfigurationsOutputResponse(infrastructureConfigurationSummaryList: \(Swift.String(describing: infrastructureConfigurationSummaryList)), nextToken: \(Swift.String(describing: nextToken)), requestId: \(Swift.String(describing: requestId)))"}
}

extension ListInfrastructureConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListInfrastructureConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationSummaryList = output.infrastructureConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListInfrastructureConfigurationsOutputResponse: Swift.Equatable {
    /// The list of infrastructure configurations.
    public var infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional
    /// 			elements that the service has not included in this request. Use this token with the next
    /// 			request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListInfrastructureConfigurationsOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    public let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InfrastructureConfigurationSummary?].self, forKey: .infrastructureConfigurationSummaryList)
        var infrastructureConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil
        if let infrastructureConfigurationSummaryListContainer = infrastructureConfigurationSummaryListContainer {
            infrastructureConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.InfrastructureConfigurationSummary]()
            for structure0 in infrastructureConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    infrastructureConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.Logging: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.S3Logs.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension ImagebuilderClientTypes.Logging: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Logging(s3Logs: \(Swift.String(describing: s3Logs)))"}
}

extension ImagebuilderClientTypes {
    /// Logging configuration defines where Image Builder uploads your logs.
    public struct Logging: Swift.Equatable {
        /// The Amazon S3 logging configuration.
        public var s3Logs: ImagebuilderClientTypes.S3Logs?

        public init (
            s3Logs: ImagebuilderClientTypes.S3Logs? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension ImagebuilderClientTypes.OutputResources: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case containers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for amilist0 in amis {
                try amisContainer.encode(amilist0)
            }
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for containerlist0 in containers {
                try containersContainer.encode(containerlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Ami?].self, forKey: .amis)
        var amisDecoded0:[ImagebuilderClientTypes.Ami]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [ImagebuilderClientTypes.Ami]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let containersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[ImagebuilderClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [ImagebuilderClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
    }
}

extension ImagebuilderClientTypes.OutputResources: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputResources(amis: \(Swift.String(describing: amis)), containers: \(Swift.String(describing: containers)))"}
}

extension ImagebuilderClientTypes {
    /// The resources produced by this image.
    public struct OutputResources: Swift.Equatable {
        /// The Amazon EC2 AMIs created by this image.
        public var amis: [ImagebuilderClientTypes.Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public var containers: [ImagebuilderClientTypes.Container]?

        public init (
            amis: [ImagebuilderClientTypes.Ami]? = nil,
            containers: [ImagebuilderClientTypes.Container]? = nil
        )
        {
            self.amis = amis
            self.containers = containers
        }
    }

}

extension ImagebuilderClientTypes {
    public enum Ownership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazon
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .amazon,
                .self,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazon: return "Amazon"
            case .self: return "Self"
            case .shared: return "Shared"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ownership(rawValue: rawValue) ?? Ownership.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum PipelineExecutionStartCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case expressionMatchAndDependencyUpdatesAvailable
        case expressionMatchOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineExecutionStartCondition] {
            return [
                .expressionMatchAndDependencyUpdatesAvailable,
                .expressionMatchOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .expressionMatchAndDependencyUpdatesAvailable: return "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
            case .expressionMatchOnly: return "EXPRESSION_MATCH_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineExecutionStartCondition(rawValue: rawValue) ?? PipelineExecutionStartCondition.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum PipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineStatus(rawValue: rawValue) ?? PipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

public struct PutComponentPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComponentPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComponentPolicyOutputError>
}

extension PutComponentPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutComponentPolicyInput(componentArn: \(Swift.String(describing: componentArn)), policy: \(Swift.String(describing: policy)))"}
}

extension PutComponentPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutComponentPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComponentPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComponentPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutComponentPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutComponentPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComponentPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutComponentPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutComponentPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutComponentPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutComponentPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/PutComponentPolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutComponentPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutComponentPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutComponentPolicyOutputError>
}

public struct PutComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
    /// This member is required.
    public var componentArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        componentArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.policy = policy
    }
}

struct PutComponentPolicyInputBody: Swift.Equatable {
    public let componentArn: Swift.String?
    public let policy: Swift.String?
}

extension PutComponentPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutComponentPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComponentPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutComponentPolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComponentPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutComponentPolicyOutputResponse(componentArn: \(Swift.String(describing: componentArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension PutComponentPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentArn = output.componentArn
            self.requestId = output.requestId
        } else {
            self.componentArn = nil
            self.requestId = nil
        }
    }
}

public struct PutComponentPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
    public var componentArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.requestId = requestId
    }
}

struct PutComponentPolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let componentArn: Swift.String?
}

extension PutComponentPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
    }
}

public struct PutContainerRecipePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContainerRecipePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContainerRecipePolicyOutputError>
}

extension PutContainerRecipePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutContainerRecipePolicyInput(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), policy: \(Swift.String(describing: policy)))"}
}

extension PutContainerRecipePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutContainerRecipePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContainerRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContainerRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutContainerRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContainerRecipePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutContainerRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutContainerRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutContainerRecipePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutContainerRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/PutContainerRecipePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutContainerRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutContainerRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutContainerRecipePolicyOutputError>
}

public struct PutContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
    /// This member is required.
    public var containerRecipeArn: Swift.String?
    /// The policy to apply to the container recipe.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.policy = policy
    }
}

struct PutContainerRecipePolicyInputBody: Swift.Equatable {
    public let containerRecipeArn: Swift.String?
    public let policy: Swift.String?
}

extension PutContainerRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContainerRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutContainerRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContainerRecipePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutContainerRecipePolicyOutputResponse(containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension PutContainerRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutContainerRecipePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct PutContainerRecipePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let containerRecipeArn: Swift.String?
}

extension PutContainerRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

public struct PutImagePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImagePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImagePolicyOutputError>
}

extension PutImagePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImagePolicyInput(imageArn: \(Swift.String(describing: imageArn)), policy: \(Swift.String(describing: policy)))"}
}

extension PutImagePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageArn = imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutImagePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImagePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImagePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImagePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImagePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImagePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutImagePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImagePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImagePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutImagePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/PutImagePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImagePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImagePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImagePolicyOutputError>
}

public struct PutImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
    /// This member is required.
    public var imageArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        imageArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.policy = policy
    }
}

struct PutImagePolicyInputBody: Swift.Equatable {
    public let imageArn: Swift.String?
    public let policy: Swift.String?
}

extension PutImagePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImagePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImagePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImagePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImagePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImagePolicyOutputResponse(imageArn: \(Swift.String(describing: imageArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension PutImagePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImagePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct PutImagePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageArn: Swift.String?
}

extension PutImagePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
    }
}

public struct PutImageRecipePolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageRecipePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageRecipePolicyOutputError>
}

extension PutImageRecipePolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageRecipePolicyInput(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), policy: \(Swift.String(describing: policy)))"}
}

extension PutImageRecipePolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

public struct PutImageRecipePolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageRecipePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageRecipePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutImageRecipePolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageRecipePolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutImageRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImageRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutImageRecipePolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutImageRecipePolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/PutImageRecipePolicy"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutImageRecipePolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutImageRecipePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutImageRecipePolicyOutputError>
}

public struct PutImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
    /// This member is required.
    public var imageRecipeArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.policy = policy
    }
}

struct PutImageRecipePolicyInputBody: Swift.Equatable {
    public let imageRecipeArn: Swift.String?
    public let policy: Swift.String?
}

extension PutImageRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImageRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutImageRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageRecipePolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutImageRecipePolicyOutputResponse(imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension PutImageRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImageRecipePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct PutImageRecipePolicyOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let imageRecipeArn: Swift.String?
}

extension PutImageRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you are trying to create already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDependencyException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDependencyException(message: \(Swift.String(describing: message)))"}
}

extension ResourceDependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to mutate or delete a resource with a dependency that prohibits this
/// 			action. See the error message for more details.
public struct ResourceDependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDependencyExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you are trying to operate on is currently in use. Review the message
/// 			details and retry later.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// At least one of the resources referenced by your request does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.S3Logs: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3KeyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension ImagebuilderClientTypes.S3Logs: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Logs(s3BucketName: \(Swift.String(describing: s3BucketName)), s3KeyPrefix: \(Swift.String(describing: s3KeyPrefix)))"}
}

extension ImagebuilderClientTypes {
    /// Amazon S3 logging configuration.
    public struct S3Logs: Swift.Equatable {
        /// The Amazon S3 bucket in which to store the logs.
        public var s3BucketName: Swift.String?
        /// The Amazon S3 path in which to store the logs.
        public var s3KeyPrefix: Swift.String?

        public init (
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension ImagebuilderClientTypes.Schedule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionStartCondition
        case scheduleExpression
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionStartCondition = pipelineExecutionStartCondition {
            try encodeContainer.encode(pipelineExecutionStartCondition.rawValue, forKey: .pipelineExecutionStartCondition)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let pipelineExecutionStartConditionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineExecutionStartCondition.self, forKey: .pipelineExecutionStartCondition)
        pipelineExecutionStartCondition = pipelineExecutionStartConditionDecoded
    }
}

extension ImagebuilderClientTypes.Schedule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Schedule(pipelineExecutionStartCondition: \(Swift.String(describing: pipelineExecutionStartCondition)), scheduleExpression: \(Swift.String(describing: scheduleExpression)), timezone: \(Swift.String(describing: timezone)))"}
}

extension ImagebuilderClientTypes {
    /// A schedule configures how often and when a pipeline will automatically create a new image.
    public struct Schedule: Swift.Equatable {
        /// The condition configures when the pipeline should trigger a new image build. When the
        /// 			pipelineExecutionStartCondition is set to
        /// 			EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version
        /// 			filters on the base image or components in your image recipe, EC2 Image Builder will build a
        /// 			new image only when there are new versions of the image or components in your recipe that
        /// 			match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it
        /// 			will build a new image every time the CRON expression matches the current time. For semantic
        /// 			version syntax, see <a href="https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html">CreateComponent in the  EC2 Image Builder API
        /// 					Reference.
        public var pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your
        /// 			pipelineExecutionStartCondition.
        /// 		       For information on how to format a cron expression in Image Builder, see <a href="https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html">Use cron
        /// 			expressions in EC2 Image Builder.
        public var scheduleExpression: Swift.String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC",
        /// 			"America/Los_Angeles" in the <a href="https://www.joda.org/joda-time/timezones.html">IANA
        /// 				timezone format. If not specified this defaults to UTC.
        public var timezone: Swift.String?

        public init (
            pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition? = nil,
            scheduleExpression: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }
    }

}

extension ServiceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceException(message: \(Swift.String(describing: message)))"}
}

extension ServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the service encounters an unrecoverable exception.
public struct ServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceQuotaExceededException(message: \(Swift.String(describing: message)))"}
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the number of permitted resources or operations for this service. For service quotas, see <a href="https://docs.aws.amazon.com/general/latest/gr/imagebuilder.html#limits_imagebuilder">EC2 Image Builder endpoints and quotas.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is unable to process your request at this time.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartImagePipelineExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImagePipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImagePipelineExecutionOutputError>
}

extension StartImagePipelineExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImagePipelineExecutionInput(clientToken: \(Swift.String(describing: clientToken)), imagePipelineArn: \(Swift.String(describing: imagePipelineArn)))"}
}

extension StartImagePipelineExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
    }
}

public struct StartImagePipelineExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImagePipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImagePipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartImagePipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImagePipelineExecutionInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartImagePipelineExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartImagePipelineExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartImagePipelineExecutionInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartImagePipelineExecutionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/StartImagePipelineExecution"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartImagePipelineExecutionInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartImagePipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartImagePipelineExecutionOutputError>
}

public struct StartImagePipelineExecutionInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
    }
}

struct StartImagePipelineExecutionInputBody: Swift.Equatable {
    public let imagePipelineArn: Swift.String?
    public let clientToken: Swift.String?
}

extension StartImagePipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartImagePipelineExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImagePipelineExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartImagePipelineExecutionOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImagePipelineExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartImagePipelineExecutionOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imageBuildVersionArn: \(Swift.String(describing: imageBuildVersionArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension StartImagePipelineExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartImagePipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct StartImagePipelineExecutionOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that was created by this request.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct StartImagePipelineExecutionOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imageBuildVersionArn: Swift.String?
}

extension StartImagePipelineExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ImagebuilderClientTypes.SystemsManagerAgent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uninstallAfterBuild
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uninstallAfterBuild = uninstallAfterBuild {
            try encodeContainer.encode(uninstallAfterBuild, forKey: .uninstallAfterBuild)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uninstallAfterBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .uninstallAfterBuild)
        uninstallAfterBuild = uninstallAfterBuildDecoded
    }
}

extension ImagebuilderClientTypes.SystemsManagerAgent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SystemsManagerAgent(uninstallAfterBuild: \(Swift.String(describing: uninstallAfterBuild)))"}
}

extension ImagebuilderClientTypes {
    /// Contains settings for the Systems Manager agent on your build instance.
    public struct SystemsManagerAgent: Swift.Equatable {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to creating
        /// 			the new AMI. If this is set to true, then the agent is removed from the final image. If it's
        /// 			set to false, then the agent is left in, so that it is included in the new AMI. The default
        /// 			value is false.
        public var uninstallAfterBuild: Swift.Bool?

        public init (
            uninstallAfterBuild: Swift.Bool? = nil
        )
        {
            self.uninstallAfterBuild = uninstallAfterBuild
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ImagebuilderClientTypes.TargetContainerRepository: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let service = service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRepositoryService.self, forKey: .service)
        service = serviceDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension ImagebuilderClientTypes.TargetContainerRepository: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TargetContainerRepository(repositoryName: \(Swift.String(describing: repositoryName)), service: \(Swift.String(describing: service)))"}
}

extension ImagebuilderClientTypes {
    /// The container repository where the output container image is stored.
    public struct TargetContainerRepository: Swift.Equatable {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// Specifies the service in which this image was registered.
        /// This member is required.
        public var service: ImagebuilderClientTypes.ContainerRepositoryService?

        public init (
            repositoryName: Swift.String? = nil,
            service: ImagebuilderClientTypes.ContainerRepositoryService? = nil
        )
        {
            self.repositoryName = repositoryName
            self.service = service
        }
    }

}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let resourceArn = input.resourceArn else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("resourceArn is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/tags/\(resourceArn.urlPercentEncoding())"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDistributionConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionConfigurationOutputError>
}

extension UpdateDistributionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), distributions: \(Swift.String(describing: distributions)))"}
}

extension UpdateDistributionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distributionlist0 in distributions {
                try distributionsContainer.encode(distributionlist0)
            }
        }
    }
}

public struct UpdateDistributionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDistributionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDistributionConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateDistributionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/UpdateDistributionConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDistributionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDistributionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDistributionConfigurationOutputError>
}

public struct UpdateDistributionConfigurationInput: Swift.Equatable {
    /// The idempotency token of the distribution configuration.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.distributions = distributions
    }
}

struct UpdateDistributionConfigurationInputBody: Swift.Equatable {
    public let distributionConfigurationArn: Swift.String?
    public let description: Swift.String?
    public let distributions: [ImagebuilderClientTypes.Distribution]?
    public let clientToken: Swift.String?
}

extension UpdateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDistributionConfigurationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension UpdateDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this
    /// 			request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateDistributionConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let distributionConfigurationArn: Swift.String?
}

extension UpdateDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

public struct UpdateImagePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePipelineOutputError>
}

extension UpdateImagePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateImagePipelineInput(clientToken: \(Swift.String(describing: clientToken)), containerRecipeArn: \(Swift.String(describing: containerRecipeArn)), description: \(Swift.String(describing: description)), distributionConfigurationArn: \(Swift.String(describing: distributionConfigurationArn)), enhancedImageMetadataEnabled: \(Swift.String(describing: enhancedImageMetadataEnabled)), imagePipelineArn: \(Swift.String(describing: imagePipelineArn)), imageRecipeArn: \(Swift.String(describing: imageRecipeArn)), imageTestsConfiguration: \(Swift.String(describing: imageTestsConfiguration)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), schedule: \(Swift.String(describing: schedule)), status: \(Swift.String(describing: status)))"}
}

extension UpdateImagePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imagePipelineArn = imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let imageRecipeArn = imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateImagePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateImagePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePipelineInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateImagePipelineInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateImagePipelineInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/UpdateImagePipeline"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateImagePipelineInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateImagePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateImagePipelineOutputError>
}

public struct UpdateImagePipelineInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container pipeline to update.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to
    /// 			configure and distribute images updated by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    ///  Collects additional information about the image being created, including the operating
    /// 			system (OS) version and package list. This information is used to enhance the overall
    /// 			experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images
    /// 			updated by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to
    /// 			build images updated by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imagePipelineArn: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imagePipelineArn = imagePipelineArn
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.schedule = schedule
        self.status = status
    }
}

struct UpdateImagePipelineInputBody: Swift.Equatable {
    public let imagePipelineArn: Swift.String?
    public let description: Swift.String?
    public let imageRecipeArn: Swift.String?
    public let containerRecipeArn: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
    public let distributionConfigurationArn: Swift.String?
    public let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    public let enhancedImageMetadataEnabled: Swift.Bool?
    public let schedule: ImagebuilderClientTypes.Schedule?
    public let status: ImagebuilderClientTypes.PipelineStatus?
    public let clientToken: Swift.String?
}

extension UpdateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateImagePipelineOutputResponse(clientToken: \(Swift.String(describing: clientToken)), imagePipelineArn: \(Swift.String(describing: imagePipelineArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension UpdateImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateImagePipelineOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct UpdateImagePipelineOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let imagePipelineArn: Swift.String?
}

extension UpdateImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

public struct UpdateInfrastructureConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInfrastructureConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInfrastructureConfigurationOutputError>
}

extension UpdateInfrastructureConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInfrastructureConfigurationInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), instanceMetadataOptions: \(Swift.String(describing: instanceMetadataOptions)), instanceProfileName: \(Swift.String(describing: instanceProfileName)), instanceTypes: \(Swift.String(describing: instanceTypes)), keyPair: \(Swift.String(describing: keyPair)), logging: \(Swift.String(describing: logging)), resourceTags: \(Swift.String(describing: resourceTags)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), snsTopicArn: \(Swift.String(describing: snsTopicArn)), subnetId: \(Swift.String(describing: subnetId)), terminateInstanceOnFailure: \(Swift.String(describing: terminateInstanceOnFailure)))"}
}

extension UpdateInfrastructureConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let infrastructureConfigurationArn = infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let instanceMetadataOptions = instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetypelist0 in instanceTypes {
                try instanceTypesContainer.encode(instancetypelist0)
            }
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourcetagmap0) in resourceTags {
                try resourceTagsContainer.encode(resourcetagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let terminateInstanceOnFailure = terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

public struct UpdateInfrastructureConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInfrastructureConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInfrastructureConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateInfrastructureConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInfrastructureConfigurationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateInfrastructureConfigurationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateInfrastructureConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/UpdateInfrastructureConfiguration"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateInfrastructureConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateInfrastructureConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateInfrastructureConfigurationOutputError>
}

public struct UpdateInfrastructureConfigurationInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to
    /// 			update.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds
    /// 			use to launch EC2 build and test instances. For more information about instance metadata
    /// 			options, see one of the following links:
    /// 		
    ///
    /// 				
    ///                   <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html">Configure
    /// 					the instance metadata options in the
    ///                      Amazon EC2 User Guide
    ///
    /// 					for Linux instances.
    /// 			
    ///
    /// 				
    ///                   <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html">Configure
    /// 					the instance metadata options in the
    ///                      Amazon EC2 Windows Guide
    ///
    /// 					for Windows instances.
    /// 			
    ///
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more
    /// 			instance types to use for this build. The service will pick one of these instance types based
    /// 			on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug
    /// 			the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The SNS topic on which to send image build events.
    public var snsTopicArn: Swift.String?
    /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
    public var subnetId: Swift.String?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to
    /// 			false if you want Image Builder to retain the instance used to configure your AMI if the build
    /// 			or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct UpdateInfrastructureConfigurationInputBody: Swift.Equatable {
    public let infrastructureConfigurationArn: Swift.String?
    public let description: Swift.String?
    public let instanceTypes: [Swift.String]?
    public let instanceProfileName: Swift.String?
    public let securityGroupIds: [Swift.String]?
    public let subnetId: Swift.String?
    public let logging: ImagebuilderClientTypes.Logging?
    public let keyPair: Swift.String?
    public let terminateInstanceOnFailure: Swift.Bool?
    public let snsTopicArn: Swift.String?
    public let clientToken: Swift.String?
    public let resourceTags: [Swift.String:Swift.String]?
    public let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
}

extension UpdateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
    }
}

extension UpdateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInfrastructureConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateInfrastructureConfigurationOutputResponse(clientToken: \(Swift.String(describing: clientToken)), infrastructureConfigurationArn: \(Swift.String(describing: infrastructureConfigurationArn)), requestId: \(Swift.String(describing: requestId)))"}
}

extension UpdateInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by
    /// 			this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    public let requestId: Swift.String?
    public let clientToken: Swift.String?
    public let infrastructureConfigurationArn: Swift.String?
}

extension UpdateInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}
