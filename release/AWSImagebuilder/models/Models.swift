// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ImagebuilderClientTypes.AdditionalInstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case systemsManagerAgent
        case userDataOverride
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let systemsManagerAgent = self.systemsManagerAgent {
            try encodeContainer.encode(systemsManagerAgent, forKey: .systemsManagerAgent)
        }
        if let userDataOverride = self.userDataOverride {
            try encodeContainer.encode(userDataOverride, forKey: .userDataOverride)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let systemsManagerAgentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.SystemsManagerAgent.self, forKey: .systemsManagerAgent)
        systemsManagerAgent = systemsManagerAgentDecoded
        let userDataOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userDataOverride)
        userDataOverride = userDataOverrideDecoded
    }
}

extension ImagebuilderClientTypes {
    /// In addition to your infrastruction configuration, these settings provide an extra layer of control over your build instances. For instances where Image Builder installs the Systems Manager agent, you can choose whether to keep it for the AMI that you create. You can also specify commands to run on launch for all of your build instances.
    public struct AdditionalInstanceConfiguration: Swift.Equatable {
        /// Contains settings for the Systems Manager agent on your build instance.
        public var systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent?
        /// Use this property to provide commands or a command script to run when you launch your build instance. The userDataOverride property replaces any commands that Image Builder might have added to ensure that Systems Manager is installed on your Linux build instance. If you override the user data, make sure that you add commands to install Systems Manager, if it is not pre-installed on your base image. The user data is always base 64 encoded. For example, the following commands are encoded as IyEvYmluL2Jhc2gKbWtkaXIgLXAgL3Zhci9iYi8KdG91Y2ggL3Zhci$: #!/bin/bash mkdir -p /var/bb/ touch /var
        public var userDataOverride: Swift.String?

        public init (
            systemsManagerAgent: ImagebuilderClientTypes.SystemsManagerAgent? = nil,
            userDataOverride: Swift.String? = nil
        )
        {
            self.systemsManagerAgent = systemsManagerAgent
            self.userDataOverride = userDataOverride
        }
    }

}

extension ImagebuilderClientTypes.Ami: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case description
        case image
        case name
        case region
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Details of an Amazon EC2 AMI.
    public struct Ami: Swift.Equatable {
        /// The account ID of the owner of the AMI.
        public var accountId: Swift.String?
        /// The description of the Amazon EC2 AMI. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The AMI ID of the Amazon EC2 AMI.
        public var image: Swift.String?
        /// The name of the Amazon EC2 AMI.
        public var name: Swift.String?
        /// The Amazon Web Services Region of the Amazon EC2 AMI.
        public var region: Swift.String?
        /// Image state shows the image status and the reason for that status.
        public var state: ImagebuilderClientTypes.ImageState?

        public init (
            accountId: Swift.String? = nil,
            description: Swift.String? = nil,
            image: Swift.String? = nil,
            name: Swift.String? = nil,
            region: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil
        )
        {
            self.accountId = accountId
            self.description = description
            self.image = image
            self.name = name
            self.region = region
            self.state = state
        }
    }

}

extension ImagebuilderClientTypes.AmiDistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiTags
        case description
        case kmsKeyId
        case launchPermission
        case name
        case targetAccountIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiTags = amiTags {
            var amiTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .amiTags)
            for (dictKey0, tagMap0) in amiTags {
                try amiTagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let launchPermission = self.launchPermission {
            try encodeContainer.encode(launchPermission, forKey: .launchPermission)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAccountIds = targetAccountIds {
            var targetAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetAccountIds)
            for accountid0 in targetAccountIds {
                try targetAccountIdsContainer.encode(accountid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let targetAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetAccountIds)
        var targetAccountIdsDecoded0:[Swift.String]? = nil
        if let targetAccountIdsContainer = targetAccountIdsContainer {
            targetAccountIdsDecoded0 = [Swift.String]()
            for string0 in targetAccountIdsContainer {
                if let string0 = string0 {
                    targetAccountIdsDecoded0?.append(string0)
                }
            }
        }
        targetAccountIds = targetAccountIdsDecoded0
        let amiTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .amiTags)
        var amiTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let amiTagsContainer = amiTagsContainer {
            amiTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in amiTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    amiTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        amiTags = amiTagsDecoded0
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let launchPermissionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.LaunchPermissionConfiguration.self, forKey: .launchPermission)
        launchPermission = launchPermissionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Define and configure the output AMIs of the pipeline.
    public struct AmiDistributionConfiguration: Swift.Equatable {
        /// The tags to apply to AMIs distributed to this Region.
        public var amiTags: [Swift.String:Swift.String]?
        /// The description of the AMI distribution configuration. Minimum and maximum length are in characters.
        public var description: Swift.String?
        /// The KMS key identifier used to encrypt the distributed image.
        public var kmsKeyId: Swift.String?
        /// Launch permissions can be used to configure which Amazon Web Services accounts can use the AMI to launch instances.
        public var launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration?
        /// The name of the output AMI.
        public var name: Swift.String?
        /// The ID of an account to which you want to distribute an image.
        public var targetAccountIds: [Swift.String]?

        public init (
            amiTags: [Swift.String:Swift.String]? = nil,
            description: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            launchPermission: ImagebuilderClientTypes.LaunchPermissionConfiguration? = nil,
            name: Swift.String? = nil,
            targetAccountIds: [Swift.String]? = nil
        )
        {
            self.amiTags = amiTags
            self.description = description
            self.kmsKeyId = kmsKeyId
            self.launchPermission = launchPermission
            self.name = name
            self.targetAccountIds = targetAccountIds
        }
    }

}

extension ImagebuilderClientTypes {
    public enum BuildType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `import`
        case scheduled
        case userInitiated
        case sdkUnknown(Swift.String)

        public static var allCases: [BuildType] {
            return [
                .import,
                .scheduled,
                .userInitiated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .import: return "IMPORT"
            case .scheduled: return "SCHEDULED"
            case .userInitiated: return "USER_INITIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BuildType(rawValue: rawValue) ?? BuildType.sdkUnknown(rawValue)
        }
    }
}

extension CallRateLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CallRateLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the permitted request rate for the specific operation.
public struct CallRateLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CallRateLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CallRateLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CancelImageCreationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
    }
}

extension CancelImageCreationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CancelImageCreation"
    }
}

public struct CancelImageCreationInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image whose creation you want to cancel.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct CancelImageCreationInputBody: Swift.Equatable {
    let imageBuildVersionArn: Swift.String?
    let clientToken: Swift.String?
}

extension CancelImageCreationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CancelImageCreationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelImageCreationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CancelImageCreationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelImageCreationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CancelImageCreationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CancelImageCreationOutputResponse: Swift.Equatable {
    /// The idempotency token that was used for this request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image whose creation has been cancelled.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CancelImageCreationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension CancelImageCreationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ClientException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// These errors are usually caused by a client action, such as using an action or resource on behalf of a user that doesn't have permissions to use the action or resource, or specifying an invalid resource identifier.
public struct ClientException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case data
        case dateCreated
        case description
        case encrypted
        case kmsKeyId
        case name
        case owner
        case parameters
        case platform
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameterdetail0 in parameters {
                try parametersContainer.encode(componentparameterdetail0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameterDetail?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameterDetail]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameterDetail]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A detailed view of a component.
    public struct Component: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description of the component.
        public var changeDescription: Swift.String?
        /// Component data contains the YAML document content for the component.
        public var data: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The encryption status of the component.
        public var encrypted: Swift.Bool?
        /// The KMS key identifier used to encrypt the component.
        public var kmsKeyId: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// Contains parameter details for each of the parameters that are defined for the component.
        public var parameters: [ImagebuilderClientTypes.ComponentParameterDetail]?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Describes the current status of the component. This is used for components that are no longer active.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags associated with the component.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            data: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameterDetail]? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.data = data
            self.dateCreated = dateCreated
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parameters = parameters
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ComponentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = self.componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for componentparameter0 in parameters {
                try parametersContainer.encode(componentparameter0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentParameter?].self, forKey: .parameters)
        var parametersDecoded0:[ImagebuilderClientTypes.ComponentParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [ImagebuilderClientTypes.ComponentParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Configuration details of the component.
    public struct ComponentConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        /// This member is required.
        public var componentArn: Swift.String?
        /// A group of parameter settings that are used to configure the component for a specific recipe.
        public var parameters: [ImagebuilderClientTypes.ComponentParameter]?

        public init (
            componentArn: Swift.String? = nil,
            parameters: [ImagebuilderClientTypes.ComponentParameter]? = nil
        )
        {
            self.componentArn = componentArn
            self.parameters = parameters
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case shell
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentFormat] {
            return [
                .shell,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .shell: return "SHELL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentFormat(rawValue: rawValue) ?? ComponentFormat.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            var valueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .value)
            for componentparametervalue0 in value {
                try valueContainer.encode(componentparametervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .value)
        var valueDecoded0:[Swift.String]? = nil
        if let valueContainer = valueContainer {
            valueDecoded0 = [Swift.String]()
            for string0 in valueContainer {
                if let string0 = string0 {
                    valueDecoded0?.append(string0)
                }
            }
        }
        value = valueDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Contains a key/value pair that sets the named component parameter.
    public struct ComponentParameter: Swift.Equatable {
        /// The name of the component parameter to set.
        /// This member is required.
        public var name: Swift.String?
        /// Sets the value for the named component parameter.
        /// This member is required.
        public var value: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            value: [Swift.String]? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension ImagebuilderClientTypes.ComponentParameterDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case description
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            var defaultValueContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValue)
            for componentparametervalue0 in defaultValue {
                try defaultValueContainer.encode(componentparametervalue0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let defaultValueContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultValue)
        var defaultValueDecoded0:[Swift.String]? = nil
        if let defaultValueContainer = defaultValueContainer {
            defaultValueDecoded0 = [Swift.String]()
            for string0 in defaultValueContainer {
                if let string0 = string0 {
                    defaultValueDecoded0?.append(string0)
                }
            }
        }
        defaultValue = defaultValueDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines a parameter that is used to provide configuration details for the component.
    public struct ComponentParameterDetail: Swift.Equatable {
        /// The default value of this parameter if no input is provided.
        public var defaultValue: [Swift.String]?
        /// Describes this parameter.
        public var description: Swift.String?
        /// The name of this input parameter.
        /// This member is required.
        public var name: Swift.String?
        /// The type of input this parameter provides. The currently supported value is "string".
        /// This member is required.
        public var type: Swift.String?

        public init (
            defaultValue: [Swift.String]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.name = name
            self.type = type
        }
    }

}

extension ImagebuilderClientTypes.ComponentState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A group of fields that describe the current status of components that are no longer active.
    public struct ComponentState: Swift.Equatable {
        /// Describes how or why the component changed state.
        public var reason: Swift.String?
        /// The current state of the component.
        public var status: ImagebuilderClientTypes.ComponentStatus?

        public init (
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ComponentStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentStatus] {
            return [
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentStatus(rawValue: rawValue) ?? ComponentStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case changeDescription
        case dateCreated
        case description
        case name
        case owner
        case platform
        case state
        case supportedOsVersions
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A high-level summary of a component.
    public struct ComponentSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component.
        public var arn: Swift.String?
        /// The change description of the component.
        public var changeDescription: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Describes the current status of the component.
        public var state: ImagebuilderClientTypes.ComponentState?
        /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The tags associated with the component.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The version of the component.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            changeDescription: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ComponentState? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.changeDescription = changeDescription
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.state = state
            self.supportedOsVersions = supportedOsVersions
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ComponentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case build
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ComponentType] {
            return [
                .build,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .build: return "BUILD"
            case .test: return "TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComponentType(rawValue: rawValue) ?? ComponentType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ComponentVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case description
        case name
        case owner
        case platform
        case supportedOsVersions
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Amazon Web Services TOE component.
    public struct ComponentVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the component. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// The date that the component was created.
        public var dateCreated: Swift.String?
        /// The description of the component.
        public var description: Swift.String?
        /// The name of the component.
        public var name: Swift.String?
        /// The owner of the component.
        public var owner: Swift.String?
        /// The platform of the component.
        public var platform: ImagebuilderClientTypes.Platform?
        /// he operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
        public var supportedOsVersions: [Swift.String]?
        /// The type of the component denotes whether the component is used to build the image or only to test it.
        public var type: ImagebuilderClientTypes.ComponentType?
        /// The semantic version of the component. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            supportedOsVersions: [Swift.String]? = nil,
            type: ImagebuilderClientTypes.ComponentType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.platform = platform
            self.supportedOsVersions = supportedOsVersions
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageUris
        case region
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUris = imageUris {
            var imageUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageUris)
            for nonemptystring0 in imageUris {
                try imageUrisContainer.encode(nonemptystring0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let imageUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageUris)
        var imageUrisDecoded0:[Swift.String]? = nil
        if let imageUrisContainer = imageUrisContainer {
            imageUrisDecoded0 = [Swift.String]()
            for string0 in imageUrisContainer {
                if let string0 = string0 {
                    imageUrisDecoded0?.append(string0)
                }
            }
        }
        imageUris = imageUrisDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A container encapsulates the runtime environment for an application.
    public struct Container: Swift.Equatable {
        /// A list of URIs for containers created in the context Region.
        public var imageUris: [Swift.String]?
        /// Containers and container images are Region-specific. This is the Region context for the container.
        public var region: Swift.String?

        public init (
            imageUris: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.imageUris = imageUris
            self.region = region
        }
    }

}

extension ImagebuilderClientTypes.ContainerDistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerTags
        case description
        case targetRepository
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerTags = containerTags {
            var containerTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containerTags)
            for nonemptystring0 in containerTags {
                try containerTagsContainer.encode(nonemptystring0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let containerTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .containerTags)
        var containerTagsDecoded0:[Swift.String]? = nil
        if let containerTagsContainer = containerTagsContainer {
            containerTagsDecoded0 = [Swift.String]()
            for string0 in containerTagsContainer {
                if let string0 = string0 {
                    containerTagsDecoded0?.append(string0)
                }
            }
        }
        containerTags = containerTagsDecoded0
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
    public struct ContainerDistributionConfiguration: Swift.Equatable {
        /// Tags that are attached to the container distribution configuration.
        public var containerTags: [Swift.String]?
        /// The description of the container distribution configuration.
        public var description: Swift.String?
        /// The destination repository for the container distribution configuration.
        /// This member is required.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?

        public init (
            containerTags: [Swift.String]? = nil,
            description: Swift.String? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil
        )
        {
            self.containerTags = containerTags
            self.description = description
            self.targetRepository = targetRepository
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case components
        case containerType
        case dateCreated
        case description
        case dockerfileTemplateData
        case encrypted
        case instanceConfiguration
        case kmsKeyId
        case name
        case owner
        case parentImage
        case platform
        case tags
        case targetRepository
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = self.dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A container recipe.
    public struct ContainerRecipe: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Components for build and test that are included in the container recipe.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// Specifies the type of container, such as Docker.
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the container recipe.
        public var description: Swift.String?
        /// Dockerfiles are text documents that are used to build Docker containers, and ensure that they contain all of the elements required by the application running inside. The template data consists of contextual variables where Image Builder places build information or scripts, based on your container image recipe.
        public var dockerfileTemplateData: Swift.String?
        /// A flag that indicates if the target container is encrypted.
        public var encrypted: Swift.Bool?
        /// A group of options that can be used to configure an instance for building and testing container images.
        public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
        /// Identifies which KMS key is used to encrypt the container image for distribution to the target Region.
        public var kmsKeyId: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?
        /// The destination repository for the container image.
        public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
        /// The semantic version of the container recipe. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?
        /// The working directory for use during build and test workflows.
        public var workingDirectory: Swift.String?

        public init (
            arn: Swift.String? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            dockerfileTemplateData: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
            kmsKeyId: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.arn = arn
            self.components = components
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.description = description
            self.dockerfileTemplateData = dockerfileTemplateData
            self.encrypted = encrypted
            self.instanceConfiguration = instanceConfiguration
            self.kmsKeyId = kmsKeyId
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.targetRepository = targetRepository
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ContainerRecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerType
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A summary of a container recipe
    public struct ContainerRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the container recipe.
        public var arn: Swift.String?
        /// Specifies the type of container, such as "Docker".
        public var containerType: ImagebuilderClientTypes.ContainerType?
        /// The date when this container recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the container recipe.
        public var name: Swift.String?
        /// The owner of the container recipe.
        public var owner: Swift.String?
        /// The base image for the container recipe.
        public var parentImage: Swift.String?
        /// The system platform for the container, such as Windows or Linux.
        public var platform: ImagebuilderClientTypes.Platform?
        /// Tags that are attached to the container recipe.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerType: ImagebuilderClientTypes.ContainerType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerType = containerType
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ContainerRepositoryService: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ecr
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerRepositoryService] {
            return [
                .ecr,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ecr: return "ECR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerRepositoryService(rawValue: rawValue) ?? ContainerRepositoryService.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum ContainerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ContainerType] {
            return [
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContainerType(rawValue: rawValue) ?? ContainerType.sdkUnknown(rawValue)
        }
    }
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let supportedOsVersions = supportedOsVersions {
            var supportedOsVersionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .supportedOsVersions)
            for osversion0 in supportedOsVersions {
                try supportedOsVersionsContainer.encode(osversion0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateComponent"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// The idempotency token of the component.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Component data contains inline YAML document content for the component. Alternatively, you can specify the uri of a YAML document file stored in Amazon S3. However, you cannot specify both properties.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The operating system (OS) version supported by the component. If the OS information is available, a prefix match is performed against the base image OS version during image recipe creation.
    public var supportedOsVersions: [Swift.String]?
    /// The tags of the component.
    public var tags: [Swift.String:Swift.String]?
    /// The uri of a YAML component document file. This must be an S3 URL (s3://bucket/key), and the requester must have permission to access the S3 bucket it points to. If you use Amazon S3, you can specify component content up to your service quota. Alternatively, you can specify the YAML document inline, using the component data property. You cannot specify both properties.
    public var uri: Swift.String?

    public init (
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        supportedOsVersions: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.supportedOsVersions = supportedOsVersions
        self.tags = tags
        self.uri = uri
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let changeDescription: Swift.String?
    let platform: ImagebuilderClientTypes.Platform?
    let supportedOsVersions: [Swift.String]?
    let data: Swift.String?
    let uri: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case supportedOsVersions
        case tags
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let supportedOsVersionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .supportedOsVersions)
        var supportedOsVersionsDecoded0:[Swift.String]? = nil
        if let supportedOsVersionsContainer = supportedOsVersionsContainer {
            supportedOsVersionsDecoded0 = [Swift.String]()
            for string0 in supportedOsVersionsContainer {
                if let string0 = string0 {
                    supportedOsVersionsDecoded0?.append(string0)
                }
            }
        }
        supportedOsVersions = supportedOsVersionsDecoded0
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateComponentOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the component that was created by this request.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateComponentOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension CreateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension CreateContainerRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let containerType = self.containerType {
            try encodeContainer.encode(containerType.rawValue, forKey: .containerType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dockerfileTemplateData = self.dockerfileTemplateData {
            try encodeContainer.encode(dockerfileTemplateData, forKey: .dockerfileTemplateData)
        }
        if let dockerfileTemplateUri = self.dockerfileTemplateUri {
            try encodeContainer.encode(dockerfileTemplateUri, forKey: .dockerfileTemplateUri)
        }
        if let imageOsVersionOverride = self.imageOsVersionOverride {
            try encodeContainer.encode(imageOsVersionOverride, forKey: .imageOsVersionOverride)
        }
        if let instanceConfiguration = self.instanceConfiguration {
            try encodeContainer.encode(instanceConfiguration, forKey: .instanceConfiguration)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platformOverride = self.platformOverride {
            try encodeContainer.encode(platformOverride.rawValue, forKey: .platformOverride)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetRepository = self.targetRepository {
            try encodeContainer.encode(targetRepository, forKey: .targetRepository)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateContainerRecipe"
    }
}

public struct CreateContainerRecipeInput: Swift.Equatable {
    /// The client token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Components for build and test that are included in the container recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The type of container to create.
    /// This member is required.
    public var containerType: ImagebuilderClientTypes.ContainerType?
    /// The description of the container recipe.
    public var description: Swift.String?
    /// The Dockerfile template used to build your image as an inline data blob.
    public var dockerfileTemplateData: Swift.String?
    /// The Amazon S3 URI for the Dockerfile that will be used to build your container image.
    public var dockerfileTemplateUri: Swift.String?
    /// Specifies the operating system version for the base image.
    public var imageOsVersionOverride: Swift.String?
    /// A group of options that can be used to configure an instance for building and testing container images.
    public var instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    /// Identifies which KMS key is used to encrypt the container image.
    public var kmsKeyId: Swift.String?
    /// The name of the container recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image for the container recipe.
    /// This member is required.
    public var parentImage: Swift.String?
    /// Specifies the operating system platform when you use a custom base image.
    public var platformOverride: ImagebuilderClientTypes.Platform?
    /// The semantic version of the container recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the container recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The destination repository for the container image.
    /// This member is required.
    public var targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    /// The working directory for use during build and test workflows.
    public var workingDirectory: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        containerType: ImagebuilderClientTypes.ContainerType? = nil,
        description: Swift.String? = nil,
        dockerfileTemplateData: Swift.String? = nil,
        dockerfileTemplateUri: Swift.String? = nil,
        imageOsVersionOverride: Swift.String? = nil,
        instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        platformOverride: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetRepository: ImagebuilderClientTypes.TargetContainerRepository? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.components = components
        self.containerType = containerType
        self.description = description
        self.dockerfileTemplateData = dockerfileTemplateData
        self.dockerfileTemplateUri = dockerfileTemplateUri
        self.imageOsVersionOverride = imageOsVersionOverride
        self.instanceConfiguration = instanceConfiguration
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.parentImage = parentImage
        self.platformOverride = platformOverride
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.targetRepository = targetRepository
        self.workingDirectory = workingDirectory
    }
}

struct CreateContainerRecipeInputBody: Swift.Equatable {
    let containerType: ImagebuilderClientTypes.ContainerType?
    let name: Swift.String?
    let description: Swift.String?
    let semanticVersion: Swift.String?
    let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    let instanceConfiguration: ImagebuilderClientTypes.InstanceConfiguration?
    let dockerfileTemplateData: Swift.String?
    let dockerfileTemplateUri: Swift.String?
    let platformOverride: ImagebuilderClientTypes.Platform?
    let imageOsVersionOverride: Swift.String?
    let parentImage: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let workingDirectory: Swift.String?
    let targetRepository: ImagebuilderClientTypes.TargetContainerRepository?
    let kmsKeyId: Swift.String?
    let clientToken: Swift.String?
}

extension CreateContainerRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case components
        case containerType
        case description
        case dockerfileTemplateData
        case dockerfileTemplateUri
        case imageOsVersionOverride
        case instanceConfiguration
        case kmsKeyId
        case name
        case parentImage
        case platformOverride
        case semanticVersion
        case tags
        case targetRepository
        case workingDirectory
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerType.self, forKey: .containerType)
        containerType = containerTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let instanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceConfiguration.self, forKey: .instanceConfiguration)
        instanceConfiguration = instanceConfigurationDecoded
        let dockerfileTemplateDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateData)
        dockerfileTemplateData = dockerfileTemplateDataDecoded
        let dockerfileTemplateUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dockerfileTemplateUri)
        dockerfileTemplateUri = dockerfileTemplateUriDecoded
        let platformOverrideDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platformOverride)
        platformOverride = platformOverrideDecoded
        let imageOsVersionOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageOsVersionOverride)
        imageOsVersionOverride = imageOsVersionOverrideDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let targetRepositoryDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.TargetContainerRepository.self, forKey: .targetRepository)
        targetRepository = targetRepositoryDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateContainerRecipeOutputResponse: Swift.Equatable {
    /// The client token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// Returns the Amazon Resource Name (ARN) of the container recipe that the request created.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct CreateContainerRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension CreateContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

extension CreateDistributionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateDistributionConfiguration"
    }
}

public struct CreateDistributionConfigurationInput: Swift.Equatable {
    /// The idempotency token of the distribution configuration.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?
    /// The name of the distribution configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags of the distribution configuration.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributions = distributions
        self.name = name
        self.tags = tags
    }
}

struct CreateDistributionConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let distributions: [ImagebuilderClientTypes.Distribution]?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributions
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was created by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct CreateDistributionConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension CreateDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

extension CreateImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImage"
    }
}

public struct CreateImageInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that defines how images are configured and tested.
    public var containerRecipeArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that defines and configures the outputs of your pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image recipe that defines how images are configured, tested, and assessed.
    public var imageRecipeArn: Swift.String?
    /// The image tests configuration of the image.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that defines the environment in which your image will be built and tested.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The tags of the image.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.tags = tags
    }
}

struct CreateImageInputBody: Swift.Equatable {
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that was created by this request.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct CreateImageOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension CreateImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension CreateImagePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImagePipeline"
    }
}

public struct CreateImagePipelineInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container recipe that is used to configure images created by this container pipeline.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images created by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images created by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images created by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The name of the image pipeline.
    /// This member is required.
    public var name: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?
    /// The tags of the image pipeline.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        name: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.name = name
        self.schedule = schedule
        self.status = status
        self.tags = tags
    }
}

struct CreateImagePipelineInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let schedule: ImagebuilderClientTypes.Schedule?
    let status: ImagebuilderClientTypes.PipelineStatus?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case schedule
        case status
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImagePipelineOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was created by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct CreateImagePipelineOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension CreateImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

extension CreateImageRecipeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = self.additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }
}

extension CreateImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateImageRecipe"
    }
}

public struct CreateImageRecipeInput: Swift.Equatable {
    /// Specify additional settings and launch scripts for your build instances.
    public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    /// The block device mappings of the image recipe.
    public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The components of the image recipe.
    /// This member is required.
    public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
    /// The description of the image recipe.
    public var description: Swift.String?
    /// The name of the image recipe.
    /// This member is required.
    public var name: Swift.String?
    /// The base image of the image recipe. The value of the string can be the ARN of the base image or an AMI ID. The format for the ARN follows this example: arn:aws:imagebuilder:us-west-2:aws:image/windows-server-2016-english-full-base-x86/x.x.x. You can provide the specific version that you want to use, or you can use a wildcard in all of the fields. If you enter an AMI ID for the string value, you must have access to the AMI, and the AMI must be in the same Region in which you are using Image Builder.
    /// This member is required.
    public var parentImage: Swift.String?
    /// The semantic version of the image recipe. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the image recipe.
    public var tags: [Swift.String:Swift.String]?
    /// The working directory used during build and test workflows.
    public var workingDirectory: Swift.String?

    public init (
        additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
        blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
        clientToken: Swift.String? = nil,
        components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        parentImage: Swift.String? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        workingDirectory: Swift.String? = nil
    )
    {
        self.additionalInstanceConfiguration = additionalInstanceConfiguration
        self.blockDeviceMappings = blockDeviceMappings
        self.clientToken = clientToken
        self.components = components
        self.description = description
        self.name = name
        self.parentImage = parentImage
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.workingDirectory = workingDirectory
    }
}

struct CreateImageRecipeInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let semanticVersion: Swift.String?
    let components: [ImagebuilderClientTypes.ComponentConfiguration]?
    let parentImage: Swift.String?
    let blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
    let tags: [Swift.String:Swift.String]?
    let workingDirectory: Swift.String?
    let additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
    let clientToken: Swift.String?
}

extension CreateImageRecipeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case blockDeviceMappings
        case clientToken
        case components
        case description
        case name
        case parentImage
        case semanticVersion
        case tags
        case workingDirectory
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateImageRecipeOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that was created by this request.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct CreateImageRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension CreateImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension CreateInfrastructureConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

extension CreateInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateInfrastructureConfiguration"
    }
}

public struct CreateInfrastructureConfigurationInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The name of the infrastructure configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID in which to place the instance used to customize your Amazon EC2 AMI.
    public var subnetId: Swift.String?
    /// The tags of the infrastructure configuration.
    public var tags: [Swift.String:Swift.String]?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        name: Swift.String? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.name = name
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.tags = tags
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct CreateInfrastructureConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceTypes: [Swift.String]?
    let instanceProfileName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetId: Swift.String?
    let logging: ImagebuilderClientTypes.Logging?
    let keyPair: Swift.String?
    let terminateInstanceOnFailure: Swift.Bool?
    let snsTopicArn: Swift.String?
    let resourceTags: [Swift.String:Swift.String]?
    let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension CreateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct CreateInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was created by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct CreateInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension CreateInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension DeleteComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentBuildVersionArn = componentBuildVersionArn else {
                let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            items.append(componentBuildVersionArnQueryItem)
            return items
        }
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteComponent"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component build version to delete.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component build version that was deleted.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteComponentOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension DeleteComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension DeleteContainerRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension DeleteContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteContainerRecipe"
    }
}

public struct DeleteContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to delete.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct DeleteContainerRecipeInputBody: Swift.Equatable {
}

extension DeleteContainerRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteContainerRecipeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that was deleted.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct DeleteContainerRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension DeleteContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

extension DeleteDistributionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let distributionConfigurationArn = distributionConfigurationArn else {
                let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            items.append(distributionConfigurationArnQueryItem)
            return items
        }
    }
}

extension DeleteDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteDistributionConfiguration"
    }
}

public struct DeleteDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration to delete.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct DeleteDistributionConfigurationInputBody: Swift.Equatable {
}

extension DeleteDistributionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that was deleted.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteDistributionConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension DeleteDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

extension DeleteImageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageBuildVersionArn = imageBuildVersionArn else {
                let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            items.append(imageBuildVersionArnQueryItem)
            return items
        }
    }
}

extension DeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImage"
    }
}

public struct DeleteImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource to delete.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct DeleteImageInputBody: Swift.Equatable {
}

extension DeleteImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Image Builder image resource that was deleted.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct DeleteImageOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension DeleteImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension DeleteImagePipelineInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imagePipelineArn = imagePipelineArn else {
                let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            items.append(imagePipelineArnQueryItem)
            return items
        }
    }
}

extension DeleteImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImagePipeline"
    }
}

public struct DeleteImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline to delete.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct DeleteImagePipelineInputBody: Swift.Equatable {
}

extension DeleteImagePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImagePipelineOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that was deleted.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct DeleteImagePipelineOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension DeleteImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

extension DeleteImageRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension DeleteImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteImageRecipe"
    }
}

public struct DeleteImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe to delete.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct DeleteImageRecipeInputBody: Swift.Equatable {
}

extension DeleteImageRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteImageRecipeOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that was deleted.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct DeleteImageRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension DeleteImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension DeleteInfrastructureConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let infrastructureConfigurationArn = infrastructureConfigurationArn else {
                let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            items.append(infrastructureConfigurationArnQueryItem)
            return items
        }
    }
}

extension DeleteInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteInfrastructureConfiguration"
    }
}

public struct DeleteInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration to delete.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct DeleteInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension DeleteInfrastructureConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceDependencyException" : self = .resourceDependencyException(try ResourceDependencyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceDependencyException(ResourceDependencyException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct DeleteInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was deleted.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct DeleteInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension DeleteInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}

extension ImagebuilderClientTypes {
    public enum DiskImageFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case raw
        case vhd
        case vmdk
        case sdkUnknown(Swift.String)

        public static var allCases: [DiskImageFormat] {
            return [
                .raw,
                .vhd,
                .vmdk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .raw: return "RAW"
            case .vhd: return "VHD"
            case .vmdk: return "VMDK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DiskImageFormat(rawValue: rawValue) ?? DiskImageFormat.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.Distribution: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiDistributionConfiguration
        case containerDistributionConfiguration
        case fastLaunchConfigurations
        case launchTemplateConfigurations
        case licenseConfigurationArns
        case region
        case s3ExportConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiDistributionConfiguration = self.amiDistributionConfiguration {
            try encodeContainer.encode(amiDistributionConfiguration, forKey: .amiDistributionConfiguration)
        }
        if let containerDistributionConfiguration = self.containerDistributionConfiguration {
            try encodeContainer.encode(containerDistributionConfiguration, forKey: .containerDistributionConfiguration)
        }
        if let fastLaunchConfigurations = fastLaunchConfigurations {
            var fastLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fastLaunchConfigurations)
            for fastlaunchconfiguration0 in fastLaunchConfigurations {
                try fastLaunchConfigurationsContainer.encode(fastlaunchconfiguration0)
            }
        }
        if let launchTemplateConfigurations = launchTemplateConfigurations {
            var launchTemplateConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchTemplateConfigurations)
            for launchtemplateconfiguration0 in launchTemplateConfigurations {
                try launchTemplateConfigurationsContainer.encode(launchtemplateconfiguration0)
            }
        }
        if let licenseConfigurationArns = licenseConfigurationArns {
            var licenseConfigurationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .licenseConfigurationArns)
            for licenseconfigurationarn0 in licenseConfigurationArns {
                try licenseConfigurationArnsContainer.encode(licenseconfigurationarn0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let s3ExportConfiguration = self.s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let amiDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AmiDistributionConfiguration.self, forKey: .amiDistributionConfiguration)
        amiDistributionConfiguration = amiDistributionConfigurationDecoded
        let containerDistributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerDistributionConfiguration.self, forKey: .containerDistributionConfiguration)
        containerDistributionConfiguration = containerDistributionConfigurationDecoded
        let licenseConfigurationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .licenseConfigurationArns)
        var licenseConfigurationArnsDecoded0:[Swift.String]? = nil
        if let licenseConfigurationArnsContainer = licenseConfigurationArnsContainer {
            licenseConfigurationArnsDecoded0 = [Swift.String]()
            for string0 in licenseConfigurationArnsContainer {
                if let string0 = string0 {
                    licenseConfigurationArnsDecoded0?.append(string0)
                }
            }
        }
        licenseConfigurationArns = licenseConfigurationArnsDecoded0
        let launchTemplateConfigurationsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.LaunchTemplateConfiguration?].self, forKey: .launchTemplateConfigurations)
        var launchTemplateConfigurationsDecoded0:[ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil
        if let launchTemplateConfigurationsContainer = launchTemplateConfigurationsContainer {
            launchTemplateConfigurationsDecoded0 = [ImagebuilderClientTypes.LaunchTemplateConfiguration]()
            for structure0 in launchTemplateConfigurationsContainer {
                if let structure0 = structure0 {
                    launchTemplateConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        launchTemplateConfigurations = launchTemplateConfigurationsDecoded0
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let fastLaunchConfigurationsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.FastLaunchConfiguration?].self, forKey: .fastLaunchConfigurations)
        var fastLaunchConfigurationsDecoded0:[ImagebuilderClientTypes.FastLaunchConfiguration]? = nil
        if let fastLaunchConfigurationsContainer = fastLaunchConfigurationsContainer {
            fastLaunchConfigurationsDecoded0 = [ImagebuilderClientTypes.FastLaunchConfiguration]()
            for structure0 in fastLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    fastLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        fastLaunchConfigurations = fastLaunchConfigurationsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Defines the settings for a specific Region.
    public struct Distribution: Swift.Equatable {
        /// The specific AMI settings; for example, launch permissions or AMI tags.
        public var amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration?
        /// Container distribution settings for encryption, licensing, and sharing in a specific Region.
        public var containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration?
        /// The Windows faster-launching configurations to use for AMI distribution.
        public var fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]?
        /// A group of launchTemplateConfiguration settings that apply to image distribution for specified accounts.
        public var launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]?
        /// The License Manager Configuration to associate with the AMI in the specified Region.
        public var licenseConfigurationArns: [Swift.String]?
        /// The target Region.
        /// This member is required.
        public var region: Swift.String?
        /// Configure export settings to deliver disk images created from your image build, using a file format that is compatible with your VMs in that Region.
        public var s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration?

        public init (
            amiDistributionConfiguration: ImagebuilderClientTypes.AmiDistributionConfiguration? = nil,
            containerDistributionConfiguration: ImagebuilderClientTypes.ContainerDistributionConfiguration? = nil,
            fastLaunchConfigurations: [ImagebuilderClientTypes.FastLaunchConfiguration]? = nil,
            launchTemplateConfigurations: [ImagebuilderClientTypes.LaunchTemplateConfiguration]? = nil,
            licenseConfigurationArns: [Swift.String]? = nil,
            region: Swift.String? = nil,
            s3ExportConfiguration: ImagebuilderClientTypes.S3ExportConfiguration? = nil
        )
        {
            self.amiDistributionConfiguration = amiDistributionConfiguration
            self.containerDistributionConfiguration = containerDistributionConfiguration
            self.fastLaunchConfigurations = fastLaunchConfigurations
            self.launchTemplateConfigurations = launchTemplateConfigurations
            self.licenseConfigurationArns = licenseConfigurationArns
            self.region = region
            self.s3ExportConfiguration = s3ExportConfiguration
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case distributions
        case name
        case tags
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeoutMinutes = self.timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A distribution configuration.
    public struct DistributionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which this distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which this distribution configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The distribution objects that apply Region-specific settings for the deployment of the image to targeted Regions.
        public var distributions: [ImagebuilderClientTypes.Distribution]?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// The tags of the distribution configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The maximum duration in minutes for this distribution configuration.
        /// This member is required.
        public var timeoutMinutes: Swift.Int?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributions: [ImagebuilderClientTypes.Distribution]? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributions = distributions
            self.name = name
            self.tags = tags
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes.DistributionConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case name
        case regions
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for nonemptystring0 in regions {
                try regionsContainer.encode(nonemptystring0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A high-level overview of a distribution configuration.
    public struct DistributionConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the distribution configuration.
        public var arn: Swift.String?
        /// The date on which the distribution configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the distribution configuration was updated.
        public var dateUpdated: Swift.String?
        /// The description of the distribution configuration.
        public var description: Swift.String?
        /// The name of the distribution configuration.
        public var name: Swift.String?
        /// A list of Regions where the container image is distributed to.
        public var regions: [Swift.String]?
        /// The tags associated with the distribution configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            regions: [Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.name = name
            self.regions = regions
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteOnTermination
        case encrypted
        case iops
        case kmsKeyId
        case snapshotId
        case throughput
        case volumeSize
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteOnTermination = self.deleteOnTermination {
            try encodeContainer.encode(deleteOnTermination, forKey: .deleteOnTermination)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let snapshotId = self.snapshotId {
            try encodeContainer.encode(snapshotId, forKey: .snapshotId)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeSize = self.volumeSize {
            try encodeContainer.encode(volumeSize, forKey: .volumeSize)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let deleteOnTerminationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteOnTermination)
        deleteOnTermination = deleteOnTerminationDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let snapshotIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotId)
        snapshotId = snapshotIdDecoded
        let volumeSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSize)
        volumeSize = volumeSizeDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsVolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Amazon EBS-specific block device mapping specifications.
    public struct EbsInstanceBlockDeviceSpecification: Swift.Equatable {
        /// Use to configure delete on termination of the associated device.
        public var deleteOnTermination: Swift.Bool?
        /// Use to configure device encryption.
        public var encrypted: Swift.Bool?
        /// Use to configure device IOPS.
        public var iops: Swift.Int?
        /// Use to configure the KMS key to use when encrypting the device.
        public var kmsKeyId: Swift.String?
        /// The snapshot that defines the device contents.
        public var snapshotId: Swift.String?
        /// For GP3 volumes only – The throughput in MiB/s that the volume supports.
        public var throughput: Swift.Int?
        /// Use to override the device's volume size.
        public var volumeSize: Swift.Int?
        /// Use to override the device's volume type.
        public var volumeType: ImagebuilderClientTypes.EbsVolumeType?

        public init (
            deleteOnTermination: Swift.Bool? = nil,
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            snapshotId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: ImagebuilderClientTypes.EbsVolumeType? = nil
        )
        {
            self.deleteOnTermination = deleteOnTermination
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.snapshotId = snapshotId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }

}

extension ImagebuilderClientTypes {
    public enum EbsVolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsVolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EbsVolumeType(rawValue: rawValue) ?? EbsVolumeType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.FastLaunchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case enabled
        case launchTemplate
        case maxParallelLaunches
        case snapshotConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let launchTemplate = self.launchTemplate {
            try encodeContainer.encode(launchTemplate, forKey: .launchTemplate)
        }
        if let maxParallelLaunches = self.maxParallelLaunches {
            try encodeContainer.encode(maxParallelLaunches, forKey: .maxParallelLaunches)
        }
        if let snapshotConfiguration = self.snapshotConfiguration {
            try encodeContainer.encode(snapshotConfiguration, forKey: .snapshotConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled) ?? false
        enabled = enabledDecoded
        let snapshotConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.FastLaunchSnapshotConfiguration.self, forKey: .snapshotConfiguration)
        snapshotConfiguration = snapshotConfigurationDecoded
        let maxParallelLaunchesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxParallelLaunches)
        maxParallelLaunches = maxParallelLaunchesDecoded
        let launchTemplateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification.self, forKey: .launchTemplate)
        launchTemplate = launchTemplateDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Define and configure faster launching for output Windows AMIs.
    public struct FastLaunchConfiguration: Swift.Equatable {
        /// The owner account ID for the fast-launch enabled Windows AMI.
        public var accountId: Swift.String?
        /// A Boolean that represents the current state of faster launching for the Windows AMI. Set to true to start using Windows faster launching, or false to stop using it.
        /// This member is required.
        public var enabled: Swift.Bool
        /// The launch template that the fast-launch enabled Windows AMI uses when it launches Windows instances to create pre-provisioned snapshots.
        public var launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification?
        /// The maximum number of parallel instances that are launched for creating resources.
        public var maxParallelLaunches: Swift.Int?
        /// Configuration settings for managing the number of snapshots that are created from pre-provisioned instances for the Windows AMI when faster launching is enabled.
        public var snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration?

        public init (
            accountId: Swift.String? = nil,
            enabled: Swift.Bool = false,
            launchTemplate: ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification? = nil,
            maxParallelLaunches: Swift.Int? = nil,
            snapshotConfiguration: ImagebuilderClientTypes.FastLaunchSnapshotConfiguration? = nil
        )
        {
            self.accountId = accountId
            self.enabled = enabled
            self.launchTemplate = launchTemplate
            self.maxParallelLaunches = maxParallelLaunches
            self.snapshotConfiguration = snapshotConfiguration
        }
    }

}

extension ImagebuilderClientTypes.FastLaunchLaunchTemplateSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchTemplateId
        case launchTemplateName
        case launchTemplateVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if let launchTemplateName = self.launchTemplateName {
            try encodeContainer.encode(launchTemplateName, forKey: .launchTemplateName)
        }
        if let launchTemplateVersion = self.launchTemplateVersion {
            try encodeContainer.encode(launchTemplateVersion, forKey: .launchTemplateVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let launchTemplateNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateName)
        launchTemplateName = launchTemplateNameDecoded
        let launchTemplateVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateVersion)
        launchTemplateVersion = launchTemplateVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Identifies the launch template that the associated Windows AMI uses for launching an instance when faster launching is enabled. You can specify either the launchTemplateName or the launchTemplateId, but not both.
    public struct FastLaunchLaunchTemplateSpecification: Swift.Equatable {
        /// The ID of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateId: Swift.String?
        /// The name of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateName: Swift.String?
        /// The version of the launch template to use for faster launching for a Windows AMI.
        public var launchTemplateVersion: Swift.String?

        public init (
            launchTemplateId: Swift.String? = nil,
            launchTemplateName: Swift.String? = nil,
            launchTemplateVersion: Swift.String? = nil
        )
        {
            self.launchTemplateId = launchTemplateId
            self.launchTemplateName = launchTemplateName
            self.launchTemplateVersion = launchTemplateVersion
        }
    }

}

extension ImagebuilderClientTypes.FastLaunchSnapshotConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetResourceCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetResourceCount = self.targetResourceCount {
            try encodeContainer.encode(targetResourceCount, forKey: .targetResourceCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetResourceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetResourceCount)
        targetResourceCount = targetResourceCountDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Configuration settings for creating and managing pre-provisioned snapshots for a fast-launch enabled Windows AMI.
    public struct FastLaunchSnapshotConfiguration: Swift.Equatable {
        /// The number of pre-provisioned snapshots to keep on hand for a fast-launch enabled Windows AMI.
        public var targetResourceCount: Swift.Int?

        public init (
            targetResourceCount: Swift.Int? = nil
        )
        {
            self.targetResourceCount = targetResourceCount
        }
    }

}

extension ImagebuilderClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervalue0 in values {
                try valuesContainer.encode(filtervalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results from a list operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs.
    public struct Filter: Swift.Equatable {
        /// The name of the filter. Filter names are case-sensitive.
        public var name: Swift.String?
        /// The filter values. Filter values are case-sensitive.
        public var values: [Swift.String]?

        public init (
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to perform the requested operation.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentBuildVersionArn = componentBuildVersionArn else {
                let message = "Creating a URL Query Item failed. componentBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let componentBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "componentBuildVersionArn".urlPercentEncoding(), value: Swift.String(componentBuildVersionArn).urlPercentEncoding())
            items.append(componentBuildVersionArnQueryItem)
            return items
        }
    }
}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetComponent"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that you want to retrieve. Regex requires "/\d+$" suffix.
    /// This member is required.
    public var componentBuildVersionArn: Swift.String?

    public init (
        componentBuildVersionArn: Swift.String? = nil
    )
    {
        self.componentBuildVersionArn = componentBuildVersionArn
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.component = output.component
            self.requestId = output.requestId
        } else {
            self.component = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    /// The component object associated with the specified ARN.
    public var component: ImagebuilderClientTypes.Component?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        component: ImagebuilderClientTypes.Component? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.component = component
        self.requestId = requestId
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let component: ImagebuilderClientTypes.Component?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetComponentPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let componentArn = componentArn else {
                let message = "Creating a URL Query Item failed. componentArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let componentArnQueryItem = ClientRuntime.URLQueryItem(name: "componentArn".urlPercentEncoding(), value: Swift.String(componentArn).urlPercentEncoding())
            items.append(componentArnQueryItem)
            return items
        }
    }
}

extension GetComponentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetComponentPolicy"
    }
}

public struct GetComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component whose policy you want to retrieve.
    /// This member is required.
    public var componentArn: Swift.String?

    public init (
        componentArn: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
    }
}

struct GetComponentPolicyInputBody: Swift.Equatable {
}

extension GetComponentPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetComponentPolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetComponentPolicyOutputResponse: Swift.Equatable {
    /// The component policy.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetComponentPolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetComponentPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetContainerRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension GetContainerRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetContainerRecipe"
    }
}

public struct GetContainerRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe to retrieve.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipeInputBody: Swift.Equatable {
}

extension GetContainerRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContainerRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContainerRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipe = output.containerRecipe
            self.requestId = output.requestId
        } else {
            self.containerRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipeOutputResponse: Swift.Equatable {
    /// The container recipe object that is returned.
    public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipe = containerRecipe
        self.requestId = requestId
    }
}

struct GetContainerRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
}

extension GetContainerRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipe
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
    }
}

extension GetContainerRecipePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let containerRecipeArn = containerRecipeArn else {
                let message = "Creating a URL Query Item failed. containerRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let containerRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "containerRecipeArn".urlPercentEncoding(), value: Swift.String(containerRecipeArn).urlPercentEncoding())
            items.append(containerRecipeArnQueryItem)
            return items
        }
    }
}

extension GetContainerRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetContainerRecipePolicy"
    }
}

public struct GetContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe for the policy being requested.
    /// This member is required.
    public var containerRecipeArn: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
    }
}

struct GetContainerRecipePolicyInputBody: Swift.Equatable {
}

extension GetContainerRecipePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetContainerRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContainerRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetContainerRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContainerRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetContainerRecipePolicyOutputResponse: Swift.Equatable {
    /// The container recipe policy object that is returned.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetContainerRecipePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetContainerRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetDistributionConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let distributionConfigurationArn = distributionConfigurationArn else {
                let message = "Creating a URL Query Item failed. distributionConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let distributionConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "distributionConfigurationArn".urlPercentEncoding(), value: Swift.String(distributionConfigurationArn).urlPercentEncoding())
            items.append(distributionConfigurationArnQueryItem)
            return items
        }
    }
}

extension GetDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetDistributionConfiguration"
    }
}

public struct GetDistributionConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to retrieve.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?

    public init (
        distributionConfigurationArn: Swift.String? = nil
    )
    {
        self.distributionConfigurationArn = distributionConfigurationArn
    }
}

struct GetDistributionConfigurationInputBody: Swift.Equatable {
}

extension GetDistributionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfiguration = output.distributionConfiguration
            self.requestId = output.requestId
        } else {
            self.distributionConfiguration = nil
            self.requestId = nil
        }
    }
}

public struct GetDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The distribution configuration object.
    public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfiguration = distributionConfiguration
        self.requestId = requestId
    }
}

struct GetDistributionConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
}

extension GetDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfiguration
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
    }
}

extension GetImageInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageBuildVersionArn = imageBuildVersionArn else {
                let message = "Creating a URL Query Item failed. imageBuildVersionArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageBuildVersionArnQueryItem = ClientRuntime.URLQueryItem(name: "imageBuildVersionArn".urlPercentEncoding(), value: Swift.String(imageBuildVersionArn).urlPercentEncoding())
            items.append(imageBuildVersionArnQueryItem)
            return items
        }
    }
}

extension GetImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImage"
    }
}

public struct GetImageInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that you want to retrieve.
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
    }
}

struct GetImageInputBody: Swift.Equatable {
}

extension GetImageInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImageOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
            self.requestId = output.requestId
        } else {
            self.image = nil
            self.requestId = nil
        }
    }
}

public struct GetImageOutputResponse: Swift.Equatable {
    /// The image object.
    public var image: ImagebuilderClientTypes.Image?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        image: ImagebuilderClientTypes.Image? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.image = image
        self.requestId = requestId
    }
}

struct GetImageOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let image: ImagebuilderClientTypes.Image?
}

extension GetImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

extension GetImagePipelineInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imagePipelineArn = imagePipelineArn else {
                let message = "Creating a URL Query Item failed. imagePipelineArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imagePipelineArnQueryItem = ClientRuntime.URLQueryItem(name: "imagePipelineArn".urlPercentEncoding(), value: Swift.String(imagePipelineArn).urlPercentEncoding())
            items.append(imagePipelineArnQueryItem)
            return items
        }
    }
}

extension GetImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImagePipeline"
    }
}

public struct GetImagePipelineInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to retrieve.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.imagePipelineArn = imagePipelineArn
    }
}

struct GetImagePipelineInputBody: Swift.Equatable {
}

extension GetImagePipelineInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipeline = output.imagePipeline
            self.requestId = output.requestId
        } else {
            self.imagePipeline = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePipelineOutputResponse: Swift.Equatable {
    /// The image pipeline object.
    public var imagePipeline: ImagebuilderClientTypes.ImagePipeline?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipeline: ImagebuilderClientTypes.ImagePipeline? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipeline = imagePipeline
        self.requestId = requestId
    }
}

struct GetImagePipelineOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipeline: ImagebuilderClientTypes.ImagePipeline?
}

extension GetImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipeline
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImagePipeline.self, forKey: .imagePipeline)
        imagePipeline = imagePipelineDecoded
    }
}

extension GetImagePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageArn = imageArn else {
                let message = "Creating a URL Query Item failed. imageArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageArnQueryItem = ClientRuntime.URLQueryItem(name: "imageArn".urlPercentEncoding(), value: Swift.String(imageArn).urlPercentEncoding())
            items.append(imageArnQueryItem)
            return items
        }
    }
}

extension GetImagePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImagePolicy"
    }
}

public struct GetImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image whose policy you want to retrieve.
    /// This member is required.
    public var imageArn: Swift.String?

    public init (
        imageArn: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
    }
}

struct GetImagePolicyInputBody: Swift.Equatable {
}

extension GetImagePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImagePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImagePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImagePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImagePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImagePolicyOutputResponse: Swift.Equatable {
    /// The image policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImagePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetImagePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetImageRecipeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension GetImageRecipeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImageRecipe"
    }
}

public struct GetImageRecipeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipeInputBody: Swift.Equatable {
}

extension GetImageRecipeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImageRecipeOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImageRecipeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipe = output.imageRecipe
            self.requestId = output.requestId
        } else {
            self.imageRecipe = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipeOutputResponse: Swift.Equatable {
    /// The image recipe object.
    public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipe = imageRecipe
        self.requestId = requestId
    }
}

struct GetImageRecipeOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipe: ImagebuilderClientTypes.ImageRecipe?
}

extension GetImageRecipeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipe
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
    }
}

extension GetImageRecipePolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let imageRecipeArn = imageRecipeArn else {
                let message = "Creating a URL Query Item failed. imageRecipeArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let imageRecipeArnQueryItem = ClientRuntime.URLQueryItem(name: "imageRecipeArn".urlPercentEncoding(), value: Swift.String(imageRecipeArn).urlPercentEncoding())
            items.append(imageRecipeArnQueryItem)
            return items
        }
    }
}

extension GetImageRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetImageRecipePolicy"
    }
}

public struct GetImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe whose policy you want to retrieve.
    /// This member is required.
    public var imageRecipeArn: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
    }
}

struct GetImageRecipePolicyInputBody: Swift.Equatable {
}

extension GetImageRecipePolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetImageRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImageRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetImageRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImageRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.policy = output.policy
            self.requestId = output.requestId
        } else {
            self.policy = nil
            self.requestId = nil
        }
    }
}

public struct GetImageRecipePolicyOutputResponse: Swift.Equatable {
    /// The image recipe policy object.
    public var policy: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        policy: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.policy = policy
        self.requestId = requestId
    }
}

struct GetImageRecipePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let policy: Swift.String?
}

extension GetImageRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policy
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GetInfrastructureConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let infrastructureConfigurationArn = infrastructureConfigurationArn else {
                let message = "Creating a URL Query Item failed. infrastructureConfigurationArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let infrastructureConfigurationArnQueryItem = ClientRuntime.URLQueryItem(name: "infrastructureConfigurationArn".urlPercentEncoding(), value: Swift.String(infrastructureConfigurationArn).urlPercentEncoding())
            items.append(infrastructureConfigurationArnQueryItem)
            return items
        }
    }
}

extension GetInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetInfrastructureConfiguration"
    }
}

/// GetInfrastructureConfiguration request object.
public struct GetInfrastructureConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to retrieve.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?

    public init (
        infrastructureConfigurationArn: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
    }
}

struct GetInfrastructureConfigurationInputBody: Swift.Equatable {
}

extension GetInfrastructureConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfiguration = output.infrastructureConfiguration
            self.requestId = output.requestId
        } else {
            self.infrastructureConfiguration = nil
            self.requestId = nil
        }
    }
}

/// GetInfrastructureConfiguration response object.
public struct GetInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The infrastructure configuration object.
    public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfiguration = infrastructureConfiguration
        self.requestId = requestId
    }
}

struct GetInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
}

extension GetInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfiguration
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
    }
}

extension IdempotentParameterMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: IdempotentParameterMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified a client token for an operation using parameter values that differ from a previous request that used the same client token.
public struct IdempotentParameterMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct IdempotentParameterMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension IdempotentParameterMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case containerRecipe
        case dateCreated
        case distributionConfiguration
        case enhancedImageMetadataEnabled
        case imageRecipe
        case imageTestsConfiguration
        case infrastructureConfiguration
        case name
        case osVersion
        case outputResources
        case platform
        case sourcePipelineArn
        case sourcePipelineName
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let containerRecipe = self.containerRecipe {
            try encodeContainer.encode(containerRecipe, forKey: .containerRecipe)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let distributionConfiguration = self.distributionConfiguration {
            try encodeContainer.encode(distributionConfiguration, forKey: .distributionConfiguration)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipe = self.imageRecipe {
            try encodeContainer.encode(imageRecipe, forKey: .imageRecipe)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfiguration = self.infrastructureConfiguration {
            try encodeContainer.encode(infrastructureConfiguration, forKey: .infrastructureConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = self.outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let sourcePipelineArn = self.sourcePipelineArn {
            try encodeContainer.encode(sourcePipelineArn, forKey: .sourcePipelineArn)
        }
        if let sourcePipelineName = self.sourcePipelineName {
            try encodeContainer.encode(sourcePipelineName, forKey: .sourcePipelineName)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let imageRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageRecipe.self, forKey: .imageRecipe)
        imageRecipe = imageRecipeDecoded
        let containerRecipeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRecipe.self, forKey: .containerRecipe)
        containerRecipe = containerRecipeDecoded
        let sourcePipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineName)
        sourcePipelineName = sourcePipelineNameDecoded
        let sourcePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePipelineArn)
        sourcePipelineArn = sourcePipelineArnDecoded
        let infrastructureConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InfrastructureConfiguration.self, forKey: .infrastructureConfiguration)
        infrastructureConfiguration = infrastructureConfigurationDecoded
        let distributionConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DistributionConfiguration.self, forKey: .distributionConfiguration)
        distributionConfiguration = distributionConfigurationDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An Image Builder image. You must specify exactly one recipe for the image – either a container recipe (containerRecipe), which creates a container image, or an image recipe (imageRecipe), which creates an AMI.
    public struct Image: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The recipe that is used to create an Image Builder container image.
        public var containerRecipe: ImagebuilderClientTypes.ContainerRecipe?
        /// The date on which this image was created.
        public var dateCreated: Swift.String?
        /// The distribution configuration used when creating this image.
        public var distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration?
        /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The image recipe used when creating the image.
        public var imageRecipe: ImagebuilderClientTypes.ImageRecipe?
        /// The image tests configuration used when creating this image.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The infrastructure used when creating this image.
        public var infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources produced when creating this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The platform of the image.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The Amazon Resource Name (ARN) of the image pipeline that created this image.
        public var sourcePipelineArn: Swift.String?
        /// The name of the image pipeline that created this image.
        public var sourcePipelineName: Swift.String?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags of the image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this is an AMI or container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The semantic version of the image. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            containerRecipe: ImagebuilderClientTypes.ContainerRecipe? = nil,
            dateCreated: Swift.String? = nil,
            distributionConfiguration: ImagebuilderClientTypes.DistributionConfiguration? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipe: ImagebuilderClientTypes.ImageRecipe? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfiguration: ImagebuilderClientTypes.InfrastructureConfiguration? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            sourcePipelineArn: Swift.String? = nil,
            sourcePipelineName: Swift.String? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.containerRecipe = containerRecipe
            self.dateCreated = dateCreated
            self.distributionConfiguration = distributionConfiguration
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipe = imageRecipe
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfiguration = infrastructureConfiguration
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.platform = platform
            self.sourcePipelineArn = sourcePipelineArn
            self.sourcePipelineName = sourcePipelineName
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImagePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case packageName
        case packageVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packageName = self.packageName {
            try encodeContainer.encode(packageName, forKey: .packageName)
        }
        if let packageVersion = self.packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageName)
        packageName = packageNameDecoded
        let packageVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Represents a package installed on an Image Builder image.
    public struct ImagePackage: Swift.Equatable {
        /// The name of the package as reported to the operating system package manager.
        public var packageName: Swift.String?
        /// The version of the package as reported to the operating system package manager.
        public var packageVersion: Swift.String?

        public init (
            packageName: Swift.String? = nil,
            packageVersion: Swift.String? = nil
        )
        {
            self.packageName = packageName
            self.packageVersion = packageVersion
        }
    }

}

extension ImagebuilderClientTypes.ImagePipeline: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case containerRecipeArn
        case dateCreated
        case dateLastRun
        case dateNextRun
        case dateUpdated
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case name
        case platform
        case schedule
        case status
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateLastRun = self.dateLastRun {
            try encodeContainer.encode(dateLastRun, forKey: .dateLastRun)
        }
        if let dateNextRun = self.dateNextRun {
            try encodeContainer.encode(dateNextRun, forKey: .dateNextRun)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let dateLastRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateLastRun)
        dateLastRun = dateLastRunDecoded
        let dateNextRunDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateNextRun)
        dateNextRun = dateNextRunDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Details of an image pipeline.
    public struct ImagePipeline: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image pipeline.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the container recipe that is used for this pipeline.
        public var containerRecipeArn: Swift.String?
        /// The date on which this image pipeline was created.
        public var dateCreated: Swift.String?
        /// The date on which this image pipeline was last run.
        public var dateLastRun: Swift.String?
        /// The date on which this image pipeline will next be run.
        public var dateNextRun: Swift.String?
        /// The date on which this image pipeline was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the image pipeline.
        public var description: Swift.String?
        /// The Amazon Resource Name (ARN) of the distribution configuration associated with this image pipeline.
        public var distributionConfigurationArn: Swift.String?
        /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
        public var enhancedImageMetadataEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the image recipe associated with this image pipeline.
        public var imageRecipeArn: Swift.String?
        /// The image tests configuration of the image pipeline.
        public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
        /// The Amazon Resource Name (ARN) of the infrastructure configuration associated with this image pipeline.
        public var infrastructureConfigurationArn: Swift.String?
        /// The name of the image pipeline.
        public var name: Swift.String?
        /// The platform of the image pipeline.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The schedule of the image pipeline.
        public var schedule: ImagebuilderClientTypes.Schedule?
        /// The status of the image pipeline.
        public var status: ImagebuilderClientTypes.PipelineStatus?
        /// The tags of this image pipeline.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            containerRecipeArn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateLastRun: Swift.String? = nil,
            dateNextRun: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            distributionConfigurationArn: Swift.String? = nil,
            enhancedImageMetadataEnabled: Swift.Bool? = nil,
            imageRecipeArn: Swift.String? = nil,
            imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
            infrastructureConfigurationArn: Swift.String? = nil,
            name: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            schedule: ImagebuilderClientTypes.Schedule? = nil,
            status: ImagebuilderClientTypes.PipelineStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.containerRecipeArn = containerRecipeArn
            self.dateCreated = dateCreated
            self.dateLastRun = dateLastRun
            self.dateNextRun = dateNextRun
            self.dateUpdated = dateUpdated
            self.description = description
            self.distributionConfigurationArn = distributionConfigurationArn
            self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
            self.imageRecipeArn = imageRecipeArn
            self.imageTestsConfiguration = imageTestsConfiguration
            self.infrastructureConfigurationArn = infrastructureConfigurationArn
            self.name = name
            self.platform = platform
            self.schedule = schedule
            self.status = status
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipe: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalInstanceConfiguration
        case arn
        case blockDeviceMappings
        case components
        case dateCreated
        case description
        case name
        case owner
        case parentImage
        case platform
        case tags
        case type
        case version
        case workingDirectory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalInstanceConfiguration = self.additionalInstanceConfiguration {
            try encodeContainer.encode(additionalInstanceConfiguration, forKey: .additionalInstanceConfiguration)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let components = components {
            var componentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .components)
            for componentconfiguration0 in components {
                try componentsContainer.encode(componentconfiguration0)
            }
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let workingDirectory = self.workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let componentsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentConfiguration?].self, forKey: .components)
        var componentsDecoded0:[ImagebuilderClientTypes.ComponentConfiguration]? = nil
        if let componentsContainer = componentsContainer {
            componentsDecoded0 = [ImagebuilderClientTypes.ComponentConfiguration]()
            for structure0 in componentsContainer {
                if let structure0 = structure0 {
                    componentsDecoded0?.append(structure0)
                }
            }
        }
        components = componentsDecoded0
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
        let additionalInstanceConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.AdditionalInstanceConfiguration.self, forKey: .additionalInstanceConfiguration)
        additionalInstanceConfiguration = additionalInstanceConfigurationDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An image recipe.
    public struct ImageRecipe: Swift.Equatable {
        /// Before you create a new AMI, Image Builder launches temporary Amazon EC2 instances to build and test your image configuration. Instance configuration adds a layer of control over those instances. You can define settings and add scripts to run when an instance is launched from your AMI.
        public var additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration?
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The block device mappings to apply when creating images from this recipe.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The components of the image recipe.
        public var components: [ImagebuilderClientTypes.ComponentConfiguration]?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The description of the image recipe.
        public var description: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies which type of image is created by the recipe - an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image recipe.
        public var version: Swift.String?
        /// The working directory to be used during build and test workflows.
        public var workingDirectory: Swift.String?

        public init (
            additionalInstanceConfiguration: ImagebuilderClientTypes.AdditionalInstanceConfiguration? = nil,
            arn: Swift.String? = nil,
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            components: [ImagebuilderClientTypes.ComponentConfiguration]? = nil,
            dateCreated: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil,
            workingDirectory: Swift.String? = nil
        )
        {
            self.additionalInstanceConfiguration = additionalInstanceConfiguration
            self.arn = arn
            self.blockDeviceMappings = blockDeviceMappings
            self.components = components
            self.dateCreated = dateCreated
            self.description = description
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
            self.type = type
            self.version = version
            self.workingDirectory = workingDirectory
        }
    }

}

extension ImagebuilderClientTypes.ImageRecipeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case name
        case owner
        case parentImage
        case platform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let parentImage = self.parentImage {
            try encodeContainer.encode(parentImage, forKey: .parentImage)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let parentImageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentImage)
        parentImage = parentImageDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// A summary of an image recipe.
    public struct ImageRecipeSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image recipe.
        public var arn: Swift.String?
        /// The date on which this image recipe was created.
        public var dateCreated: Swift.String?
        /// The name of the image recipe.
        public var name: Swift.String?
        /// The owner of the image recipe.
        public var owner: Swift.String?
        /// The base image of the image recipe.
        public var parentImage: Swift.String?
        /// The platform of the image recipe.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The tags of the image recipe.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            parentImage: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.name = name
            self.owner = owner
            self.parentImage = parentImage
            self.platform = platform
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.ImageState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Image state shows the image status and the reason for that status.
    public struct ImageState: Swift.Equatable {
        /// The reason for the image's status.
        public var reason: Swift.String?
        /// The status of the image.
        public var status: ImagebuilderClientTypes.ImageStatus?

        public init (
            reason: Swift.String? = nil,
            status: ImagebuilderClientTypes.ImageStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case building
        case cancelled
        case creating
        case deleted
        case deprecated
        case distributing
        case failed
        case integrating
        case pending
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageStatus] {
            return [
                .available,
                .building,
                .cancelled,
                .creating,
                .deleted,
                .deprecated,
                .distributing,
                .failed,
                .integrating,
                .pending,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .building: return "BUILDING"
            case .cancelled: return "CANCELLED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deprecated: return "DEPRECATED"
            case .distributing: return "DISTRIBUTING"
            case .failed: return "FAILED"
            case .integrating: return "INTEGRATING"
            case .pending: return "PENDING"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageStatus(rawValue: rawValue) ?? ImageStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case dateCreated
        case name
        case osVersion
        case outputResources
        case owner
        case platform
        case state
        case tags
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let outputResources = self.outputResources {
            try encodeContainer.encode(outputResources, forKey: .outputResources)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let state = self.state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageState.self, forKey: .state)
        state = stateDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let outputResourcesDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.OutputResources.self, forKey: .outputResources)
        outputResources = outputResourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// An image summary.
    public struct ImageSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the image.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which this image was created.
        public var dateCreated: Swift.String?
        /// The name of the image.
        public var name: Swift.String?
        /// The operating system version of the instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The output resources produced when creating this image.
        public var outputResources: ImagebuilderClientTypes.OutputResources?
        /// The owner of the image.
        public var owner: Swift.String?
        /// The platform of the image.
        public var platform: ImagebuilderClientTypes.Platform?
        /// The state of the image.
        public var state: ImagebuilderClientTypes.ImageState?
        /// The tags of the image.
        public var tags: [Swift.String:Swift.String]?
        /// Specifies whether this is an AMI or container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// The version of the image.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            outputResources: ImagebuilderClientTypes.OutputResources? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            state: ImagebuilderClientTypes.ImageState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.outputResources = outputResources
            self.owner = owner
            self.platform = platform
            self.state = state
            self.tags = tags
            self.type = type
            self.version = version
        }
    }

}

extension ImagebuilderClientTypes.ImageTestsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTestsEnabled
        case timeoutMinutes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTestsEnabled = self.imageTestsEnabled {
            try encodeContainer.encode(imageTestsEnabled, forKey: .imageTestsEnabled)
        }
        if let timeoutMinutes = self.timeoutMinutes {
            try encodeContainer.encode(timeoutMinutes, forKey: .timeoutMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTestsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .imageTestsEnabled)
        imageTestsEnabled = imageTestsEnabledDecoded
        let timeoutMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutMinutes)
        timeoutMinutes = timeoutMinutesDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Configure image tests for your pipeline build. Tests run after building the image, to verify that the AMI or container image is valid before distributing it.
    public struct ImageTestsConfiguration: Swift.Equatable {
        /// Determines if tests should run after building the image. Image Builder defaults to enable tests to run following the image build, before image distribution.
        public var imageTestsEnabled: Swift.Bool?
        /// The maximum time in minutes that tests are permitted to run.
        public var timeoutMinutes: Swift.Int?

        public init (
            imageTestsEnabled: Swift.Bool? = nil,
            timeoutMinutes: Swift.Int? = nil
        )
        {
            self.imageTestsEnabled = imageTestsEnabled
            self.timeoutMinutes = timeoutMinutes
        }
    }

}

extension ImagebuilderClientTypes {
    public enum ImageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ami
        case docker
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageType] {
            return [
                .ami,
                .docker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ami: return "AMI"
            case .docker: return "DOCKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageType(rawValue: rawValue) ?? ImageType.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes.ImageVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case buildType
        case dateCreated
        case name
        case osVersion
        case owner
        case platform
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let buildType = self.buildType {
            try encodeContainer.encode(buildType.rawValue, forKey: .buildType)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let buildTypeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.BuildType.self, forKey: .buildType)
        buildType = buildTypeDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The defining characteristics of a specific version of an Image Builder image.
    public struct ImageVersion: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a specific version of an Image Builder image. Semantic versioning is included in each object's Amazon Resource Name (ARN), at the level that applies to that object as follows:
        ///
        /// * Versionless ARNs and Name ARNs do not include specific values in any of the nodes. The nodes are either left off entirely, or they are specified as wildcards, for example: x.x.x.
        ///
        /// * Version ARNs have only the first three nodes: ..
        ///
        /// * Build version ARNs have all four nodes, and point to a specific build for a specific version of an object.
        public var arn: Swift.String?
        /// Indicates the type of build that created this image. The build can be initiated in the following ways:
        ///
        /// * USER_INITIATED – A manual pipeline build request.
        ///
        /// * SCHEDULED – A pipeline build initiated by a cron expression in the Image Builder pipeline, or from EventBridge.
        ///
        /// * IMPORT – A VM import created the image to use as the base image for the recipe.
        public var buildType: ImagebuilderClientTypes.BuildType?
        /// The date on which this specific version of the Image Builder image was created.
        public var dateCreated: Swift.String?
        /// The name of this specific version of an Image Builder image.
        public var name: Swift.String?
        /// The operating system version of the Amazon EC2 build instance. For example, Amazon Linux 2, Ubuntu 18, or Microsoft Windows Server 2019.
        public var osVersion: Swift.String?
        /// The owner of the image version.
        public var owner: Swift.String?
        /// The platform of the image version, for example "Windows" or "Linux".
        public var platform: ImagebuilderClientTypes.Platform?
        /// Specifies whether this image is an AMI or a container image.
        public var type: ImagebuilderClientTypes.ImageType?
        /// Details for a specific version of an Image Builder image. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
        public var version: Swift.String?

        public init (
            arn: Swift.String? = nil,
            buildType: ImagebuilderClientTypes.BuildType? = nil,
            dateCreated: Swift.String? = nil,
            name: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            owner: Swift.String? = nil,
            platform: ImagebuilderClientTypes.Platform? = nil,
            type: ImagebuilderClientTypes.ImageType? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.buildType = buildType
            self.dateCreated = dateCreated
            self.name = name
            self.osVersion = osVersion
            self.owner = owner
            self.platform = platform
            self.type = type
            self.version = version
        }
    }

}

extension ImportComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeDescription = self.changeDescription {
            try encodeContainer.encode(changeDescription, forKey: .changeDescription)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }
}

extension ImportComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportComponent"
    }
}

public struct ImportComponentInput: Swift.Equatable {
    /// The change description of the component. Describes what change has been made in this version, or what makes this version different from other versions of this component.
    public var changeDescription: Swift.String?
    /// The idempotency token of the component.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The data of the component. Used to specify the data inline. Either data or uri can be used to specify the data within the component.
    public var data: Swift.String?
    /// The description of the component. Describes the contents of the component.
    public var description: Swift.String?
    /// The format of the resource that you want to import as a component.
    /// This member is required.
    public var format: ImagebuilderClientTypes.ComponentFormat?
    /// The ID of the KMS key that should be used to encrypt this component.
    public var kmsKeyId: Swift.String?
    /// The name of the component.
    /// This member is required.
    public var name: Swift.String?
    /// The platform of the component.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version of the component. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// The tags of the component.
    public var tags: [Swift.String:Swift.String]?
    /// The type of the component denotes whether the component is used to build the image, or only to test it.
    /// This member is required.
    public var type: ImagebuilderClientTypes.ComponentType?
    /// The uri of the component. Must be an Amazon S3 URL and the requester must have permission to access the Amazon S3 bucket. If you use Amazon S3, you can specify component content up to your service quota. Either data or uri can be used to specify the data within the component.
    public var uri: Swift.String?

    public init (
        changeDescription: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        description: Swift.String? = nil,
        format: ImagebuilderClientTypes.ComponentFormat? = nil,
        kmsKeyId: Swift.String? = nil,
        name: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: ImagebuilderClientTypes.ComponentType? = nil,
        uri: Swift.String? = nil
    )
    {
        self.changeDescription = changeDescription
        self.clientToken = clientToken
        self.data = data
        self.description = description
        self.format = format
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.type = type
        self.uri = uri
    }
}

struct ImportComponentInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let changeDescription: Swift.String?
    let type: ImagebuilderClientTypes.ComponentType?
    let format: ImagebuilderClientTypes.ComponentFormat?
    let platform: ImagebuilderClientTypes.Platform?
    let data: Swift.String?
    let uri: Swift.String?
    let kmsKeyId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ImportComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeDescription
        case clientToken
        case data
        case description
        case format
        case kmsKeyId
        case name
        case platform
        case semanticVersion
        case tags
        case type
        case uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let changeDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeDescription)
        changeDescription = changeDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentType.self, forKey: .type)
        type = typeDecoded
        let formatDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ComponentFormat.self, forKey: .format)
        format = formatDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVersionNumberException" : self = .invalidVersionNumberException(try InvalidVersionNumberException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportComponentOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case invalidVersionNumberException(InvalidVersionNumberException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.componentBuildVersionArn = output.componentBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.componentBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportComponentOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the imported component.
    public var componentBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        componentBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.componentBuildVersionArn = componentBuildVersionArn
        self.requestId = requestId
    }
}

struct ImportComponentOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let componentBuildVersionArn: Swift.String?
}

extension ImportComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case componentBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let componentBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentBuildVersionArn)
        componentBuildVersionArn = componentBuildVersionArnDecoded
    }
}

extension ImportVmImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case osVersion
        case platform
        case semanticVersion
        case tags
        case vmImportTaskId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform.rawValue, forKey: .platform)
        }
        if let semanticVersion = self.semanticVersion {
            try encodeContainer.encode(semanticVersion, forKey: .semanticVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vmImportTaskId = self.vmImportTaskId {
            try encodeContainer.encode(vmImportTaskId, forKey: .vmImportTaskId)
        }
    }
}

extension ImportVmImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportVmImage"
    }
}

public struct ImportVmImageInput: Swift.Equatable {
    /// Unique, case-sensitive identifier you provide to ensure idempotency of the request. For more information, see [Ensuring idempotency](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description for the base image that is created by the import process.
    public var description: Swift.String?
    /// The name of the base image that is created by the import process.
    /// This member is required.
    public var name: Swift.String?
    /// The operating system version for the imported VM.
    public var osVersion: Swift.String?
    /// The operating system platform for the imported VM.
    /// This member is required.
    public var platform: ImagebuilderClientTypes.Platform?
    /// The semantic version to attach to the base image that was created during the import process. This version follows the semantic version syntax. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Assignment: For the first three nodes you can assign any positive integer value, including zero, with an upper limit of 2^30-1, or 1073741823 for each node. Image Builder automatically assigns the build number to the fourth node. Patterns: You can use any numeric pattern that adheres to the assignment requirements for the nodes that you can assign. For example, you might choose a software version pattern, such as 1.0.0, or a date, such as 2021.01.01.
    /// This member is required.
    public var semanticVersion: Swift.String?
    /// Tags that are attached to the import resources.
    public var tags: [Swift.String:Swift.String]?
    /// The importTaskId (API) or ImportTaskId (CLI) from the Amazon EC2 VM import process. Image Builder retrieves information from the import process to pull in the AMI that is created from the VM source as the base image for your recipe.
    /// This member is required.
    public var vmImportTaskId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        osVersion: Swift.String? = nil,
        platform: ImagebuilderClientTypes.Platform? = nil,
        semanticVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vmImportTaskId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.osVersion = osVersion
        self.platform = platform
        self.semanticVersion = semanticVersion
        self.tags = tags
        self.vmImportTaskId = vmImportTaskId
    }
}

struct ImportVmImageInputBody: Swift.Equatable {
    let name: Swift.String?
    let semanticVersion: Swift.String?
    let description: Swift.String?
    let platform: ImagebuilderClientTypes.Platform?
    let osVersion: Swift.String?
    let vmImportTaskId: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let clientToken: Swift.String?
}

extension ImportVmImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case osVersion
        case platform
        case semanticVersion
        case tags
        case vmImportTaskId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let semanticVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .semanticVersion)
        semanticVersion = semanticVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Platform.self, forKey: .platform)
        platform = platformDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let vmImportTaskIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmImportTaskId)
        vmImportTaskId = vmImportTaskIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImportVmImageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportVmImageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportVmImageOutputError: Swift.Error, Swift.Equatable {
    case clientException(ClientException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportVmImageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportVmImageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct ImportVmImageOutputResponse: Swift.Equatable {
    /// The idempotency token that was used for this request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the AMI that was created during the VM import process. This AMI is used as the base image for the recipe that imported the VM.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct ImportVmImageOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageArn: Swift.String?
    let clientToken: Swift.String?
}

extension ImportVmImageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ImagebuilderClientTypes.InfrastructureConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case name
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case tags
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Details of the infrastructure configuration.
    public struct InfrastructureConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance metadata option settings for the infrastructure configuration.
        public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The Amazon EC2 key pair of the infrastructure configuration.
        public var keyPair: Swift.String?
        /// The logging configuration of the infrastructure configuration.
        public var logging: ImagebuilderClientTypes.Logging?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the resource created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The security group IDs of the infrastructure configuration.
        public var securityGroupIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
        public var snsTopicArn: Swift.String?
        /// The subnet ID of the infrastructure configuration.
        public var subnetId: Swift.String?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?
        /// The terminate instance on failure configuration of the infrastructure configuration.
        public var terminateInstanceOnFailure: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            keyPair: Swift.String? = nil,
            logging: ImagebuilderClientTypes.Logging? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            securityGroupIds: [Swift.String]? = nil,
            snsTopicArn: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            terminateInstanceOnFailure: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceMetadataOptions = instanceMetadataOptions
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.keyPair = keyPair
            self.logging = logging
            self.name = name
            self.resourceTags = resourceTags
            self.securityGroupIds = securityGroupIds
            self.snsTopicArn = snsTopicArn
            self.subnetId = subnetId
            self.tags = tags
            self.terminateInstanceOnFailure = terminateInstanceOnFailure
        }
    }

}

extension ImagebuilderClientTypes.InfrastructureConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dateCreated
        case dateUpdated
        case description
        case instanceProfileName
        case instanceTypes
        case name
        case resourceTags
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dateCreated = self.dateCreated {
            try encodeContainer.encode(dateCreated, forKey: .dateCreated)
        }
        if let dateUpdated = self.dateUpdated {
            try encodeContainer.encode(dateUpdated, forKey: .dateUpdated)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateUpdatedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dateUpdated)
        dateUpdated = dateUpdatedDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The infrastructure used when building Amazon EC2 AMIs.
    public struct InfrastructureConfigurationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the infrastructure configuration.
        public var arn: Swift.String?
        /// The date on which the infrastructure configuration was created.
        public var dateCreated: Swift.String?
        /// The date on which the infrastructure configuration was last updated.
        public var dateUpdated: Swift.String?
        /// The description of the infrastructure configuration.
        public var description: Swift.String?
        /// The instance profile of the infrastructure configuration.
        public var instanceProfileName: Swift.String?
        /// The instance types of the infrastructure configuration.
        public var instanceTypes: [Swift.String]?
        /// The name of the infrastructure configuration.
        public var name: Swift.String?
        /// The tags attached to the image created by Image Builder.
        public var resourceTags: [Swift.String:Swift.String]?
        /// The tags of the infrastructure configuration.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dateCreated: Swift.String? = nil,
            dateUpdated: Swift.String? = nil,
            description: Swift.String? = nil,
            instanceProfileName: Swift.String? = nil,
            instanceTypes: [Swift.String]? = nil,
            name: Swift.String? = nil,
            resourceTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dateCreated = dateCreated
            self.dateUpdated = dateUpdated
            self.description = description
            self.instanceProfileName = instanceProfileName
            self.instanceTypes = instanceTypes
            self.name = name
            self.resourceTags = resourceTags
            self.tags = tags
        }
    }

}

extension ImagebuilderClientTypes.InstanceBlockDeviceMapping: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case ebs
        case noDevice
        case virtualName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let ebs = self.ebs {
            try encodeContainer.encode(ebs, forKey: .ebs)
        }
        if let noDevice = self.noDevice {
            try encodeContainer.encode(noDevice, forKey: .noDevice)
        }
        if let virtualName = self.virtualName {
            try encodeContainer.encode(virtualName, forKey: .virtualName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let ebsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification.self, forKey: .ebs)
        ebs = ebsDecoded
        let virtualNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .virtualName)
        virtualName = virtualNameDecoded
        let noDeviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .noDevice)
        noDevice = noDeviceDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Defines block device mappings for the instance used to configure your image.
    public struct InstanceBlockDeviceMapping: Swift.Equatable {
        /// The device to which these mappings apply.
        public var deviceName: Swift.String?
        /// Use to manage Amazon EBS-specific configuration for this mapping.
        public var ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification?
        /// Use to remove a mapping from the base image.
        public var noDevice: Swift.String?
        /// Use to manage instance ephemeral devices.
        public var virtualName: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            ebs: ImagebuilderClientTypes.EbsInstanceBlockDeviceSpecification? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }

}

extension ImagebuilderClientTypes.InstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockDeviceMappings
        case image
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockDeviceMappings = blockDeviceMappings {
            var blockDeviceMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockDeviceMappings)
            for instanceblockdevicemapping0 in blockDeviceMappings {
                try blockDeviceMappingsContainer.encode(instanceblockdevicemapping0)
            }
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let blockDeviceMappingsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InstanceBlockDeviceMapping?].self, forKey: .blockDeviceMappings)
        var blockDeviceMappingsDecoded0:[ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil
        if let blockDeviceMappingsContainer = blockDeviceMappingsContainer {
            blockDeviceMappingsDecoded0 = [ImagebuilderClientTypes.InstanceBlockDeviceMapping]()
            for structure0 in blockDeviceMappingsContainer {
                if let structure0 = structure0 {
                    blockDeviceMappingsDecoded0?.append(structure0)
                }
            }
        }
        blockDeviceMappings = blockDeviceMappingsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Defines a custom base AMI and block device mapping configurations of an instance used for building and testing container images.
    public struct InstanceConfiguration: Swift.Equatable {
        /// Defines the block devices to attach for building an instance from this Image Builder AMI.
        public var blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]?
        /// The AMI ID to use as the base image for a container build and test instance. If not specified, Image Builder will use the appropriate ECS-optimized AMI as a base image.
        public var image: Swift.String?

        public init (
            blockDeviceMappings: [ImagebuilderClientTypes.InstanceBlockDeviceMapping]? = nil,
            image: Swift.String? = nil
        )
        {
            self.blockDeviceMappings = blockDeviceMappings
            self.image = image
        }
    }

}

extension ImagebuilderClientTypes.InstanceMetadataOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case httpPutResponseHopLimit
        case httpTokens
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpPutResponseHopLimit = self.httpPutResponseHopLimit {
            try encodeContainer.encode(httpPutResponseHopLimit, forKey: .httpPutResponseHopLimit)
        }
        if let httpTokens = self.httpTokens {
            try encodeContainer.encode(httpTokens, forKey: .httpTokens)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpTokensDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .httpTokens)
        httpTokens = httpTokensDecoded
        let httpPutResponseHopLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .httpPutResponseHopLimit)
        httpPutResponseHopLimit = httpPutResponseHopLimitDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The instance metadata options that apply to the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances, or [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public struct InstanceMetadataOptions: Swift.Equatable {
        /// Limit the number of hops that an instance metadata request can traverse to reach its destination.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Indicates whether a signed token header is required for instance metadata retrieval requests. The values affect the response as follows:
        ///
        /// * required – When you retrieve the IAM role credentials, version 2.0 credentials are returned in all cases.
        ///
        /// * optional – You can include a signed token header in your request to retrieve instance metadata, or you can leave it out. If you include it, version 2.0 credentials are returned for the IAM role. Otherwise, version 1.0 credentials are returned.
        ///
        ///
        /// The default setting is optional.
        public var httpTokens: Swift.String?

        public init (
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: Swift.String? = nil
        )
        {
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
        }
    }

}

extension InvalidPaginationTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPaginationTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have provided an invalid pagination token in your request.
public struct InvalidPaginationTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have specified two or more mutually exclusive parameters. Review the error message for details.
public struct InvalidParameterCombinationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterCombinationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API request.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value that you provided for the specified parameter is invalid.
public struct InvalidParameterValueException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterValueExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have made a request for an action that is not supported by the service.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVersionNumberException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidVersionNumberExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your version number is out of bounds or does not follow the required syntax.
public struct InvalidVersionNumberException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVersionNumberExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidVersionNumberExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.LaunchPermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationArns
        case organizationalUnitArns
        case userGroups
        case userIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationArns = organizationArns {
            var organizationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationArns)
            for organizationarn0 in organizationArns {
                try organizationArnsContainer.encode(organizationarn0)
            }
        }
        if let organizationalUnitArns = organizationalUnitArns {
            var organizationalUnitArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationalUnitArns)
            for organizationalunitarn0 in organizationalUnitArns {
                try organizationalUnitArnsContainer.encode(organizationalunitarn0)
            }
        }
        if let userGroups = userGroups {
            var userGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userGroups)
            for nonemptystring0 in userGroups {
                try userGroupsContainer.encode(nonemptystring0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for accountid0 in userIds {
                try userIdsContainer.encode(accountid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let userGroupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userGroups)
        var userGroupsDecoded0:[Swift.String]? = nil
        if let userGroupsContainer = userGroupsContainer {
            userGroupsDecoded0 = [Swift.String]()
            for string0 in userGroupsContainer {
                if let string0 = string0 {
                    userGroupsDecoded0?.append(string0)
                }
            }
        }
        userGroups = userGroupsDecoded0
        let organizationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationArns)
        var organizationArnsDecoded0:[Swift.String]? = nil
        if let organizationArnsContainer = organizationArnsContainer {
            organizationArnsDecoded0 = [Swift.String]()
            for string0 in organizationArnsContainer {
                if let string0 = string0 {
                    organizationArnsDecoded0?.append(string0)
                }
            }
        }
        organizationArns = organizationArnsDecoded0
        let organizationalUnitArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .organizationalUnitArns)
        var organizationalUnitArnsDecoded0:[Swift.String]? = nil
        if let organizationalUnitArnsContainer = organizationalUnitArnsContainer {
            organizationalUnitArnsDecoded0 = [Swift.String]()
            for string0 in organizationalUnitArnsContainer {
                if let string0 = string0 {
                    organizationalUnitArnsDecoded0?.append(string0)
                }
            }
        }
        organizationalUnitArns = organizationalUnitArnsDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// Describes the configuration for a launch permission. The launch permission modification request is sent to the [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html) API on behalf of the user for each Region they have selected to distribute the AMI. To make an AMI public, set the launch permission authorized accounts to all. See the examples for making an AMI public at [Amazon EC2 ModifyImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyImageAttribute.html).
    public struct LaunchPermissionConfiguration: Swift.Equatable {
        /// The ARN for an Amazon Web Services Organization that you want to share your AMI with. For more information, see [What is Organizations?](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html).
        public var organizationArns: [Swift.String]?
        /// The ARN for an Organizations organizational unit (OU) that you want to share your AMI with. For more information about key concepts for Organizations, see [Organizations terminology and concepts](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_getting-started_concepts.html).
        public var organizationalUnitArns: [Swift.String]?
        /// The name of the group.
        public var userGroups: [Swift.String]?
        /// The Amazon Web Services account ID.
        public var userIds: [Swift.String]?

        public init (
            organizationArns: [Swift.String]? = nil,
            organizationalUnitArns: [Swift.String]? = nil,
            userGroups: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.organizationArns = organizationArns
            self.organizationalUnitArns = organizationalUnitArns
            self.userGroups = userGroups
            self.userIds = userIds
        }
    }

}

extension ImagebuilderClientTypes.LaunchTemplateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case launchTemplateId
        case setDefaultVersion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let launchTemplateId = self.launchTemplateId {
            try encodeContainer.encode(launchTemplateId, forKey: .launchTemplateId)
        }
        if setDefaultVersion != false {
            try encodeContainer.encode(setDefaultVersion, forKey: .setDefaultVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTemplateId)
        launchTemplateId = launchTemplateIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let setDefaultVersionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setDefaultVersion) ?? false
        setDefaultVersion = setDefaultVersionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Identifies an Amazon EC2 launch template to use for a specific account.
    public struct LaunchTemplateConfiguration: Swift.Equatable {
        /// The account ID that this configuration applies to.
        public var accountId: Swift.String?
        /// Identifies the Amazon EC2 launch template to use.
        /// This member is required.
        public var launchTemplateId: Swift.String?
        /// Set the specified Amazon EC2 launch template as the default launch template for the specified account.
        public var setDefaultVersion: Swift.Bool

        public init (
            accountId: Swift.String? = nil,
            launchTemplateId: Swift.String? = nil,
            setDefaultVersion: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.launchTemplateId = launchTemplateId
            self.setDefaultVersion = setDefaultVersion
        }
    }

}

extension ListComponentBuildVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentVersionArn = self.componentVersionArn {
            try encodeContainer.encode(componentVersionArn, forKey: .componentVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListComponentBuildVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListComponentBuildVersions"
    }
}

public struct ListComponentBuildVersionsInput: Swift.Equatable {
    /// The component version Amazon Resource Name (ARN) whose versions you want to list.
    /// This member is required.
    public var componentVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        componentVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.componentVersionArn = componentVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentBuildVersionsInputBody: Swift.Equatable {
    let componentVersionArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentVersionArn)
        componentVersionArn = componentVersionArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentBuildVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentBuildVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentBuildVersionsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentBuildVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentSummaryList = output.componentSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentBuildVersionsOutputResponse: Swift.Equatable {
    /// The list of component summaries for the specified semantic version.
    public var componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentSummaryList = componentSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentBuildVersionsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentSummaryList: [ImagebuilderClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentBuildVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentSummary?].self, forKey: .componentSummaryList)
        var componentSummaryListDecoded0:[ImagebuilderClientTypes.ComponentSummary]? = nil
        if let componentSummaryListContainer = componentSummaryListContainer {
            componentSummaryListDecoded0 = [ImagebuilderClientTypes.ComponentSummary]()
            for structure0 in componentSummaryListContainer {
                if let structure0 = structure0 {
                    componentSummaryListDecoded0?.append(structure0)
                }
            }
        }
        componentSummaryList = componentSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListComponents"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// Returns the list of component build versions for the specified name.
    public var byName: Swift.Bool
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * name
    ///
    /// * platform
    ///
    /// * supportedOsVersion
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which components you want to list. By default, this request will only show components owned by your account. You can use this field to specify if you want to view components owned by yourself, by Amazon, or those components that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        byName: Swift.Bool = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListComponentsInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let byName: Swift.Bool
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .byName) ?? false
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentVersionList = output.componentVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.componentVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// The list of component semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them.
    public var componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentVersionList: [ImagebuilderClientTypes.ComponentVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentVersionList = componentVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentVersionList: [ImagebuilderClientTypes.ComponentVersion]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ComponentVersion?].self, forKey: .componentVersionList)
        var componentVersionListDecoded0:[ImagebuilderClientTypes.ComponentVersion]? = nil
        if let componentVersionListContainer = componentVersionListContainer {
            componentVersionListDecoded0 = [ImagebuilderClientTypes.ComponentVersion]()
            for structure0 in componentVersionListContainer {
                if let structure0 = structure0 {
                    componentVersionListDecoded0?.append(structure0)
                }
            }
        }
        componentVersionList = componentVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContainerRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListContainerRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListContainerRecipes"
    }
}

public struct ListContainerRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * containerType
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum number of results to return in the list.
    public var maxResults: Swift.Int?
    /// Provides a token for pagination, which determines where to begin the next set of results when the current set reaches the maximum for one request.
    public var nextToken: Swift.String?
    /// Returns container recipes belonging to the specified owner, that have been shared with you. You can omit this field to return container recipes belonging to your account.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListContainerRecipesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListContainerRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListContainerRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListContainerRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListContainerRecipesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListContainerRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListContainerRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeSummaryList = output.containerRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.containerRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListContainerRecipesOutputResponse: Swift.Equatable {
    /// The list of container recipes returned for the request.
    public var containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    /// The next token field is used for paginated responses. When this is not empty, there are additional container recipes that the service has not included in this response. Use this token with the next request to retrieve additional list items.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeSummaryList = containerRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListContainerRecipesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeSummaryList: [ImagebuilderClientTypes.ContainerRecipeSummary]?
    let nextToken: Swift.String?
}

extension ListContainerRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ContainerRecipeSummary?].self, forKey: .containerRecipeSummaryList)
        var containerRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ContainerRecipeSummary]? = nil
        if let containerRecipeSummaryListContainer = containerRecipeSummaryListContainer {
            containerRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ContainerRecipeSummary]()
            for structure0 in containerRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    containerRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        containerRecipeSummaryList = containerRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDistributionConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDistributionConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListDistributionConfigurations"
    }
}

public struct ListDistributionConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDistributionConfigurationsInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListDistributionConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDistributionConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDistributionConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDistributionConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDistributionConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDistributionConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.distributionConfigurationSummaryList = output.distributionConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.distributionConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListDistributionConfigurationsOutputResponse: Swift.Equatable {
    /// The list of distributions.
    public var distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.distributionConfigurationSummaryList = distributionConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListDistributionConfigurationsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let distributionConfigurationSummaryList: [ImagebuilderClientTypes.DistributionConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListDistributionConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributionConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let distributionConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.DistributionConfigurationSummary?].self, forKey: .distributionConfigurationSummaryList)
        var distributionConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.DistributionConfigurationSummary]? = nil
        if let distributionConfigurationSummaryListContainer = distributionConfigurationSummaryListContainer {
            distributionConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.DistributionConfigurationSummary]()
            for structure0 in distributionConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    distributionConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        distributionConfigurationSummaryList = distributionConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageBuildVersionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let imageVersionArn = self.imageVersionArn {
            try encodeContainer.encode(imageVersionArn, forKey: .imageVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImageBuildVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageBuildVersions"
    }
}

public struct ListImageBuildVersionsInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image whose build versions you want to retrieve.
    /// This member is required.
    public var imageVersionArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imageVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imageVersionArn = imageVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImageBuildVersionsInputBody: Swift.Equatable {
    let imageVersionArn: Swift.String?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImageBuildVersionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imageVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageVersionArn)
        imageVersionArn = imageVersionArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageBuildVersionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageBuildVersionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImageBuildVersionsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageBuildVersionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImageBuildVersionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageBuildVersionsOutputResponse: Swift.Equatable {
    /// The list of image build versions.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageBuildVersionsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    let nextToken: Swift.String?
}

extension ListImageBuildVersionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePackagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageBuildVersionArn = self.imageBuildVersionArn {
            try encodeContainer.encode(imageBuildVersionArn, forKey: .imageBuildVersionArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePackagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePackages"
    }
}

public struct ListImagePackagesInput: Swift.Equatable {
    /// Filter results for the ListImagePackages request by the Image Build Version ARN
    /// This member is required.
    public var imageBuildVersionArn: Swift.String?
    /// The maxiumum number of results to return from the ListImagePackages request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        imageBuildVersionArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageBuildVersionArn = imageBuildVersionArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePackagesInputBody: Swift.Equatable {
    let imageBuildVersionArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePackagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageBuildVersionArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePackagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePackagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImagePackagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePackagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImagePackagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePackageList = output.imagePackageList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePackageList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePackagesOutputResponse: Swift.Equatable {
    /// The list of Image Packages returned in the response.
    public var imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePackageList: [ImagebuilderClientTypes.ImagePackage]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePackageList = imagePackageList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePackagesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePackageList: [ImagebuilderClientTypes.ImagePackage]?
    let nextToken: Swift.String?
}

extension ListImagePackagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePackageList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePackageListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePackage?].self, forKey: .imagePackageList)
        var imagePackageListDecoded0:[ImagebuilderClientTypes.ImagePackage]? = nil
        if let imagePackageListContainer = imagePackageListContainer {
            imagePackageListDecoded0 = [ImagebuilderClientTypes.ImagePackage]()
            for structure0 in imagePackageListContainer {
                if let structure0 = structure0 {
                    imagePackageListDecoded0?.append(structure0)
                }
            }
        }
        imagePackageList = imagePackageListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelineImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePipelineImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePipelineImages"
    }
}

public struct ListImagePipelineImagesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The Amazon Resource Name (ARN) of the image pipeline whose images you want to view.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        imagePipelineArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.imagePipelineArn = imagePipelineArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelineImagesInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePipelineImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case imagePipelineArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelineImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelineImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImagePipelineImagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelineImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImagePipelineImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageSummaryList = output.imageSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelineImagesOutputResponse: Swift.Equatable {
    /// The list of images built by this pipeline.
    public var imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageSummaryList: [ImagebuilderClientTypes.ImageSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageSummaryList = imageSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelineImagesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageSummaryList: [ImagebuilderClientTypes.ImageSummary]?
    let nextToken: Swift.String?
}

extension ListImagePipelineImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageSummary?].self, forKey: .imageSummaryList)
        var imageSummaryListDecoded0:[ImagebuilderClientTypes.ImageSummary]? = nil
        if let imageSummaryListContainer = imageSummaryListContainer {
            imageSummaryListDecoded0 = [ImagebuilderClientTypes.ImageSummary]()
            for structure0 in imageSummaryListContainer {
                if let structure0 = structure0 {
                    imageSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageSummaryList = imageSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelinesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListImagePipelinesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImagePipelines"
    }
}

public struct ListImagePipelinesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * description
    ///
    /// * distributionConfigurationArn
    ///
    /// * imageRecipeArn
    ///
    /// * infrastructureConfigurationArn
    ///
    /// * name
    ///
    /// * status
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImagePipelinesInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImagePipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagePipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagePipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImagePipelinesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagePipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImagePipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imagePipelineList = output.imagePipelineList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imagePipelineList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagePipelinesOutputResponse: Swift.Equatable {
    /// The list of image pipelines.
    public var imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imagePipelineList = imagePipelineList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagePipelinesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imagePipelineList: [ImagebuilderClientTypes.ImagePipeline]?
    let nextToken: Swift.String?
}

extension ListImagePipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imagePipelineList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imagePipelineListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImagePipeline?].self, forKey: .imagePipelineList)
        var imagePipelineListDecoded0:[ImagebuilderClientTypes.ImagePipeline]? = nil
        if let imagePipelineListContainer = imagePipelineListContainer {
            imagePipelineListDecoded0 = [ImagebuilderClientTypes.ImagePipeline]()
            for structure0 in imagePipelineListContainer {
                if let structure0 = structure0 {
                    imagePipelineListDecoded0?.append(structure0)
                }
            }
        }
        imagePipelineList = imagePipelineListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageRecipesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListImageRecipesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImageRecipes"
    }
}

public struct ListImageRecipesInput: Swift.Equatable {
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * parentImage
    ///
    /// * platform
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which image recipes you want to list. By default, this request will only show image recipes owned by your account. You can use this field to specify if you want to view image recipes owned by yourself, by Amazon, or those image recipes that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImageRecipesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListImageRecipesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImageRecipesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImageRecipesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImageRecipesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImageRecipesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImageRecipesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeSummaryList = output.imageRecipeSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageRecipeSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImageRecipesOutputResponse: Swift.Equatable {
    /// The list of image pipelines.
    public var imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeSummaryList = imageRecipeSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImageRecipesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeSummaryList: [ImagebuilderClientTypes.ImageRecipeSummary]?
    let nextToken: Swift.String?
}

extension ListImageRecipesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageRecipeSummary?].self, forKey: .imageRecipeSummaryList)
        var imageRecipeSummaryListDecoded0:[ImagebuilderClientTypes.ImageRecipeSummary]? = nil
        if let imageRecipeSummaryListContainer = imageRecipeSummaryListContainer {
            imageRecipeSummaryListDecoded0 = [ImagebuilderClientTypes.ImageRecipeSummary]()
            for structure0 in imageRecipeSummaryListContainer {
                if let structure0 = structure0 {
                    imageRecipeSummaryListDecoded0?.append(structure0)
                }
            }
        }
        imageRecipeSummaryList = imageRecipeSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if byName != false {
            try encodeContainer.encode(byName, forKey: .byName)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let includeDeprecated = self.includeDeprecated {
            try encodeContainer.encode(includeDeprecated, forKey: .includeDeprecated)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
    }
}

extension ListImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListImages"
    }
}

public struct ListImagesInput: Swift.Equatable {
    /// Requests a list of images with a specific recipe name.
    public var byName: Swift.Bool
    /// Use the following filters to streamline results:
    ///
    /// * name
    ///
    /// * osVersion
    ///
    /// * platform
    ///
    /// * type
    ///
    /// * version
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// Includes deprecated images in the response list.
    public var includeDeprecated: Swift.Bool?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?
    /// The owner defines which images you want to list. By default, this request will only show images owned by your account. You can use this field to specify if you want to view images owned by yourself, by Amazon, or those images that have been shared with you by other customers.
    public var owner: ImagebuilderClientTypes.Ownership?

    public init (
        byName: Swift.Bool = false,
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        includeDeprecated: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        owner: ImagebuilderClientTypes.Ownership? = nil
    )
    {
        self.byName = byName
        self.filters = filters
        self.includeDeprecated = includeDeprecated
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.owner = owner
    }
}

struct ListImagesInputBody: Swift.Equatable {
    let owner: ImagebuilderClientTypes.Ownership?
    let filters: [ImagebuilderClientTypes.Filter]?
    let byName: Swift.Bool
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let includeDeprecated: Swift.Bool?
}

extension ListImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case byName
        case filters
        case includeDeprecated
        case maxResults
        case nextToken
        case owner
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Ownership.self, forKey: .owner)
        owner = ownerDecoded
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let byNameDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .byName) ?? false
        byName = byNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let includeDeprecatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDeprecated)
        includeDeprecated = includeDeprecatedDecoded
    }
}

extension ListImagesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListImagesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListImagesOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListImagesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageVersionList = output.imageVersionList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.imageVersionList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListImagesOutputResponse: Swift.Equatable {
    /// The list of image semantic versions. The semantic version has four nodes: ../. You can assign values for the first three, and can filter on all of them. Filtering: With semantic versioning, you have the flexibility to use wildcards (x) to specify the most recent versions or nodes when selecting the base image or components for your recipe. When you use a wildcard in any node, all nodes to the right of the first wildcard must also be wildcards.
    public var imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageVersionList: [ImagebuilderClientTypes.ImageVersion]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageVersionList = imageVersionList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListImagesOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageVersionList: [ImagebuilderClientTypes.ImageVersion]?
    let nextToken: Swift.String?
}

extension ListImagesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageVersionList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageVersionListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.ImageVersion?].self, forKey: .imageVersionList)
        var imageVersionListDecoded0:[ImagebuilderClientTypes.ImageVersion]? = nil
        if let imageVersionListContainer = imageVersionListContainer {
            imageVersionListDecoded0 = [ImagebuilderClientTypes.ImageVersion]()
            for structure0 in imageVersionListContainer {
                if let structure0 = structure0 {
                    imageVersionListDecoded0?.append(structure0)
                }
            }
        }
        imageVersionList = imageVersionListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInfrastructureConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filter0 in filters {
                try filtersContainer.encode(filter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInfrastructureConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListInfrastructureConfigurations"
    }
}

public struct ListInfrastructureConfigurationsInput: Swift.Equatable {
    /// You can filter on name to streamline results.
    public var filters: [ImagebuilderClientTypes.Filter]?
    /// The maximum items to return in a request.
    public var maxResults: Swift.Int?
    /// A token to specify where to start paginating. This is the NextToken from a previously truncated response.
    public var nextToken: Swift.String?

    public init (
        filters: [ImagebuilderClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInfrastructureConfigurationsInputBody: Swift.Equatable {
    let filters: [ImagebuilderClientTypes.Filter]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[ImagebuilderClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [ImagebuilderClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInfrastructureConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInfrastructureConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPaginationTokenException" : self = .invalidPaginationTokenException(try InvalidPaginationTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInfrastructureConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidPaginationTokenException(InvalidPaginationTokenException)
    case invalidRequestException(InvalidRequestException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInfrastructureConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInfrastructureConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.infrastructureConfigurationSummaryList = output.infrastructureConfigurationSummaryList
            self.nextToken = output.nextToken
            self.requestId = output.requestId
        } else {
            self.infrastructureConfigurationSummaryList = nil
            self.nextToken = nil
            self.requestId = nil
        }
    }
}

public struct ListInfrastructureConfigurationsOutputResponse: Swift.Equatable {
    /// The list of infrastructure configurations.
    public var infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    /// The next token used for paginated responses. When this is not empty, there are additional elements that the service has not included in this request. Use this token with the next request to retrieve additional objects.
    public var nextToken: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil,
        nextToken: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryList
        self.nextToken = nextToken
        self.requestId = requestId
    }
}

struct ListInfrastructureConfigurationsOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let infrastructureConfigurationSummaryList: [ImagebuilderClientTypes.InfrastructureConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListInfrastructureConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case infrastructureConfigurationSummaryList
        case nextToken
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let infrastructureConfigurationSummaryListContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.InfrastructureConfigurationSummary?].self, forKey: .infrastructureConfigurationSummaryList)
        var infrastructureConfigurationSummaryListDecoded0:[ImagebuilderClientTypes.InfrastructureConfigurationSummary]? = nil
        if let infrastructureConfigurationSummaryListContainer = infrastructureConfigurationSummaryListContainer {
            infrastructureConfigurationSummaryListDecoded0 = [ImagebuilderClientTypes.InfrastructureConfigurationSummary]()
            for structure0 in infrastructureConfigurationSummaryListContainer {
                if let structure0 = structure0 {
                    infrastructureConfigurationSummaryListDecoded0?.append(structure0)
                }
            }
        }
        infrastructureConfigurationSummaryList = infrastructureConfigurationSummaryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource whose tags you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags for the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImagebuilderClientTypes.Logging: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Logs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.S3Logs.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Logging configuration defines where Image Builder uploads your logs.
    public struct Logging: Swift.Equatable {
        /// The Amazon S3 logging configuration.
        public var s3Logs: ImagebuilderClientTypes.S3Logs?

        public init (
            s3Logs: ImagebuilderClientTypes.S3Logs? = nil
        )
        {
            self.s3Logs = s3Logs
        }
    }

}

extension ImagebuilderClientTypes.OutputResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amis
        case containers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amis = amis {
            var amisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .amis)
            for ami0 in amis {
                try amisContainer.encode(ami0)
            }
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amisContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Ami?].self, forKey: .amis)
        var amisDecoded0:[ImagebuilderClientTypes.Ami]? = nil
        if let amisContainer = amisContainer {
            amisDecoded0 = [ImagebuilderClientTypes.Ami]()
            for structure0 in amisContainer {
                if let structure0 = structure0 {
                    amisDecoded0?.append(structure0)
                }
            }
        }
        amis = amisDecoded0
        let containersContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[ImagebuilderClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [ImagebuilderClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
    }
}

extension ImagebuilderClientTypes {
    /// The resources produced by this image.
    public struct OutputResources: Swift.Equatable {
        /// The Amazon EC2 AMIs created by this image.
        public var amis: [ImagebuilderClientTypes.Ami]?
        /// Container images that the pipeline has generated and stored in the output repository.
        public var containers: [ImagebuilderClientTypes.Container]?

        public init (
            amis: [ImagebuilderClientTypes.Ami]? = nil,
            containers: [ImagebuilderClientTypes.Container]? = nil
        )
        {
            self.amis = amis
            self.containers = containers
        }
    }

}

extension ImagebuilderClientTypes {
    public enum Ownership: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazon
        case `self`
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [Ownership] {
            return [
                .amazon,
                .self,
                .shared,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazon: return "Amazon"
            case .self: return "Self"
            case .shared: return "Shared"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Ownership(rawValue: rawValue) ?? Ownership.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum PipelineExecutionStartCondition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case expressionMatchAndDependencyUpdatesAvailable
        case expressionMatchOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineExecutionStartCondition] {
            return [
                .expressionMatchAndDependencyUpdatesAvailable,
                .expressionMatchOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .expressionMatchAndDependencyUpdatesAvailable: return "EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE"
            case .expressionMatchOnly: return "EXPRESSION_MATCH_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineExecutionStartCondition(rawValue: rawValue) ?? PipelineExecutionStartCondition.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum PipelineStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineStatus(rawValue: rawValue) ?? PipelineStatus.sdkUnknown(rawValue)
        }
    }
}

extension ImagebuilderClientTypes {
    public enum Platform: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [Platform] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "Linux"
            case .windows: return "Windows"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Platform(rawValue: rawValue) ?? Platform.sdkUnknown(rawValue)
        }
    }
}

extension PutComponentPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentArn = self.componentArn {
            try encodeContainer.encode(componentArn, forKey: .componentArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutComponentPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutComponentPolicy"
    }
}

public struct PutComponentPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy should be applied to.
    /// This member is required.
    public var componentArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        componentArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.policy = policy
    }
}

struct PutComponentPolicyInputBody: Swift.Equatable {
    let componentArn: Swift.String?
    let policy: Swift.String?
}

extension PutComponentPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutComponentPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutComponentPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutComponentPolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutComponentPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutComponentPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentArn = output.componentArn
            self.requestId = output.requestId
        } else {
            self.componentArn = nil
            self.requestId = nil
        }
    }
}

public struct PutComponentPolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the component that this policy was applied to.
    public var componentArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        componentArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.componentArn = componentArn
        self.requestId = requestId
    }
}

struct PutComponentPolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let componentArn: Swift.String?
}

extension PutComponentPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let componentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentArn)
        componentArn = componentArnDecoded
    }
}

extension PutContainerRecipePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContainerRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutContainerRecipePolicy"
    }
}

public struct PutContainerRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy should be applied to.
    /// This member is required.
    public var containerRecipeArn: Swift.String?
    /// The policy to apply to the container recipe.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.policy = policy
    }
}

struct PutContainerRecipePolicyInputBody: Swift.Equatable {
    let containerRecipeArn: Swift.String?
    let policy: Swift.String?
}

extension PutContainerRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContainerRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutContainerRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutContainerRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutContainerRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutContainerRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.containerRecipeArn = output.containerRecipeArn
            self.requestId = output.requestId
        } else {
            self.containerRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutContainerRecipePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the container recipe that this policy was applied to.
    public var containerRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        containerRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.containerRecipeArn = containerRecipeArn
        self.requestId = requestId
    }
}

struct PutContainerRecipePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let containerRecipeArn: Swift.String?
}

extension PutContainerRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
    }
}

extension PutImagePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageArn = self.imageArn {
            try encodeContainer.encode(imageArn, forKey: .imageArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutImagePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutImagePolicy"
    }
}

public struct PutImagePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy should be applied to.
    /// This member is required.
    public var imageArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        imageArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.policy = policy
    }
}

struct PutImagePolicyInputBody: Swift.Equatable {
    let imageArn: Swift.String?
    let policy: Swift.String?
}

extension PutImagePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImagePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImagePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutImagePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImagePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutImagePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageArn = output.imageArn
            self.requestId = output.requestId
        } else {
            self.imageArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImagePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image that this policy was applied to.
    public var imageArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageArn = imageArn
        self.requestId = requestId
    }
}

struct PutImagePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageArn: Swift.String?
}

extension PutImagePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageArn)
        imageArn = imageArnDecoded
    }
}

extension PutImageRecipePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutImageRecipePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutImageRecipePolicy"
    }
}

public struct PutImageRecipePolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy should be applied to.
    /// This member is required.
    public var imageRecipeArn: Swift.String?
    /// The policy to apply.
    /// This member is required.
    public var policy: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.policy = policy
    }
}

struct PutImageRecipePolicyInputBody: Swift.Equatable {
    let imageRecipeArn: Swift.String?
    let policy: Swift.String?
}

extension PutImageRecipePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case policy
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutImageRecipePolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutImageRecipePolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutImageRecipePolicyOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutImageRecipePolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutImageRecipePolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageRecipeArn = output.imageRecipeArn
            self.requestId = output.requestId
        } else {
            self.imageRecipeArn = nil
            self.requestId = nil
        }
    }
}

public struct PutImageRecipePolicyOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the image recipe that this policy was applied to.
    public var imageRecipeArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        imageRecipeArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.imageRecipeArn = imageRecipeArn
        self.requestId = requestId
    }
}

struct PutImageRecipePolicyOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let imageRecipeArn: Swift.String?
}

extension PutImageRecipePolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageRecipeArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
    }
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you are trying to create already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceDependencyException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceDependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have attempted to mutate or delete a resource with a dependency that prohibits this action. See the error message for more details.
public struct ResourceDependencyException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceDependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceDependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource that you are trying to operate on is currently in use. Review the message details and retry later.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// At least one of the resources referenced by your request does not exist.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImagebuilderClientTypes.S3ExportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case diskImageFormat
        case roleName
        case s3Bucket
        case s3Prefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskImageFormat = self.diskImageFormat {
            try encodeContainer.encode(diskImageFormat.rawValue, forKey: .diskImageFormat)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Prefix = self.s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let diskImageFormatDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.DiskImageFormat.self, forKey: .diskImageFormat)
        diskImageFormat = diskImageFormatDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Properties that configure export from your build instance to a compatible file format for your VM.
    public struct S3ExportConfiguration: Swift.Equatable {
        /// Export the updated image to one of the following supported disk image formats:
        ///
        /// * Virtual Hard Disk (VHD) – Compatible with Citrix Xen and Microsoft Hyper-V virtualization products.
        ///
        /// * Stream-optimized ESX Virtual Machine Disk (VMDK) – Compatible with VMware ESX and VMware vSphere versions 4, 5, and 6.
        ///
        /// * Raw – Raw format.
        /// This member is required.
        public var diskImageFormat: ImagebuilderClientTypes.DiskImageFormat?
        /// The name of the role that grants VM Import/Export permission to export images to your S3 bucket.
        /// This member is required.
        public var roleName: Swift.String?
        /// The S3 bucket in which to store the output disk images for your VM.
        /// This member is required.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 path for the bucket where the output disk images for your VM are stored.
        public var s3Prefix: Swift.String?

        public init (
            diskImageFormat: ImagebuilderClientTypes.DiskImageFormat? = nil,
            roleName: Swift.String? = nil,
            s3Bucket: Swift.String? = nil,
            s3Prefix: Swift.String? = nil
        )
        {
            self.diskImageFormat = diskImageFormat
            self.roleName = roleName
            self.s3Bucket = s3Bucket
            self.s3Prefix = s3Prefix
        }
    }

}

extension ImagebuilderClientTypes.S3Logs: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3BucketName
        case s3KeyPrefix
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3BucketName = self.s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = self.s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Amazon S3 logging configuration.
    public struct S3Logs: Swift.Equatable {
        /// The S3 bucket in which to store the logs.
        public var s3BucketName: Swift.String?
        /// The Amazon S3 path to the bucket where the logs are stored.
        public var s3KeyPrefix: Swift.String?

        public init (
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil
        )
        {
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
        }
    }

}

extension ImagebuilderClientTypes.Schedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionStartCondition
        case scheduleExpression
        case timezone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionStartCondition = self.pipelineExecutionStartCondition {
            try encodeContainer.encode(pipelineExecutionStartCondition.rawValue, forKey: .pipelineExecutionStartCondition)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let timezone = self.timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let pipelineExecutionStartConditionDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineExecutionStartCondition.self, forKey: .pipelineExecutionStartCondition)
        pipelineExecutionStartCondition = pipelineExecutionStartConditionDecoded
    }
}

extension ImagebuilderClientTypes {
    /// A schedule configures how often and when a pipeline will automatically create a new image.
    public struct Schedule: Swift.Equatable {
        /// The condition configures when the pipeline should trigger a new image build. When the pipelineExecutionStartCondition is set to EXPRESSION_MATCH_AND_DEPENDENCY_UPDATES_AVAILABLE, and you use semantic version filters on the base image or components in your image recipe, EC2 Image Builder will build a new image only when there are new versions of the image or components in your recipe that match the semantic version filter. When it is set to EXPRESSION_MATCH_ONLY, it will build a new image every time the CRON expression matches the current time. For semantic version syntax, see [CreateComponent](https://docs.aws.amazon.com/imagebuilder/latest/APIReference/API_CreateComponent.html) in the EC2 Image Builder API Reference.
        public var pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition?
        /// The cron expression determines how often EC2 Image Builder evaluates your pipelineExecutionStartCondition. For information on how to format a cron expression in Image Builder, see [Use cron expressions in EC2 Image Builder](https://docs.aws.amazon.com/imagebuilder/latest/userguide/image-builder-cron.html).
        public var scheduleExpression: Swift.String?
        /// The timezone that applies to the scheduling expression. For example, "Etc/UTC", "America/Los_Angeles" in the [IANA timezone format](https://www.joda.org/joda-time/timezones.html). If not specified this defaults to UTC.
        public var timezone: Swift.String?

        public init (
            pipelineExecutionStartCondition: ImagebuilderClientTypes.PipelineExecutionStartCondition? = nil,
            scheduleExpression: Swift.String? = nil,
            timezone: Swift.String? = nil
        )
        {
            self.pipelineExecutionStartCondition = pipelineExecutionStartCondition
            self.scheduleExpression = scheduleExpression
            self.timezone = timezone
        }
    }

}

extension ServiceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is thrown when the service encounters an unrecoverable exception.
public struct ServiceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the number of permitted resources or operations for this service. For service quotas, see [EC2 Image Builder endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/imagebuilder.html#limits_imagebuilder).
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service is unable to process your request at this time.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartImagePipelineExecutionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
    }
}

extension StartImagePipelineExecutionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartImagePipelineExecution"
    }
}

public struct StartImagePipelineExecutionInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to manually invoke.
    /// This member is required.
    public var imagePipelineArn: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
    }
}

struct StartImagePipelineExecutionInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let clientToken: Swift.String?
}

extension StartImagePipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartImagePipelineExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartImagePipelineExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartImagePipelineExecutionOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartImagePipelineExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartImagePipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imageBuildVersionArn = output.imageBuildVersionArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imageBuildVersionArn = nil
            self.requestId = nil
        }
    }
}

public struct StartImagePipelineExecutionOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image that was created by this request.
    public var imageBuildVersionArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imageBuildVersionArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imageBuildVersionArn = imageBuildVersionArn
        self.requestId = requestId
    }
}

struct StartImagePipelineExecutionOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imageBuildVersionArn: Swift.String?
}

extension StartImagePipelineExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imageBuildVersionArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imageBuildVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageBuildVersionArn)
        imageBuildVersionArn = imageBuildVersionArnDecoded
    }
}

extension ImagebuilderClientTypes.SystemsManagerAgent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uninstallAfterBuild
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uninstallAfterBuild = self.uninstallAfterBuild {
            try encodeContainer.encode(uninstallAfterBuild, forKey: .uninstallAfterBuild)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uninstallAfterBuildDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .uninstallAfterBuild)
        uninstallAfterBuild = uninstallAfterBuildDecoded
    }
}

extension ImagebuilderClientTypes {
    /// Contains settings for the Systems Manager agent on your build instance.
    public struct SystemsManagerAgent: Swift.Equatable {
        /// Controls whether the Systems Manager agent is removed from your final build image, prior to creating the new AMI. If this is set to true, then the agent is removed from the final image. If it's set to false, then the agent is left in, so that it is included in the new AMI. The default value is false.
        public var uninstallAfterBuild: Swift.Bool?

        public init (
            uninstallAfterBuild: Swift.Bool? = nil
        )
        {
            self.uninstallAfterBuild = uninstallAfterBuild
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ImagebuilderClientTypes.TargetContainerRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryName
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let service = self.service {
            try encodeContainer.encode(service.rawValue, forKey: .service)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ContainerRepositoryService.self, forKey: .service)
        service = serviceDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension ImagebuilderClientTypes {
    /// The container repository where the output container image is stored.
    public struct TargetContainerRepository: Swift.Equatable {
        /// The name of the container repository where the output container image is stored. This name is prefixed by the repository location.
        /// This member is required.
        public var repositoryName: Swift.String?
        /// Specifies the service in which this image was registered.
        /// This member is required.
        public var service: ImagebuilderClientTypes.ContainerRepositoryService?

        public init (
            repositoryName: Swift.String? = nil,
            service: ImagebuilderClientTypes.ContainerRepositoryService? = nil
        )
        {
            self.repositoryName = repositoryName
            self.service = service
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDistributionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let distributions = distributions {
            var distributionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .distributions)
            for distribution0 in distributions {
                try distributionsContainer.encode(distribution0)
            }
        }
    }
}

extension UpdateDistributionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateDistributionConfiguration"
    }
}

public struct UpdateDistributionConfigurationInput: Swift.Equatable {
    /// The idempotency token of the distribution configuration.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the distribution configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that you want to update.
    /// This member is required.
    public var distributionConfigurationArn: Swift.String?
    /// The distributions of the distribution configuration.
    /// This member is required.
    public var distributions: [ImagebuilderClientTypes.Distribution]?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        distributions: [ImagebuilderClientTypes.Distribution]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.distributions = distributions
    }
}

struct UpdateDistributionConfigurationInputBody: Swift.Equatable {
    let distributionConfigurationArn: Swift.String?
    let description: Swift.String?
    let distributions: [ImagebuilderClientTypes.Distribution]?
    let clientToken: Swift.String?
}

extension UpdateDistributionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case distributionConfigurationArn
        case distributions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributionsContainer = try containerValues.decodeIfPresent([ImagebuilderClientTypes.Distribution?].self, forKey: .distributions)
        var distributionsDecoded0:[ImagebuilderClientTypes.Distribution]? = nil
        if let distributionsContainer = distributionsContainer {
            distributionsDecoded0 = [ImagebuilderClientTypes.Distribution]()
            for structure0 in distributionsContainer {
                if let structure0 = structure0 {
                    distributionsDecoded0?.append(structure0)
                }
            }
        }
        distributions = distributionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDistributionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDistributionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDistributionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDistributionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDistributionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.distributionConfigurationArn = output.distributionConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.distributionConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateDistributionConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that was updated by this request.
    public var distributionConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.distributionConfigurationArn = distributionConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateDistributionConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let distributionConfigurationArn: Swift.String?
}

extension UpdateDistributionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case distributionConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
    }
}

extension UpdateImagePipelineInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let containerRecipeArn = self.containerRecipeArn {
            try encodeContainer.encode(containerRecipeArn, forKey: .containerRecipeArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributionConfigurationArn = self.distributionConfigurationArn {
            try encodeContainer.encode(distributionConfigurationArn, forKey: .distributionConfigurationArn)
        }
        if let enhancedImageMetadataEnabled = self.enhancedImageMetadataEnabled {
            try encodeContainer.encode(enhancedImageMetadataEnabled, forKey: .enhancedImageMetadataEnabled)
        }
        if let imagePipelineArn = self.imagePipelineArn {
            try encodeContainer.encode(imagePipelineArn, forKey: .imagePipelineArn)
        }
        if let imageRecipeArn = self.imageRecipeArn {
            try encodeContainer.encode(imageRecipeArn, forKey: .imageRecipeArn)
        }
        if let imageTestsConfiguration = self.imageTestsConfiguration {
            try encodeContainer.encode(imageTestsConfiguration, forKey: .imageTestsConfiguration)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let schedule = self.schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateImagePipelineInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateImagePipeline"
    }
}

public struct UpdateImagePipelineInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the container pipeline to update.
    public var containerRecipeArn: Swift.String?
    /// The description of the image pipeline.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the distribution configuration that will be used to configure and distribute images updated by this image pipeline.
    public var distributionConfigurationArn: Swift.String?
    /// Collects additional information about the image being created, including the operating system (OS) version and package list. This information is used to enhance the overall experience of using EC2 Image Builder. Enabled by default.
    public var enhancedImageMetadataEnabled: Swift.Bool?
    /// The Amazon Resource Name (ARN) of the image pipeline that you want to update.
    /// This member is required.
    public var imagePipelineArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the image recipe that will be used to configure images updated by this image pipeline.
    public var imageRecipeArn: Swift.String?
    /// The image test configuration of the image pipeline.
    public var imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that will be used to build images updated by this image pipeline.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The schedule of the image pipeline.
    public var schedule: ImagebuilderClientTypes.Schedule?
    /// The status of the image pipeline.
    public var status: ImagebuilderClientTypes.PipelineStatus?

    public init (
        clientToken: Swift.String? = nil,
        containerRecipeArn: Swift.String? = nil,
        description: Swift.String? = nil,
        distributionConfigurationArn: Swift.String? = nil,
        enhancedImageMetadataEnabled: Swift.Bool? = nil,
        imagePipelineArn: Swift.String? = nil,
        imageRecipeArn: Swift.String? = nil,
        imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        schedule: ImagebuilderClientTypes.Schedule? = nil,
        status: ImagebuilderClientTypes.PipelineStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.containerRecipeArn = containerRecipeArn
        self.description = description
        self.distributionConfigurationArn = distributionConfigurationArn
        self.enhancedImageMetadataEnabled = enhancedImageMetadataEnabled
        self.imagePipelineArn = imagePipelineArn
        self.imageRecipeArn = imageRecipeArn
        self.imageTestsConfiguration = imageTestsConfiguration
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.schedule = schedule
        self.status = status
    }
}

struct UpdateImagePipelineInputBody: Swift.Equatable {
    let imagePipelineArn: Swift.String?
    let description: Swift.String?
    let imageRecipeArn: Swift.String?
    let containerRecipeArn: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
    let distributionConfigurationArn: Swift.String?
    let imageTestsConfiguration: ImagebuilderClientTypes.ImageTestsConfiguration?
    let enhancedImageMetadataEnabled: Swift.Bool?
    let schedule: ImagebuilderClientTypes.Schedule?
    let status: ImagebuilderClientTypes.PipelineStatus?
    let clientToken: Swift.String?
}

extension UpdateImagePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case containerRecipeArn
        case description
        case distributionConfigurationArn
        case enhancedImageMetadataEnabled
        case imagePipelineArn
        case imageRecipeArn
        case imageTestsConfiguration
        case infrastructureConfigurationArn
        case schedule
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let imageRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageRecipeArn)
        imageRecipeArn = imageRecipeArnDecoded
        let containerRecipeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRecipeArn)
        containerRecipeArn = containerRecipeArnDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let distributionConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributionConfigurationArn)
        distributionConfigurationArn = distributionConfigurationArnDecoded
        let imageTestsConfigurationDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.ImageTestsConfiguration.self, forKey: .imageTestsConfiguration)
        imageTestsConfiguration = imageTestsConfigurationDecoded
        let enhancedImageMetadataEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enhancedImageMetadataEnabled)
        enhancedImageMetadataEnabled = enhancedImageMetadataEnabledDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.PipelineStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateImagePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImagePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateImagePipelineOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImagePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateImagePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.imagePipelineArn = output.imagePipelineArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.imagePipelineArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateImagePipelineOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the image pipeline that was updated by this request.
    public var imagePipelineArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        imagePipelineArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.imagePipelineArn = imagePipelineArn
        self.requestId = requestId
    }
}

struct UpdateImagePipelineOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let imagePipelineArn: Swift.String?
}

extension UpdateImagePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case imagePipelineArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let imagePipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePipelineArn)
        imagePipelineArn = imagePipelineArnDecoded
    }
}

extension UpdateInfrastructureConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let infrastructureConfigurationArn = self.infrastructureConfigurationArn {
            try encodeContainer.encode(infrastructureConfigurationArn, forKey: .infrastructureConfigurationArn)
        }
        if let instanceMetadataOptions = self.instanceMetadataOptions {
            try encodeContainer.encode(instanceMetadataOptions, forKey: .instanceMetadataOptions)
        }
        if let instanceProfileName = self.instanceProfileName {
            try encodeContainer.encode(instanceProfileName, forKey: .instanceProfileName)
        }
        if let instanceTypes = instanceTypes {
            var instanceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceTypes)
            for instancetype0 in instanceTypes {
                try instanceTypesContainer.encode(instancetype0)
            }
        }
        if let keyPair = self.keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let logging = self.logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let resourceTags = resourceTags {
            var resourceTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resourceTags)
            for (dictKey0, resourceTagMap0) in resourceTags {
                try resourceTagsContainer.encode(resourceTagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for nonemptystring0 in securityGroupIds {
                try securityGroupIdsContainer.encode(nonemptystring0)
            }
        }
        if let snsTopicArn = self.snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let terminateInstanceOnFailure = self.terminateInstanceOnFailure {
            try encodeContainer.encode(terminateInstanceOnFailure, forKey: .terminateInstanceOnFailure)
        }
    }
}

extension UpdateInfrastructureConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateInfrastructureConfiguration"
    }
}

public struct UpdateInfrastructureConfigurationInput: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The description of the infrastructure configuration.
    public var description: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that you want to update.
    /// This member is required.
    public var infrastructureConfigurationArn: Swift.String?
    /// The instance metadata options that you can set for the HTTP requests that pipeline builds use to launch EC2 build and test instances. For more information about instance metadata options, see one of the following links:
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the Amazon EC2 User Guide for Linux instances.
    ///
    /// * [Configure the instance metadata options](https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/configuring-instance-metadata-options.html) in the Amazon EC2 Windows Guide for Windows instances.
    public var instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
    /// The instance profile to associate with the instance used to customize your Amazon EC2 AMI.
    /// This member is required.
    public var instanceProfileName: Swift.String?
    /// The instance types of the infrastructure configuration. You can specify one or more instance types to use for this build. The service will pick one of these instance types based on availability.
    public var instanceTypes: [Swift.String]?
    /// The key pair of the infrastructure configuration. You can use this to log on to and debug the instance used to create your image.
    public var keyPair: Swift.String?
    /// The logging configuration of the infrastructure configuration.
    public var logging: ImagebuilderClientTypes.Logging?
    /// The tags attached to the resource created by Image Builder.
    public var resourceTags: [Swift.String:Swift.String]?
    /// The security group IDs to associate with the instance used to customize your Amazon EC2 AMI.
    public var securityGroupIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) for the SNS topic to which we send image build event notifications. EC2 Image Builder is unable to send notifications to SNS topics that are encrypted using keys from other accounts. The key that is used to encrypt the SNS topic must reside in the account that the Image Builder service runs under.
    public var snsTopicArn: Swift.String?
    /// The subnet ID to place the instance used to customize your Amazon EC2 AMI in.
    public var subnetId: Swift.String?
    /// The terminate instance on failure setting of the infrastructure configuration. Set to false if you want Image Builder to retain the instance used to configure your AMI if the build or test phase of your workflow fails.
    public var terminateInstanceOnFailure: Swift.Bool?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions? = nil,
        instanceProfileName: Swift.String? = nil,
        instanceTypes: [Swift.String]? = nil,
        keyPair: Swift.String? = nil,
        logging: ImagebuilderClientTypes.Logging? = nil,
        resourceTags: [Swift.String:Swift.String]? = nil,
        securityGroupIds: [Swift.String]? = nil,
        snsTopicArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        terminateInstanceOnFailure: Swift.Bool? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.instanceMetadataOptions = instanceMetadataOptions
        self.instanceProfileName = instanceProfileName
        self.instanceTypes = instanceTypes
        self.keyPair = keyPair
        self.logging = logging
        self.resourceTags = resourceTags
        self.securityGroupIds = securityGroupIds
        self.snsTopicArn = snsTopicArn
        self.subnetId = subnetId
        self.terminateInstanceOnFailure = terminateInstanceOnFailure
    }
}

struct UpdateInfrastructureConfigurationInputBody: Swift.Equatable {
    let infrastructureConfigurationArn: Swift.String?
    let description: Swift.String?
    let instanceTypes: [Swift.String]?
    let instanceProfileName: Swift.String?
    let securityGroupIds: [Swift.String]?
    let subnetId: Swift.String?
    let logging: ImagebuilderClientTypes.Logging?
    let keyPair: Swift.String?
    let terminateInstanceOnFailure: Swift.Bool?
    let snsTopicArn: Swift.String?
    let clientToken: Swift.String?
    let resourceTags: [Swift.String:Swift.String]?
    let instanceMetadataOptions: ImagebuilderClientTypes.InstanceMetadataOptions?
}

extension UpdateInfrastructureConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case infrastructureConfigurationArn
        case instanceMetadataOptions
        case instanceProfileName
        case instanceTypes
        case keyPair
        case logging
        case resourceTags
        case securityGroupIds
        case snsTopicArn
        case subnetId
        case terminateInstanceOnFailure
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceTypes)
        var instanceTypesDecoded0:[Swift.String]? = nil
        if let instanceTypesContainer = instanceTypesContainer {
            instanceTypesDecoded0 = [Swift.String]()
            for string0 in instanceTypesContainer {
                if let string0 = string0 {
                    instanceTypesDecoded0?.append(string0)
                }
            }
        }
        instanceTypes = instanceTypesDecoded0
        let instanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileName)
        instanceProfileName = instanceProfileNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.Logging.self, forKey: .logging)
        logging = loggingDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let terminateInstanceOnFailureDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .terminateInstanceOnFailure)
        terminateInstanceOnFailure = terminateInstanceOnFailureDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let resourceTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resourceTags)
        var resourceTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let resourceTagsContainer = resourceTagsContainer {
            resourceTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in resourceTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    resourceTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        resourceTags = resourceTagsDecoded0
        let instanceMetadataOptionsDecoded = try containerValues.decodeIfPresent(ImagebuilderClientTypes.InstanceMetadataOptions.self, forKey: .instanceMetadataOptions)
        instanceMetadataOptions = instanceMetadataOptionsDecoded
    }
}

extension UpdateInfrastructureConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateInfrastructureConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "CallRateLimitExceededException" : self = .callRateLimitExceededException(try CallRateLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientException" : self = .clientException(try ClientException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IdempotentParameterMismatchException" : self = .idempotentParameterMismatchException(try IdempotentParameterMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateInfrastructureConfigurationOutputError: Swift.Error, Swift.Equatable {
    case callRateLimitExceededException(CallRateLimitExceededException)
    case clientException(ClientException)
    case forbiddenException(ForbiddenException)
    case idempotentParameterMismatchException(IdempotentParameterMismatchException)
    case invalidRequestException(InvalidRequestException)
    case resourceInUseException(ResourceInUseException)
    case serviceException(ServiceException)
    case serviceUnavailableException(ServiceUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateInfrastructureConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateInfrastructureConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clientToken = output.clientToken
            self.infrastructureConfigurationArn = output.infrastructureConfigurationArn
            self.requestId = output.requestId
        } else {
            self.clientToken = nil
            self.infrastructureConfigurationArn = nil
            self.requestId = nil
        }
    }
}

public struct UpdateInfrastructureConfigurationOutputResponse: Swift.Equatable {
    /// The idempotency token used to make this request idempotent.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the infrastructure configuration that was updated by this request.
    public var infrastructureConfigurationArn: Swift.String?
    /// The request ID that uniquely identifies this request.
    public var requestId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        infrastructureConfigurationArn: Swift.String? = nil,
        requestId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.infrastructureConfigurationArn = infrastructureConfigurationArn
        self.requestId = requestId
    }
}

struct UpdateInfrastructureConfigurationOutputResponseBody: Swift.Equatable {
    let requestId: Swift.String?
    let clientToken: Swift.String?
    let infrastructureConfigurationArn: Swift.String?
}

extension UpdateInfrastructureConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case infrastructureConfigurationArn
        case requestId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let infrastructureConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .infrastructureConfigurationArn)
        infrastructureConfigurationArn = infrastructureConfigurationArnDecoded
    }
}
