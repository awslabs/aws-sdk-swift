// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AdMarkers {
    case `none`
    case passthrough
    case scte35Enhanced
    case sdkUnknown(String)
}

extension AdMarkers : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AdMarkers] {
        return [
            .none,
            .passthrough,
            .scte35Enhanced,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "NONE"
        case .passthrough: return "PASSTHROUGH"
        case .scte35Enhanced: return "SCTE35_ENHANCED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AdMarkers(rawValue: rawValue) ?? AdMarkers.sdkUnknown(rawValue)
    }
}

extension AssetShallow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let packagingGroupId = packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceRoleArn = sourceRoleArn {
            try encodeContainer.encode(sourceRoleArn, forKey: .sourceRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssetShallow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetShallow(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), packagingGroupId: \(String(describing: packagingGroupId)), resourceId: \(String(describing: resourceId)), sourceArn: \(String(describing: sourceArn)), sourceRoleArn: \(String(describing: sourceRoleArn)), tags: \(String(describing: tags)))"}
}

/// A MediaPackage VOD Asset resource.
public struct AssetShallow: Equatable {
    /// The ARN of the Asset.
    public let arn: String?
    /// The time the Asset was initially submitted for Ingest.
    public let createdAt: String?
    /// The unique identifier for the Asset.
    public let id: String?
    /// The ID of the PackagingGroup for the Asset.
    public let packagingGroupId: String?
    /// The resource ID to include in SPEKE key requests.
    public let resourceId: String?
    /// ARN of the source object in S3.
    public let sourceArn: String?
    /// The IAM role ARN used to access the source S3 bucket.
    public let sourceRoleArn: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: String? = nil,
        id: String? = nil,
        packagingGroupId: String? = nil,
        resourceId: String? = nil,
        sourceArn: String? = nil,
        sourceRoleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

extension Authorization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cdnIdentifierSecret = "cdnIdentifierSecret"
        case secretsRoleArn = "secretsRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cdnIdentifierSecret = cdnIdentifierSecret {
            try encodeContainer.encode(cdnIdentifierSecret, forKey: .cdnIdentifierSecret)
        }
        if let secretsRoleArn = secretsRoleArn {
            try encodeContainer.encode(secretsRoleArn, forKey: .secretsRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cdnIdentifierSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cdnIdentifierSecret)
        cdnIdentifierSecret = cdnIdentifierSecretDecoded
        let secretsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretsRoleArn)
        secretsRoleArn = secretsRoleArnDecoded
    }
}

extension Authorization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Authorization(cdnIdentifierSecret: \(String(describing: cdnIdentifierSecret)), secretsRoleArn: \(String(describing: secretsRoleArn)))"}
}

/// CDN Authorization credentials
public struct Authorization: Equatable {
    /// The Amazon Resource Name (ARN) for the secret in AWS Secrets Manager that is used for CDN authorization.
    public let cdnIdentifierSecret: String?
    /// The Amazon Resource Name (ARN) for the IAM role that allows MediaPackage to communicate with AWS Secrets Manager.
    public let secretsRoleArn: String?

    public init (
        cdnIdentifierSecret: String? = nil,
        secretsRoleArn: String? = nil
    )
    {
        self.cdnIdentifierSecret = cdnIdentifierSecret
        self.secretsRoleArn = secretsRoleArn
    }
}

extension CmafEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension CmafEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CmafEncryption(spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A CMAF encryption configuration.
public struct CmafEncryption: Equatable {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension CmafPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
        case segmentDurationSeconds = "segmentDurationSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifest0)
            }
        }
        if includeEncoderConfigurationInSegments != false {
            try encodeContainer.encode(includeEncoderConfigurationInSegments, forKey: .includeEncoderConfigurationInSegments)
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(CmafEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let includeEncoderConfigurationInSegmentsDecoded = try containerValues.decode(Bool.self, forKey: .includeEncoderConfigurationInSegments)
        includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegmentsDecoded
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
    }
}

extension CmafPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CmafPackage(encryption: \(String(describing: encryption)), hlsManifests: \(String(describing: hlsManifests)), includeEncoderConfigurationInSegments: \(String(describing: includeEncoderConfigurationInSegments)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)))"}
}

/// A CMAF packaging configuration.
public struct CmafPackage: Equatable {
    /// A CMAF encryption configuration.
    public let encryption: CmafEncryption?
    /// A list of HLS manifest configurations.
    public let hlsManifests: [HlsManifest]?
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    public let includeEncoderConfigurationInSegments: Bool
    /// Duration (in seconds) of each fragment. Actual fragments will be
    /// rounded to the nearest multiple of the source fragment duration.
    public let segmentDurationSeconds: Int

    public init (
        encryption: CmafEncryption? = nil,
        hlsManifests: [HlsManifest]? = nil,
        includeEncoderConfigurationInSegments: Bool = false,
        segmentDurationSeconds: Int = 0
    )
    {
        self.encryption = encryption
        self.hlsManifests = hlsManifests
        self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
        self.segmentDurationSeconds = segmentDurationSeconds
    }
}

public struct ConfigureLogsInputBodyMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

extension ConfigureLogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureLogsInput(egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)))"}
}

extension ConfigureLogsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case egressAccessLogs = "egressAccessLogs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
    }
}

public struct ConfigureLogsInputHeadersMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

public struct ConfigureLogsInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfigureLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureLogsInput>
    public typealias MOutput = OperationOutput<ConfigureLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureLogsOutputError>
}

/// The option to configure log subscription.
public struct ConfigureLogsInput: Equatable {
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    public let id: String?

    public init (
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil
    )
    {
        self.egressAccessLogs = egressAccessLogs
        self.id = id
    }
}

struct ConfigureLogsInputBody: Equatable {
    public let egressAccessLogs: EgressAccessLogs?
}

extension ConfigureLogsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case egressAccessLogs = "egressAccessLogs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
    }
}

extension ConfigureLogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureLogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureLogsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureLogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureLogsOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), domainName: \(String(describing: domainName)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension ConfigureLogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConfigureLogsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct ConfigureLogsOutputResponse: Equatable {
    /// The ARN of the PackagingGroup.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public let domainName: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        domainName: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct ConfigureLogsOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let domainName: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let id: String?
    public let tags: [String:String]?
}

extension ConfigureLogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateAssetInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

extension CreateAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetInput(id: \(String(describing: id)), packagingGroupId: \(String(describing: packagingGroupId)), resourceId: \(String(describing: resourceId)), sourceArn: \(String(describing: sourceArn)), sourceRoleArn: \(String(describing: sourceRoleArn)), tags: \(String(describing: tags)))"}
}

extension CreateAssetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let packagingGroupId = packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let sourceRoleArn = sourceRoleArn {
            try encodeContainer.encode(sourceRoleArn, forKey: .sourceRoleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

public struct CreateAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssetInput>
    public typealias MOutput = OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssetOutputError>
}

/// A new MediaPackage VOD Asset configuration.
public struct CreateAssetInput: Equatable {
    /// The unique identifier for the Asset.
    public let id: String?
    /// The ID of the PackagingGroup for the Asset.
    public let packagingGroupId: String?
    /// The resource ID to include in SPEKE key requests.
    public let resourceId: String?
    /// ARN of the source object in S3.
    public let sourceArn: String?
    /// The IAM role ARN used to access the source S3 bucket.
    public let sourceRoleArn: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        id: String? = nil,
        packagingGroupId: String? = nil,
        resourceId: String? = nil,
        sourceArn: String? = nil,
        sourceRoleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct CreateAssetInputBody: Equatable {
    public let id: String?
    public let packagingGroupId: String?
    public let resourceId: String?
    public let sourceArn: String?
    public let sourceRoleArn: String?
    public let tags: [String:String]?
}

extension CreateAssetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssetOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssetOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), egressEndpoints: \(String(describing: egressEndpoints)), id: \(String(describing: id)), packagingGroupId: \(String(describing: packagingGroupId)), resourceId: \(String(describing: resourceId)), sourceArn: \(String(describing: sourceArn)), sourceRoleArn: \(String(describing: sourceRoleArn)), tags: \(String(describing: tags)))"}
}

extension CreateAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.egressEndpoints = output.egressEndpoints
            self.id = output.id
            self.packagingGroupId = output.packagingGroupId
            self.resourceId = output.resourceId
            self.sourceArn = output.sourceArn
            self.sourceRoleArn = output.sourceRoleArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.egressEndpoints = nil
            self.id = nil
            self.packagingGroupId = nil
            self.resourceId = nil
            self.sourceArn = nil
            self.sourceRoleArn = nil
            self.tags = nil
        }
    }
}

public struct CreateAssetOutputResponse: Equatable {
    /// The ARN of the Asset.
    public let arn: String?
    /// The time the Asset was initially submitted for Ingest.
    public let createdAt: String?
    /// The list of egress endpoints available for the Asset.
    public let egressEndpoints: [EgressEndpoint]?
    /// The unique identifier for the Asset.
    public let id: String?
    /// The ID of the PackagingGroup for the Asset.
    public let packagingGroupId: String?
    /// The resource ID to include in SPEKE key requests.
    public let resourceId: String?
    /// ARN of the source object in S3.
    public let sourceArn: String?
    /// The IAM role_arn used to access the source S3 bucket.
    public let sourceRoleArn: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: String? = nil,
        egressEndpoints: [EgressEndpoint]? = nil,
        id: String? = nil,
        packagingGroupId: String? = nil,
        resourceId: String? = nil,
        sourceArn: String? = nil,
        sourceRoleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.egressEndpoints = egressEndpoints
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct CreateAssetOutputResponseBody: Equatable {
    public let arn: String?
    public let createdAt: String?
    public let egressEndpoints: [EgressEndpoint]?
    public let id: String?
    public let packagingGroupId: String?
    public let resourceId: String?
    public let sourceArn: String?
    public let sourceRoleArn: String?
    public let tags: [String:String]?
}

extension CreateAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case egressEndpoints = "egressEndpoints"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let egressEndpointsContainer = try containerValues.decodeIfPresent([EgressEndpoint?].self, forKey: .egressEndpoints)
        var egressEndpointsDecoded0:[EgressEndpoint]? = nil
        if let egressEndpointsContainer = egressEndpointsContainer {
            egressEndpointsDecoded0 = [EgressEndpoint]()
            for structure0 in egressEndpointsContainer {
                if let structure0 = structure0 {
                    egressEndpointsDecoded0?.append(structure0)
                }
            }
        }
        egressEndpoints = egressEndpointsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePackagingConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreatePackagingConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<CreatePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingConfigurationOutputError>
}

extension CreatePackagingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePackagingConfigurationInput(cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), mssPackage: \(String(describing: mssPackage)), packagingGroupId: \(String(describing: packagingGroupId)), tags: \(String(describing: tags)))"}
}

extension CreatePackagingConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let packagingGroupId = packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePackagingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePackagingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<CreatePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingConfigurationOutputError>
}

public struct CreatePackagingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePackagingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<CreatePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingConfigurationOutputError>
}

/// A new MediaPackage VOD PackagingConfiguration resource configuration.
public struct CreatePackagingConfigurationInput: Equatable {
    /// A CMAF packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the PackagingConfiguration.
    public let id: String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public let mssPackage: MssPackage?
    /// The ID of a PackagingGroup.
    public let packagingGroupId: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        mssPackage: MssPackage? = nil,
        packagingGroupId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct CreatePackagingConfigurationInputBody: Equatable {
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let mssPackage: MssPackage?
    public let packagingGroupId: String?
    public let tags: [String:String]?
}

extension CreatePackagingConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackagingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePackagingConfigurationOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackagingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePackagingConfigurationOutputResponse(arn: \(String(describing: arn)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), mssPackage: \(String(describing: mssPackage)), packagingGroupId: \(String(describing: packagingGroupId)), tags: \(String(describing: tags)))"}
}

extension CreatePackagingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePackagingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.mssPackage = output.mssPackage
            self.packagingGroupId = output.packagingGroupId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.hlsPackage = nil
            self.id = nil
            self.mssPackage = nil
            self.packagingGroupId = nil
            self.tags = nil
        }
    }
}

public struct CreatePackagingConfigurationOutputResponse: Equatable {
    /// The ARN of the PackagingConfiguration.
    public let arn: String?
    /// A CMAF packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the PackagingConfiguration.
    public let id: String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public let mssPackage: MssPackage?
    /// The ID of a PackagingGroup.
    public let packagingGroupId: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        mssPackage: MssPackage? = nil,
        packagingGroupId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct CreatePackagingConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let mssPackage: MssPackage?
    public let packagingGroupId: String?
    public let tags: [String:String]?
}

extension CreatePackagingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePackagingGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreatePackagingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingGroupInput>
    public typealias MOutput = OperationOutput<CreatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingGroupOutputError>
}

extension CreatePackagingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePackagingGroupInput(authorization: \(String(describing: authorization)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension CreatePackagingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePackagingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePackagingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingGroupInput>
    public typealias MOutput = OperationOutput<CreatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingGroupOutputError>
}

public struct CreatePackagingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePackagingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePackagingGroupInput>
    public typealias MOutput = OperationOutput<CreatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePackagingGroupOutputError>
}

/// A new MediaPackage VOD PackagingGroup resource configuration.
public struct CreatePackagingGroupInput: Equatable {
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        authorization: Authorization? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.authorization = authorization
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct CreatePackagingGroupInputBody: Equatable {
    public let authorization: Authorization?
    public let egressAccessLogs: EgressAccessLogs?
    public let id: String?
    public let tags: [String:String]?
}

extension CreatePackagingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePackagingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePackagingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePackagingGroupOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePackagingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePackagingGroupOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), domainName: \(String(describing: domainName)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension CreatePackagingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct CreatePackagingGroupOutputResponse: Equatable {
    /// The ARN of the PackagingGroup.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public let domainName: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        domainName: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct CreatePackagingGroupOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let domainName: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let id: String?
    public let tags: [String:String]?
}

extension CreatePackagingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DashEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension DashEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashEncryption(spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
public struct DashEncryption: Equatable {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension DashManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestLayout = "manifestLayout"
        case manifestName = "manifestName"
        case minBufferTimeSeconds = "minBufferTimeSeconds"
        case profile = "profile"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestLayout = manifestLayout {
            try encodeContainer.encode(manifestLayout.rawValue, forKey: .manifestLayout)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if minBufferTimeSeconds != 0 {
            try encodeContainer.encode(minBufferTimeSeconds, forKey: .minBufferTimeSeconds)
        }
        if let profile = profile {
            try encodeContainer.encode(profile.rawValue, forKey: .profile)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestLayoutDecoded = try containerValues.decodeIfPresent(ManifestLayout.self, forKey: .manifestLayout)
        manifestLayout = manifestLayoutDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let minBufferTimeSecondsDecoded = try containerValues.decode(Int.self, forKey: .minBufferTimeSeconds)
        minBufferTimeSeconds = minBufferTimeSecondsDecoded
        let profileDecoded = try containerValues.decodeIfPresent(Profile.self, forKey: .profile)
        profile = profileDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension DashManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashManifest(manifestLayout: \(String(describing: manifestLayout)), manifestName: \(String(describing: manifestName)), minBufferTimeSeconds: \(String(describing: minBufferTimeSeconds)), profile: \(String(describing: profile)), streamSelection: \(String(describing: streamSelection)))"}
}

/// A DASH manifest configuration.
public struct DashManifest: Equatable {
    /// Determines the position of some tags in the Media Presentation Description (MPD).  When set to FULL, elements like SegmentTemplate and ContentProtection are included in each Representation.  When set to COMPACT, duplicate elements are combined and presented at the AdaptationSet level.
    public let manifestLayout: ManifestLayout?
    /// An optional string to include in the name of the manifest.
    public let manifestName: String?
    /// Minimum duration (in seconds) that a player will buffer media before starting the presentation.
    public let minBufferTimeSeconds: Int
    /// The Dynamic Adaptive Streaming over HTTP (DASH) profile type.  When set to "HBBTV_1_5", HbbTV 1.5 compliant output is enabled.
    public let profile: Profile?
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        manifestLayout: ManifestLayout? = nil,
        manifestName: String? = nil,
        minBufferTimeSeconds: Int = 0,
        profile: Profile? = nil,
        streamSelection: StreamSelection? = nil
    )
    {
        self.manifestLayout = manifestLayout
        self.manifestName = manifestName
        self.minBufferTimeSeconds = minBufferTimeSeconds
        self.profile = profile
        self.streamSelection = streamSelection
    }
}

extension DashPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dashManifests = "dashManifests"
        case encryption = "encryption"
        case includeEncoderConfigurationInSegments = "includeEncoderConfigurationInSegments"
        case periodTriggers = "periodTriggers"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case segmentTemplateFormat = "segmentTemplateFormat"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dashManifests = dashManifests {
            var dashManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dashManifests)
            for __listofdashmanifest0 in dashManifests {
                try dashManifestsContainer.encode(__listofdashmanifest0)
            }
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if includeEncoderConfigurationInSegments != false {
            try encodeContainer.encode(includeEncoderConfigurationInSegments, forKey: .includeEncoderConfigurationInSegments)
        }
        if let periodTriggers = periodTriggers {
            var periodTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .periodTriggers)
            for __listof__periodtriggerselement0 in periodTriggers {
                try periodTriggersContainer.encode(__listof__periodtriggerselement0.rawValue)
            }
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if let segmentTemplateFormat = segmentTemplateFormat {
            try encodeContainer.encode(segmentTemplateFormat.rawValue, forKey: .segmentTemplateFormat)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashManifestsContainer = try containerValues.decodeIfPresent([DashManifest?].self, forKey: .dashManifests)
        var dashManifestsDecoded0:[DashManifest]? = nil
        if let dashManifestsContainer = dashManifestsContainer {
            dashManifestsDecoded0 = [DashManifest]()
            for structure0 in dashManifestsContainer {
                if let structure0 = structure0 {
                    dashManifestsDecoded0?.append(structure0)
                }
            }
        }
        dashManifests = dashManifestsDecoded0
        let encryptionDecoded = try containerValues.decodeIfPresent(DashEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let includeEncoderConfigurationInSegmentsDecoded = try containerValues.decode(Bool.self, forKey: .includeEncoderConfigurationInSegments)
        includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegmentsDecoded
        let periodTriggersContainer = try containerValues.decodeIfPresent([__PeriodTriggersElement?].self, forKey: .periodTriggers)
        var periodTriggersDecoded0:[__PeriodTriggersElement]? = nil
        if let periodTriggersContainer = periodTriggersContainer {
            periodTriggersDecoded0 = [__PeriodTriggersElement]()
            for string0 in periodTriggersContainer {
                if let string0 = string0 {
                    periodTriggersDecoded0?.append(string0)
                }
            }
        }
        periodTriggers = periodTriggersDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let segmentTemplateFormatDecoded = try containerValues.decodeIfPresent(SegmentTemplateFormat.self, forKey: .segmentTemplateFormat)
        segmentTemplateFormat = segmentTemplateFormatDecoded
    }
}

extension DashPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DashPackage(dashManifests: \(String(describing: dashManifests)), encryption: \(String(describing: encryption)), includeEncoderConfigurationInSegments: \(String(describing: includeEncoderConfigurationInSegments)), periodTriggers: \(String(describing: periodTriggers)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), segmentTemplateFormat: \(String(describing: segmentTemplateFormat)))"}
}

/// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
public struct DashPackage: Equatable {
    /// A list of DASH manifest configurations.
    public let dashManifests: [DashManifest]?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) encryption configuration.
    public let encryption: DashEncryption?
    /// When includeEncoderConfigurationInSegments is set to true, MediaPackage places your encoder's Sequence Parameter Set (SPS), Picture Parameter Set (PPS), and Video Parameter Set (VPS) metadata in every video segment instead of in the init fragment. This lets you use different SPS/PPS/VPS settings for your assets during content playback.
    public let includeEncoderConfigurationInSegments: Bool
    /// A list of triggers that controls when the outgoing Dynamic Adaptive Streaming over HTTP (DASH)
    /// Media Presentation Description (MPD) will be partitioned into multiple periods. If empty, the content will not
    /// be partitioned into more than one period. If the list contains "ADS", new periods will be created where
    /// the Asset contains SCTE-35 ad markers.
    public let periodTriggers: [__PeriodTriggersElement]?
    /// Duration (in seconds) of each segment. Actual segments will be
    /// rounded to the nearest multiple of the source segment duration.
    public let segmentDurationSeconds: Int
    /// Determines the type of SegmentTemplate included in the Media Presentation Description (MPD).  When set to NUMBER_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Number$ media URLs.  When set to TIME_WITH_TIMELINE, a full timeline is presented in each SegmentTemplate, with $Time$ media URLs. When set to NUMBER_WITH_DURATION, only a duration is included in each SegmentTemplate, with $Number$ media URLs.
    public let segmentTemplateFormat: SegmentTemplateFormat?

    public init (
        dashManifests: [DashManifest]? = nil,
        encryption: DashEncryption? = nil,
        includeEncoderConfigurationInSegments: Bool = false,
        periodTriggers: [__PeriodTriggersElement]? = nil,
        segmentDurationSeconds: Int = 0,
        segmentTemplateFormat: SegmentTemplateFormat? = nil
    )
    {
        self.dashManifests = dashManifests
        self.encryption = encryption
        self.includeEncoderConfigurationInSegments = includeEncoderConfigurationInSegments
        self.periodTriggers = periodTriggers
        self.segmentDurationSeconds = segmentDurationSeconds
        self.segmentTemplateFormat = segmentTemplateFormat
    }
}

extension DeleteAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetInput(id: \(String(describing: id)))"}
}

extension DeleteAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInput: Equatable {
    /// The ID of the MediaPackage VOD Asset resource to delete.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteAssetInputBody: Equatable {
}

extension DeleteAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssetOutputResponse()"}
}

extension DeleteAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssetOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssetOutputResponseBody: Equatable {
}

extension DeleteAssetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePackagingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackagingConfigurationInput(id: \(String(describing: id)))"}
}

extension DeletePackagingConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePackagingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePackagingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<DeletePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackagingConfigurationOutputError>
}

public struct DeletePackagingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePackagingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<DeletePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackagingConfigurationOutputError>
}

public struct DeletePackagingConfigurationInput: Equatable {
    /// The ID of the MediaPackage VOD PackagingConfiguration resource to delete.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePackagingConfigurationInputBody: Equatable {
}

extension DeletePackagingConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePackagingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackagingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackagingConfigurationOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackagingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackagingConfigurationOutputResponse()"}
}

extension DeletePackagingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePackagingConfigurationOutputResponse: Equatable {

    public init() {}
}

struct DeletePackagingConfigurationOutputResponseBody: Equatable {
}

extension DeletePackagingConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePackagingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackagingGroupInput(id: \(String(describing: id)))"}
}

extension DeletePackagingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePackagingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePackagingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackagingGroupInput>
    public typealias MOutput = OperationOutput<DeletePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackagingGroupOutputError>
}

public struct DeletePackagingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePackagingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePackagingGroupInput>
    public typealias MOutput = OperationOutput<DeletePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePackagingGroupOutputError>
}

public struct DeletePackagingGroupInput: Equatable {
    /// The ID of the MediaPackage VOD PackagingGroup resource to delete.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeletePackagingGroupInputBody: Equatable {
}

extension DeletePackagingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePackagingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePackagingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePackagingGroupOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePackagingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePackagingGroupOutputResponse()"}
}

extension DeletePackagingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePackagingGroupOutputResponse: Equatable {

    public init() {}
}

struct DeletePackagingGroupOutputResponseBody: Equatable {
}

extension DeletePackagingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAssetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetInput(id: \(String(describing: id)))"}
}

extension DescribeAssetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAssetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInput: Equatable {
    /// The ID of an MediaPackage VOD Asset resource.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeAssetInputBody: Equatable {
}

extension DescribeAssetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAssetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssetOutputResponse(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), egressEndpoints: \(String(describing: egressEndpoints)), id: \(String(describing: id)), packagingGroupId: \(String(describing: packagingGroupId)), resourceId: \(String(describing: resourceId)), sourceArn: \(String(describing: sourceArn)), sourceRoleArn: \(String(describing: sourceRoleArn)), tags: \(String(describing: tags)))"}
}

extension DescribeAssetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdAt = output.createdAt
            self.egressEndpoints = output.egressEndpoints
            self.id = output.id
            self.packagingGroupId = output.packagingGroupId
            self.resourceId = output.resourceId
            self.sourceArn = output.sourceArn
            self.sourceRoleArn = output.sourceRoleArn
            self.tags = output.tags
        } else {
            self.arn = nil
            self.createdAt = nil
            self.egressEndpoints = nil
            self.id = nil
            self.packagingGroupId = nil
            self.resourceId = nil
            self.sourceArn = nil
            self.sourceRoleArn = nil
            self.tags = nil
        }
    }
}

public struct DescribeAssetOutputResponse: Equatable {
    /// The ARN of the Asset.
    public let arn: String?
    /// The time the Asset was initially submitted for Ingest.
    public let createdAt: String?
    /// The list of egress endpoints available for the Asset.
    public let egressEndpoints: [EgressEndpoint]?
    /// The unique identifier for the Asset.
    public let id: String?
    /// The ID of the PackagingGroup for the Asset.
    public let packagingGroupId: String?
    /// The resource ID to include in SPEKE key requests.
    public let resourceId: String?
    /// ARN of the source object in S3.
    public let sourceArn: String?
    /// The IAM role_arn used to access the source S3 bucket.
    public let sourceRoleArn: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        createdAt: String? = nil,
        egressEndpoints: [EgressEndpoint]? = nil,
        id: String? = nil,
        packagingGroupId: String? = nil,
        resourceId: String? = nil,
        sourceArn: String? = nil,
        sourceRoleArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.egressEndpoints = egressEndpoints
        self.id = id
        self.packagingGroupId = packagingGroupId
        self.resourceId = resourceId
        self.sourceArn = sourceArn
        self.sourceRoleArn = sourceRoleArn
        self.tags = tags
    }
}

struct DescribeAssetOutputResponseBody: Equatable {
    public let arn: String?
    public let createdAt: String?
    public let egressEndpoints: [EgressEndpoint]?
    public let id: String?
    public let packagingGroupId: String?
    public let resourceId: String?
    public let sourceArn: String?
    public let sourceRoleArn: String?
    public let tags: [String:String]?
}

extension DescribeAssetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case egressEndpoints = "egressEndpoints"
        case id = "id"
        case packagingGroupId = "packagingGroupId"
        case resourceId = "resourceId"
        case sourceArn = "sourceArn"
        case sourceRoleArn = "sourceRoleArn"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let egressEndpointsContainer = try containerValues.decodeIfPresent([EgressEndpoint?].self, forKey: .egressEndpoints)
        var egressEndpointsDecoded0:[EgressEndpoint]? = nil
        if let egressEndpointsContainer = egressEndpointsContainer {
            egressEndpointsDecoded0 = [EgressEndpoint]()
            for structure0 in egressEndpointsContainer {
                if let structure0 = structure0 {
                    egressEndpointsDecoded0?.append(structure0)
                }
            }
        }
        egressEndpoints = egressEndpointsDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceRoleArn)
        sourceRoleArn = sourceRoleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribePackagingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackagingConfigurationInput(id: \(String(describing: id)))"}
}

extension DescribePackagingConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePackagingConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePackagingConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackagingConfigurationOutputError>
}

public struct DescribePackagingConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePackagingConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackagingConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackagingConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackagingConfigurationInput>
    public typealias MOutput = OperationOutput<DescribePackagingConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackagingConfigurationOutputError>
}

public struct DescribePackagingConfigurationInput: Equatable {
    /// The ID of a MediaPackage VOD PackagingConfiguration resource.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribePackagingConfigurationInputBody: Equatable {
}

extension DescribePackagingConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePackagingConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackagingConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackagingConfigurationOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackagingConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackagingConfigurationOutputResponse(arn: \(String(describing: arn)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), mssPackage: \(String(describing: mssPackage)), packagingGroupId: \(String(describing: packagingGroupId)), tags: \(String(describing: tags)))"}
}

extension DescribePackagingConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePackagingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.cmafPackage = output.cmafPackage
            self.dashPackage = output.dashPackage
            self.hlsPackage = output.hlsPackage
            self.id = output.id
            self.mssPackage = output.mssPackage
            self.packagingGroupId = output.packagingGroupId
            self.tags = output.tags
        } else {
            self.arn = nil
            self.cmafPackage = nil
            self.dashPackage = nil
            self.hlsPackage = nil
            self.id = nil
            self.mssPackage = nil
            self.packagingGroupId = nil
            self.tags = nil
        }
    }
}

public struct DescribePackagingConfigurationOutputResponse: Equatable {
    /// The ARN of the PackagingConfiguration.
    public let arn: String?
    /// A CMAF packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the PackagingConfiguration.
    public let id: String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public let mssPackage: MssPackage?
    /// The ID of a PackagingGroup.
    public let packagingGroupId: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        mssPackage: MssPackage? = nil,
        packagingGroupId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

struct DescribePackagingConfigurationOutputResponseBody: Equatable {
    public let arn: String?
    public let cmafPackage: CmafPackage?
    public let dashPackage: DashPackage?
    public let hlsPackage: HlsPackage?
    public let id: String?
    public let mssPackage: MssPackage?
    public let packagingGroupId: String?
    public let tags: [String:String]?
}

extension DescribePackagingConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DescribePackagingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackagingGroupInput(id: \(String(describing: id)))"}
}

extension DescribePackagingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribePackagingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePackagingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackagingGroupInput>
    public typealias MOutput = OperationOutput<DescribePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackagingGroupOutputError>
}

public struct DescribePackagingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePackagingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePackagingGroupInput>
    public typealias MOutput = OperationOutput<DescribePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePackagingGroupOutputError>
}

public struct DescribePackagingGroupInput: Equatable {
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DescribePackagingGroupInputBody: Equatable {
}

extension DescribePackagingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribePackagingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePackagingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePackagingGroupOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePackagingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePackagingGroupOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), domainName: \(String(describing: domainName)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension DescribePackagingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct DescribePackagingGroupOutputResponse: Equatable {
    /// The ARN of the PackagingGroup.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public let domainName: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        domainName: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct DescribePackagingGroupOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let domainName: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let id: String?
    public let tags: [String:String]?
}

extension DescribePackagingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension EgressAccessLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logGroupName = "logGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logGroupName = logGroupName {
            try encodeContainer.encode(logGroupName, forKey: .logGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupName)
        logGroupName = logGroupNameDecoded
    }
}

extension EgressAccessLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EgressAccessLogs(logGroupName: \(String(describing: logGroupName)))"}
}

/// Configure egress access logging.
public struct EgressAccessLogs: Equatable {
    /// Customize the log group name.
    public let logGroupName: String?

    public init (
        logGroupName: String? = nil
    )
    {
        self.logGroupName = logGroupName
    }
}

extension EgressEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case packagingConfigurationId = "packagingConfigurationId"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let packagingConfigurationId = packagingConfigurationId {
            try encodeContainer.encode(packagingConfigurationId, forKey: .packagingConfigurationId)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packagingConfigurationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingConfigurationId)
        packagingConfigurationId = packagingConfigurationIdDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension EgressEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EgressEndpoint(packagingConfigurationId: \(String(describing: packagingConfigurationId)), url: \(String(describing: url)))"}
}

/// The endpoint URL used to access an Asset using one PackagingConfiguration.
public struct EgressEndpoint: Equatable {
    /// The ID of the PackagingConfiguration being applied to the Asset.
    public let packagingConfigurationId: String?
    /// The URL of the parent manifest for the repackaged Asset.
    public let url: String?

    public init (
        packagingConfigurationId: String? = nil,
        url: String? = nil
    )
    {
        self.packagingConfigurationId = packagingConfigurationId
        self.url = url
    }
}

public enum EncryptionMethod {
    case aes128
    case sampleAes
    case sdkUnknown(String)
}

extension EncryptionMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionMethod] {
        return [
            .aes128,
            .sampleAes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aes128: return "AES_128"
        case .sampleAes: return "SAMPLE_AES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionMethod(rawValue: rawValue) ?? EncryptionMethod.sdkUnknown(rawValue)
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client is not authorized to access the requested resource.
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HlsEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constantInitializationVector = "constantInitializationVector"
        case encryptionMethod = "encryptionMethod"
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constantInitializationVector = constantInitializationVector {
            try encodeContainer.encode(constantInitializationVector, forKey: .constantInitializationVector)
        }
        if let encryptionMethod = encryptionMethod {
            try encodeContainer.encode(encryptionMethod.rawValue, forKey: .encryptionMethod)
        }
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constantInitializationVectorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .constantInitializationVector)
        constantInitializationVector = constantInitializationVectorDecoded
        let encryptionMethodDecoded = try containerValues.decodeIfPresent(EncryptionMethod.self, forKey: .encryptionMethod)
        encryptionMethod = encryptionMethodDecoded
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension HlsEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsEncryption(constantInitializationVector: \(String(describing: constantInitializationVector)), encryptionMethod: \(String(describing: encryptionMethod)), spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// An HTTP Live Streaming (HLS) encryption configuration.
public struct HlsEncryption: Equatable {
    /// A constant initialization vector for encryption (optional).
    /// When not specified the initialization vector will be periodically rotated.
    public let constantInitializationVector: String?
    /// The encryption method to use.
    public let encryptionMethod: EncryptionMethod?
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        constantInitializationVector: String? = nil,
        encryptionMethod: EncryptionMethod? = nil,
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.constantInitializationVector = constantInitializationVector
        self.encryptionMethod = encryptionMethod
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension HlsManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case includeIframeOnlyStream = "includeIframeOnlyStream"
        case manifestName = "manifestName"
        case programDateTimeIntervalSeconds = "programDateTimeIntervalSeconds"
        case repeatExtXKey = "repeatExtXKey"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            try encodeContainer.encode(adMarkers.rawValue, forKey: .adMarkers)
        }
        if includeIframeOnlyStream != false {
            try encodeContainer.encode(includeIframeOnlyStream, forKey: .includeIframeOnlyStream)
        }
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if programDateTimeIntervalSeconds != 0 {
            try encodeContainer.encode(programDateTimeIntervalSeconds, forKey: .programDateTimeIntervalSeconds)
        }
        if repeatExtXKey != false {
            try encodeContainer.encode(repeatExtXKey, forKey: .repeatExtXKey)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersDecoded = try containerValues.decodeIfPresent(AdMarkers.self, forKey: .adMarkers)
        adMarkers = adMarkersDecoded
        let includeIframeOnlyStreamDecoded = try containerValues.decode(Bool.self, forKey: .includeIframeOnlyStream)
        includeIframeOnlyStream = includeIframeOnlyStreamDecoded
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let programDateTimeIntervalSecondsDecoded = try containerValues.decode(Int.self, forKey: .programDateTimeIntervalSeconds)
        programDateTimeIntervalSeconds = programDateTimeIntervalSecondsDecoded
        let repeatExtXKeyDecoded = try containerValues.decode(Bool.self, forKey: .repeatExtXKey)
        repeatExtXKey = repeatExtXKeyDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension HlsManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsManifest(adMarkers: \(String(describing: adMarkers)), includeIframeOnlyStream: \(String(describing: includeIframeOnlyStream)), manifestName: \(String(describing: manifestName)), programDateTimeIntervalSeconds: \(String(describing: programDateTimeIntervalSeconds)), repeatExtXKey: \(String(describing: repeatExtXKey)), streamSelection: \(String(describing: streamSelection)))"}
}

/// An HTTP Live Streaming (HLS) manifest configuration.
public struct HlsManifest: Equatable {
    /// This setting controls how ad markers are included in the packaged OriginEndpoint.
    /// "NONE" will omit all SCTE-35 ad markers from the output.
    /// "PASSTHROUGH" causes the manifest to contain a copy of the SCTE-35 ad
    /// markers (comments) taken directly from the input HTTP Live Streaming (HLS) manifest.
    /// "SCTE35_ENHANCED" generates ad markers and blackout tags based on SCTE-35
    /// messages in the input source.
    public let adMarkers: AdMarkers?
    /// When enabled, an I-Frame only stream will be included in the output.
    public let includeIframeOnlyStream: Bool
    /// An optional string to include in the name of the manifest.
    public let manifestName: String?
    /// The interval (in seconds) between each EXT-X-PROGRAM-DATE-TIME tag
    /// inserted into manifests. Additionally, when an interval is specified
    /// ID3Timed Metadata messages will be generated every 5 seconds using the
    /// ingest time of the content.
    /// If the interval is not specified, or set to 0, then
    /// no EXT-X-PROGRAM-DATE-TIME tags will be inserted into manifests and no
    /// ID3Timed Metadata messages will be generated. Note that irrespective
    /// of this parameter, if any ID3 Timed Metadata is found in HTTP Live Streaming (HLS) input,
    /// it will be passed through to HLS output.
    public let programDateTimeIntervalSeconds: Int
    /// When enabled, the EXT-X-KEY tag will be repeated in output manifests.
    public let repeatExtXKey: Bool
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        adMarkers: AdMarkers? = nil,
        includeIframeOnlyStream: Bool = false,
        manifestName: String? = nil,
        programDateTimeIntervalSeconds: Int = 0,
        repeatExtXKey: Bool = false,
        streamSelection: StreamSelection? = nil
    )
    {
        self.adMarkers = adMarkers
        self.includeIframeOnlyStream = includeIframeOnlyStream
        self.manifestName = manifestName
        self.programDateTimeIntervalSeconds = programDateTimeIntervalSeconds
        self.repeatExtXKey = repeatExtXKey
        self.streamSelection = streamSelection
    }
}

extension HlsPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case hlsManifests = "hlsManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
        case useAudioRenditionGroup = "useAudioRenditionGroup"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let hlsManifests = hlsManifests {
            var hlsManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hlsManifests)
            for __listofhlsmanifest0 in hlsManifests {
                try hlsManifestsContainer.encode(__listofhlsmanifest0)
            }
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
        if useAudioRenditionGroup != false {
            try encodeContainer.encode(useAudioRenditionGroup, forKey: .useAudioRenditionGroup)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(HlsEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let hlsManifestsContainer = try containerValues.decodeIfPresent([HlsManifest?].self, forKey: .hlsManifests)
        var hlsManifestsDecoded0:[HlsManifest]? = nil
        if let hlsManifestsContainer = hlsManifestsContainer {
            hlsManifestsDecoded0 = [HlsManifest]()
            for structure0 in hlsManifestsContainer {
                if let structure0 = structure0 {
                    hlsManifestsDecoded0?.append(structure0)
                }
            }
        }
        hlsManifests = hlsManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
        let useAudioRenditionGroupDecoded = try containerValues.decode(Bool.self, forKey: .useAudioRenditionGroup)
        useAudioRenditionGroup = useAudioRenditionGroupDecoded
    }
}

extension HlsPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HlsPackage(encryption: \(String(describing: encryption)), hlsManifests: \(String(describing: hlsManifests)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)), useAudioRenditionGroup: \(String(describing: useAudioRenditionGroup)))"}
}

/// An HTTP Live Streaming (HLS) packaging configuration.
public struct HlsPackage: Equatable {
    /// An HTTP Live Streaming (HLS) encryption configuration.
    public let encryption: HlsEncryption?
    /// A list of HLS manifest configurations.
    public let hlsManifests: [HlsManifest]?
    /// Duration (in seconds) of each fragment. Actual fragments will be
    /// rounded to the nearest multiple of the source fragment duration.
    public let segmentDurationSeconds: Int
    /// When enabled, audio streams will be placed in rendition groups in the output.
    public let useAudioRenditionGroup: Bool

    public init (
        encryption: HlsEncryption? = nil,
        hlsManifests: [HlsManifest]? = nil,
        segmentDurationSeconds: Int = 0,
        useAudioRenditionGroup: Bool = false
    )
    {
        self.encryption = encryption
        self.hlsManifests = hlsManifests
        self.segmentDurationSeconds = segmentDurationSeconds
        self.useAudioRenditionGroup = useAudioRenditionGroup
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAssetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), packagingGroupId: \(String(describing: packagingGroupId)))"}
}

extension ListAssetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetsInput>
    public typealias MOutput = OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetsOutputError>
}

public struct ListAssetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let packagingGroupId = input.operationInput.packagingGroupId {
            let packagingGroupIdQueryItem = URLQueryItem(name: "packagingGroupId".urlPercentEncoding(), value: String(packagingGroupId).urlPercentEncoding())
            input.builder.withQueryItem(packagingGroupIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssetsInput>
    public typealias MOutput = OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssetsOutputError>
}

public struct ListAssetsInput: Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?
    /// Returns Assets associated with the specified PackagingGroup.
    public let packagingGroupId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        packagingGroupId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packagingGroupId = packagingGroupId
    }
}

struct ListAssetsInputBody: Equatable {
}

extension ListAssetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssetsOutputResponse(assets: \(String(describing: assets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assets = output.assets
            self.nextToken = output.nextToken
        } else {
            self.assets = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutputResponse: Equatable {
    /// A list of MediaPackage VOD Asset resources.
    public let assets: [AssetShallow]?
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?

    public init (
        assets: [AssetShallow]? = nil,
        nextToken: String? = nil
    )
    {
        self.assets = assets
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputResponseBody: Equatable {
    public let assets: [AssetShallow]?
    public let nextToken: String?
}

extension ListAssetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assets = "assets"
        case nextToken = "nextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetsContainer = try containerValues.decodeIfPresent([AssetShallow?].self, forKey: .assets)
        var assetsDecoded0:[AssetShallow]? = nil
        if let assetsContainer = assetsContainer {
            assetsDecoded0 = [AssetShallow]()
            for structure0 in assetsContainer {
                if let structure0 = structure0 {
                    assetsDecoded0?.append(structure0)
                }
            }
        }
        assets = assetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPackagingConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagingConfigurationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), packagingGroupId: \(String(describing: packagingGroupId)))"}
}

extension ListPackagingConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackagingConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackagingConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListPackagingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagingConfigurationsOutputError>
}

public struct ListPackagingConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackagingConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagingConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagingConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let packagingGroupId = input.operationInput.packagingGroupId {
            let packagingGroupIdQueryItem = URLQueryItem(name: "packagingGroupId".urlPercentEncoding(), value: String(packagingGroupId).urlPercentEncoding())
            input.builder.withQueryItem(packagingGroupIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagingConfigurationsInput>
    public typealias MOutput = OperationOutput<ListPackagingConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagingConfigurationsOutputError>
}

public struct ListPackagingConfigurationsInput: Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?
    /// Returns MediaPackage VOD PackagingConfigurations associated with the specified PackagingGroup.
    public let packagingGroupId: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        packagingGroupId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.packagingGroupId = packagingGroupId
    }
}

struct ListPackagingConfigurationsInputBody: Equatable {
}

extension ListPackagingConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackagingConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagingConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagingConfigurationsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagingConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagingConfigurationsOutputResponse(nextToken: \(String(describing: nextToken)), packagingConfigurations: \(String(describing: packagingConfigurations)))"}
}

extension ListPackagingConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackagingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.packagingConfigurations = output.packagingConfigurations
        } else {
            self.nextToken = nil
            self.packagingConfigurations = nil
        }
    }
}

public struct ListPackagingConfigurationsOutputResponse: Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?
    /// A list of MediaPackage VOD PackagingConfiguration resources.
    public let packagingConfigurations: [PackagingConfiguration]?

    public init (
        nextToken: String? = nil,
        packagingConfigurations: [PackagingConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.packagingConfigurations = packagingConfigurations
    }
}

struct ListPackagingConfigurationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let packagingConfigurations: [PackagingConfiguration]?
}

extension ListPackagingConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case packagingConfigurations = "packagingConfigurations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let packagingConfigurationsContainer = try containerValues.decodeIfPresent([PackagingConfiguration?].self, forKey: .packagingConfigurations)
        var packagingConfigurationsDecoded0:[PackagingConfiguration]? = nil
        if let packagingConfigurationsContainer = packagingConfigurationsContainer {
            packagingConfigurationsDecoded0 = [PackagingConfiguration]()
            for structure0 in packagingConfigurationsContainer {
                if let structure0 = structure0 {
                    packagingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        packagingConfigurations = packagingConfigurationsDecoded0
    }
}

extension ListPackagingGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagingGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPackagingGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPackagingGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPackagingGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagingGroupsInput>
    public typealias MOutput = OperationOutput<ListPackagingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagingGroupsOutputError>
}

public struct ListPackagingGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPackagingGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPackagingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPackagingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPackagingGroupsInput>
    public typealias MOutput = OperationOutput<ListPackagingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPackagingGroupsOutputError>
}

public struct ListPackagingGroupsInput: Equatable {
    /// Upper bound on number of records to return.
    public let maxResults: Int
    /// A token used to resume pagination from the end of a previous request.
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPackagingGroupsInputBody: Equatable {
}

extension ListPackagingGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPackagingGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPackagingGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPackagingGroupsOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPackagingGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPackagingGroupsOutputResponse(nextToken: \(String(describing: nextToken)), packagingGroups: \(String(describing: packagingGroups)))"}
}

extension ListPackagingGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPackagingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.packagingGroups = output.packagingGroups
        } else {
            self.nextToken = nil
            self.packagingGroups = nil
        }
    }
}

public struct ListPackagingGroupsOutputResponse: Equatable {
    /// A token that can be used to resume pagination from the end of the collection.
    public let nextToken: String?
    /// A list of MediaPackage VOD PackagingGroup resources.
    public let packagingGroups: [PackagingGroup]?

    public init (
        nextToken: String? = nil,
        packagingGroups: [PackagingGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.packagingGroups = packagingGroups
    }
}

struct ListPackagingGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let packagingGroups: [PackagingGroup]?
}

extension ListPackagingGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "nextToken"
        case packagingGroups = "packagingGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let packagingGroupsContainer = try containerValues.decodeIfPresent([PackagingGroup?].self, forKey: .packagingGroups)
        var packagingGroupsDecoded0:[PackagingGroup]? = nil
        if let packagingGroupsContainer = packagingGroupsContainer {
            packagingGroupsDecoded0 = [PackagingGroup]()
            for structure0 in packagingGroupsContainer {
                if let structure0 = structure0 {
                    packagingGroupsDecoded0?.append(structure0)
                }
            }
        }
        packagingGroups = packagingGroupsDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum ManifestLayout {
    case compact
    case full
    case sdkUnknown(String)
}

extension ManifestLayout : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ManifestLayout] {
        return [
            .compact,
            .full,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .compact: return "COMPACT"
        case .full: return "FULL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ManifestLayout(rawValue: rawValue) ?? ManifestLayout.sdkUnknown(rawValue)
    }
}

extension MssEncryption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case spekeKeyProvider = "spekeKeyProvider"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let spekeKeyProvider = spekeKeyProvider {
            try encodeContainer.encode(spekeKeyProvider, forKey: .spekeKeyProvider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spekeKeyProviderDecoded = try containerValues.decodeIfPresent(SpekeKeyProvider.self, forKey: .spekeKeyProvider)
        spekeKeyProvider = spekeKeyProviderDecoded
    }
}

extension MssEncryption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MssEncryption(spekeKeyProvider: \(String(describing: spekeKeyProvider)))"}
}

/// A Microsoft Smooth Streaming (MSS) encryption configuration.
public struct MssEncryption: Equatable {
    /// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
    public let spekeKeyProvider: SpekeKeyProvider?

    public init (
        spekeKeyProvider: SpekeKeyProvider? = nil
    )
    {
        self.spekeKeyProvider = spekeKeyProvider
    }
}

extension MssManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manifestName = "manifestName"
        case streamSelection = "streamSelection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manifestName = manifestName {
            try encodeContainer.encode(manifestName, forKey: .manifestName)
        }
        if let streamSelection = streamSelection {
            try encodeContainer.encode(streamSelection, forKey: .streamSelection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestName)
        manifestName = manifestNameDecoded
        let streamSelectionDecoded = try containerValues.decodeIfPresent(StreamSelection.self, forKey: .streamSelection)
        streamSelection = streamSelectionDecoded
    }
}

extension MssManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MssManifest(manifestName: \(String(describing: manifestName)), streamSelection: \(String(describing: streamSelection)))"}
}

/// A Microsoft Smooth Streaming (MSS) manifest configuration.
public struct MssManifest: Equatable {
    /// An optional string to include in the name of the manifest.
    public let manifestName: String?
    /// A StreamSelection configuration.
    public let streamSelection: StreamSelection?

    public init (
        manifestName: String? = nil,
        streamSelection: StreamSelection? = nil
    )
    {
        self.manifestName = manifestName
        self.streamSelection = streamSelection
    }
}

extension MssPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryption = "encryption"
        case mssManifests = "mssManifests"
        case segmentDurationSeconds = "segmentDurationSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let mssManifests = mssManifests {
            var mssManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mssManifests)
            for __listofmssmanifest0 in mssManifests {
                try mssManifestsContainer.encode(__listofmssmanifest0)
            }
        }
        if segmentDurationSeconds != 0 {
            try encodeContainer.encode(segmentDurationSeconds, forKey: .segmentDurationSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionDecoded = try containerValues.decodeIfPresent(MssEncryption.self, forKey: .encryption)
        encryption = encryptionDecoded
        let mssManifestsContainer = try containerValues.decodeIfPresent([MssManifest?].self, forKey: .mssManifests)
        var mssManifestsDecoded0:[MssManifest]? = nil
        if let mssManifestsContainer = mssManifestsContainer {
            mssManifestsDecoded0 = [MssManifest]()
            for structure0 in mssManifestsContainer {
                if let structure0 = structure0 {
                    mssManifestsDecoded0?.append(structure0)
                }
            }
        }
        mssManifests = mssManifestsDecoded0
        let segmentDurationSecondsDecoded = try containerValues.decode(Int.self, forKey: .segmentDurationSeconds)
        segmentDurationSeconds = segmentDurationSecondsDecoded
    }
}

extension MssPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MssPackage(encryption: \(String(describing: encryption)), mssManifests: \(String(describing: mssManifests)), segmentDurationSeconds: \(String(describing: segmentDurationSeconds)))"}
}

/// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
public struct MssPackage: Equatable {
    /// A Microsoft Smooth Streaming (MSS) encryption configuration.
    public let encryption: MssEncryption?
    /// A list of MSS manifest configurations.
    public let mssManifests: [MssManifest]?
    /// The duration (in seconds) of each segment.
    public let segmentDurationSeconds: Int

    public init (
        encryption: MssEncryption? = nil,
        mssManifests: [MssManifest]? = nil,
        segmentDurationSeconds: Int = 0
    )
    {
        self.encryption = encryption
        self.mssManifests = mssManifests
        self.segmentDurationSeconds = segmentDurationSeconds
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist.
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PackagingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case cmafPackage = "cmafPackage"
        case dashPackage = "dashPackage"
        case hlsPackage = "hlsPackage"
        case id = "id"
        case mssPackage = "mssPackage"
        case packagingGroupId = "packagingGroupId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let cmafPackage = cmafPackage {
            try encodeContainer.encode(cmafPackage, forKey: .cmafPackage)
        }
        if let dashPackage = dashPackage {
            try encodeContainer.encode(dashPackage, forKey: .dashPackage)
        }
        if let hlsPackage = hlsPackage {
            try encodeContainer.encode(hlsPackage, forKey: .hlsPackage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let mssPackage = mssPackage {
            try encodeContainer.encode(mssPackage, forKey: .mssPackage)
        }
        if let packagingGroupId = packagingGroupId {
            try encodeContainer.encode(packagingGroupId, forKey: .packagingGroupId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let cmafPackageDecoded = try containerValues.decodeIfPresent(CmafPackage.self, forKey: .cmafPackage)
        cmafPackage = cmafPackageDecoded
        let dashPackageDecoded = try containerValues.decodeIfPresent(DashPackage.self, forKey: .dashPackage)
        dashPackage = dashPackageDecoded
        let hlsPackageDecoded = try containerValues.decodeIfPresent(HlsPackage.self, forKey: .hlsPackage)
        hlsPackage = hlsPackageDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let mssPackageDecoded = try containerValues.decodeIfPresent(MssPackage.self, forKey: .mssPackage)
        mssPackage = mssPackageDecoded
        let packagingGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packagingGroupId)
        packagingGroupId = packagingGroupIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PackagingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackagingConfiguration(arn: \(String(describing: arn)), cmafPackage: \(String(describing: cmafPackage)), dashPackage: \(String(describing: dashPackage)), hlsPackage: \(String(describing: hlsPackage)), id: \(String(describing: id)), mssPackage: \(String(describing: mssPackage)), packagingGroupId: \(String(describing: packagingGroupId)), tags: \(String(describing: tags)))"}
}

/// A MediaPackage VOD PackagingConfiguration resource.
public struct PackagingConfiguration: Equatable {
    /// The ARN of the PackagingConfiguration.
    public let arn: String?
    /// A CMAF packaging configuration.
    public let cmafPackage: CmafPackage?
    /// A Dynamic Adaptive Streaming over HTTP (DASH) packaging configuration.
    public let dashPackage: DashPackage?
    /// An HTTP Live Streaming (HLS) packaging configuration.
    public let hlsPackage: HlsPackage?
    /// The ID of the PackagingConfiguration.
    public let id: String?
    /// A Microsoft Smooth Streaming (MSS) PackagingConfiguration.
    public let mssPackage: MssPackage?
    /// The ID of a PackagingGroup.
    public let packagingGroupId: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        cmafPackage: CmafPackage? = nil,
        dashPackage: DashPackage? = nil,
        hlsPackage: HlsPackage? = nil,
        id: String? = nil,
        mssPackage: MssPackage? = nil,
        packagingGroupId: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.cmafPackage = cmafPackage
        self.dashPackage = dashPackage
        self.hlsPackage = hlsPackage
        self.id = id
        self.mssPackage = mssPackage
        self.packagingGroupId = packagingGroupId
        self.tags = tags
    }
}

extension PackagingGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let egressAccessLogs = egressAccessLogs {
            try encodeContainer.encode(egressAccessLogs, forKey: .egressAccessLogs)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PackagingGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackagingGroup(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), domainName: \(String(describing: domainName)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

/// A MediaPackage VOD PackagingGroup resource.
public struct PackagingGroup: Equatable {
    /// The ARN of the PackagingGroup.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public let domainName: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        domainName: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

public enum Profile {
    case hbbtv15
    case `none`
    case sdkUnknown(String)
}

extension Profile : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Profile] {
        return [
            .hbbtv15,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hbbtv15: return "HBBTV_1_5"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Profile(rawValue: rawValue) ?? Profile.sdkUnknown(rawValue)
    }
}

public enum SegmentTemplateFormat {
    case numberWithDuration
    case numberWithTimeline
    case timeWithTimeline
    case sdkUnknown(String)
}

extension SegmentTemplateFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SegmentTemplateFormat] {
        return [
            .numberWithDuration,
            .numberWithTimeline,
            .timeWithTimeline,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .numberWithDuration: return "NUMBER_WITH_DURATION"
        case .numberWithTimeline: return "NUMBER_WITH_TIMELINE"
        case .timeWithTimeline: return "TIME_WITH_TIMELINE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SegmentTemplateFormat(rawValue: rawValue) ?? SegmentTemplateFormat.sdkUnknown(rawValue)
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SpekeKeyProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "roleArn"
        case systemIds = "systemIds"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let systemIds = systemIds {
            var systemIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .systemIds)
            for __listof__string0 in systemIds {
                try systemIdsContainer.encode(__listof__string0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let systemIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .systemIds)
        var systemIdsDecoded0:[String]? = nil
        if let systemIdsContainer = systemIdsContainer {
            systemIdsDecoded0 = [String]()
            for string0 in systemIdsContainer {
                if let string0 = string0 {
                    systemIdsDecoded0?.append(string0)
                }
            }
        }
        systemIds = systemIdsDecoded0
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension SpekeKeyProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SpekeKeyProvider(roleArn: \(String(describing: roleArn)), systemIds: \(String(describing: systemIds)), url: \(String(describing: url)))"}
}

/// A configuration for accessing an external Secure Packager and Encoder Key Exchange (SPEKE) service that will provide encryption keys.
public struct SpekeKeyProvider: Equatable {
    /// An Amazon Resource Name (ARN) of an IAM role that AWS Elemental
    /// MediaPackage will assume when accessing the key provider service.
    public let roleArn: String?
    /// The system IDs to include in key requests.
    public let systemIds: [String]?
    /// The URL of the external key provider service.
    public let url: String?

    public init (
        roleArn: String? = nil,
        systemIds: [String]? = nil,
        url: String? = nil
    )
    {
        self.roleArn = roleArn
        self.systemIds = systemIds
        self.url = url
    }
}

public enum StreamOrder {
    case original
    case videoBitrateAscending
    case videoBitrateDescending
    case sdkUnknown(String)
}

extension StreamOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StreamOrder] {
        return [
            .original,
            .videoBitrateAscending,
            .videoBitrateDescending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .original: return "ORIGINAL"
        case .videoBitrateAscending: return "VIDEO_BITRATE_ASCENDING"
        case .videoBitrateDescending: return "VIDEO_BITRATE_DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StreamOrder(rawValue: rawValue) ?? StreamOrder.sdkUnknown(rawValue)
    }
}

extension StreamSelection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxVideoBitsPerSecond = "maxVideoBitsPerSecond"
        case minVideoBitsPerSecond = "minVideoBitsPerSecond"
        case streamOrder = "streamOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxVideoBitsPerSecond != 0 {
            try encodeContainer.encode(maxVideoBitsPerSecond, forKey: .maxVideoBitsPerSecond)
        }
        if minVideoBitsPerSecond != 0 {
            try encodeContainer.encode(minVideoBitsPerSecond, forKey: .minVideoBitsPerSecond)
        }
        if let streamOrder = streamOrder {
            try encodeContainer.encode(streamOrder.rawValue, forKey: .streamOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxVideoBitsPerSecondDecoded = try containerValues.decode(Int.self, forKey: .maxVideoBitsPerSecond)
        maxVideoBitsPerSecond = maxVideoBitsPerSecondDecoded
        let minVideoBitsPerSecondDecoded = try containerValues.decode(Int.self, forKey: .minVideoBitsPerSecond)
        minVideoBitsPerSecond = minVideoBitsPerSecondDecoded
        let streamOrderDecoded = try containerValues.decodeIfPresent(StreamOrder.self, forKey: .streamOrder)
        streamOrder = streamOrderDecoded
    }
}

extension StreamSelection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StreamSelection(maxVideoBitsPerSecond: \(String(describing: maxVideoBitsPerSecond)), minVideoBitsPerSecond: \(String(describing: minVideoBitsPerSecond)), streamOrder: \(String(describing: streamOrder)))"}
}

/// A StreamSelection configuration.
public struct StreamSelection: Equatable {
    /// The maximum video bitrate (bps) to include in output.
    public let maxVideoBitsPerSecond: Int
    /// The minimum video bitrate (bps) to include in output.
    public let minVideoBitsPerSecond: Int
    /// A directive that determines the order of streams in the output.
    public let streamOrder: StreamOrder?

    public init (
        maxVideoBitsPerSecond: Int = 0,
        minVideoBitsPerSecond: Int = 0,
        streamOrder: StreamOrder? = nil
    )
    {
        self.maxVideoBitsPerSecond = maxVideoBitsPerSecond
        self.minVideoBitsPerSecond = minVideoBitsPerSecond
        self.streamOrder = streamOrder
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, __mapof__string0) in tags {
                try tagsContainer.encode(__mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    public let resourceArn: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The client has exceeded their resource or throttling limits.
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnprocessableEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessableEntityException(message: \(String(describing: message)))"}
}

extension UnprocessableEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnprocessableEntityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The parameters sent in the request are not valid.
public struct UnprocessableEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnprocessableEntityExceptionBody: Equatable {
    public let message: String?
}

extension UnprocessableEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// The Amazon Resource Name (ARN) for the resource. You can get this from the response to any request to the resource.
    public let resourceArn: String?
    /// A comma-separated list of the tag keys to remove from the resource.
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePackagingGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePackagingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackagingGroupInput>
    public typealias MOutput = OperationOutput<UpdatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackagingGroupOutputError>
}

extension UpdatePackagingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePackagingGroupInput(authorization: \(String(describing: authorization)), id: \(String(describing: id)))"}
}

extension UpdatePackagingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorization = authorization {
            try encodeContainer.encode(authorization, forKey: .authorization)
        }
    }
}

public struct UpdatePackagingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePackagingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackagingGroupInput>
    public typealias MOutput = OperationOutput<UpdatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackagingGroupOutputError>
}

public struct UpdatePackagingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePackagingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePackagingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePackagingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePackagingGroupInput>
    public typealias MOutput = OperationOutput<UpdatePackagingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePackagingGroupOutputError>
}

/// A MediaPackage VOD PackagingGroup resource configuration.
public struct UpdatePackagingGroupInput: Equatable {
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The ID of a MediaPackage VOD PackagingGroup resource.
    public let id: String?

    public init (
        authorization: Authorization? = nil,
        id: String? = nil
    )
    {
        self.authorization = authorization
        self.id = id
    }
}

struct UpdatePackagingGroupInputBody: Equatable {
    public let authorization: Authorization?
}

extension UpdatePackagingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authorization = "authorization"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
    }
}

extension UpdatePackagingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePackagingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnprocessableEntityException" : self = .unprocessableEntityException(try UnprocessableEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePackagingGroupOutputError: Equatable {
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unprocessableEntityException(UnprocessableEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePackagingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePackagingGroupOutputResponse(arn: \(String(describing: arn)), authorization: \(String(describing: authorization)), domainName: \(String(describing: domainName)), egressAccessLogs: \(String(describing: egressAccessLogs)), id: \(String(describing: id)), tags: \(String(describing: tags)))"}
}

extension UpdatePackagingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdatePackagingGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.authorization = output.authorization
            self.domainName = output.domainName
            self.egressAccessLogs = output.egressAccessLogs
            self.id = output.id
            self.tags = output.tags
        } else {
            self.arn = nil
            self.authorization = nil
            self.domainName = nil
            self.egressAccessLogs = nil
            self.id = nil
            self.tags = nil
        }
    }
}

public struct UpdatePackagingGroupOutputResponse: Equatable {
    /// The ARN of the PackagingGroup.
    public let arn: String?
    /// CDN Authorization credentials
    public let authorization: Authorization?
    /// The fully qualified domain name for Assets in the PackagingGroup.
    public let domainName: String?
    /// Configure egress access logging.
    public let egressAccessLogs: EgressAccessLogs?
    /// The ID of the PackagingGroup.
    public let id: String?
    /// A collection of tags associated with a resource
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        authorization: Authorization? = nil,
        domainName: String? = nil,
        egressAccessLogs: EgressAccessLogs? = nil,
        id: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.authorization = authorization
        self.domainName = domainName
        self.egressAccessLogs = egressAccessLogs
        self.id = id
        self.tags = tags
    }
}

struct UpdatePackagingGroupOutputResponseBody: Equatable {
    public let arn: String?
    public let authorization: Authorization?
    public let domainName: String?
    public let egressAccessLogs: EgressAccessLogs?
    public let id: String?
    public let tags: [String:String]?
}

extension UpdatePackagingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "arn"
        case authorization = "authorization"
        case domainName = "domainName"
        case egressAccessLogs = "egressAccessLogs"
        case id = "id"
        case tags = "tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let authorizationDecoded = try containerValues.decodeIfPresent(Authorization.self, forKey: .authorization)
        authorization = authorizationDecoded
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let egressAccessLogsDecoded = try containerValues.decodeIfPresent(EgressAccessLogs.self, forKey: .egressAccessLogs)
        egressAccessLogs = egressAccessLogsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum __PeriodTriggersElement {
    case ads
    case sdkUnknown(String)
}

extension __PeriodTriggersElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [__PeriodTriggersElement] {
        return [
            .ads,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ads: return "ADS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = __PeriodTriggersElement(rawValue: rawValue) ?? __PeriodTriggersElement.sdkUnknown(rawValue)
    }
}
