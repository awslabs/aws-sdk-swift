// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension RdsDataClientTypes.ArrayValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case booleanvalues = "booleanValues"
        case doublevalues = "doubleValues"
        case longvalues = "longValues"
        case sdkUnknown
        case stringvalues = "stringValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for arrayofarray0 in arrayvalues {
                    try arrayvaluesContainer.encode(arrayofarray0)
                }
            case let .booleanvalues(booleanvalues):
                var booleanvaluesContainer = container.nestedUnkeyedContainer(forKey: .booleanvalues)
                for booleanarray0 in booleanvalues {
                    try booleanvaluesContainer.encode(booleanarray0)
                }
            case let .doublevalues(doublevalues):
                var doublevaluesContainer = container.nestedUnkeyedContainer(forKey: .doublevalues)
                for doublearray0 in doublevalues {
                    try doublevaluesContainer.encode(doublearray0)
                }
            case let .longvalues(longvalues):
                var longvaluesContainer = container.nestedUnkeyedContainer(forKey: .longvalues)
                for longarray0 in longvalues {
                    try longvaluesContainer.encode(longarray0)
                }
            case let .stringvalues(stringvalues):
                var stringvaluesContainer = container.nestedUnkeyedContainer(forKey: .stringvalues)
                for stringarray0 in stringvalues {
                    try stringvaluesContainer.encode(stringarray0)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let booleanvaluesContainer = try values.decodeIfPresent([Swift.Bool?].self, forKey: .booleanvalues)
        var booleanvaluesDecoded0:[Swift.Bool]? = nil
        if let booleanvaluesContainer = booleanvaluesContainer {
            booleanvaluesDecoded0 = [Swift.Bool]()
            for boolean0 in booleanvaluesContainer {
                if let boolean0 = boolean0 {
                    booleanvaluesDecoded0?.append(boolean0)
                }
            }
        }
        if let booleanvalues = booleanvaluesDecoded0 {
            self = .booleanvalues(booleanvalues)
            return
        }
        let longvaluesContainer = try values.decodeIfPresent([Swift.Int?].self, forKey: .longvalues)
        var longvaluesDecoded0:[Swift.Int]? = nil
        if let longvaluesContainer = longvaluesContainer {
            longvaluesDecoded0 = [Swift.Int]()
            for long0 in longvaluesContainer {
                if let long0 = long0 {
                    longvaluesDecoded0?.append(long0)
                }
            }
        }
        if let longvalues = longvaluesDecoded0 {
            self = .longvalues(longvalues)
            return
        }
        let doublevaluesContainer = try values.decodeIfPresent([Swift.Double?].self, forKey: .doublevalues)
        var doublevaluesDecoded0:[Swift.Double]? = nil
        if let doublevaluesContainer = doublevaluesContainer {
            doublevaluesDecoded0 = [Swift.Double]()
            for double0 in doublevaluesContainer {
                if let double0 = double0 {
                    doublevaluesDecoded0?.append(double0)
                }
            }
        }
        if let doublevalues = doublevaluesDecoded0 {
            self = .doublevalues(doublevalues)
            return
        }
        let stringvaluesContainer = try values.decodeIfPresent([Swift.String?].self, forKey: .stringvalues)
        var stringvaluesDecoded0:[Swift.String]? = nil
        if let stringvaluesContainer = stringvaluesContainer {
            stringvaluesDecoded0 = [Swift.String]()
            for string0 in stringvaluesContainer {
                if let string0 = string0 {
                    stringvaluesDecoded0?.append(string0)
                }
            }
        }
        if let stringvalues = stringvaluesDecoded0 {
            self = .stringvalues(stringvalues)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RdsDataClientTypes.ArrayValue?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RdsDataClientTypes.ArrayValue]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RdsDataClientTypes.ArrayValue]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// Contains an array.
    public enum ArrayValue: Swift.Equatable {
        /// An array of Boolean values.
        case booleanvalues([Swift.Bool])
        /// An array of floating point numbers.
        case longvalues([Swift.Int])
        /// An array of integers.
        case doublevalues([Swift.Double])
        /// An array of strings.
        case stringvalues([Swift.String])
        /// An array of arrays.
        case arrayvalues([RdsDataClientTypes.ArrayValue])
        case sdkUnknown(Swift.String)
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is an error in the call or in a SQL statement.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by this BadRequestException error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let parameterSets = parameterSets {
            var parameterSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterSets)
            for sqlparametersets0 in parameterSets {
                var sqlparametersets0Container = parameterSetsContainer.nestedUnkeyedContainer()
                for sqlparameterslist1 in sqlparametersets0 {
                    try sqlparametersets0Container.encode(sqlparameterslist1)
                }
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension BatchExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchExecute"
    }
}

/// The request parameters represent the input of a SQL statement over an array of data.
public struct BatchExecuteStatementInput: Swift.Equatable {
    /// The name of the database.
    public var database: Swift.String?
    /// The parameter set for the batch operation. The SQL statement is executed as many times as the number of parameter sets provided. To execute a SQL statement with no parameters, use one of the following options:
    ///
    /// * Specify one or more empty parameter sets.
    ///
    /// * Use the ExecuteStatement operation instead of the BatchExecuteStatement operation.
    ///
    ///
    /// Array parameters are not supported.
    public var parameterSets: [[RdsDataClientTypes.SqlParameter]]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init (
        database: Swift.String? = nil,
        parameterSets: [[RdsDataClientTypes.SqlParameter]]? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.database = database
        self.parameterSets = parameterSets
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct BatchExecuteStatementInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let sql: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
    let parameterSets: [[RdsDataClientTypes.SqlParameter]]?
    let transactionId: Swift.String?
}

extension BatchExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case parameterSets
        case resourceArn
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parameterSetsContainer = try containerValues.decodeIfPresent([[RdsDataClientTypes.SqlParameter?]?].self, forKey: .parameterSets)
        var parameterSetsDecoded0:[[RdsDataClientTypes.SqlParameter]]? = nil
        if let parameterSetsContainer = parameterSetsContainer {
            parameterSetsDecoded0 = [[RdsDataClientTypes.SqlParameter]]()
            for list0 in parameterSetsContainer {
                var list0Decoded0: [RdsDataClientTypes.SqlParameter]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RdsDataClientTypes.SqlParameter]()
                    for structure1 in list0 {
                        if let structure1 = structure1 {
                            list0Decoded0?.append(structure1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    parameterSetsDecoded0?.append(list0Decoded0)
                }
            }
        }
        parameterSets = parameterSetsDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension BatchExecuteStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchExecuteStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchExecuteStatementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchExecuteStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updateResults = output.updateResults
        } else {
            self.updateResults = nil
        }
    }
}

/// The response elements represent the output of a SQL statement over an array of data.
public struct BatchExecuteStatementOutputResponse: Swift.Equatable {
    /// The execution results of each batch entry.
    public var updateResults: [RdsDataClientTypes.UpdateResult]?

    public init (
        updateResults: [RdsDataClientTypes.UpdateResult]? = nil
    )
    {
        self.updateResults = updateResults
    }
}

struct BatchExecuteStatementOutputResponseBody: Swift.Equatable {
    let updateResults: [RdsDataClientTypes.UpdateResult]?
}

extension BatchExecuteStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updateResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateResultsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.UpdateResult?].self, forKey: .updateResults)
        var updateResultsDecoded0:[RdsDataClientTypes.UpdateResult]? = nil
        if let updateResultsContainer = updateResultsContainer {
            updateResultsDecoded0 = [RdsDataClientTypes.UpdateResult]()
            for structure0 in updateResultsContainer {
                if let structure0 = structure0 {
                    updateResultsDecoded0?.append(structure0)
                }
            }
        }
        updateResults = updateResultsDecoded0
    }
}

extension BeginTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
    }
}

extension BeginTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BeginTransaction"
    }
}

/// The request parameters represent the input of a request to start a SQL transaction.
public struct BeginTransactionInput: Swift.Equatable {
    /// The name of the database.
    public var database: Swift.String?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?

    public init (
        database: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil
    )
    {
        self.database = database
        self.resourceArn = resourceArn
        self.schema = schema
        self.secretArn = secretArn
    }
}

struct BeginTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
}

extension BeginTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case database
        case resourceArn
        case schema
        case secretArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension BeginTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BeginTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BeginTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BeginTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BeginTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionId = output.transactionId
        } else {
            self.transactionId = nil
        }
    }
}

/// The response elements represent the output of a request to start a SQL transaction.
public struct BeginTransactionOutputResponse: Swift.Equatable {
    /// The transaction ID of the transaction started by the call.
    public var transactionId: Swift.String?

    public init (
        transactionId: Swift.String? = nil
    )
    {
        self.transactionId = transactionId
    }
}

struct BeginTransactionOutputResponseBody: Swift.Equatable {
    let transactionId: Swift.String?
}

extension BeginTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RdsDataClientTypes.ColumnMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayBaseColumnType
        case isAutoIncrement
        case isCaseSensitive
        case isCurrency
        case isSigned
        case label
        case name
        case nullable
        case precision
        case scale
        case schemaName
        case tableName
        case type
        case typeName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if arrayBaseColumnType != 0 {
            try encodeContainer.encode(arrayBaseColumnType, forKey: .arrayBaseColumnType)
        }
        if isAutoIncrement != false {
            try encodeContainer.encode(isAutoIncrement, forKey: .isAutoIncrement)
        }
        if isCaseSensitive != false {
            try encodeContainer.encode(isCaseSensitive, forKey: .isCaseSensitive)
        }
        if isCurrency != false {
            try encodeContainer.encode(isCurrency, forKey: .isCurrency)
        }
        if isSigned != false {
            try encodeContainer.encode(isSigned, forKey: .isSigned)
        }
        if let label = label {
            try encodeContainer.encode(label, forKey: .label)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if nullable != 0 {
            try encodeContainer.encode(nullable, forKey: .nullable)
        }
        if precision != 0 {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if scale != 0 {
            try encodeContainer.encode(scale, forKey: .scale)
        }
        if let schemaName = schemaName {
            try encodeContainer.encode(schemaName, forKey: .schemaName)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
        if type != 0 {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let typeName = typeName {
            try encodeContainer.encode(typeName, forKey: .typeName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decode(Swift.Int.self, forKey: .type)
        type = typeDecoded
        let typeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .typeName)
        typeName = typeNameDecoded
        let labelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .label)
        label = labelDecoded
        let schemaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaName)
        schemaName = schemaNameDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let isAutoIncrementDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isAutoIncrement)
        isAutoIncrement = isAutoIncrementDecoded
        let isSignedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isSigned)
        isSigned = isSignedDecoded
        let isCurrencyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCurrency)
        isCurrency = isCurrencyDecoded
        let isCaseSensitiveDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isCaseSensitive)
        isCaseSensitive = isCaseSensitiveDecoded
        let nullableDecoded = try containerValues.decode(Swift.Int.self, forKey: .nullable)
        nullable = nullableDecoded
        let precisionDecoded = try containerValues.decode(Swift.Int.self, forKey: .precision)
        precision = precisionDecoded
        let scaleDecoded = try containerValues.decode(Swift.Int.self, forKey: .scale)
        scale = scaleDecoded
        let arrayBaseColumnTypeDecoded = try containerValues.decode(Swift.Int.self, forKey: .arrayBaseColumnType)
        arrayBaseColumnType = arrayBaseColumnTypeDecoded
    }
}

extension RdsDataClientTypes {
    /// Contains the metadata for a column.
    public struct ColumnMetadata: Swift.Equatable {
        /// The type of the column.
        public var arrayBaseColumnType: Swift.Int
        /// A value that indicates whether the column increments automatically.
        public var isAutoIncrement: Swift.Bool
        /// A value that indicates whether the column is case-sensitive.
        public var isCaseSensitive: Swift.Bool
        /// A value that indicates whether the column contains currency values.
        public var isCurrency: Swift.Bool
        /// A value that indicates whether an integer column is signed.
        public var isSigned: Swift.Bool
        /// The label for the column.
        public var label: Swift.String?
        /// The name of the column.
        public var name: Swift.String?
        /// A value that indicates whether the column is nullable.
        public var nullable: Swift.Int
        /// The precision value of a decimal number column.
        public var precision: Swift.Int
        /// The scale value of a decimal number column.
        public var scale: Swift.Int
        /// The name of the schema that owns the table that includes the column.
        public var schemaName: Swift.String?
        /// The name of the table that includes the column.
        public var tableName: Swift.String?
        /// The type of the column.
        public var type: Swift.Int
        /// The database-specific data type of the column.
        public var typeName: Swift.String?

        public init (
            arrayBaseColumnType: Swift.Int = 0,
            isAutoIncrement: Swift.Bool = false,
            isCaseSensitive: Swift.Bool = false,
            isCurrency: Swift.Bool = false,
            isSigned: Swift.Bool = false,
            label: Swift.String? = nil,
            name: Swift.String? = nil,
            nullable: Swift.Int = 0,
            precision: Swift.Int = 0,
            scale: Swift.Int = 0,
            schemaName: Swift.String? = nil,
            tableName: Swift.String? = nil,
            type: Swift.Int = 0,
            typeName: Swift.String? = nil
        )
        {
            self.arrayBaseColumnType = arrayBaseColumnType
            self.isAutoIncrement = isAutoIncrement
            self.isCaseSensitive = isCaseSensitive
            self.isCurrency = isCurrency
            self.isSigned = isSigned
            self.label = label
            self.name = name
            self.nullable = nullable
            self.precision = precision
            self.scale = scale
            self.schemaName = schemaName
            self.tableName = tableName
            self.type = type
            self.typeName = typeName
        }
    }

}

extension CommitTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension CommitTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CommitTransaction"
    }
}

/// The request parameters represent the input of a commit transaction request.
public struct CommitTransactionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to end and commit.
    /// This member is required.
    public var transactionId: Swift.String?

    public init (
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct CommitTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let transactionId: Swift.String?
}

extension CommitTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension CommitTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CommitTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CommitTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CommitTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CommitTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// The response elements represent the output of a commit transaction request.
public struct CommitTransactionOutputResponse: Swift.Equatable {
    /// The status of the commit operation.
    public var transactionStatus: Swift.String?

    public init (
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct CommitTransactionOutputResponseBody: Swift.Equatable {
    let transactionStatus: Swift.String?
}

extension CommitTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

extension RdsDataClientTypes {
    public enum DecimalReturnType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case doubleOrLong
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [DecimalReturnType] {
            return [
                .doubleOrLong,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .doubleOrLong: return "DOUBLE_OR_LONG"
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DecimalReturnType(rawValue: rawValue) ?? DecimalReturnType.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteSqlInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsSecretStoreArn = awsSecretStoreArn {
            try encodeContainer.encode(awsSecretStoreArn, forKey: .awsSecretStoreArn)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbClusterOrInstanceArn = dbClusterOrInstanceArn {
            try encodeContainer.encode(dbClusterOrInstanceArn, forKey: .dbClusterOrInstanceArn)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let sqlStatements = sqlStatements {
            try encodeContainer.encode(sqlStatements, forKey: .sqlStatements)
        }
    }
}

extension ExecuteSqlInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ExecuteSql"
    }
}

/// The request parameters represent the input of a request to run one or more SQL statements.
public struct ExecuteSqlInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the secret that enables access to the DB cluster.
    /// This member is required.
    public var awsSecretStoreArn: Swift.String?
    /// The name of the database.
    public var database: Swift.String?
    /// The ARN of the Aurora Serverless DB cluster.
    /// This member is required.
    public var dbClusterOrInstanceArn: Swift.String?
    /// The name of the database schema.
    public var schema: Swift.String?
    /// One or more SQL statements to run on the DB cluster. You can separate SQL statements from each other with a semicolon (;). Any valid SQL statement is permitted, including data definition, data manipulation, and commit statements.
    /// This member is required.
    public var sqlStatements: Swift.String?

    public init (
        awsSecretStoreArn: Swift.String? = nil,
        database: Swift.String? = nil,
        dbClusterOrInstanceArn: Swift.String? = nil,
        schema: Swift.String? = nil,
        sqlStatements: Swift.String? = nil
    )
    {
        self.awsSecretStoreArn = awsSecretStoreArn
        self.database = database
        self.dbClusterOrInstanceArn = dbClusterOrInstanceArn
        self.schema = schema
        self.sqlStatements = sqlStatements
    }
}

struct ExecuteSqlInputBody: Swift.Equatable {
    let dbClusterOrInstanceArn: Swift.String?
    let awsSecretStoreArn: Swift.String?
    let sqlStatements: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
}

extension ExecuteSqlInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsSecretStoreArn
        case database
        case dbClusterOrInstanceArn
        case schema
        case sqlStatements
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbClusterOrInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterOrInstanceArn)
        dbClusterOrInstanceArn = dbClusterOrInstanceArnDecoded
        let awsSecretStoreArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsSecretStoreArn)
        awsSecretStoreArn = awsSecretStoreArnDecoded
        let sqlStatementsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sqlStatements)
        sqlStatements = sqlStatementsDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
    }
}

extension ExecuteSqlOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteSqlOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteSqlOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteSqlOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteSqlOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.sqlStatementResults = output.sqlStatementResults
        } else {
            self.sqlStatementResults = nil
        }
    }
}

/// The response elements represent the output of a request to run one or more SQL statements.
public struct ExecuteSqlOutputResponse: Swift.Equatable {
    /// The results of the SQL statement or statements.
    public var sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]?

    public init (
        sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]? = nil
    )
    {
        self.sqlStatementResults = sqlStatementResults
    }
}

struct ExecuteSqlOutputResponseBody: Swift.Equatable {
    let sqlStatementResults: [RdsDataClientTypes.SqlStatementResult]?
}

extension ExecuteSqlOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sqlStatementResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sqlStatementResultsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.SqlStatementResult?].self, forKey: .sqlStatementResults)
        var sqlStatementResultsDecoded0:[RdsDataClientTypes.SqlStatementResult]? = nil
        if let sqlStatementResultsContainer = sqlStatementResultsContainer {
            sqlStatementResultsDecoded0 = [RdsDataClientTypes.SqlStatementResult]()
            for structure0 in sqlStatementResultsContainer {
                if let structure0 = structure0 {
                    sqlStatementResultsDecoded0?.append(structure0)
                }
            }
        }
        sqlStatementResults = sqlStatementResultsDecoded0
    }
}

extension ExecuteStatementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if continueAfterTimeout != false {
            try encodeContainer.encode(continueAfterTimeout, forKey: .continueAfterTimeout)
        }
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if includeResultMetadata != false {
            try encodeContainer.encode(includeResultMetadata, forKey: .includeResultMetadata)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameters)
            for sqlparameterslist0 in parameters {
                try parametersContainer.encode(sqlparameterslist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resultSetOptions = resultSetOptions {
            try encodeContainer.encode(resultSetOptions, forKey: .resultSetOptions)
        }
        if let schema = schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension ExecuteStatementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/Execute"
    }
}

/// The request parameters represent the input of a request to run a SQL statement against a database.
public struct ExecuteStatementInput: Swift.Equatable {
    /// A value that indicates whether to continue running the statement after the call times out. By default, the statement stops running when the call times out. For DDL statements, we recommend continuing to run the statement after the call times out. When a DDL statement terminates before it is finished running, it can result in errors and possibly corrupted data structures.
    public var continueAfterTimeout: Swift.Bool
    /// The name of the database.
    public var database: Swift.String?
    /// A value that indicates whether to include metadata in the results.
    public var includeResultMetadata: Swift.Bool
    /// The parameters for the SQL statement. Array parameters are not supported.
    public var parameters: [RdsDataClientTypes.SqlParameter]?
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Options that control how the result set is returned.
    public var resultSetOptions: RdsDataClientTypes.ResultSetOptions?
    /// The name of the database schema. Currently, the schema parameter isn't supported.
    public var schema: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The SQL statement to run.
    /// This member is required.
    public var sql: Swift.String?
    /// The identifier of a transaction that was started by using the BeginTransaction operation. Specify the transaction ID of the transaction that you want to include the SQL statement in. If the SQL statement is not part of a transaction, don't set this parameter.
    public var transactionId: Swift.String?

    public init (
        continueAfterTimeout: Swift.Bool = false,
        database: Swift.String? = nil,
        includeResultMetadata: Swift.Bool = false,
        parameters: [RdsDataClientTypes.SqlParameter]? = nil,
        resourceArn: Swift.String? = nil,
        resultSetOptions: RdsDataClientTypes.ResultSetOptions? = nil,
        schema: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        sql: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.continueAfterTimeout = continueAfterTimeout
        self.database = database
        self.includeResultMetadata = includeResultMetadata
        self.parameters = parameters
        self.resourceArn = resourceArn
        self.resultSetOptions = resultSetOptions
        self.schema = schema
        self.secretArn = secretArn
        self.sql = sql
        self.transactionId = transactionId
    }
}

struct ExecuteStatementInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let sql: Swift.String?
    let database: Swift.String?
    let schema: Swift.String?
    let parameters: [RdsDataClientTypes.SqlParameter]?
    let transactionId: Swift.String?
    let includeResultMetadata: Swift.Bool
    let continueAfterTimeout: Swift.Bool
    let resultSetOptions: RdsDataClientTypes.ResultSetOptions?
}

extension ExecuteStatementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continueAfterTimeout
        case database
        case includeResultMetadata
        case parameters
        case resourceArn
        case resultSetOptions
        case schema
        case secretArn
        case sql
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sql)
        sql = sqlDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schema)
        schema = schemaDecoded
        let parametersContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.SqlParameter?].self, forKey: .parameters)
        var parametersDecoded0:[RdsDataClientTypes.SqlParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [RdsDataClientTypes.SqlParameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let includeResultMetadataDecoded = try containerValues.decode(Swift.Bool.self, forKey: .includeResultMetadata)
        includeResultMetadata = includeResultMetadataDecoded
        let continueAfterTimeoutDecoded = try containerValues.decode(Swift.Bool.self, forKey: .continueAfterTimeout)
        continueAfterTimeout = continueAfterTimeoutDecoded
        let resultSetOptionsDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultSetOptions.self, forKey: .resultSetOptions)
        resultSetOptions = resultSetOptionsDecoded
    }
}

extension ExecuteStatementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteStatementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteStatementOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteStatementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteStatementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.columnMetadata = output.columnMetadata
            self.generatedFields = output.generatedFields
            self.numberOfRecordsUpdated = output.numberOfRecordsUpdated
            self.records = output.records
        } else {
            self.columnMetadata = nil
            self.generatedFields = nil
            self.numberOfRecordsUpdated = 0
            self.records = nil
        }
    }
}

/// The response elements represent the output of a request to run a SQL statement against a database.
public struct ExecuteStatementOutputResponse: Swift.Equatable {
    /// Metadata for the columns included in the results.
    public var columnMetadata: [RdsDataClientTypes.ColumnMetadata]?
    /// Values for fields generated during the request. The generatedFields data isn't supported by Aurora PostgreSQL. To get the values of generated fields, use the RETURNING clause. For more information, see [Returning Data From Modified Rows](https://www.postgresql.org/docs/10/dml-returning.html) in the PostgreSQL documentation.
    public var generatedFields: [RdsDataClientTypes.Field]?
    /// The number of records updated by the request.
    public var numberOfRecordsUpdated: Swift.Int
    /// The records returned by the SQL statement.
    public var records: [[RdsDataClientTypes.Field]]?

    public init (
        columnMetadata: [RdsDataClientTypes.ColumnMetadata]? = nil,
        generatedFields: [RdsDataClientTypes.Field]? = nil,
        numberOfRecordsUpdated: Swift.Int = 0,
        records: [[RdsDataClientTypes.Field]]? = nil
    )
    {
        self.columnMetadata = columnMetadata
        self.generatedFields = generatedFields
        self.numberOfRecordsUpdated = numberOfRecordsUpdated
        self.records = records
    }
}

struct ExecuteStatementOutputResponseBody: Swift.Equatable {
    let records: [[RdsDataClientTypes.Field]]?
    let columnMetadata: [RdsDataClientTypes.ColumnMetadata]?
    let numberOfRecordsUpdated: Swift.Int
    let generatedFields: [RdsDataClientTypes.Field]?
}

extension ExecuteStatementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnMetadata
        case generatedFields
        case numberOfRecordsUpdated
        case records
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordsContainer = try containerValues.decodeIfPresent([[RdsDataClientTypes.Field?]?].self, forKey: .records)
        var recordsDecoded0:[[RdsDataClientTypes.Field]]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [[RdsDataClientTypes.Field]]()
            for list0 in recordsContainer {
                var list0Decoded0: [RdsDataClientTypes.Field]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [RdsDataClientTypes.Field]()
                    for union1 in list0 {
                        if let union1 = union1 {
                            list0Decoded0?.append(union1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    recordsDecoded0?.append(list0Decoded0)
                }
            }
        }
        records = recordsDecoded0
        let columnMetadataContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RdsDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RdsDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RdsDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RdsDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension RdsDataClientTypes.Field: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalue = "arrayValue"
        case blobvalue = "blobValue"
        case booleanvalue = "booleanValue"
        case doublevalue = "doubleValue"
        case isnull = "isNull"
        case longvalue = "longValue"
        case sdkUnknown
        case stringvalue = "stringValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalue(arrayvalue):
                try container.encode(arrayvalue, forKey: .arrayvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .booleanvalue(booleanvalue):
                try container.encode(booleanvalue, forKey: .booleanvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .longvalue(longvalue):
                try container.encode(longvalue, forKey: .longvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let booleanvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .booleanvalue)
        if let booleanvalue = booleanvalueDecoded {
            self = .booleanvalue(booleanvalue)
            return
        }
        let longvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .longvalue)
        if let longvalue = longvalueDecoded {
            self = .longvalue(longvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvalueDecoded = try values.decodeIfPresent(RdsDataClientTypes.ArrayValue.self, forKey: .arrayvalue)
        if let arrayvalue = arrayvalueDecoded {
            self = .arrayvalue(arrayvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// Contains a value.
    public enum Field: Swift.Equatable {
        /// A NULL value.
        case isnull(Swift.Bool)
        /// A value of Boolean data type.
        case booleanvalue(Swift.Bool)
        /// A value of long data type.
        case longvalue(Swift.Int)
        /// A value of double data type.
        case doublevalue(Swift.Double)
        /// A value of string data type.
        case stringvalue(Swift.String)
        /// A value of BLOB data type.
        case blobvalue(ClientRuntime.Data)
        /// An array of values.
        case arrayvalue(RdsDataClientTypes.ArrayValue)
        case sdkUnknown(Swift.String)
    }

}

extension ForbiddenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are insufficient privileges to make the call.
public struct ForbiddenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by this ForbiddenException error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error occurred.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server

}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resourceArn, secretArn, or transactionId value can't be found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message returned by this NotFoundException error.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RdsDataClientTypes.Record: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for row0 in values {
                try valuesContainer.encode(row0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valuesContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .values)
        var valuesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in valuesContainer {
                if let union0 = union0 {
                    valuesDecoded0?.append(union0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RdsDataClientTypes {
    /// A record returned by a call.
    public struct Record: Swift.Equatable {
        /// The values returned in the record.
        public var values: [RdsDataClientTypes.Value]?

        public init (
            values: [RdsDataClientTypes.Value]? = nil
        )
        {
            self.values = values
        }
    }

}

extension RdsDataClientTypes.ResultFrame: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case records
        case resultSetMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let records = records {
            var recordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .records)
            for records0 in records {
                try recordsContainer.encode(records0)
            }
        }
        if let resultSetMetadata = resultSetMetadata {
            try encodeContainer.encode(resultSetMetadata, forKey: .resultSetMetadata)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultSetMetadataDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultSetMetadata.self, forKey: .resultSetMetadata)
        resultSetMetadata = resultSetMetadataDecoded
        let recordsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Record?].self, forKey: .records)
        var recordsDecoded0:[RdsDataClientTypes.Record]? = nil
        if let recordsContainer = recordsContainer {
            recordsDecoded0 = [RdsDataClientTypes.Record]()
            for structure0 in recordsContainer {
                if let structure0 = structure0 {
                    recordsDecoded0?.append(structure0)
                }
            }
        }
        records = recordsDecoded0
    }
}

extension RdsDataClientTypes {
    /// The result set returned by a SQL statement.
    public struct ResultFrame: Swift.Equatable {
        /// The records in the result set.
        public var records: [RdsDataClientTypes.Record]?
        /// The result-set metadata in the result set.
        public var resultSetMetadata: RdsDataClientTypes.ResultSetMetadata?

        public init (
            records: [RdsDataClientTypes.Record]? = nil,
            resultSetMetadata: RdsDataClientTypes.ResultSetMetadata? = nil
        )
        {
            self.records = records
            self.resultSetMetadata = resultSetMetadata
        }
    }

}

extension RdsDataClientTypes.ResultSetMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnCount
        case columnMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnCount != 0 {
            try encodeContainer.encode(columnCount, forKey: .columnCount)
        }
        if let columnMetadata = columnMetadata {
            var columnMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnMetadata)
            for metadata0 in columnMetadata {
                try columnMetadataContainer.encode(metadata0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .columnCount)
        columnCount = columnCountDecoded
        let columnMetadataContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.ColumnMetadata?].self, forKey: .columnMetadata)
        var columnMetadataDecoded0:[RdsDataClientTypes.ColumnMetadata]? = nil
        if let columnMetadataContainer = columnMetadataContainer {
            columnMetadataDecoded0 = [RdsDataClientTypes.ColumnMetadata]()
            for structure0 in columnMetadataContainer {
                if let structure0 = structure0 {
                    columnMetadataDecoded0?.append(structure0)
                }
            }
        }
        columnMetadata = columnMetadataDecoded0
    }
}

extension RdsDataClientTypes {
    /// The metadata of the result set returned by a SQL statement.
    public struct ResultSetMetadata: Swift.Equatable {
        /// The number of columns in the result set.
        public var columnCount: Swift.Int
        /// The metadata of the columns in the result set.
        public var columnMetadata: [RdsDataClientTypes.ColumnMetadata]?

        public init (
            columnCount: Swift.Int = 0,
            columnMetadata: [RdsDataClientTypes.ColumnMetadata]? = nil
        )
        {
            self.columnCount = columnCount
            self.columnMetadata = columnMetadata
        }
    }

}

extension RdsDataClientTypes.ResultSetOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case decimalReturnType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let decimalReturnType = decimalReturnType {
            try encodeContainer.encode(decimalReturnType.rawValue, forKey: .decimalReturnType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let decimalReturnTypeDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.DecimalReturnType.self, forKey: .decimalReturnType)
        decimalReturnType = decimalReturnTypeDecoded
    }
}

extension RdsDataClientTypes {
    /// Options that control how the result set is returned.
    public struct ResultSetOptions: Swift.Equatable {
        /// A value that indicates how a field of DECIMAL type is represented in the response. The value of STRING, the default, specifies that it is converted to a String value. The value of DOUBLE_OR_LONG specifies that it is converted to a Long value if its scale is 0, or to a Double value otherwise. Conversion to Double or Long can result in roundoff errors due to precision loss. We recommend converting to String, especially when working with currency values.
        public var decimalReturnType: RdsDataClientTypes.DecimalReturnType?

        public init (
            decimalReturnType: RdsDataClientTypes.DecimalReturnType? = nil
        )
        {
            self.decimalReturnType = decimalReturnType
        }
    }

}

extension RollbackTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let secretArn = secretArn {
            try encodeContainer.encode(secretArn, forKey: .secretArn)
        }
        if let transactionId = transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
    }
}

extension RollbackTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RollbackTransaction"
    }
}

/// The request parameters represent the input of a request to perform a rollback of a transaction.
public struct RollbackTransactionInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Aurora Serverless DB cluster.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The name or ARN of the secret that enables access to the DB cluster.
    /// This member is required.
    public var secretArn: Swift.String?
    /// The identifier of the transaction to roll back.
    /// This member is required.
    public var transactionId: Swift.String?

    public init (
        resourceArn: Swift.String? = nil,
        secretArn: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
        self.secretArn = secretArn
        self.transactionId = transactionId
    }
}

struct RollbackTransactionInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let secretArn: Swift.String?
    let transactionId: Swift.String?
}

extension RollbackTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case secretArn
        case transactionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension RollbackTransactionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RollbackTransactionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableError" : self = .serviceUnavailableError(try ServiceUnavailableError(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StatementTimeoutException" : self = .statementTimeoutException(try StatementTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RollbackTransactionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableError(ServiceUnavailableError)
    case statementTimeoutException(StatementTimeoutException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RollbackTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RollbackTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transactionStatus = output.transactionStatus
        } else {
            self.transactionStatus = nil
        }
    }
}

/// The response elements represent the output of a request to perform a rollback of a transaction.
public struct RollbackTransactionOutputResponse: Swift.Equatable {
    /// The status of the rollback operation.
    public var transactionStatus: Swift.String?

    public init (
        transactionStatus: Swift.String? = nil
    )
    {
        self.transactionStatus = transactionStatus
    }
}

struct RollbackTransactionOutputResponseBody: Swift.Equatable {
    let transactionStatus: Swift.String?
}

extension RollbackTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transactionStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionStatus)
        transactionStatus = transactionStatusDecoded
    }
}

extension ServiceUnavailableError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service specified by the resourceArn parameter is not available.
public struct ServiceUnavailableError: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server

}

extension RdsDataClientTypes.SqlParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case typeHint
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let typeHint = typeHint {
            try encodeContainer.encode(typeHint.rawValue, forKey: .typeHint)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.Field.self, forKey: .value)
        value = valueDecoded
        let typeHintDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.TypeHint.self, forKey: .typeHint)
        typeHint = typeHintDecoded
    }
}

extension RdsDataClientTypes {
    /// A parameter used in a SQL statement.
    public struct SqlParameter: Swift.Equatable {
        /// The name of the parameter.
        public var name: Swift.String?
        /// A hint that specifies the correct object type for data type mapping. Possible values are as follows:
        ///
        /// * DATE - The corresponding String parameter value is sent as an object of DATE type to the database. The accepted format is YYYY-MM-DD.
        ///
        /// * DECIMAL - The corresponding String parameter value is sent as an object of DECIMAL type to the database.
        ///
        /// * JSON - The corresponding String parameter value is sent as an object of JSON type to the database.
        ///
        /// * TIME - The corresponding String parameter value is sent as an object of TIME type to the database. The accepted format is HH:MM:SS[.FFF].
        ///
        /// * TIMESTAMP - The corresponding String parameter value is sent as an object of TIMESTAMP type to the database. The accepted format is YYYY-MM-DD HH:MM:SS[.FFF].
        ///
        /// * UUID - The corresponding String parameter value is sent as an object of UUID type to the database.
        public var typeHint: RdsDataClientTypes.TypeHint?
        /// The value of the parameter.
        public var value: RdsDataClientTypes.Field?

        public init (
            name: Swift.String? = nil,
            typeHint: RdsDataClientTypes.TypeHint? = nil,
            value: RdsDataClientTypes.Field? = nil
        )
        {
            self.name = name
            self.typeHint = typeHint
            self.value = value
        }
    }

}

extension RdsDataClientTypes.SqlStatementResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfRecordsUpdated
        case resultFrame
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if numberOfRecordsUpdated != 0 {
            try encodeContainer.encode(numberOfRecordsUpdated, forKey: .numberOfRecordsUpdated)
        }
        if let resultFrame = resultFrame {
            try encodeContainer.encode(resultFrame, forKey: .resultFrame)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFrameDecoded = try containerValues.decodeIfPresent(RdsDataClientTypes.ResultFrame.self, forKey: .resultFrame)
        resultFrame = resultFrameDecoded
        let numberOfRecordsUpdatedDecoded = try containerValues.decode(Swift.Int.self, forKey: .numberOfRecordsUpdated)
        numberOfRecordsUpdated = numberOfRecordsUpdatedDecoded
    }
}

extension RdsDataClientTypes {
    /// The result of a SQL statement. This data type is deprecated.
    public struct SqlStatementResult: Swift.Equatable {
        /// The number of records updated by a SQL statement.
        public var numberOfRecordsUpdated: Swift.Int
        /// The result set of the SQL statement.
        public var resultFrame: RdsDataClientTypes.ResultFrame?

        public init (
            numberOfRecordsUpdated: Swift.Int = 0,
            resultFrame: RdsDataClientTypes.ResultFrame? = nil
        )
        {
            self.numberOfRecordsUpdated = numberOfRecordsUpdated
            self.resultFrame = resultFrame
        }
    }

}

extension StatementTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StatementTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.dbConnectionId = output.dbConnectionId
            self.message = output.message
        } else {
            self.dbConnectionId = 0
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The execution of the SQL statement timed out.
public struct StatementTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The database connection ID that executed the SQL statement.
    public var dbConnectionId: Swift.Int
    /// The error message returned by this StatementTimeoutException error.
    public var message: Swift.String?

    public init (
        dbConnectionId: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.dbConnectionId = dbConnectionId
        self.message = message
    }
}

struct StatementTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let dbConnectionId: Swift.Int
}

extension StatementTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbConnectionId
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let dbConnectionIdDecoded = try containerValues.decode(Swift.Int.self, forKey: .dbConnectionId)
        dbConnectionId = dbConnectionIdDecoded
    }
}

extension RdsDataClientTypes.StructValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for arrayvaluelist0 in attributes {
                try attributesContainer.encode(arrayvaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .attributes)
        var attributesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in attributesContainer {
                if let union0 = union0 {
                    attributesDecoded0?.append(union0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension RdsDataClientTypes {
    /// A structure value returned by a call.
    public struct StructValue: Swift.Equatable {
        /// The attributes returned in the record.
        public var attributes: [RdsDataClientTypes.Value]?

        public init (
            attributes: [RdsDataClientTypes.Value]? = nil
        )
        {
            self.attributes = attributes
        }
    }

}

extension RdsDataClientTypes {
    public enum TypeHint: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case date
        case decimal
        case json
        case time
        case timestamp
        case uuid
        case sdkUnknown(Swift.String)

        public static var allCases: [TypeHint] {
            return [
                .date,
                .decimal,
                .json,
                .time,
                .timestamp,
                .uuid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .json: return "JSON"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .uuid: return "UUID"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TypeHint(rawValue: rawValue) ?? TypeHint.sdkUnknown(rawValue)
        }
    }
}

extension RdsDataClientTypes.UpdateResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case generatedFields
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedFields = generatedFields {
            var generatedFieldsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedFields)
            for fieldlist0 in generatedFields {
                try generatedFieldsContainer.encode(fieldlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let generatedFieldsContainer = try containerValues.decodeIfPresent([RdsDataClientTypes.Field?].self, forKey: .generatedFields)
        var generatedFieldsDecoded0:[RdsDataClientTypes.Field]? = nil
        if let generatedFieldsContainer = generatedFieldsContainer {
            generatedFieldsDecoded0 = [RdsDataClientTypes.Field]()
            for union0 in generatedFieldsContainer {
                if let union0 = union0 {
                    generatedFieldsDecoded0?.append(union0)
                }
            }
        }
        generatedFields = generatedFieldsDecoded0
    }
}

extension RdsDataClientTypes {
    /// The response elements represent the results of an update.
    public struct UpdateResult: Swift.Equatable {
        /// Values for fields generated during the request.
        public var generatedFields: [RdsDataClientTypes.Field]?

        public init (
            generatedFields: [RdsDataClientTypes.Field]? = nil
        )
        {
            self.generatedFields = generatedFields
        }
    }

}

extension RdsDataClientTypes.Value: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arrayvalues = "arrayValues"
        case bigintvalue = "bigIntValue"
        case bitvalue = "bitValue"
        case blobvalue = "blobValue"
        case doublevalue = "doubleValue"
        case intvalue = "intValue"
        case isnull = "isNull"
        case realvalue = "realValue"
        case sdkUnknown
        case stringvalue = "stringValue"
        case structvalue = "structValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arrayvalues(arrayvalues):
                var arrayvaluesContainer = container.nestedUnkeyedContainer(forKey: .arrayvalues)
                for arrayvaluelist0 in arrayvalues {
                    try arrayvaluesContainer.encode(arrayvaluelist0)
                }
            case let .bigintvalue(bigintvalue):
                try container.encode(bigintvalue, forKey: .bigintvalue)
            case let .bitvalue(bitvalue):
                try container.encode(bitvalue, forKey: .bitvalue)
            case let .blobvalue(blobvalue):
                try container.encode(blobvalue.base64EncodedString(), forKey: .blobvalue)
            case let .doublevalue(doublevalue):
                try container.encode(doublevalue, forKey: .doublevalue)
            case let .intvalue(intvalue):
                try container.encode(intvalue, forKey: .intvalue)
            case let .isnull(isnull):
                try container.encode(isnull, forKey: .isnull)
            case let .realvalue(realvalue):
                try container.encode(realvalue, forKey: .realvalue)
            case let .stringvalue(stringvalue):
                try container.encode(stringvalue, forKey: .stringvalue)
            case let .structvalue(structvalue):
                try container.encode(structvalue, forKey: .structvalue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let isnullDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .isnull)
        if let isnull = isnullDecoded {
            self = .isnull(isnull)
            return
        }
        let bitvalueDecoded = try values.decodeIfPresent(Swift.Bool.self, forKey: .bitvalue)
        if let bitvalue = bitvalueDecoded {
            self = .bitvalue(bitvalue)
            return
        }
        let bigintvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .bigintvalue)
        if let bigintvalue = bigintvalueDecoded {
            self = .bigintvalue(bigintvalue)
            return
        }
        let intvalueDecoded = try values.decodeIfPresent(Swift.Int.self, forKey: .intvalue)
        if let intvalue = intvalueDecoded {
            self = .intvalue(intvalue)
            return
        }
        let doublevalueDecoded = try values.decodeIfPresent(Swift.Double.self, forKey: .doublevalue)
        if let doublevalue = doublevalueDecoded {
            self = .doublevalue(doublevalue)
            return
        }
        let realvalueDecoded = try values.decodeIfPresent(Swift.Float.self, forKey: .realvalue)
        if let realvalue = realvalueDecoded {
            self = .realvalue(realvalue)
            return
        }
        let stringvalueDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .stringvalue)
        if let stringvalue = stringvalueDecoded {
            self = .stringvalue(stringvalue)
            return
        }
        let blobvalueDecoded = try values.decodeIfPresent(ClientRuntime.Data.self, forKey: .blobvalue)
        if let blobvalue = blobvalueDecoded {
            self = .blobvalue(blobvalue)
            return
        }
        let arrayvaluesContainer = try values.decodeIfPresent([RdsDataClientTypes.Value?].self, forKey: .arrayvalues)
        var arrayvaluesDecoded0:[RdsDataClientTypes.Value]? = nil
        if let arrayvaluesContainer = arrayvaluesContainer {
            arrayvaluesDecoded0 = [RdsDataClientTypes.Value]()
            for union0 in arrayvaluesContainer {
                if let union0 = union0 {
                    arrayvaluesDecoded0?.append(union0)
                }
            }
        }
        if let arrayvalues = arrayvaluesDecoded0 {
            self = .arrayvalues(arrayvalues)
            return
        }
        let structvalueDecoded = try values.decodeIfPresent(RdsDataClientTypes.StructValue.self, forKey: .structvalue)
        if let structvalue = structvalueDecoded {
            self = .structvalue(structvalue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension RdsDataClientTypes {
    /// Contains the value of a column. This data type is deprecated.
    public enum Value: Swift.Equatable {
        /// A NULL value.
        case isnull(Swift.Bool)
        /// A value for a column of BIT data type.
        case bitvalue(Swift.Bool)
        /// A value for a column of big integer data type.
        case bigintvalue(Swift.Int)
        /// A value for a column of integer data type.
        case intvalue(Swift.Int)
        /// A value for a column of double data type.
        case doublevalue(Swift.Double)
        /// A value for a column of real data type.
        case realvalue(Swift.Float)
        /// A value for a column of string data type.
        case stringvalue(Swift.String)
        /// A value for a column of BLOB data type.
        case blobvalue(ClientRuntime.Data)
        /// An array of column values.
        case arrayvalues([RdsDataClientTypes.Value])
        /// A value for a column of STRUCT data type.
        case structvalue(RdsDataClientTypes.StructValue)
        case sdkUnknown(Swift.String)
    }

}
