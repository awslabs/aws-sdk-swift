// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AddTagsInputBodyMiddleware: Middleware {
    public let id: String = "AddTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

extension AddTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsInput(resourceId: \(String(describing: resourceId)), tagsList: \(String(describing: tagsList)))"}
}

extension AddTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

public struct AddTagsInputHeadersMiddleware: Middleware {
    public let id: String = "AddTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

public struct AddTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddTagsInput>
    public typealias MOutput = OperationOutput<AddTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddTagsOutputError>
}

/// <p>Specifies the tags to add to a trail.</p>
public struct AddTagsInput: Equatable {
    /// <p>Specifies the ARN of the trail to which one or more tags will be added. The format of a trail ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let resourceId: String?
    /// <p>Contains a list of CloudTrail tags, up to a limit of 50</p>
    public let tagsList: [Tag]?

    public init (
        resourceId: String? = nil,
        tagsList: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct AddTagsInputBody: Equatable {
    public let resourceId: String?
    public let tagsList: [Tag]?
}

extension AddTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension AddTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalidException" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupportedException" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsLimitExceededException" : self = .tagsLimitExceededException(try TagsLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddTagsOutputError: Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case tagsLimitExceededException(TagsLimitExceededException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddTagsOutputResponse()"}
}

extension AddTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct AddTagsOutputResponse: Equatable {

    public init() {}
}

struct AddTagsOutputResponseBody: Equatable {
}

extension AddTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension AdvancedEventSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fieldSelectors = "FieldSelectors"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldSelectors = fieldSelectors {
            var fieldSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fieldSelectors)
            for advancedfieldselectors0 in fieldSelectors {
                try fieldSelectorsContainer.encode(advancedfieldselectors0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let fieldSelectorsContainer = try containerValues.decodeIfPresent([AdvancedFieldSelector?].self, forKey: .fieldSelectors)
        var fieldSelectorsDecoded0:[AdvancedFieldSelector]? = nil
        if let fieldSelectorsContainer = fieldSelectorsContainer {
            fieldSelectorsDecoded0 = [AdvancedFieldSelector]()
            for structure0 in fieldSelectorsContainer {
                if let structure0 = structure0 {
                    fieldSelectorsDecoded0?.append(structure0)
                }
            }
        }
        fieldSelectors = fieldSelectorsDecoded0
    }
}

extension AdvancedEventSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdvancedEventSelector(fieldSelectors: \(String(describing: fieldSelectors)), name: \(String(describing: name)))"}
}

/// <p>Advanced event selectors let you create fine-grained selectors for the following AWS
///          CloudTrail event record ﬁelds. They help you control costs by logging only those events
///          that are important to you. For more information about advanced event selectors, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html">Logging data events for trails</a> in the <i>AWS
///             CloudTrail User Guide</i>.</p>
///          <ul>
///             <li>
///                <p>
///                   <code>readOnly</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>eventSource</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>eventName</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>eventCategory</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>resources.type</code>
///                </p>
///             </li>
///             <li>
///                <p>
///                   <code>resources.ARN</code>
///                </p>
///             </li>
///          </ul>
///          <p>You cannot apply both event selectors and advanced event selectors to a trail.</p>
public struct AdvancedEventSelector: Equatable {
    /// <p>Contains all selector statements in an advanced event selector.</p>
    public let fieldSelectors: [AdvancedFieldSelector]?
    /// <p>An optional, descriptive name for an advanced event selector, such as "Log data events
    ///          for only two S3 buckets".</p>
    public let name: String?

    public init (
        fieldSelectors: [AdvancedFieldSelector]? = nil,
        name: String? = nil
    )
    {
        self.fieldSelectors = fieldSelectors
        self.name = name
    }
}

extension AdvancedFieldSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endsWith = "EndsWith"
        case equals = "Equals"
        case field = "Field"
        case notEndsWith = "NotEndsWith"
        case notEquals = "NotEquals"
        case notStartsWith = "NotStartsWith"
        case startsWith = "StartsWith"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endsWith = endsWith {
            var endsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endsWith)
            for operator0 in endsWith {
                try endsWithContainer.encode(operator0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for operator0 in equals {
                try equalsContainer.encode(operator0)
            }
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let notEndsWith = notEndsWith {
            var notEndsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEndsWith)
            for operator0 in notEndsWith {
                try notEndsWithContainer.encode(operator0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for operator0 in notEquals {
                try notEqualsContainer.encode(operator0)
            }
        }
        if let notStartsWith = notStartsWith {
            var notStartsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notStartsWith)
            for operator0 in notStartsWith {
                try notStartsWithContainer.encode(operator0)
            }
        }
        if let startsWith = startsWith {
            var startsWithContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startsWith)
            for operator0 in startsWith {
                try startsWithContainer.encode(operator0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(String.self, forKey: .field)
        field = fieldDecoded
        let equalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .equals)
        var equalsDecoded0:[String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let startsWithContainer = try containerValues.decodeIfPresent([String?].self, forKey: .startsWith)
        var startsWithDecoded0:[String]? = nil
        if let startsWithContainer = startsWithContainer {
            startsWithDecoded0 = [String]()
            for string0 in startsWithContainer {
                if let string0 = string0 {
                    startsWithDecoded0?.append(string0)
                }
            }
        }
        startsWith = startsWithDecoded0
        let endsWithContainer = try containerValues.decodeIfPresent([String?].self, forKey: .endsWith)
        var endsWithDecoded0:[String]? = nil
        if let endsWithContainer = endsWithContainer {
            endsWithDecoded0 = [String]()
            for string0 in endsWithContainer {
                if let string0 = string0 {
                    endsWithDecoded0?.append(string0)
                }
            }
        }
        endsWith = endsWithDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let notStartsWithContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notStartsWith)
        var notStartsWithDecoded0:[String]? = nil
        if let notStartsWithContainer = notStartsWithContainer {
            notStartsWithDecoded0 = [String]()
            for string0 in notStartsWithContainer {
                if let string0 = string0 {
                    notStartsWithDecoded0?.append(string0)
                }
            }
        }
        notStartsWith = notStartsWithDecoded0
        let notEndsWithContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notEndsWith)
        var notEndsWithDecoded0:[String]? = nil
        if let notEndsWithContainer = notEndsWithContainer {
            notEndsWithDecoded0 = [String]()
            for string0 in notEndsWithContainer {
                if let string0 = string0 {
                    notEndsWithDecoded0?.append(string0)
                }
            }
        }
        notEndsWith = notEndsWithDecoded0
    }
}

extension AdvancedFieldSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AdvancedFieldSelector(endsWith: \(String(describing: endsWith)), equals: \(String(describing: equals)), field: \(String(describing: field)), notEndsWith: \(String(describing: notEndsWith)), notEquals: \(String(describing: notEquals)), notStartsWith: \(String(describing: notStartsWith)), startsWith: \(String(describing: startsWith)))"}
}

/// <p>A single selector statement in an advanced event selector.</p>
public struct AdvancedFieldSelector: Equatable {
    /// <p>
    ///          An operator that includes events that match the last few characters of the event record field specified as the value of <code>Field</code>.
    ///       </p>
    public let endsWith: [String]?
    /// <p>
    ///          An operator that includes events that match the exact value of the event record field specified as the value of <code>Field</code>. This is the only valid operator
    ///          that you can use with the <code>readOnly</code>, <code>eventCategory</code>, and <code>resources.type</code> fields.
    ///       </p>
    public let equals: [String]?
    /// <p>
    ///          A field in an event record on which to filter events to be logged. Supported fields include <code>readOnly</code>, <code>eventCategory</code>,
    ///          <code>eventSource</code> (for management events), <code>eventName</code>, <code>resources.type</code>, and <code>resources.ARN</code>.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>readOnly</code>
    ///                   </b> - Optional. Can be set to <code>Equals</code> a value of <code>true</code>
    ///             or <code>false</code>. A value of <code>false</code> logs both <code>read</code> and
    ///             <code>write</code> events.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>eventSource</code>
    ///                   </b> - For filtering management events only.
    ///             This can be set only to <code>NotEquals</code>
    ///                   <code>kms.amazonaws.com</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>eventName</code>
    ///                   </b> - Can use any operator. You can use it to ﬁlter in
    ///             or ﬁlter out any data event logged to CloudTrail, such as <code>PutBucket</code>. You can have multiple values
    ///             for this ﬁeld, separated by commas.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>eventCategory</code>
    ///                   </b> - This is required. It must be set to <code>Equals</code>, and
    ///             the value must be <code>Management</code> or <code>Data</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>resources.type</code>
    ///                   </b> - This ﬁeld is required.
    ///                   <code>resources.type</code> can only use the <code>Equals</code> operator, and the
    ///                value can be one of the following: <code>AWS::S3::Object</code>,
    ///                   <code>AWS::Lambda::Function</code>, <code>AWS::DynamoDB::Table</code>,
    ///                   <code>AWS::S3Outposts::Object</code>, <code>AWS::ManagedBlockchain::Node</code>,
    ///                or <code>AWS::S3ObjectLambda::AccessPoint</code>. You can have only one
    ///                   <code>resources.type</code> ﬁeld per selector. To log data events on more than one
    ///                resource type, add another selector.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>
    ///                      <code>resources.ARN</code>
    ///                   </b> - You can use any operator with
    ///                resources.ARN, but if you use <code>Equals</code> or <code>NotEquals</code>, the
    ///                value must exactly match the ARN of a valid resource of the type you've speciﬁed in
    ///                the template as the value of resources.type. For example, if resources.type equals
    ///                   <code>AWS::S3::Object</code>, the ARN must be in one of the following formats. To
    ///                log all data events for all objects in a specific S3 bucket, use the
    ///                   <code>StartsWith</code> operator, and include only the bucket ARN as the matching
    ///                value.</p>
    ///                <p>The trailing slash is intentional; do not exclude it.</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:s3:::bucket_name/</code>
    ///                      </p>
    ///                   </li>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:s3:::bucket_name/object_or_file_name/</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>When resources.type equals <code>AWS::Lambda::Function</code>, and the operator is set
    ///             to <code>Equals</code> or <code>NotEquals</code>, the ARN must be in the following format:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:lambda:region:account_ID:function:function_name</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>When resources.type equals <code>AWS::DynamoDB::Table</code>, and the operator is
    ///                set to <code>Equals</code> or <code>NotEquals</code>, the ARN must be in the
    ///                following format:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:dynamodb:region:account_ID:table:table_name</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>When <code>resources.type</code> equals <code>AWS::S3Outposts::Object</code>, and the operator
    ///                is set to <code>Equals</code> or <code>NotEquals</code>, the ARN must be in the following format:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:s3-outposts:region:>account_ID:object_path</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>When <code>resources.type</code> equals <code>AWS::ManagedBlockchain::Node</code>,
    ///                and the operator is set to <code>Equals</code> or <code>NotEquals</code>, the ARN
    ///                must be in the following format:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:managedblockchain:region:account_ID:nodes/node_ID</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///                <p>When <code>resources.type</code> equals
    ///                   <code>AWS::S3ObjectLambda::AccessPoint</code>, and the operator is set to
    ///                   <code>Equals</code> or <code>NotEquals</code>, the ARN must be in the following
    ///                format:</p>
    ///                <ul>
    ///                   <li>
    ///                      <p>
    ///                         <code>arn:partition:s3-object-lambda:region:account_ID:accesspoint/access_point_name</code>
    ///                      </p>
    ///                   </li>
    ///                </ul>
    ///             </li>
    ///          </ul>
    public let field: String?
    /// <p>
    ///          An operator that excludes events that match the last few characters of the event record field specified as the value of <code>Field</code>.
    ///       </p>
    public let notEndsWith: [String]?
    /// <p>
    ///          An operator that excludes events that match the exact value of the event record field specified as the value of <code>Field</code>.
    ///       </p>
    public let notEquals: [String]?
    /// <p>
    ///          An operator that excludes events that match the first few characters of the event record field specified as the value of <code>Field</code>.
    ///       </p>
    public let notStartsWith: [String]?
    /// <p>
    ///          An operator that includes events that match the first few characters of the event record field specified as the value of <code>Field</code>.
    ///       </p>
    public let startsWith: [String]?

    public init (
        endsWith: [String]? = nil,
        equals: [String]? = nil,
        field: String? = nil,
        notEndsWith: [String]? = nil,
        notEquals: [String]? = nil,
        notStartsWith: [String]? = nil,
        startsWith: [String]? = nil
    )
    {
        self.endsWith = endsWith
        self.equals = equals
        self.field = field
        self.notEndsWith = notEndsWith
        self.notEquals = notEquals
        self.notStartsWith = notStartsWith
        self.startsWith = startsWith
    }
}

extension CloudTrailARNInvalidException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailARNInvalidException(message: \(String(describing: message)))"}
}

extension CloudTrailARNInvalidException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudTrailARNInvalidExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when an operation is called with an invalid trail ARN. The format of a trail ARN is:</p>
///          <p>
///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
///          </p>
public struct CloudTrailARNInvalidException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailARNInvalidExceptionBody: Equatable {
    public let message: String?
}

extension CloudTrailARNInvalidExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailAccessNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailAccessNotEnabledException(message: \(String(describing: message)))"}
}

extension CloudTrailAccessNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudTrailAccessNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when trusted access has not been enabled between AWS CloudTrail and AWS Organizations. For more information,
///          see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_integrate_services.html">Enabling Trusted Access with Other AWS Services</a>
///          and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>. </p>
public struct CloudTrailAccessNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailAccessNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension CloudTrailAccessNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudTrailInvalidClientTokenIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailInvalidClientTokenIdException(message: \(String(describing: message)))"}
}

extension CloudTrailInvalidClientTokenIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudTrailInvalidClientTokenIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when a call results in the <code>InvalidClientTokenId</code> error code. This can occur when you are creating or updating a trail to send notifications to an Amazon SNS topic that
///       is in a suspended AWS account.</p>
public struct CloudTrailInvalidClientTokenIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudTrailInvalidClientTokenIdExceptionBody: Equatable {
    public let message: String?
}

extension CloudTrailInvalidClientTokenIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CloudWatchLogsDeliveryUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsDeliveryUnavailableException(message: \(String(describing: message)))"}
}

extension CloudWatchLogsDeliveryUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CloudWatchLogsDeliveryUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cannot set a CloudWatch Logs delivery for this region.</p>
public struct CloudWatchLogsDeliveryUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct CloudWatchLogsDeliveryUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension CloudWatchLogsDeliveryUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified resource is not ready for an operation.
///          This can occur when you try to run an operation on a trail before CloudTrail has time to fully load the trail.
///          If this exception occurs, wait a few minutes, and then try the operation again.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateTrailInputBodyMiddleware: Middleware {
    public let id: String = "CreateTrailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrailInput>
    public typealias MOutput = OperationOutput<CreateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrailOutputError>
}

extension CreateTrailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTrailInput(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), enableLogFileValidation: \(String(describing: enableLogFileValidation)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicName: \(String(describing: snsTopicName)), tagsList: \(String(describing: tagsList)))"}
}

extension CreateTrailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

public struct CreateTrailInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTrailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrailInput>
    public typealias MOutput = OperationOutput<CreateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrailOutputError>
}

public struct CreateTrailInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTrailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTrailInput>
    public typealias MOutput = OperationOutput<CreateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTrailOutputError>
}

/// <p>Specifies the settings for each trail.</p>
public struct CreateTrailInput: Equatable {
    /// <p>Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group
    ///          to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Specifies whether log file integrity validation is enabled. The default is false.</p>
    ///          <note>
    ///             <p>When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail will not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.</p>
    ///          </note>
    public let enableLogFileValidation: Bool?
    /// <p>Specifies whether the trail is publishing events from global services such as IAM to the log files.</p>
    public let includeGlobalServiceEvents: Bool?
    /// <p>Specifies whether the trail is created in the current region or in all regions. The default is false, which creates a trail only in the region where you are signed in. As a best practice, consider
    ///       creating trails that log events in all regions.</p>
    public let isMultiRegionTrail: Bool?
    /// <p>Specifies whether the trail is created for all accounts in an organization in AWS Organizations, or only for the current AWS account.
    ///       The default is false, and cannot be true unless the call is made on behalf of an AWS account that is the master account for an organization in
    ///       AWS Organizations.</p>
    public let isOrganizationTrail: Bool?
    /// <p>Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The
    ///          value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully
    ///          specified ARN to a key, or a globally unique identifier.</p>
    ///          <p>Examples:</p>
    ///          <ul>
    ///             <li>
    ///                <p>alias/MyAliasName</p>
    ///             </li>
    ///             <li>
    ///                <p>arn:aws:kms:us-east-2:123456789012:alias/MyAliasName</p>
    ///             </li>
    ///             <li>
    ///                <p>arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012</p>
    ///             </li>
    ///             <li>
    ///                <p>12345678-1234-1234-1234-123456789012</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>Specifies the name of the trail. The name must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    ///             </li>
    ///             <li>
    ///                <p>Start with a letter or number, and end with a letter or number</p>
    ///             </li>
    ///             <li>
    ///                <p>Be between 3 and 128 characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    ///             and <code>my--namespace</code> are invalid.</p>
    ///             </li>
    ///             <li>
    ///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>Specifies the name of the Amazon S3 bucket designated for publishing log files. See <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html">Amazon S3 Bucket Naming Requirements</a>.</p>
    public let s3BucketName: String?
    /// <p>Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated
    ///          for log file delivery. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html">Finding Your CloudTrail Log Files</a>. The maximum length is 200 characters.</p>
    public let s3KeyPrefix: String?
    /// <p>Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.</p>
    public let snsTopicName: String?
    /// <p>A list of tags.</p>
    public let tagsList: [Tag]?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        enableLogFileValidation: Bool? = nil,
        includeGlobalServiceEvents: Bool? = nil,
        isMultiRegionTrail: Bool? = nil,
        isOrganizationTrail: Bool? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicName: String? = nil,
        tagsList: [Tag]? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
        self.tagsList = tagsList
    }
}

struct CreateTrailInputBody: Equatable {
    public let name: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let snsTopicName: String?
    public let includeGlobalServiceEvents: Bool?
    public let isMultiRegionTrail: Bool?
    public let enableLogFileValidation: Bool?
    public let cloudWatchLogsLogGroupArn: String?
    public let cloudWatchLogsRoleArn: String?
    public let kmsKeyId: String?
    public let isOrganizationTrail: Bool?
    public let tagsList: [Tag]?
}

extension CreateTrailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
        case tagsList = "TagsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension CreateTrailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTrailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabledException" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenIdException" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailableException" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicyException" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicyException" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicyException" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArnException" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArnException" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyIdException" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketNameException" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3PrefixException" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicNameException" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabledException" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFoundException" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MaximumNumberOfTrailsExceededException" : self = .maximumNumberOfTrailsExceededException(try MaximumNumberOfTrailsExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesModeException" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUseException" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExistException" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailAlreadyExistsException" : self = .trailAlreadyExistsException(try TrailAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvidedException" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTrailOutputError: Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case maximumNumberOfTrailsExceededException(MaximumNumberOfTrailsExceededException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailAlreadyExistsException(TrailAlreadyExistsException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTrailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTrailOutputResponse(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), logFileValidationEnabled: \(String(describing: logFileValidationEnabled)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicARN: \(String(describing: snsTopicARN)), snsTopicName: \(String(describing: snsTopicName)), trailARN: \(String(describing: trailARN)))"}
}

extension CreateTrailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTrailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct CreateTrailOutputResponse: Equatable {
    /// <p>Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Specifies whether the trail is publishing events from global services such as IAM to the log files.</p>
    public let includeGlobalServiceEvents: Bool?
    /// <p>Specifies whether the trail exists in one region or in all regions.</p>
    public let isMultiRegionTrail: Bool?
    /// <p>Specifies whether the trail is an organization trail.</p>
    public let isOrganizationTrail: Bool?
    /// <p>Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the format:</p>
    ///          <p>
    ///             <code>arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///          </p>
    public let kmsKeyId: String?
    /// <p>Specifies whether log file integrity validation is enabled.</p>
    public let logFileValidationEnabled: Bool?
    /// <p>Specifies the name of the trail.</p>
    public let name: String?
    /// <p>Specifies the name of the Amazon S3 bucket designated for publishing log files.</p>
    public let s3BucketName: String?
    /// <p>Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated
    ///          for log file delivery. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html">Finding Your CloudTrail Log Files</a>.</p>
    public let s3KeyPrefix: String?
    /// <p>Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications when log files are delivered. The format of a topic ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:sns:us-east-2:123456789012:MyTopic</code>
    ///          </p>
    public let snsTopicARN: String?
    /// <p>This field is no longer in use. Use SnsTopicARN.</p>
    @available(*, deprecated)
    public let snsTopicName: String?
    /// <p>Specifies the ARN of the trail that was created. The format of a trail ARN
    ///          is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailARN: String?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        includeGlobalServiceEvents: Bool? = nil,
        isMultiRegionTrail: Bool? = nil,
        isOrganizationTrail: Bool? = nil,
        kmsKeyId: String? = nil,
        logFileValidationEnabled: Bool? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicARN: String? = nil,
        snsTopicName: String? = nil,
        trailARN: String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct CreateTrailOutputResponseBody: Equatable {
    public let name: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let snsTopicName: String?
    public let snsTopicARN: String?
    public let includeGlobalServiceEvents: Bool?
    public let isMultiRegionTrail: Bool?
    public let trailARN: String?
    public let logFileValidationEnabled: Bool?
    public let cloudWatchLogsLogGroupArn: String?
    public let cloudWatchLogsRoleArn: String?
    public let kmsKeyId: String?
    public let isOrganizationTrail: Bool?
}

extension CreateTrailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension DataResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for dataresourcevalues0 in values {
                try valuesContainer.encode(dataresourcevalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension DataResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataResource(type: \(String(describing: type)), values: \(String(describing: values)))"}
}

/// <p>The Amazon S3 buckets, AWS Lambda functions, or Amazon DynamoDB tables that you specify
///          in your event selectors for your trail to log data events. Data events provide information
///          about the resource operations performed on or within a resource itself. These are also
///          known as data plane operations. You can specify up to 250 data resources for a
///          trail.</p>
///          <note>
///             <p>The total number of allowed data resources is 250. This number can be distributed between 1 and 5 event selectors,
///       but the total cannot exceed 250 across all selectors.</p>
///             <p>If you are using advanced event selectors, the maximum total number of values for
///             all conditions, across all advanced event selectors for the trail, is 500.</p>
///          </note>
///          <p>The following example demonstrates how logging works when you configure logging of all data events
///       for an S3 bucket named <code>bucket-1</code>. In this example, the CloudTrail user specified an empty prefix,
///       and the option to log both <code>Read</code> and <code>Write</code> data events.</p>
///          <ol>
///             <li>
///                <p>A user uploads an image file to <code>bucket-1</code>.</p>
///             </li>
///             <li>
///                <p>The <code>PutObject</code> API operation is an Amazon S3 object-level API.
///             It is recorded as a data event in CloudTrail. Because the CloudTrail user specified an S3 bucket
///             with an empty prefix, events that occur on any object in that bucket are logged. The trail processes and logs the
///                event.</p>
///             </li>
///             <li>
///                <p>A user uploads an object to an Amazon S3 bucket named
///                   <code>arn:aws:s3:::bucket-2</code>.</p>
///             </li>
///             <li>
///                <p>The <code>PutObject</code> API operation occurred for an object in an S3 bucket that the CloudTrail
///             user didn't specify for the trail. The trail doesn’t log the event.</p>
///             </li>
///          </ol>
///          <p>The following example demonstrates how logging works when you configure logging of AWS Lambda data events for a
///          Lambda function named <i>MyLambdaFunction</i>, but not for all AWS Lambda functions.</p>
///          <ol>
///             <li>
///                <p>A user runs a script that includes a call to the <i>MyLambdaFunction</i> function and the
///                <i>MyOtherLambdaFunction</i> function.</p>
///             </li>
///             <li>
///                <p>The <code>Invoke</code> API operation on <i>MyLambdaFunction</i> is an AWS Lambda API.
///                It is recorded as a data event in CloudTrail. Because the CloudTrail user specified logging data events for
///                <i>MyLambdaFunction</i>, any invocations of that function are logged. The trail processes and logs the event. </p>
///             </li>
///             <li>
///                <p>The <code>Invoke</code> API operation on <i>MyOtherLambdaFunction</i> is an AWS Lambda API.
///                Because the CloudTrail user did not specify logging data events for all Lambda functions,
///                the <code>Invoke</code> operation for <i>MyOtherLambdaFunction</i> does not match the function specified for the trail.
///                The trail doesn’t log the event. </p>
///             </li>
///          </ol>
public struct DataResource: Equatable {
    /// <p>The resource type in which you want to log data events. You can specify
    ///             <code>AWS::S3::Object</code>, <code>AWS::Lambda::Function</code>, or
    ///             <code>AWS::DynamoDB::Table</code> resources.</p>
    ///          <p>The <code>AWS::S3Outposts::Object</code>, <code>AWS::ManagedBlockchain::Node</code>, and
    ///             <code>AWS::S3ObjectLambda::AccessPoint</code> resource types are not valid in basic
    ///          event selectors. To log data events on these resource types, use advanced event
    ///          selectors.</p>
    public let type: String?
    /// <p>An array of Amazon Resource Name (ARN) strings or partial ARN strings for the specified objects.</p>
    ///          <ul>
    ///             <li>
    ///                <p>To log data events for all objects in all S3 buckets in your AWS account, specify the
    ///          prefix as <code>arn:aws:s3:::</code>. </p>
    ///                <note>
    ///                   <p>This will also enable logging of data event activity performed by any user or role in your AWS account,
    ///          even if that activity is performed on a bucket that belongs to another AWS account. </p>
    ///                </note>
    ///             </li>
    ///             <li>
    ///                <p>To log data events for all objects in an S3 bucket, specify the bucket and an empty
    ///          object prefix such as <code>arn:aws:s3:::bucket-1/</code>. The trail logs data events for
    ///          all objects in this S3 bucket.</p>
    ///             </li>
    ///             <li>
    ///                <p>To log data events for specific objects, specify the S3 bucket and object prefix such
    ///          as <code>arn:aws:s3:::bucket-1/example-images</code>. The trail logs data events for
    ///          objects in this S3 bucket that match the prefix.</p>
    ///             </li>
    ///             <li>
    ///                <p>To log data events for all Lambda functions in your AWS account, specify the prefix as
    ///                   <code>arn:aws:lambda</code>.</p>
    ///                <note>
    ///                   <p>This will also enable logging of <code>Invoke</code> activity performed by any user or role in your AWS account,
    ///             even if that activity is performed on a function that belongs to another AWS account. </p>
    ///                </note>
    ///             </li>
    ///             <li>
    ///                <p>To log data events for a specific Lambda function, specify the function ARN.</p>
    ///                <note>
    ///                   <p>Lambda function ARNs are exact. For example, if you specify a
    ///             function ARN <i>arn:aws:lambda:us-west-2:111111111111:function:helloworld</i>, data events will
    ///             only be logged for <i>arn:aws:lambda:us-west-2:111111111111:function:helloworld</i>. They will
    ///             not be logged for <i>arn:aws:lambda:us-west-2:111111111111:function:helloworld2</i>.</p>
    ///                </note>
    ///             </li>
    ///             <li>
    ///                <p>To log data events for all DynamoDB tables in your AWS account, specify the prefix
    ///                as <code>arn:aws:dynamodb</code>.</p>
    ///             </li>
    ///          </ul>
    public let values: [String]?

    public init (
        type: String? = nil,
        values: [String]? = nil
    )
    {
        self.type = type
        self.values = values
    }
}

public struct DeleteTrailInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTrailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrailInput>
    public typealias MOutput = OperationOutput<DeleteTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrailOutputError>
}

extension DeleteTrailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTrailInput(name: \(String(describing: name)))"}
}

extension DeleteTrailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteTrailInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTrailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrailInput>
    public typealias MOutput = OperationOutput<DeleteTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrailOutputError>
}

public struct DeleteTrailInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTrailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTrailInput>
    public typealias MOutput = OperationOutput<DeleteTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTrailOutputError>
}

/// <p>The request that specifies the name of a trail to delete.</p>
public struct DeleteTrailInput: Equatable {
    /// <p>Specifies the name or the CloudTrail ARN of the trail to be deleted. The format of a
    ///          trail ARN is:
    ///          <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteTrailInputBody: Equatable {
    public let name: String?
}

extension DeleteTrailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteTrailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTrailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTrailOutputError: Equatable {
    case conflictException(ConflictException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTrailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTrailOutputResponse()"}
}

extension DeleteTrailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct DeleteTrailOutputResponse: Equatable {

    public init() {}
}

struct DeleteTrailOutputResponseBody: Equatable {
}

extension DeleteTrailOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeTrailsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeTrailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrailsInput>
    public typealias MOutput = OperationOutput<DescribeTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrailsOutputError>
}

extension DescribeTrailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrailsInput(includeShadowTrails: \(String(describing: includeShadowTrails)), trailNameList: \(String(describing: trailNameList)))"}
}

extension DescribeTrailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeShadowTrails = includeShadowTrails {
            try encodeContainer.encode(includeShadowTrails, forKey: .includeShadowTrails)
        }
        if let trailNameList = trailNameList {
            var trailNameListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailNameList)
            for trailnamelist0 in trailNameList {
                try trailNameListContainer.encode(trailnamelist0)
            }
        }
    }
}

public struct DescribeTrailsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTrailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrailsInput>
    public typealias MOutput = OperationOutput<DescribeTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrailsOutputError>
}

public struct DescribeTrailsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTrailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTrailsInput>
    public typealias MOutput = OperationOutput<DescribeTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTrailsOutputError>
}

/// <p>Returns information about the trail.</p>
public struct DescribeTrailsInput: Equatable {
    /// <p>Specifies whether to include shadow trails in the response. A shadow trail is the replication in a region of a trail that was created in a different region,
    ///          or in the case of an organization trail, the replication of an organization trail in member accounts. If you do not include shadow trails, organization trails in a member account
    ///          and region replication trails will not be returned. The default is true.</p>
    public let includeShadowTrails: Bool?
    /// <p>Specifies a list of trail names, trail ARNs, or both, of the trails to describe. The format of a trail ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    ///
    ///          <p>If an empty list is specified, information for the trail in the current region is returned.</p>
    ///          <ul>
    ///             <li>
    ///                <p>If an empty list is specified and <code>IncludeShadowTrails</code> is false, then
    ///             information for all trails in the current region is returned.</p>
    ///             </li>
    ///             <li>
    ///                <p>If an empty list is specified and IncludeShadowTrails is null or true, then information for all trails in the current region and any associated shadow trails in other regions is returned.</p>
    ///             </li>
    ///          </ul>
    ///          <note>
    ///             <p>If one or more trail names are specified, information is returned only if the names match the names of trails belonging only to the current region. To return information about a trail in another region, you must specify its trail ARN.</p>
    ///          </note>
    public let trailNameList: [String]?

    public init (
        includeShadowTrails: Bool? = nil,
        trailNameList: [String]? = nil
    )
    {
        self.includeShadowTrails = includeShadowTrails
        self.trailNameList = trailNameList
    }
}

struct DescribeTrailsInputBody: Equatable {
    public let trailNameList: [String]?
    public let includeShadowTrails: Bool?
}

extension DescribeTrailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case includeShadowTrails
        case trailNameList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .trailNameList)
        var trailNameListDecoded0:[String]? = nil
        if let trailNameListContainer = trailNameListContainer {
            trailNameListDecoded0 = [String]()
            for string0 in trailNameListContainer {
                if let string0 = string0 {
                    trailNameListDecoded0?.append(string0)
                }
            }
        }
        trailNameList = trailNameListDecoded0
        let includeShadowTrailsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeShadowTrails)
        includeShadowTrails = includeShadowTrailsDecoded
    }
}

extension DescribeTrailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTrailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTrailsOutputError: Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTrailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTrailsOutputResponse(trailList: \(String(describing: trailList)))"}
}

extension DescribeTrailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTrailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trailList = output.trailList
        } else {
            self.trailList = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct DescribeTrailsOutputResponse: Equatable {
    /// <p>The list of trail objects. Trail objects with string values are only returned if values for the objects exist in a trail's configuration.
    ///          For example, <code>SNSTopicName</code> and <code>SNSTopicARN</code> are only returned in results if a trail is configured to send SNS notifications. Similarly,
    ///       <code>KMSKeyId</code> only appears in results if a trail's log files are encrypted with AWS KMS-managed keys.</p>
    public let trailList: [Trail]?

    public init (
        trailList: [Trail]? = nil
    )
    {
        self.trailList = trailList
    }
}

struct DescribeTrailsOutputResponseBody: Equatable {
    public let trailList: [Trail]?
}

extension DescribeTrailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trailList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailListContainer = try containerValues.decodeIfPresent([Trail?].self, forKey: .trailList)
        var trailListDecoded0:[Trail]? = nil
        if let trailListContainer = trailListContainer {
            trailListDecoded0 = [Trail]()
            for structure0 in trailListContainer {
                if let structure0 = structure0 {
                    trailListDecoded0?.append(structure0)
                }
            }
        }
        trailList = trailListDecoded0
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case cloudTrailEvent = "CloudTrailEvent"
        case eventId = "EventId"
        case eventName = "EventName"
        case eventSource = "EventSource"
        case eventTime = "EventTime"
        case readOnly = "ReadOnly"
        case resources = "Resources"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let cloudTrailEvent = cloudTrailEvent {
            try encodeContainer.encode(cloudTrailEvent, forKey: .cloudTrailEvent)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let readOnly = readOnly {
            try encodeContainer.encode(readOnly, forKey: .readOnly)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resourcelist0 in resources {
                try resourcesContainer.encode(resourcelist0)
            }
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let readOnlyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .readOnly)
        readOnly = readOnlyDecoded
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let cloudTrailEventDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudTrailEvent)
        cloudTrailEvent = cloudTrailEventDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(accessKeyId: \(String(describing: accessKeyId)), cloudTrailEvent: \(String(describing: cloudTrailEvent)), eventId: \(String(describing: eventId)), eventName: \(String(describing: eventName)), eventSource: \(String(describing: eventSource)), eventTime: \(String(describing: eventTime)), readOnly: \(String(describing: readOnly)), resources: \(String(describing: resources)), username: \(String(describing: username)))"}
}

/// <p>Contains information about an event that was returned by a lookup request. The result includes a representation of a CloudTrail event.</p>
public struct Event: Equatable {
    /// <p>The AWS access key ID that was used to sign the request. If the request was made
    ///          with temporary security credentials, this is the access key ID of the temporary credentials.</p>
    public let accessKeyId: String?
    /// <p>A JSON string that contains a representation of the event returned.</p>
    public let cloudTrailEvent: String?
    /// <p>The CloudTrail ID of the event returned.</p>
    public let eventId: String?
    /// <p>The name of the event returned.</p>
    public let eventName: String?
    /// <p>The AWS service that the request was made to.</p>
    public let eventSource: String?
    /// <p>The date and time of the event returned.</p>
    public let eventTime: Date?
    /// <p>Information about whether the event is a write event or a read event. </p>
    public let readOnly: String?
    /// <p>A list of resources referenced by the event returned.</p>
    public let resources: [Resource]?
    /// <p>A user name or role name of the requester that called the API in the event returned.</p>
    public let username: String?

    public init (
        accessKeyId: String? = nil,
        cloudTrailEvent: String? = nil,
        eventId: String? = nil,
        eventName: String? = nil,
        eventSource: String? = nil,
        eventTime: Date? = nil,
        readOnly: String? = nil,
        resources: [Resource]? = nil,
        username: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.cloudTrailEvent = cloudTrailEvent
        self.eventId = eventId
        self.eventName = eventName
        self.eventSource = eventSource
        self.eventTime = eventTime
        self.readOnly = readOnly
        self.resources = resources
        self.username = username
    }
}

public enum EventCategory {
    case insight
    case sdkUnknown(String)
}

extension EventCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventCategory] {
        return [
            .insight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insight: return "insight"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventCategory(rawValue: rawValue) ?? EventCategory.sdkUnknown(rawValue)
    }
}

extension EventSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataResources = "DataResources"
        case excludeManagementEventSources = "ExcludeManagementEventSources"
        case includeManagementEvents = "IncludeManagementEvents"
        case readWriteType = "ReadWriteType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataResources = dataResources {
            var dataResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataResources)
            for dataresources0 in dataResources {
                try dataResourcesContainer.encode(dataresources0)
            }
        }
        if let excludeManagementEventSources = excludeManagementEventSources {
            var excludeManagementEventSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .excludeManagementEventSources)
            for excludemanagementeventsources0 in excludeManagementEventSources {
                try excludeManagementEventSourcesContainer.encode(excludemanagementeventsources0)
            }
        }
        if let includeManagementEvents = includeManagementEvents {
            try encodeContainer.encode(includeManagementEvents, forKey: .includeManagementEvents)
        }
        if let readWriteType = readWriteType {
            try encodeContainer.encode(readWriteType.rawValue, forKey: .readWriteType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let readWriteTypeDecoded = try containerValues.decodeIfPresent(ReadWriteType.self, forKey: .readWriteType)
        readWriteType = readWriteTypeDecoded
        let includeManagementEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeManagementEvents)
        includeManagementEvents = includeManagementEventsDecoded
        let dataResourcesContainer = try containerValues.decodeIfPresent([DataResource?].self, forKey: .dataResources)
        var dataResourcesDecoded0:[DataResource]? = nil
        if let dataResourcesContainer = dataResourcesContainer {
            dataResourcesDecoded0 = [DataResource]()
            for structure0 in dataResourcesContainer {
                if let structure0 = structure0 {
                    dataResourcesDecoded0?.append(structure0)
                }
            }
        }
        dataResources = dataResourcesDecoded0
        let excludeManagementEventSourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .excludeManagementEventSources)
        var excludeManagementEventSourcesDecoded0:[String]? = nil
        if let excludeManagementEventSourcesContainer = excludeManagementEventSourcesContainer {
            excludeManagementEventSourcesDecoded0 = [String]()
            for string0 in excludeManagementEventSourcesContainer {
                if let string0 = string0 {
                    excludeManagementEventSourcesDecoded0?.append(string0)
                }
            }
        }
        excludeManagementEventSources = excludeManagementEventSourcesDecoded0
    }
}

extension EventSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSelector(dataResources: \(String(describing: dataResources)), excludeManagementEventSources: \(String(describing: excludeManagementEventSources)), includeManagementEvents: \(String(describing: includeManagementEvents)), readWriteType: \(String(describing: readWriteType)))"}
}

/// <p>Use event selectors to further specify the management and data event settings for your trail. By
///          default, trails created without specific event selectors will be configured to log all read and
///          write management events, and no data events. When an event occurs in your account, CloudTrail evaluates the event selector
///          for all trails. For each trail, if the event matches any event selector, the trail
///          processes and logs the event. If the event doesn't match any event selector, the trail
///          doesn't log the event.</p>
///          <p>You can configure up to five event selectors for a trail.</p>
///          <p>You cannot apply both event selectors and advanced event selectors to a trail.</p>
public struct EventSelector: Equatable {
    /// <p>CloudTrail supports data event logging for Amazon S3 objects and AWS Lambda functions
    ///          with basic event selectors. You can specify up to 250 resources for an individual event
    ///          selector, but the total number of data resources cannot exceed 250 across all event
    ///          selectors in a trail. This limit does not apply if you configure resource logging for all
    ///          data events. </p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-and-data-events-with-cloudtrail.html#logging-data-events">Data Events</a> and <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html">Limits in AWS CloudTrail</a>
    ///          in the <i>AWS CloudTrail User Guide</i>.</p>
    public let dataResources: [DataResource]?
    /// <p>An optional list of service event sources from which you do not want management events to be logged on your trail. In this release, the list can be empty (disables the filter), or it can filter out AWS Key Management Service events by
    ///          containing <code>"kms.amazonaws.com"</code>. By default, <code>ExcludeManagementEventSources</code> is empty, and AWS KMS events are included in events that are logged to your trail. </p>
    public let excludeManagementEventSources: [String]?
    /// <p>Specify if you want your event selector to include management events for your trail.</p>
    ///          <p>
    ///          For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-management-and-data-events-with-cloudtrail.html#logging-management-events">Management Events</a> in the <i>AWS CloudTrail User Guide</i>.</p>
    ///
    ///          <p>By default, the value is <code>true</code>.</p>
    ///          <p>The first copy of management events is free. You are charged for additional copies of management
    ///          events that you are logging on any subsequent trail in the same region. For more information about
    ///          CloudTrail pricing, see <a href="http://aws.amazon.com/cloudtrail/pricing/">AWS CloudTrail Pricing</a>.</p>
    public let includeManagementEvents: Bool?
    /// <p>Specify if you want your trail to log read-only events, write-only events, or all. For example,
    ///          the EC2 <code>GetConsoleOutput</code> is a read-only API operation and
    ///             <code>RunInstances</code> is a write-only API operation.</p>
    ///          <p> By default, the value is <code>All</code>.</p>
    public let readWriteType: ReadWriteType?

    public init (
        dataResources: [DataResource]? = nil,
        excludeManagementEventSources: [String]? = nil,
        includeManagementEvents: Bool? = nil,
        readWriteType: ReadWriteType? = nil
    )
    {
        self.dataResources = dataResources
        self.excludeManagementEventSources = excludeManagementEventSources
        self.includeManagementEvents = includeManagementEvents
        self.readWriteType = readWriteType
    }
}

public struct GetEventSelectorsInputBodyMiddleware: Middleware {
    public let id: String = "GetEventSelectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventSelectorsInput>
    public typealias MOutput = OperationOutput<GetEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventSelectorsOutputError>
}

extension GetEventSelectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventSelectorsInput(trailName: \(String(describing: trailName)))"}
}

extension GetEventSelectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

public struct GetEventSelectorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventSelectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventSelectorsInput>
    public typealias MOutput = OperationOutput<GetEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventSelectorsOutputError>
}

public struct GetEventSelectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventSelectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventSelectorsInput>
    public typealias MOutput = OperationOutput<GetEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventSelectorsOutputError>
}

public struct GetEventSelectorsInput: Equatable {
    /// <p>Specifies the name of the trail or trail ARN. If you specify a trail name, the
    ///          string must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    ///             </li>
    ///             <li>
    ///                <p>Start with a letter or number, and end with a letter or number</p>
    ///             </li>
    ///             <li>
    ///                <p>Be between 3 and 128 characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    ///                   and <code>my--namespace</code> are not valid.</p>
    ///             </li>
    ///             <li>
    ///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify a trail ARN, it must be in the format:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailName: String?

    public init (
        trailName: String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetEventSelectorsInputBody: Equatable {
    public let trailName: String?
}

extension GetEventSelectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetEventSelectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSelectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventSelectorsOutputError: Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSelectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventSelectorsOutputResponse(advancedEventSelectors: \(String(describing: advancedEventSelectors)), eventSelectors: \(String(describing: eventSelectors)), trailARN: \(String(describing: trailARN)))"}
}

extension GetEventSelectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetEventSelectorsOutputResponse: Equatable {
    /// <p>
    ///          The advanced event selectors that are configured for the trail.
    ///       </p>
    public let advancedEventSelectors: [AdvancedEventSelector]?
    /// <p>The event selectors that are configured for the trail.</p>
    public let eventSelectors: [EventSelector]?
    /// <p>The specified trail ARN that has the event selectors.</p>
    public let trailARN: String?

    public init (
        advancedEventSelectors: [AdvancedEventSelector]? = nil,
        eventSelectors: [EventSelector]? = nil,
        trailARN: String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct GetEventSelectorsOutputResponseBody: Equatable {
    public let trailARN: String?
    public let eventSelectors: [EventSelector]?
    public let advancedEventSelectors: [AdvancedEventSelector]?
}

extension GetEventSelectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

public struct GetInsightSelectorsInputBodyMiddleware: Middleware {
    public let id: String = "GetInsightSelectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSelectorsInput>
    public typealias MOutput = OperationOutput<GetInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSelectorsOutputError>
}

extension GetInsightSelectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightSelectorsInput(trailName: \(String(describing: trailName)))"}
}

extension GetInsightSelectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case trailName = "TrailName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

public struct GetInsightSelectorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetInsightSelectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSelectorsInput>
    public typealias MOutput = OperationOutput<GetInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSelectorsOutputError>
}

public struct GetInsightSelectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetInsightSelectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetInsightSelectorsInput>
    public typealias MOutput = OperationOutput<GetInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetInsightSelectorsOutputError>
}

public struct GetInsightSelectorsInput: Equatable {
    /// <p>Specifies the name of the trail or trail ARN. If you specify a trail name, the
    ///          string must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    ///             </li>
    ///             <li>
    ///                <p>Start with a letter or number, and end with a letter or number</p>
    ///             </li>
    ///             <li>
    ///                <p>Be between 3 and 128 characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    ///                and <code>my--namespace</code> are not valid.</p>
    ///             </li>
    ///             <li>
    ///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify a trail ARN, it must be in the format:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailName: String?

    public init (
        trailName: String? = nil
    )
    {
        self.trailName = trailName
    }
}

struct GetInsightSelectorsInputBody: Equatable {
    public let trailName: String?
}

extension GetInsightSelectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trailName = "TrailName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailName)
        trailName = trailNameDecoded
    }
}

extension GetInsightSelectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInsightSelectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsightNotEnabledException" : self = .insightNotEnabledException(try InsightNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInsightSelectorsOutputError: Equatable {
    case insightNotEnabledException(InsightNotEnabledException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInsightSelectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetInsightSelectorsOutputResponse(insightSelectors: \(String(describing: insightSelectors)), trailARN: \(String(describing: trailARN)))"}
}

extension GetInsightSelectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct GetInsightSelectorsOutputResponse: Equatable {
    /// <p>A JSON string that contains the insight types you want to log on a trail. In this release, only <code>ApiCallRateInsight</code> is supported as an insight type.</p>
    public let insightSelectors: [InsightSelector]?
    /// <p>The Amazon Resource Name (ARN) of a trail for which you want to get Insights selectors.</p>
    public let trailARN: String?

    public init (
        insightSelectors: [InsightSelector]? = nil,
        trailARN: String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct GetInsightSelectorsOutputResponseBody: Equatable {
    public let trailARN: String?
    public let insightSelectors: [InsightSelector]?
}

extension GetInsightSelectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

public struct GetTrailInputBodyMiddleware: Middleware {
    public let id: String = "GetTrailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailInput>
    public typealias MOutput = OperationOutput<GetTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailOutputError>
}

extension GetTrailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTrailInput(name: \(String(describing: name)))"}
}

extension GetTrailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTrailInputHeadersMiddleware: Middleware {
    public let id: String = "GetTrailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailInput>
    public typealias MOutput = OperationOutput<GetTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailOutputError>
}

public struct GetTrailInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTrailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailInput>
    public typealias MOutput = OperationOutput<GetTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailOutputError>
}

public struct GetTrailInput: Equatable {
    /// <p>The name or the Amazon Resource Name (ARN) of the trail for which you want to retrieve settings information.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailInputBody: Equatable {
    public let name: String?
}

extension GetTrailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrailOutputError: Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTrailOutputResponse(trail: \(String(describing: trail)))"}
}

extension GetTrailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTrailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.trail = output.trail
        } else {
            self.trail = nil
        }
    }
}

public struct GetTrailOutputResponse: Equatable {
    /// <p>The settings for a trail.</p>
    public let trail: Trail?

    public init (
        trail: Trail? = nil
    )
    {
        self.trail = trail
    }
}

struct GetTrailOutputResponseBody: Equatable {
    public let trail: Trail?
}

extension GetTrailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case trail = "Trail"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailDecoded = try containerValues.decodeIfPresent(Trail.self, forKey: .trail)
        trail = trailDecoded
    }
}

public struct GetTrailStatusInputBodyMiddleware: Middleware {
    public let id: String = "GetTrailStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailStatusInput>
    public typealias MOutput = OperationOutput<GetTrailStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailStatusOutputError>
}

extension GetTrailStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTrailStatusInput(name: \(String(describing: name)))"}
}

extension GetTrailStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetTrailStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetTrailStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailStatusInput>
    public typealias MOutput = OperationOutput<GetTrailStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailStatusOutputError>
}

public struct GetTrailStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTrailStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTrailStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTrailStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTrailStatusInput>
    public typealias MOutput = OperationOutput<GetTrailStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTrailStatusOutputError>
}

/// <p>The name of a trail about which you want the current status.</p>
public struct GetTrailStatusInput: Equatable {
    /// <p>Specifies the name or the CloudTrail ARN of the trail for which you are requesting status. To get the status of a shadow trail (a replication of the trail in another region), you must specify its ARN. The format of a trail ARN is:</p>
    ///           <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetTrailStatusInputBody: Equatable {
    public let name: String?
}

extension GetTrailStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetTrailStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTrailStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTrailStatusOutputError: Equatable {
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTrailStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTrailStatusOutputResponse(isLogging: \(String(describing: isLogging)), latestCloudWatchLogsDeliveryError: \(String(describing: latestCloudWatchLogsDeliveryError)), latestCloudWatchLogsDeliveryTime: \(String(describing: latestCloudWatchLogsDeliveryTime)), latestDeliveryAttemptSucceeded: \(String(describing: latestDeliveryAttemptSucceeded)), latestDeliveryAttemptTime: \(String(describing: latestDeliveryAttemptTime)), latestDeliveryError: \(String(describing: latestDeliveryError)), latestDeliveryTime: \(String(describing: latestDeliveryTime)), latestDigestDeliveryError: \(String(describing: latestDigestDeliveryError)), latestDigestDeliveryTime: \(String(describing: latestDigestDeliveryTime)), latestNotificationAttemptSucceeded: \(String(describing: latestNotificationAttemptSucceeded)), latestNotificationAttemptTime: \(String(describing: latestNotificationAttemptTime)), latestNotificationError: \(String(describing: latestNotificationError)), latestNotificationTime: \(String(describing: latestNotificationTime)), startLoggingTime: \(String(describing: startLoggingTime)), stopLoggingTime: \(String(describing: stopLoggingTime)), timeLoggingStarted: \(String(describing: timeLoggingStarted)), timeLoggingStopped: \(String(describing: timeLoggingStopped)))"}
}

extension GetTrailStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTrailStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.isLogging = output.isLogging
            self.latestCloudWatchLogsDeliveryError = output.latestCloudWatchLogsDeliveryError
            self.latestCloudWatchLogsDeliveryTime = output.latestCloudWatchLogsDeliveryTime
            self.latestDeliveryAttemptSucceeded = output.latestDeliveryAttemptSucceeded
            self.latestDeliveryAttemptTime = output.latestDeliveryAttemptTime
            self.latestDeliveryError = output.latestDeliveryError
            self.latestDeliveryTime = output.latestDeliveryTime
            self.latestDigestDeliveryError = output.latestDigestDeliveryError
            self.latestDigestDeliveryTime = output.latestDigestDeliveryTime
            self.latestNotificationAttemptSucceeded = output.latestNotificationAttemptSucceeded
            self.latestNotificationAttemptTime = output.latestNotificationAttemptTime
            self.latestNotificationError = output.latestNotificationError
            self.latestNotificationTime = output.latestNotificationTime
            self.startLoggingTime = output.startLoggingTime
            self.stopLoggingTime = output.stopLoggingTime
            self.timeLoggingStarted = output.timeLoggingStarted
            self.timeLoggingStopped = output.timeLoggingStopped
        } else {
            self.isLogging = nil
            self.latestCloudWatchLogsDeliveryError = nil
            self.latestCloudWatchLogsDeliveryTime = nil
            self.latestDeliveryAttemptSucceeded = nil
            self.latestDeliveryAttemptTime = nil
            self.latestDeliveryError = nil
            self.latestDeliveryTime = nil
            self.latestDigestDeliveryError = nil
            self.latestDigestDeliveryTime = nil
            self.latestNotificationAttemptSucceeded = nil
            self.latestNotificationAttemptTime = nil
            self.latestNotificationError = nil
            self.latestNotificationTime = nil
            self.startLoggingTime = nil
            self.stopLoggingTime = nil
            self.timeLoggingStarted = nil
            self.timeLoggingStopped = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct GetTrailStatusOutputResponse: Equatable {
    /// <p>Whether the CloudTrail is currently logging AWS API calls.</p>
    public let isLogging: Bool?
    /// <p>Displays any CloudWatch Logs error that CloudTrail encountered when attempting to deliver logs to CloudWatch Logs.</p>
    public let latestCloudWatchLogsDeliveryError: String?
    /// <p>Displays the most recent date and time when CloudTrail delivered logs to CloudWatch Logs.</p>
    public let latestCloudWatchLogsDeliveryTime: Date?
    /// <p>This field is no longer in use.</p>
    public let latestDeliveryAttemptSucceeded: String?
    /// <p>This field is no longer in use.</p>
    public let latestDeliveryAttemptTime: String?
    /// <p>Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver log files
    ///          to the designated bucket. For more information see the topic <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html">Error
    ///             Responses</a> in the Amazon S3 API Reference. </p>
    ///          <note>
    ///             <p>This error occurs only when there is a problem with the destination S3 bucket and will
    ///          not occur for timeouts. To resolve the issue, create a new bucket and call
    ///             <code>UpdateTrail</code> to specify the new bucket, or fix the existing objects so that
    ///          CloudTrail can again write to the bucket.</p>
    ///          </note>
    public let latestDeliveryError: String?
    /// <p>Specifies the date and time that CloudTrail last delivered log files to an account's Amazon S3 bucket.</p>
    public let latestDeliveryTime: Date?
    /// <p>Displays any Amazon S3 error that CloudTrail encountered when attempting to deliver a digest
    ///          file to the designated bucket. For more information see the topic <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html">Error
    ///             Responses</a> in the Amazon S3 API Reference. </p>
    ///          <note>
    ///             <p>This error occurs only when there is a problem with the destination S3 bucket and will
    ///          not occur for timeouts. To resolve the issue, create a new bucket and call
    ///             <code>UpdateTrail</code> to specify the new bucket, or fix the existing objects so that
    ///          CloudTrail can again write to the bucket.</p>
    ///          </note>
    public let latestDigestDeliveryError: String?
    /// <p>Specifies the date and time that CloudTrail last delivered a digest file to an account's Amazon S3 bucket.</p>
    public let latestDigestDeliveryTime: Date?
    /// <p>This field is no longer in use.</p>
    public let latestNotificationAttemptSucceeded: String?
    /// <p>This field is no longer in use.</p>
    public let latestNotificationAttemptTime: String?
    /// <p>Displays any Amazon SNS error that CloudTrail encountered when attempting to send a
    ///          notification. For more information about Amazon SNS errors, see the <a href="https://docs.aws.amazon.com/sns/latest/dg/welcome.html">Amazon SNS Developer Guide</a>.
    ///       </p>
    public let latestNotificationError: String?
    /// <p>Specifies the date and time of the most recent Amazon SNS notification that CloudTrail has written a new log file to an account's Amazon S3 bucket.</p>
    public let latestNotificationTime: Date?
    /// <p>Specifies the most recent date and time when CloudTrail started recording API calls for an AWS account.</p>
    public let startLoggingTime: Date?
    /// <p>Specifies the most recent date and time when CloudTrail stopped recording API calls for an AWS account.</p>
    public let stopLoggingTime: Date?
    /// <p>This field is no longer in use.</p>
    public let timeLoggingStarted: String?
    /// <p>This field is no longer in use.</p>
    public let timeLoggingStopped: String?

    public init (
        isLogging: Bool? = nil,
        latestCloudWatchLogsDeliveryError: String? = nil,
        latestCloudWatchLogsDeliveryTime: Date? = nil,
        latestDeliveryAttemptSucceeded: String? = nil,
        latestDeliveryAttemptTime: String? = nil,
        latestDeliveryError: String? = nil,
        latestDeliveryTime: Date? = nil,
        latestDigestDeliveryError: String? = nil,
        latestDigestDeliveryTime: Date? = nil,
        latestNotificationAttemptSucceeded: String? = nil,
        latestNotificationAttemptTime: String? = nil,
        latestNotificationError: String? = nil,
        latestNotificationTime: Date? = nil,
        startLoggingTime: Date? = nil,
        stopLoggingTime: Date? = nil,
        timeLoggingStarted: String? = nil,
        timeLoggingStopped: String? = nil
    )
    {
        self.isLogging = isLogging
        self.latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryError
        self.latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTime
        self.latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceeded
        self.latestDeliveryAttemptTime = latestDeliveryAttemptTime
        self.latestDeliveryError = latestDeliveryError
        self.latestDeliveryTime = latestDeliveryTime
        self.latestDigestDeliveryError = latestDigestDeliveryError
        self.latestDigestDeliveryTime = latestDigestDeliveryTime
        self.latestNotificationAttemptSucceeded = latestNotificationAttemptSucceeded
        self.latestNotificationAttemptTime = latestNotificationAttemptTime
        self.latestNotificationError = latestNotificationError
        self.latestNotificationTime = latestNotificationTime
        self.startLoggingTime = startLoggingTime
        self.stopLoggingTime = stopLoggingTime
        self.timeLoggingStarted = timeLoggingStarted
        self.timeLoggingStopped = timeLoggingStopped
    }
}

struct GetTrailStatusOutputResponseBody: Equatable {
    public let isLogging: Bool?
    public let latestDeliveryError: String?
    public let latestNotificationError: String?
    public let latestDeliveryTime: Date?
    public let latestNotificationTime: Date?
    public let startLoggingTime: Date?
    public let stopLoggingTime: Date?
    public let latestCloudWatchLogsDeliveryError: String?
    public let latestCloudWatchLogsDeliveryTime: Date?
    public let latestDigestDeliveryTime: Date?
    public let latestDigestDeliveryError: String?
    public let latestDeliveryAttemptTime: String?
    public let latestNotificationAttemptTime: String?
    public let latestNotificationAttemptSucceeded: String?
    public let latestDeliveryAttemptSucceeded: String?
    public let timeLoggingStarted: String?
    public let timeLoggingStopped: String?
}

extension GetTrailStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isLogging = "IsLogging"
        case latestCloudWatchLogsDeliveryError = "LatestCloudWatchLogsDeliveryError"
        case latestCloudWatchLogsDeliveryTime = "LatestCloudWatchLogsDeliveryTime"
        case latestDeliveryAttemptSucceeded = "LatestDeliveryAttemptSucceeded"
        case latestDeliveryAttemptTime = "LatestDeliveryAttemptTime"
        case latestDeliveryError = "LatestDeliveryError"
        case latestDeliveryTime = "LatestDeliveryTime"
        case latestDigestDeliveryError = "LatestDigestDeliveryError"
        case latestDigestDeliveryTime = "LatestDigestDeliveryTime"
        case latestNotificationAttemptSucceeded = "LatestNotificationAttemptSucceeded"
        case latestNotificationAttemptTime = "LatestNotificationAttemptTime"
        case latestNotificationError = "LatestNotificationError"
        case latestNotificationTime = "LatestNotificationTime"
        case startLoggingTime = "StartLoggingTime"
        case stopLoggingTime = "StopLoggingTime"
        case timeLoggingStarted = "TimeLoggingStarted"
        case timeLoggingStopped = "TimeLoggingStopped"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isLoggingDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isLogging)
        isLogging = isLoggingDecoded
        let latestDeliveryErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestDeliveryError)
        latestDeliveryError = latestDeliveryErrorDecoded
        let latestNotificationErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestNotificationError)
        latestNotificationError = latestNotificationErrorDecoded
        let latestDeliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestDeliveryTime)
        latestDeliveryTime = latestDeliveryTimeDecoded
        let latestNotificationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestNotificationTime)
        latestNotificationTime = latestNotificationTimeDecoded
        let startLoggingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startLoggingTime)
        startLoggingTime = startLoggingTimeDecoded
        let stopLoggingTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stopLoggingTime)
        stopLoggingTime = stopLoggingTimeDecoded
        let latestCloudWatchLogsDeliveryErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestCloudWatchLogsDeliveryError)
        latestCloudWatchLogsDeliveryError = latestCloudWatchLogsDeliveryErrorDecoded
        let latestCloudWatchLogsDeliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestCloudWatchLogsDeliveryTime)
        latestCloudWatchLogsDeliveryTime = latestCloudWatchLogsDeliveryTimeDecoded
        let latestDigestDeliveryTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestDigestDeliveryTime)
        latestDigestDeliveryTime = latestDigestDeliveryTimeDecoded
        let latestDigestDeliveryErrorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestDigestDeliveryError)
        latestDigestDeliveryError = latestDigestDeliveryErrorDecoded
        let latestDeliveryAttemptTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestDeliveryAttemptTime)
        latestDeliveryAttemptTime = latestDeliveryAttemptTimeDecoded
        let latestNotificationAttemptTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestNotificationAttemptTime)
        latestNotificationAttemptTime = latestNotificationAttemptTimeDecoded
        let latestNotificationAttemptSucceededDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestNotificationAttemptSucceeded)
        latestNotificationAttemptSucceeded = latestNotificationAttemptSucceededDecoded
        let latestDeliveryAttemptSucceededDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestDeliveryAttemptSucceeded)
        latestDeliveryAttemptSucceeded = latestDeliveryAttemptSucceededDecoded
        let timeLoggingStartedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeLoggingStarted)
        timeLoggingStarted = timeLoggingStartedDecoded
        let timeLoggingStoppedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeLoggingStopped)
        timeLoggingStopped = timeLoggingStoppedDecoded
    }
}

extension InsightNotEnabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightNotEnabledException(message: \(String(describing: message)))"}
}

extension InsightNotEnabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsightNotEnabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>If you run <code>GetInsightSelectors</code> on a trail that does not have Insights events enabled, the operation throws the exception <code>InsightNotEnabledException</code>.</p>
public struct InsightNotEnabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsightNotEnabledExceptionBody: Equatable {
    public let message: String?
}

extension InsightNotEnabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsightSelector: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightType = "InsightType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightType = insightType {
            try encodeContainer.encode(insightType.rawValue, forKey: .insightType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let insightTypeDecoded = try containerValues.decodeIfPresent(InsightType.self, forKey: .insightType)
        insightType = insightTypeDecoded
    }
}

extension InsightSelector: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsightSelector(insightType: \(String(describing: insightType)))"}
}

/// <p>A JSON string that contains a list of insight types that are logged on a trail.</p>
public struct InsightSelector: Equatable {
    /// <p>The type of insights to log on a trail. In this release, only <code>ApiCallRateInsight</code> is supported as an insight type.</p>
    public let insightType: InsightType?

    public init (
        insightType: InsightType? = nil
    )
    {
        self.insightType = insightType
    }
}

public enum InsightType {
    case apicallrateinsight
    case sdkUnknown(String)
}

extension InsightType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InsightType] {
        return [
            .apicallrateinsight,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .apicallrateinsight: return "ApiCallRateInsight"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InsightType(rawValue: rawValue) ?? InsightType.sdkUnknown(rawValue)
    }
}

extension InsufficientDependencyServiceAccessPermissionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientDependencyServiceAccessPermissionException(message: \(String(describing: message)))"}
}

extension InsufficientDependencyServiceAccessPermissionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientDependencyServiceAccessPermissionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the IAM user or role that is used to create the organization trail is lacking one or more required permissions for
///          creating an organization trail in a required service. For more information, see
///          <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
public struct InsufficientDependencyServiceAccessPermissionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientDependencyServiceAccessPermissionExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientDependencyServiceAccessPermissionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientEncryptionPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientEncryptionPolicyException(message: \(String(describing: message)))"}
}

extension InsufficientEncryptionPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientEncryptionPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the policy on the S3 bucket or KMS key is not sufficient.</p>
public struct InsufficientEncryptionPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientEncryptionPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientEncryptionPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientS3BucketPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientS3BucketPolicyException(message: \(String(describing: message)))"}
}

extension InsufficientS3BucketPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientS3BucketPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the policy on the S3 bucket is not sufficient.</p>
public struct InsufficientS3BucketPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientS3BucketPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientS3BucketPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InsufficientSnsTopicPolicyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientSnsTopicPolicyException(message: \(String(describing: message)))"}
}

extension InsufficientSnsTopicPolicyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientSnsTopicPolicyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the policy on the SNS topic is not sufficient.</p>
public struct InsufficientSnsTopicPolicyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientSnsTopicPolicyExceptionBody: Equatable {
    public let message: String?
}

extension InsufficientSnsTopicPolicyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsLogGroupArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCloudWatchLogsLogGroupArnException(message: \(String(describing: message)))"}
}

extension InvalidCloudWatchLogsLogGroupArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCloudWatchLogsLogGroupArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided CloudWatch log group is not valid.</p>
public struct InvalidCloudWatchLogsLogGroupArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsLogGroupArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCloudWatchLogsLogGroupArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidCloudWatchLogsRoleArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCloudWatchLogsRoleArnException(message: \(String(describing: message)))"}
}

extension InvalidCloudWatchLogsRoleArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCloudWatchLogsRoleArnExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided role is not valid.</p>
public struct InvalidCloudWatchLogsRoleArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCloudWatchLogsRoleArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidCloudWatchLogsRoleArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventCategoryException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEventCategoryException(message: \(String(describing: message)))"}
}

extension InvalidEventCategoryException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEventCategoryExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs if an event category that is not valid is specified as a value of <code>EventCategory</code>.</p>
public struct InvalidEventCategoryException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventCategoryExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEventCategoryExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventSelectorsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEventSelectorsException(message: \(String(describing: message)))"}
}

extension InvalidEventSelectorsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEventSelectorsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the <code>PutEventSelectors</code> operation is called with a number of event
///          selectors, advanced event selectors, or data resources that is not valid. The combination of event selectors or advanced event selectors and
///          data resources is not valid. A trail can have up to 5 event selectors. If a trail uses advanced event selectors, a maximum
///          of 500 total values for all conditions in all advanced event selectors is allowed. A trail is limited to 250 data resources. These data resources can be distributed across event selectors, but the overall total cannot exceed 250.</p>
///          <p>You can:</p>
///          <ul>
///             <li>
///                <p>Specify a valid number of event selectors (1 to 5) for a trail.</p>
///             </li>
///             <li>
///                <p>Specify a valid number of data resources (1 to 250) for an event selector.
///                The limit of number of resources on an individual event selector is configurable up to 250.
///                However, this upper limit is allowed only if the total number of data resources does not
///                exceed 250 across all event selectors for a trail.</p>
///             </li>
///             <li>
///                <p>Specify up to 500 values for all conditions in all advanced event selectors for a trail.</p>
///             </li>
///             <li>
///                <p>Specify a valid value for a parameter. For example, specifying the <code>ReadWriteType</code>
///                parameter with a value of <code>read-only</code> is invalid.</p>
///             </li>
///          </ul>
public struct InvalidEventSelectorsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventSelectorsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEventSelectorsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidHomeRegionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidHomeRegionException(message: \(String(describing: message)))"}
}

extension InvalidHomeRegionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidHomeRegionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when an operation is called on a trail from a region other than the region in which the trail was created.</p>
public struct InvalidHomeRegionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidHomeRegionExceptionBody: Equatable {
    public let message: String?
}

extension InvalidHomeRegionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInsightSelectorsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInsightSelectorsException(message: \(String(describing: message)))"}
}

extension InvalidInsightSelectorsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInsightSelectorsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The formatting or syntax of the <code>InsightSelectors</code> JSON statement in your <code>PutInsightSelectors</code> or <code>GetInsightSelectors</code> request
///          is not valid, or the specified insight type in the <code>InsightSelectors</code> statement is not a valid insight type.</p>
public struct InvalidInsightSelectorsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInsightSelectorsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInsightSelectorsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidKmsKeyIdException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidKmsKeyIdException(message: \(String(describing: message)))"}
}

extension InvalidKmsKeyIdException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidKmsKeyIdExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the KMS key ARN is invalid.</p>
public struct InvalidKmsKeyIdException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidKmsKeyIdExceptionBody: Equatable {
    public let message: String?
}

extension InvalidKmsKeyIdExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLookupAttributesException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidLookupAttributesException(message: \(String(describing: message)))"}
}

extension InvalidLookupAttributesException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidLookupAttributesExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs when an invalid lookup attribute is specified.</p>
public struct InvalidLookupAttributesException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidLookupAttributesExceptionBody: Equatable {
    public let message: String?
}

extension InvalidLookupAttributesExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidMaxResultsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidMaxResultsException(message: \(String(describing: message)))"}
}

extension InvalidMaxResultsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidMaxResultsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown if the limit specified is invalid.</p>
public struct InvalidMaxResultsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidMaxResultsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidMaxResultsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Invalid token or token that was previously used in a request with different parameters. This exception is thrown if the token is invalid.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterCombinationException(message: \(String(describing: message)))"}
}

extension InvalidParameterCombinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the combination of parameters provided is not valid.</p>
public struct InvalidParameterCombinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterCombinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3BucketNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3BucketNameException(message: \(String(describing: message)))"}
}

extension InvalidS3BucketNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3BucketNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided S3 bucket name is not valid.</p>
public struct InvalidS3BucketNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3BucketNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3BucketNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidS3PrefixException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidS3PrefixException(message: \(String(describing: message)))"}
}

extension InvalidS3PrefixException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidS3PrefixExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided S3 prefix is not valid.</p>
public struct InvalidS3PrefixException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidS3PrefixExceptionBody: Equatable {
    public let message: String?
}

extension InvalidS3PrefixExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSnsTopicNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSnsTopicNameException(message: \(String(describing: message)))"}
}

extension InvalidSnsTopicNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSnsTopicNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided SNS topic name is not valid.</p>
public struct InvalidSnsTopicNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSnsTopicNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidSnsTopicNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagParameterException(message: \(String(describing: message)))"}
}

extension InvalidTagParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified tag key or values are not valid.
///          It can also occur if there are duplicate tags or too many tags on the resource.</p>
public struct InvalidTagParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTimeRangeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTimeRangeException(message: \(String(describing: message)))"}
}

extension InvalidTimeRangeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTimeRangeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Occurs if the timestamp values are invalid. Either the start time occurs after the end time or the time range is outside the range of possible values.</p>
public struct InvalidTimeRangeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTimeRangeExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTimeRangeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTokenException(message: \(String(describing: message)))"}
}

extension InvalidTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Reserved for future use.</p>
public struct InvalidTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTrailNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTrailNameException(message: \(String(describing: message)))"}
}

extension InvalidTrailNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidTrailNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the provided trail name is not valid. Trail names must meet the following requirements:</p>
///          <ul>
///             <li>
///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
///             </li>
///             <li>
///                <p>Start with a letter or number, and end with a letter or number</p>
///             </li>
///             <li>
///                <p>Be between 3 and 128 characters</p>
///             </li>
///             <li>
///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
///             and <code>my--namespace</code> are invalid.</p>
///             </li>
///             <li>
///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
///             </li>
///          </ul>
public struct InvalidTrailNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTrailNameExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTrailNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsException(message: \(String(describing: message)))"}
}

extension KmsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when there is an issue with the specified KMS key and the trail can’t be updated.</p>
public struct KmsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KmsExceptionBody: Equatable {
    public let message: String?
}

extension KmsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsKeyDisabledException(message: \(String(describing: message)))"}
}

extension KmsKeyDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KmsKeyDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is no longer in use.</p>
@available(*, deprecated)
public struct KmsKeyDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyDisabledExceptionBody: Equatable {
    public let message: String?
}

extension KmsKeyDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsKeyNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsKeyNotFoundException(message: \(String(describing: message)))"}
}

extension KmsKeyNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KmsKeyNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the AWS KMS key does not exist, when the S3 bucket and the
///          AWS KMS key are not in the same region, or when the AWS KMS key associated with the SNS
///          topic either does not exist or is not in the same region.</p>
public struct KmsKeyNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KmsKeyNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension KmsKeyNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListPublicKeysInputBodyMiddleware: Middleware {
    public let id: String = "ListPublicKeysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublicKeysOutputError>
}

extension ListPublicKeysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublicKeysInput(endTime: \(String(describing: endTime)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension ListPublicKeysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct ListPublicKeysInputHeadersMiddleware: Middleware {
    public let id: String = "ListPublicKeysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublicKeysOutputError>
}

public struct ListPublicKeysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPublicKeysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPublicKeysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPublicKeysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPublicKeysInput>
    public typealias MOutput = OperationOutput<ListPublicKeysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPublicKeysOutputError>
}

/// <p>Requests the public keys for a specified time range.</p>
public struct ListPublicKeysInput: Equatable {
    /// <p>Optionally specifies, in UTC, the end of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used.</p>
    public let endTime: Date?
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>Optionally specifies, in UTC, the start of the time range to look up public keys for CloudTrail digest files. If not specified, the current time is used, and the current public key is returned.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct ListPublicKeysInputBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let nextToken: String?
}

extension ListPublicKeysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublicKeysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublicKeysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidTimeRangeException" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPublicKeysOutputError: Equatable {
    case invalidTimeRangeException(InvalidTimeRangeException)
    case invalidTokenException(InvalidTokenException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublicKeysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPublicKeysOutputResponse(nextToken: \(String(describing: nextToken)), publicKeyList: \(String(describing: publicKeyList)))"}
}

extension ListPublicKeysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPublicKeysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.publicKeyList = output.publicKeyList
        } else {
            self.nextToken = nil
            self.publicKeyList = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct ListPublicKeysOutputResponse: Equatable {
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>Contains an array of PublicKey objects.</p>
    ///          <note>
    ///             <p>The returned public keys may have validity time ranges that overlap.</p>
    ///          </note>
    public let publicKeyList: [PublicKey]?

    public init (
        nextToken: String? = nil,
        publicKeyList: [PublicKey]? = nil
    )
    {
        self.nextToken = nextToken
        self.publicKeyList = publicKeyList
    }
}

struct ListPublicKeysOutputResponseBody: Equatable {
    public let publicKeyList: [PublicKey]?
    public let nextToken: String?
}

extension ListPublicKeysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case publicKeyList = "PublicKeyList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyListContainer = try containerValues.decodeIfPresent([PublicKey?].self, forKey: .publicKeyList)
        var publicKeyListDecoded0:[PublicKey]? = nil
        if let publicKeyListContainer = publicKeyListContainer {
            publicKeyListDecoded0 = [PublicKey]()
            for structure0 in publicKeyListContainer {
                if let structure0 = structure0 {
                    publicKeyListDecoded0?.append(structure0)
                }
            }
        }
        publicKeyList = publicKeyListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(nextToken: \(String(describing: nextToken)), resourceIdList: \(String(describing: resourceIdList)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceIdList = resourceIdList {
            var resourceIdListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIdList)
            for resourceidlist0 in resourceIdList {
                try resourceIdListContainer.encode(resourceidlist0)
            }
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

/// <p>Specifies a list of trail tags to return.</p>
public struct ListTagsInput: Equatable {
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>Specifies a list of trail ARNs whose tags will be listed. The list has a limit of 20 ARNs. The format of a trail ARN is:</p>
    ///             <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let resourceIdList: [String]?

    public init (
        nextToken: String? = nil,
        resourceIdList: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceIdList = resourceIdList
    }
}

struct ListTagsInputBody: Equatable {
    public let resourceIdList: [String]?
    public let nextToken: String?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceIdList = "ResourceIdList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceIdList)
        var resourceIdListDecoded0:[String]? = nil
        if let resourceIdListContainer = resourceIdListContainer {
            resourceIdListDecoded0 = [String]()
            for string0 in resourceIdListContainer {
                if let string0 = string0 {
                    resourceIdListDecoded0?.append(string0)
                }
            }
        }
        resourceIdList = resourceIdListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalidException" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTokenException" : self = .invalidTokenException(try InvalidTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupportedException" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTokenException(InvalidTokenException)
    case invalidTrailNameException(InvalidTrailNameException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), resourceTagList: \(String(describing: resourceTagList)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourceTagList = output.resourceTagList
        } else {
            self.nextToken = nil
            self.resourceTagList = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct ListTagsOutputResponse: Equatable {
    /// <p>Reserved for future use.</p>
    public let nextToken: String?
    /// <p>A list of resource tags.</p>
    public let resourceTagList: [ResourceTag]?

    public init (
        nextToken: String? = nil,
        resourceTagList: [ResourceTag]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceTagList = resourceTagList
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let resourceTagList: [ResourceTag]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceTagList = "ResourceTagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTagListContainer = try containerValues.decodeIfPresent([ResourceTag?].self, forKey: .resourceTagList)
        var resourceTagListDecoded0:[ResourceTag]? = nil
        if let resourceTagListContainer = resourceTagListContainer {
            resourceTagListDecoded0 = [ResourceTag]()
            for structure0 in resourceTagListContainer {
                if let structure0 = structure0 {
                    resourceTagListDecoded0?.append(structure0)
                }
            }
        }
        resourceTagList = resourceTagListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTrailsInputBodyMiddleware: Middleware {
    public let id: String = "ListTrailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTrailsInput>
    public typealias MOutput = OperationOutput<ListTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTrailsOutputError>
}

extension ListTrailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTrailsInput(nextToken: \(String(describing: nextToken)))"}
}

extension ListTrailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListTrailsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTrailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTrailsInput>
    public typealias MOutput = OperationOutput<ListTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTrailsOutputError>
}

public struct ListTrailsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTrailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTrailsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTrailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTrailsInput>
    public typealias MOutput = OperationOutput<ListTrailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTrailsOutputError>
}

public struct ListTrailsInput: Equatable {
    /// <p>The token to use to get the next page of results after a previous API call. This token must be passed
    ///          in with the same parameters that were specified in the the original call. For example, if the original
    ///          call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should
    ///          include those same parameters.</p>
    public let nextToken: String?

    public init (
        nextToken: String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListTrailsInputBody: Equatable {
    public let nextToken: String?
}

extension ListTrailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTrailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTrailsOutputError: Equatable {
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTrailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTrailsOutputResponse(nextToken: \(String(describing: nextToken)), trails: \(String(describing: trails)))"}
}

extension ListTrailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTrailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.trails = output.trails
        } else {
            self.nextToken = nil
            self.trails = nil
        }
    }
}

public struct ListTrailsOutputResponse: Equatable {
    /// <p>The token to use to get the next page of results after a previous API call. If the token does not appear,
    ///          there are no more results to return. The token must be passed in with the same parameters as the previous call.
    ///          For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with
    ///          NextToken should include those same parameters.</p>
    public let nextToken: String?
    /// <p>Returns the name, ARN, and home region of trails in the current account.</p>
    public let trails: [TrailInfo]?

    public init (
        nextToken: String? = nil,
        trails: [TrailInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.trails = trails
    }
}

struct ListTrailsOutputResponseBody: Equatable {
    public let trails: [TrailInfo]?
    public let nextToken: String?
}

extension ListTrailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case trails = "Trails"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([TrailInfo?].self, forKey: .trails)
        var trailsDecoded0:[TrailInfo]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [TrailInfo]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeKey = "AttributeKey"
        case attributeValue = "AttributeValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKey = attributeKey {
            try encodeContainer.encode(attributeKey.rawValue, forKey: .attributeKey)
        }
        if let attributeValue = attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeKeyDecoded = try containerValues.decodeIfPresent(LookupAttributeKey.self, forKey: .attributeKey)
        attributeKey = attributeKeyDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension LookupAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupAttribute(attributeKey: \(String(describing: attributeKey)), attributeValue: \(String(describing: attributeValue)))"}
}

/// <p>Specifies an attribute and value that filter the events returned.</p>
public struct LookupAttribute: Equatable {
    /// <p>Specifies an attribute on which to filter the events returned.</p>
    public let attributeKey: LookupAttributeKey?
    /// <p>Specifies a value for the specified AttributeKey.</p>
    public let attributeValue: String?

    public init (
        attributeKey: LookupAttributeKey? = nil,
        attributeValue: String? = nil
    )
    {
        self.attributeKey = attributeKey
        self.attributeValue = attributeValue
    }
}

public enum LookupAttributeKey {
    case accessKeyId
    case eventId
    case eventName
    case eventSource
    case readOnly
    case resourceName
    case resourceType
    case username
    case sdkUnknown(String)
}

extension LookupAttributeKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LookupAttributeKey] {
        return [
            .accessKeyId,
            .eventId,
            .eventName,
            .eventSource,
            .readOnly,
            .resourceName,
            .resourceType,
            .username,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessKeyId: return "AccessKeyId"
        case .eventId: return "EventId"
        case .eventName: return "EventName"
        case .eventSource: return "EventSource"
        case .readOnly: return "ReadOnly"
        case .resourceName: return "ResourceName"
        case .resourceType: return "ResourceType"
        case .username: return "Username"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LookupAttributeKey(rawValue: rawValue) ?? LookupAttributeKey.sdkUnknown(rawValue)
    }
}

public struct LookupEventsInputBodyMiddleware: Middleware {
    public let id: String = "LookupEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupEventsInput>
    public typealias MOutput = OperationOutput<LookupEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupEventsOutputError>
}

extension LookupEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupEventsInput(endTime: \(String(describing: endTime)), eventCategory: \(String(describing: eventCategory)), lookupAttributes: \(String(describing: lookupAttributes)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

extension LookupEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventCategory = eventCategory {
            try encodeContainer.encode(eventCategory.rawValue, forKey: .eventCategory)
        }
        if let lookupAttributes = lookupAttributes {
            var lookupAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lookupAttributes)
            for lookupattributeslist0 in lookupAttributes {
                try lookupAttributesContainer.encode(lookupattributeslist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct LookupEventsInputHeadersMiddleware: Middleware {
    public let id: String = "LookupEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupEventsInput>
    public typealias MOutput = OperationOutput<LookupEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupEventsOutputError>
}

public struct LookupEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "LookupEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupEventsInput>
    public typealias MOutput = OperationOutput<LookupEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupEventsOutputError>
}

/// <p>Contains a request for LookupEvents.</p>
public struct LookupEventsInput: Equatable {
    /// <p>Specifies that only events that occur before or at the specified time are returned. If the specified end time is before the specified start time, an error is returned.</p>
    public let endTime: Date?
    /// <p>Specifies the event category. If you do not specify an event category, events of the category are not returned in the response. For example,
    ///          if you do not specify <code>insight</code> as the value of <code>EventCategory</code>, no Insights events are returned.</p>
    public let eventCategory: EventCategory?
    /// <p>Contains a list of lookup attributes. Currently the list can contain only one item.</p>
    public let lookupAttributes: [LookupAttribute]?
    /// <p>The number of events to return. Possible values are 1 through 50. The default is 50.</p>
    public let maxResults: Int?
    /// <p>The token to use to get the next page of results after a previous API call. This token must be passed in with the same parameters that were specified in the the original call.
    ///          For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with NextToken should include those same parameters.</p>
    public let nextToken: String?
    /// <p>Specifies that only events that occur after or at the specified time are returned. If the specified start time is after the specified end time, an error is returned.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        eventCategory: EventCategory? = nil,
        lookupAttributes: [LookupAttribute]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.eventCategory = eventCategory
        self.lookupAttributes = lookupAttributes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

struct LookupEventsInputBody: Equatable {
    public let lookupAttributes: [LookupAttribute]?
    public let startTime: Date?
    public let endTime: Date?
    public let eventCategory: EventCategory?
    public let maxResults: Int?
    public let nextToken: String?
}

extension LookupEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case eventCategory = "EventCategory"
        case lookupAttributes = "LookupAttributes"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lookupAttributesContainer = try containerValues.decodeIfPresent([LookupAttribute?].self, forKey: .lookupAttributes)
        var lookupAttributesDecoded0:[LookupAttribute]? = nil
        if let lookupAttributesContainer = lookupAttributesContainer {
            lookupAttributesDecoded0 = [LookupAttribute]()
            for structure0 in lookupAttributesContainer {
                if let structure0 = structure0 {
                    lookupAttributesDecoded0?.append(structure0)
                }
            }
        }
        lookupAttributes = lookupAttributesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let eventCategoryDecoded = try containerValues.decodeIfPresent(EventCategory.self, forKey: .eventCategory)
        eventCategory = eventCategoryDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidEventCategoryException" : self = .invalidEventCategoryException(try InvalidEventCategoryException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidLookupAttributesException" : self = .invalidLookupAttributesException(try InvalidLookupAttributesException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidMaxResultsException" : self = .invalidMaxResultsException(try InvalidMaxResultsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTimeRangeException" : self = .invalidTimeRangeException(try InvalidTimeRangeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupEventsOutputError: Equatable {
    case invalidEventCategoryException(InvalidEventCategoryException)
    case invalidLookupAttributesException(InvalidLookupAttributesException)
    case invalidMaxResultsException(InvalidMaxResultsException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidTimeRangeException(InvalidTimeRangeException)
    case operationNotPermittedException(OperationNotPermittedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupEventsOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension LookupEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LookupEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

/// <p>Contains a response to a LookupEvents action.</p>
public struct LookupEventsOutputResponse: Equatable {
    /// <p>A list of events returned based on the lookup attributes specified and the CloudTrail event. The events list is sorted by time. The most recent event is listed first.</p>
    public let events: [Event]?
    /// <p>The token to use to get the next page of results after a previous API call. If the token does not appear,
    ///          there are no more results to return. The token must be passed in with the same parameters as the previous call.
    ///          For example, if the original call specified an AttributeKey of 'Username' with a value of 'root', the call with
    ///          NextToken should include those same parameters.</p>
    public let nextToken: String?

    public init (
        events: [Event]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct LookupEventsOutputResponseBody: Equatable {
    public let events: [Event]?
    public let nextToken: String?
}

extension LookupEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MaximumNumberOfTrailsExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MaximumNumberOfTrailsExceededException(message: \(String(describing: message)))"}
}

extension MaximumNumberOfTrailsExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MaximumNumberOfTrailsExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the maximum number of trails is reached.</p>
public struct MaximumNumberOfTrailsExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MaximumNumberOfTrailsExceededExceptionBody: Equatable {
    public let message: String?
}

extension MaximumNumberOfTrailsExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotOrganizationMasterAccountException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotOrganizationMasterAccountException(message: \(String(describing: message)))"}
}

extension NotOrganizationMasterAccountException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotOrganizationMasterAccountExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the AWS account making the request to create or update an organization trail is not the master account for an
///          organization in AWS Organizations. For more information, see
///          <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
public struct NotOrganizationMasterAccountException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotOrganizationMasterAccountExceptionBody: Equatable {
    public let message: String?
}

extension NotOrganizationMasterAccountExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OperationNotPermittedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationNotPermittedException(message: \(String(describing: message)))"}
}

extension OperationNotPermittedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the requested operation is not permitted.</p>
public struct OperationNotPermittedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotPermittedExceptionBody: Equatable {
    public let message: String?
}

extension OperationNotPermittedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotInAllFeaturesModeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationNotInAllFeaturesModeException(message: \(String(describing: message)))"}
}

extension OrganizationNotInAllFeaturesModeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationNotInAllFeaturesModeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when AWS Organizations is not configured to support all features. All features must be enabled in AWS Organization to support
///          creating an organization trail. For more information, see
///          <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/creating-an-organizational-trail-prepare.html">Prepare For Creating a Trail For Your Organization</a>.</p>
public struct OrganizationNotInAllFeaturesModeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotInAllFeaturesModeExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationNotInAllFeaturesModeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationsNotInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationsNotInUseException(message: \(String(describing: message)))"}
}

extension OrganizationsNotInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationsNotInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the request is made from an AWS account that is not a member of an organization.
///          To make this request, sign in using the credentials of an account that belongs to an organization.</p>
public struct OrganizationsNotInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationsNotInUseExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationsNotInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PublicKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fingerprint = "Fingerprint"
        case validityEndTime = "ValidityEndTime"
        case validityStartTime = "ValidityStartTime"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let validityEndTime = validityEndTime {
            try encodeContainer.encode(validityEndTime.timeIntervalSince1970, forKey: .validityEndTime)
        }
        if let validityStartTime = validityStartTime {
            try encodeContainer.encode(validityStartTime.timeIntervalSince1970, forKey: .validityStartTime)
        }
        if let value = value {
            try encodeContainer.encode(value.base64EncodedString(), forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .value)
        value = valueDecoded
        let validityStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validityStartTime)
        validityStartTime = validityStartTimeDecoded
        let validityEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .validityEndTime)
        validityEndTime = validityEndTimeDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
    }
}

extension PublicKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicKey(fingerprint: \(String(describing: fingerprint)), validityEndTime: \(String(describing: validityEndTime)), validityStartTime: \(String(describing: validityStartTime)), value: \(String(describing: value)))"}
}

/// <p>Contains information about a returned public key.</p>
public struct PublicKey: Equatable {
    /// <p>The fingerprint of the public key.</p>
    public let fingerprint: String?
    /// <p>The ending time of validity of the public key.</p>
    public let validityEndTime: Date?
    /// <p>The starting time of validity of the public key.</p>
    public let validityStartTime: Date?
    /// <p>The DER encoded public key value in PKCS#1 format.</p>
    public let value: Data?

    public init (
        fingerprint: String? = nil,
        validityEndTime: Date? = nil,
        validityStartTime: Date? = nil,
        value: Data? = nil
    )
    {
        self.fingerprint = fingerprint
        self.validityEndTime = validityEndTime
        self.validityStartTime = validityStartTime
        self.value = value
    }
}

public struct PutEventSelectorsInputBodyMiddleware: Middleware {
    public let id: String = "PutEventSelectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventSelectorsInput>
    public typealias MOutput = OperationOutput<PutEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventSelectorsOutputError>
}

extension PutEventSelectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventSelectorsInput(advancedEventSelectors: \(String(describing: advancedEventSelectors)), eventSelectors: \(String(describing: eventSelectors)), trailName: \(String(describing: trailName)))"}
}

extension PutEventSelectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let advancedEventSelectors = advancedEventSelectors {
            var advancedEventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .advancedEventSelectors)
            for advancedeventselectors0 in advancedEventSelectors {
                try advancedEventSelectorsContainer.encode(advancedeventselectors0)
            }
        }
        if let eventSelectors = eventSelectors {
            var eventSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSelectors)
            for eventselectors0 in eventSelectors {
                try eventSelectorsContainer.encode(eventselectors0)
            }
        }
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

public struct PutEventSelectorsInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventSelectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventSelectorsInput>
    public typealias MOutput = OperationOutput<PutEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventSelectorsOutputError>
}

public struct PutEventSelectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventSelectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventSelectorsInput>
    public typealias MOutput = OperationOutput<PutEventSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventSelectorsOutputError>
}

public struct PutEventSelectorsInput: Equatable {
    /// <p>
    ///          Specifies the settings for advanced event selectors. You can add advanced event selectors, and conditions for your advanced
    ///          event selectors, up to a maximum of 500 values for all conditions and selectors on a trail.
    ///          You can use either <code>AdvancedEventSelectors</code> or <code>EventSelectors</code>, but not both. If you apply <code>AdvancedEventSelectors</code>
    ///          to a trail, any existing <code>EventSelectors</code> are overwritten. For more information about
    ///          advanced event selectors, see
    ///          <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/logging-data-events-with-cloudtrail.html">Logging
    ///             data events for trails</a> in the <i>AWS CloudTrail User Guide</i>.
    ///       </p>
    public let advancedEventSelectors: [AdvancedEventSelector]?
    /// <p>Specifies the settings for your event selectors. You can configure up to five event selectors for a trail.
    ///          You can use either <code>EventSelectors</code> or <code>AdvancedEventSelectors</code> in a <code>PutEventSelectors</code> request, but not both.
    ///          If you apply <code>EventSelectors</code> to a trail, any existing <code>AdvancedEventSelectors</code> are overwritten.</p>
    public let eventSelectors: [EventSelector]?
    /// <p>Specifies the name of the trail or trail ARN. If you specify a trail name, the
    ///          string must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    ///             </li>
    ///             <li>
    ///                <p>Start with a letter or number, and end with a letter or number</p>
    ///             </li>
    ///             <li>
    ///                <p>Be between 3 and 128 characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    ///                and <code>my--namespace</code> are invalid.</p>
    ///             </li>
    ///             <li>
    ///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify a trail ARN, it must be in the format:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailName: String?

    public init (
        advancedEventSelectors: [AdvancedEventSelector]? = nil,
        eventSelectors: [EventSelector]? = nil,
        trailName: String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailName = trailName
    }
}

struct PutEventSelectorsInputBody: Equatable {
    public let trailName: String?
    public let eventSelectors: [EventSelector]?
    public let advancedEventSelectors: [AdvancedEventSelector]?
}

extension PutEventSelectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

extension PutEventSelectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventSelectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectorsException" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventSelectorsOutputError: Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventSelectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventSelectorsOutputResponse(advancedEventSelectors: \(String(describing: advancedEventSelectors)), eventSelectors: \(String(describing: eventSelectors)), trailARN: \(String(describing: trailARN)))"}
}

extension PutEventSelectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutEventSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.advancedEventSelectors = output.advancedEventSelectors
            self.eventSelectors = output.eventSelectors
            self.trailARN = output.trailARN
        } else {
            self.advancedEventSelectors = nil
            self.eventSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutEventSelectorsOutputResponse: Equatable {
    /// <p>Specifies the advanced event selectors configured for your trail.</p>
    public let advancedEventSelectors: [AdvancedEventSelector]?
    /// <p>Specifies the event selectors configured for your trail.</p>
    public let eventSelectors: [EventSelector]?
    /// <p>Specifies the ARN of the trail that was updated with event selectors. The format of a trail ARN
    ///          is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailARN: String?

    public init (
        advancedEventSelectors: [AdvancedEventSelector]? = nil,
        eventSelectors: [EventSelector]? = nil,
        trailARN: String? = nil
    )
    {
        self.advancedEventSelectors = advancedEventSelectors
        self.eventSelectors = eventSelectors
        self.trailARN = trailARN
    }
}

struct PutEventSelectorsOutputResponseBody: Equatable {
    public let trailARN: String?
    public let eventSelectors: [EventSelector]?
    public let advancedEventSelectors: [AdvancedEventSelector]?
}

extension PutEventSelectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case advancedEventSelectors = "AdvancedEventSelectors"
        case eventSelectors = "EventSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let eventSelectorsContainer = try containerValues.decodeIfPresent([EventSelector?].self, forKey: .eventSelectors)
        var eventSelectorsDecoded0:[EventSelector]? = nil
        if let eventSelectorsContainer = eventSelectorsContainer {
            eventSelectorsDecoded0 = [EventSelector]()
            for structure0 in eventSelectorsContainer {
                if let structure0 = structure0 {
                    eventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        eventSelectors = eventSelectorsDecoded0
        let advancedEventSelectorsContainer = try containerValues.decodeIfPresent([AdvancedEventSelector?].self, forKey: .advancedEventSelectors)
        var advancedEventSelectorsDecoded0:[AdvancedEventSelector]? = nil
        if let advancedEventSelectorsContainer = advancedEventSelectorsContainer {
            advancedEventSelectorsDecoded0 = [AdvancedEventSelector]()
            for structure0 in advancedEventSelectorsContainer {
                if let structure0 = structure0 {
                    advancedEventSelectorsDecoded0?.append(structure0)
                }
            }
        }
        advancedEventSelectors = advancedEventSelectorsDecoded0
    }
}

public struct PutInsightSelectorsInputBodyMiddleware: Middleware {
    public let id: String = "PutInsightSelectorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInsightSelectorsInput>
    public typealias MOutput = OperationOutput<PutInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInsightSelectorsOutputError>
}

extension PutInsightSelectorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInsightSelectorsInput(insightSelectors: \(String(describing: insightSelectors)), trailName: \(String(describing: trailName)))"}
}

extension PutInsightSelectorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let insightSelectors = insightSelectors {
            var insightSelectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .insightSelectors)
            for insightselectors0 in insightSelectors {
                try insightSelectorsContainer.encode(insightselectors0)
            }
        }
        if let trailName = trailName {
            try encodeContainer.encode(trailName, forKey: .trailName)
        }
    }
}

public struct PutInsightSelectorsInputHeadersMiddleware: Middleware {
    public let id: String = "PutInsightSelectorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInsightSelectorsInput>
    public typealias MOutput = OperationOutput<PutInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInsightSelectorsOutputError>
}

public struct PutInsightSelectorsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutInsightSelectorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutInsightSelectorsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutInsightSelectorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutInsightSelectorsInput>
    public typealias MOutput = OperationOutput<PutInsightSelectorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutInsightSelectorsOutputError>
}

public struct PutInsightSelectorsInput: Equatable {
    /// <p>A JSON string that contains the insight types you want to log on a trail. In this release, only <code>ApiCallRateInsight</code> is supported as an insight type.</p>
    public let insightSelectors: [InsightSelector]?
    /// <p>The name of the CloudTrail trail for which you want to change or add Insights selectors.</p>
    public let trailName: String?

    public init (
        insightSelectors: [InsightSelector]? = nil,
        trailName: String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailName = trailName
    }
}

struct PutInsightSelectorsInputBody: Equatable {
    public let trailName: String?
    public let insightSelectors: [InsightSelector]?
}

extension PutInsightSelectorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailName = "TrailName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailName)
        trailName = trailNameDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

extension PutInsightSelectorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInsightSelectorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientEncryptionPolicyException" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicyException" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInsightSelectorsException" : self = .invalidInsightSelectorsException(try InvalidInsightSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExistException" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInsightSelectorsOutputError: Equatable {
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidInsightSelectorsException(InvalidInsightSelectorsException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInsightSelectorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutInsightSelectorsOutputResponse(insightSelectors: \(String(describing: insightSelectors)), trailARN: \(String(describing: trailARN)))"}
}

extension PutInsightSelectorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutInsightSelectorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.insightSelectors = output.insightSelectors
            self.trailARN = output.trailARN
        } else {
            self.insightSelectors = nil
            self.trailARN = nil
        }
    }
}

public struct PutInsightSelectorsOutputResponse: Equatable {
    /// <p>A JSON string that contains the insight types you want to log on a trail. In this release, only <code>ApiCallRateInsight</code> is supported as an insight type.</p>
    public let insightSelectors: [InsightSelector]?
    /// <p>The Amazon Resource Name (ARN) of a trail for which you want to change or add Insights selectors.</p>
    public let trailARN: String?

    public init (
        insightSelectors: [InsightSelector]? = nil,
        trailARN: String? = nil
    )
    {
        self.insightSelectors = insightSelectors
        self.trailARN = trailARN
    }
}

struct PutInsightSelectorsOutputResponseBody: Equatable {
    public let trailARN: String?
    public let insightSelectors: [InsightSelector]?
}

extension PutInsightSelectorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case insightSelectors = "InsightSelectors"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let insightSelectorsContainer = try containerValues.decodeIfPresent([InsightSelector?].self, forKey: .insightSelectors)
        var insightSelectorsDecoded0:[InsightSelector]? = nil
        if let insightSelectorsContainer = insightSelectorsContainer {
            insightSelectorsDecoded0 = [InsightSelector]()
            for structure0 in insightSelectorsContainer {
                if let structure0 = structure0 {
                    insightSelectorsDecoded0?.append(structure0)
                }
            }
        }
        insightSelectors = insightSelectorsDecoded0
    }
}

public enum ReadWriteType {
    case all
    case readonly
    case writeonly
    case sdkUnknown(String)
}

extension ReadWriteType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReadWriteType] {
        return [
            .all,
            .readonly,
            .writeonly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "All"
        case .readonly: return "ReadOnly"
        case .writeonly: return "WriteOnly"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReadWriteType(rawValue: rawValue) ?? ReadWriteType.sdkUnknown(rawValue)
    }
}

public struct RemoveTagsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

extension RemoveTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsInput(resourceId: \(String(describing: resourceId)), tagsList: \(String(describing: tagsList)))"}
}

extension RemoveTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }
}

public struct RemoveTagsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

public struct RemoveTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTagsInput>
    public typealias MOutput = OperationOutput<RemoveTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTagsOutputError>
}

/// <p>Specifies the tags to remove from a trail.</p>
public struct RemoveTagsInput: Equatable {
    /// <p>Specifies the ARN of the trail from which tags should be removed. The format of a trail ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let resourceId: String?
    /// <p>Specifies a list of tags to be removed.</p>
    public let tagsList: [Tag]?

    public init (
        resourceId: String? = nil,
        tagsList: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

struct RemoveTagsInputBody: Equatable {
    public let resourceId: String?
    public let tagsList: [Tag]?
}

extension RemoveTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension RemoveTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudTrailARNInvalidException" : self = .cloudTrailARNInvalidException(try CloudTrailARNInvalidException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagParameterException" : self = .invalidTagParameterException(try InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceTypeNotSupportedException" : self = .resourceTypeNotSupportedException(try ResourceTypeNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTagsOutputError: Equatable {
    case cloudTrailARNInvalidException(CloudTrailARNInvalidException)
    case invalidTagParameterException(InvalidTagParameterException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceTypeNotSupportedException(ResourceTypeNotSupportedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTagsOutputResponse()"}
}

extension RemoveTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct RemoveTagsOutputResponse: Equatable {

    public init() {}
}

struct RemoveTagsOutputResponseBody: Equatable {
}

extension RemoveTagsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(resourceName: \(String(describing: resourceName)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Specifies the type and name of a resource referenced by an event.</p>
public struct Resource: Equatable {
    /// <p>The name of the resource referenced by the event returned. These are user-created names whose values will depend on the environment. For example, the resource name might be "auto-scaling-test-group" for an Auto Scaling Group or "i-1234567" for an EC2 Instance.</p>
    public let resourceName: String?
    /// <p>The type of a resource referenced by the event returned. When the resource type cannot be
    ///          determined, null is returned. Some examples of resource types are: <b>Instance</b> for EC2,
    ///             <b>Trail</b> for CloudTrail, <b>DBInstance</b> for RDS, and <b>AccessKey</b> for IAM.
    ///          To learn more about how to look up and filter events by the resource types supported for a service, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/view-cloudtrail-events-console.html#filtering-cloudtrail-events">Filtering CloudTrail Events</a>.</p>
    public let resourceType: String?

    public init (
        resourceName: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceName = resourceName
        self.resourceType = resourceType
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified resource is not found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
        case tagsList = "TagsList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagsList = tagsList {
            var tagsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagsList)
            for tagslist0 in tagsList {
                try tagsListContainer.encode(tagslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagsListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagsList)
        var tagsListDecoded0:[Tag]? = nil
        if let tagsListContainer = tagsListContainer {
            tagsListDecoded0 = [Tag]()
            for structure0 in tagsListContainer {
                if let structure0 = structure0 {
                    tagsListDecoded0?.append(structure0)
                }
            }
        }
        tagsList = tagsListDecoded0
    }
}

extension ResourceTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTag(resourceId: \(String(describing: resourceId)), tagsList: \(String(describing: tagsList)))"}
}

/// <p>A resource tag.</p>
public struct ResourceTag: Equatable {
    /// <p>Specifies the ARN of the resource.</p>
    public let resourceId: String?
    /// <p>A list of tags.</p>
    public let tagsList: [Tag]?

    public init (
        resourceId: String? = nil,
        tagsList: [Tag]? = nil
    )
    {
        self.resourceId = resourceId
        self.tagsList = tagsList
    }
}

extension ResourceTypeNotSupportedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceTypeNotSupportedException(message: \(String(describing: message)))"}
}

extension ResourceTypeNotSupportedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceTypeNotSupportedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified resource type is not supported by CloudTrail.</p>
public struct ResourceTypeNotSupportedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceTypeNotSupportedExceptionBody: Equatable {
    public let message: String?
}

extension ResourceTypeNotSupportedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3BucketDoesNotExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketDoesNotExistException(message: \(String(describing: message)))"}
}

extension S3BucketDoesNotExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: S3BucketDoesNotExistExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified S3 bucket does not exist.</p>
public struct S3BucketDoesNotExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct S3BucketDoesNotExistExceptionBody: Equatable {
    public let message: String?
}

extension S3BucketDoesNotExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartLoggingInputBodyMiddleware: Middleware {
    public let id: String = "StartLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLoggingInput>
    public typealias MOutput = OperationOutput<StartLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLoggingOutputError>
}

extension StartLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartLoggingInput(name: \(String(describing: name)))"}
}

extension StartLoggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "StartLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLoggingInput>
    public typealias MOutput = OperationOutput<StartLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLoggingOutputError>
}

public struct StartLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "StartLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StartLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartLoggingInput>
    public typealias MOutput = OperationOutput<StartLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartLoggingOutputError>
}

/// <p>The request to CloudTrail to start logging AWS API calls for an account.</p>
public struct StartLoggingInput: Equatable {
    /// <p>Specifies the name or the CloudTrail ARN of the trail for which CloudTrail logs AWS API calls. The format of a trail ARN is:</p>
    ///             <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StartLoggingInputBody: Equatable {
    public let name: String?
}

extension StartLoggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StartLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartLoggingOutputError: Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartLoggingOutputResponse()"}
}

extension StartLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct StartLoggingOutputResponse: Equatable {

    public init() {}
}

struct StartLoggingOutputResponseBody: Equatable {
}

extension StartLoggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct StopLoggingInputBodyMiddleware: Middleware {
    public let id: String = "StopLoggingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopLoggingInput>
    public typealias MOutput = OperationOutput<StopLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopLoggingOutputError>
}

extension StopLoggingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopLoggingInput(name: \(String(describing: name)))"}
}

extension StopLoggingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StopLoggingInputHeadersMiddleware: Middleware {
    public let id: String = "StopLoggingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopLoggingInput>
    public typealias MOutput = OperationOutput<StopLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopLoggingOutputError>
}

public struct StopLoggingInputQueryItemMiddleware: Middleware {
    public let id: String = "StopLoggingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopLoggingInput>,
                  next: H) -> Swift.Result<OperationOutput<StopLoggingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopLoggingInput>
    public typealias MOutput = OperationOutput<StopLoggingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopLoggingOutputError>
}

/// <p>Passes the request to CloudTrail to stop logging AWS API calls for the specified account.</p>
public struct StopLoggingInput: Equatable {
    /// <p>Specifies the name or the CloudTrail ARN of the trail for which CloudTrail will stop logging AWS API calls. The format of a trail ARN is:</p>
    ///             <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct StopLoggingInputBody: Equatable {
    public let name: String?
}

extension StopLoggingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StopLoggingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopLoggingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopLoggingOutputError: Equatable {
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidTrailNameException(InvalidTrailNameException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case trailNotFoundException(TrailNotFoundException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopLoggingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopLoggingOutputResponse()"}
}

extension StopLoggingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct StopLoggingOutputResponse: Equatable {

    public init() {}
}

struct StopLoggingOutputResponseBody: Equatable {
}

extension StopLoggingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A custom key-value pair associated with a resource such as a CloudTrail trail.</p>
public struct Tag: Equatable {
    /// <p>The key in a key-value pair. The key must be must be no longer than 128 Unicode characters. The key must be unique for the resource to which it applies.</p>
    public let key: String?
    /// <p>The value in a key-value pair of a tag. The value must be no longer than 256 Unicode characters.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagsLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagsLimitExceededException(message: \(String(describing: message)))"}
}

extension TagsLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagsLimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of tags per trail has exceeded the permitted amount. Currently, the limit is 50.</p>
public struct TagsLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagsLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension TagsLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Trail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case hasCustomEventSelectors = "HasCustomEventSelectors"
        case hasInsightSelectors = "HasInsightSelectors"
        case homeRegion = "HomeRegion"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let hasCustomEventSelectors = hasCustomEventSelectors {
            try encodeContainer.encode(hasCustomEventSelectors, forKey: .hasCustomEventSelectors)
        }
        if let hasInsightSelectors = hasInsightSelectors {
            try encodeContainer.encode(hasInsightSelectors, forKey: .hasInsightSelectors)
        }
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let logFileValidationEnabled = logFileValidationEnabled {
            try encodeContainer.encode(logFileValidationEnabled, forKey: .logFileValidationEnabled)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicARN = snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
        if let trailARN = trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let hasCustomEventSelectorsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasCustomEventSelectors)
        hasCustomEventSelectors = hasCustomEventSelectorsDecoded
        let hasInsightSelectorsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .hasInsightSelectors)
        hasInsightSelectors = hasInsightSelectorsDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension Trail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trail(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), hasCustomEventSelectors: \(String(describing: hasCustomEventSelectors)), hasInsightSelectors: \(String(describing: hasInsightSelectors)), homeRegion: \(String(describing: homeRegion)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), logFileValidationEnabled: \(String(describing: logFileValidationEnabled)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicARN: \(String(describing: snsTopicARN)), snsTopicName: \(String(describing: snsTopicName)), trailARN: \(String(describing: trailARN)))"}
}

/// <p>The settings for a trail.</p>
public struct Trail: Equatable {
    /// <p>Specifies an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Specifies if the trail has custom event selectors.</p>
    public let hasCustomEventSelectors: Bool?
    /// <p>Specifies whether a trail has insight types specified in an <code>InsightSelector</code> list.</p>
    public let hasInsightSelectors: Bool?
    /// <p>The region in which the trail was created.</p>
    public let homeRegion: String?
    /// <p>Set to <b>True</b> to include AWS API calls from AWS global services such as IAM.
    ///          Otherwise, <b>False</b>.</p>
    public let includeGlobalServiceEvents: Bool?
    /// <p>Specifies whether the trail exists only in one region or exists in all regions.</p>
    public let isMultiRegionTrail: Bool?
    /// <p>Specifies whether the trail is an organization trail.</p>
    public let isOrganizationTrail: Bool?
    /// <p>Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the format:</p>
    ///          <p>
    ///             <code>arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///          </p>
    public let kmsKeyId: String?
    /// <p>Specifies whether log file validation is enabled.</p>
    public let logFileValidationEnabled: Bool?
    /// <p>Name of the trail set by calling <a>CreateTrail</a>. The maximum length is 128
    ///          characters.</p>
    public let name: String?
    /// <p>Name of the Amazon S3 bucket into which CloudTrail delivers your trail files. See <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html">Amazon S3 Bucket Naming Requirements</a>.</p>
    public let s3BucketName: String?
    /// <p>Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated
    ///          for log file delivery. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html">Finding Your CloudTrail Log Files</a>.The maximum length is 200 characters.</p>
    public let s3KeyPrefix: String?
    /// <p>Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications
    ///          when log files are delivered. The format of a topic ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:sns:us-east-2:123456789012:MyTopic</code>
    ///          </p>
    public let snsTopicARN: String?
    /// <p>This field is no longer in use. Use SnsTopicARN.</p>
    @available(*, deprecated)
    public let snsTopicName: String?
    /// <p>Specifies the ARN of the trail. The format of a trail ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailARN: String?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        hasCustomEventSelectors: Bool? = nil,
        hasInsightSelectors: Bool? = nil,
        homeRegion: String? = nil,
        includeGlobalServiceEvents: Bool? = nil,
        isMultiRegionTrail: Bool? = nil,
        isOrganizationTrail: Bool? = nil,
        kmsKeyId: String? = nil,
        logFileValidationEnabled: Bool? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicARN: String? = nil,
        snsTopicName: String? = nil,
        trailARN: String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.hasCustomEventSelectors = hasCustomEventSelectors
        self.hasInsightSelectors = hasInsightSelectors
        self.homeRegion = homeRegion
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

extension TrailAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrailAlreadyExistsException(message: \(String(describing: message)))"}
}

extension TrailAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TrailAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the specified trail already exists.</p>
public struct TrailAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrailAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension TrailAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrailInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case homeRegion = "HomeRegion"
        case name = "Name"
        case trailARN = "TrailARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let homeRegion = homeRegion {
            try encodeContainer.encode(homeRegion, forKey: .homeRegion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trailARN = trailARN {
            try encodeContainer.encode(trailARN, forKey: .trailARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let homeRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .homeRegion)
        homeRegion = homeRegionDecoded
    }
}

extension TrailInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrailInfo(homeRegion: \(String(describing: homeRegion)), name: \(String(describing: name)), trailARN: \(String(describing: trailARN)))"}
}

/// <p>Information about a CloudTrail trail, including the trail's name, home region, and Amazon Resource Name (ARN).</p>
public struct TrailInfo: Equatable {
    /// <p>The AWS region in which a trail was created.</p>
    public let homeRegion: String?
    /// <p>The name of a trail.</p>
    public let name: String?
    /// <p>The ARN of a trail.</p>
    public let trailARN: String?

    public init (
        homeRegion: String? = nil,
        name: String? = nil,
        trailARN: String? = nil
    )
    {
        self.homeRegion = homeRegion
        self.name = name
        self.trailARN = trailARN
    }
}

extension TrailNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrailNotFoundException(message: \(String(describing: message)))"}
}

extension TrailNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TrailNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the trail with the given name is not found.</p>
public struct TrailNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension TrailNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrailNotProvidedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrailNotProvidedException(message: \(String(describing: message)))"}
}

extension TrailNotProvidedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TrailNotProvidedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is no longer in use.</p>
public struct TrailNotProvidedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TrailNotProvidedExceptionBody: Equatable {
    public let message: String?
}

extension TrailNotProvidedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception is thrown when the requested operation is not supported.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Brief description of the exception returned by the request.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateTrailInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTrailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrailInput>
    public typealias MOutput = OperationOutput<UpdateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrailOutputError>
}

extension UpdateTrailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTrailInput(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), enableLogFileValidation: \(String(describing: enableLogFileValidation)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicName: \(String(describing: snsTopicName)))"}
}

extension UpdateTrailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn {
            try encodeContainer.encode(cloudWatchLogsLogGroupArn, forKey: .cloudWatchLogsLogGroupArn)
        }
        if let cloudWatchLogsRoleArn = cloudWatchLogsRoleArn {
            try encodeContainer.encode(cloudWatchLogsRoleArn, forKey: .cloudWatchLogsRoleArn)
        }
        if let enableLogFileValidation = enableLogFileValidation {
            try encodeContainer.encode(enableLogFileValidation, forKey: .enableLogFileValidation)
        }
        if let includeGlobalServiceEvents = includeGlobalServiceEvents {
            try encodeContainer.encode(includeGlobalServiceEvents, forKey: .includeGlobalServiceEvents)
        }
        if let isMultiRegionTrail = isMultiRegionTrail {
            try encodeContainer.encode(isMultiRegionTrail, forKey: .isMultiRegionTrail)
        }
        if let isOrganizationTrail = isOrganizationTrail {
            try encodeContainer.encode(isOrganizationTrail, forKey: .isOrganizationTrail)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let snsTopicName = snsTopicName {
            try encodeContainer.encode(snsTopicName, forKey: .snsTopicName)
        }
    }
}

public struct UpdateTrailInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTrailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrailInput>
    public typealias MOutput = OperationOutput<UpdateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrailOutputError>
}

public struct UpdateTrailInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTrailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTrailInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTrailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTrailInput>
    public typealias MOutput = OperationOutput<UpdateTrailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTrailOutputError>
}

/// <p>Specifies settings to update for the trail.</p>
public struct UpdateTrailInput: Equatable {
    /// <p>Specifies a log group name using an Amazon Resource Name (ARN), a unique identifier that represents the log group to which CloudTrail logs will be delivered. Not required unless you specify CloudWatchLogsRoleArn.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Specifies whether log file validation is enabled. The default is false.</p>
    ///          <note>
    ///             <p>When you disable log file integrity validation, the chain of digest files is broken after one hour. CloudTrail will not create digest files for log files that were delivered during a period in which log file integrity validation was disabled. For example, if you enable log file integrity validation at noon on January 1, disable it at noon on January 2, and re-enable it at noon on January 10, digest files will not be created for the log files delivered from noon on January 2 to noon on January 10. The same applies whenever you stop CloudTrail logging or delete a trail.</p>
    ///          </note>
    public let enableLogFileValidation: Bool?
    /// <p>Specifies whether the trail is publishing events from global services such as IAM to the log files.</p>
    public let includeGlobalServiceEvents: Bool?
    /// <p>Specifies whether the trail applies only to the current region or to all regions. The default is false. If the trail exists only in the current region and this value is set to true,
    ///          shadow trails (replications of the trail) will be created in the other regions. If the trail exists in all regions and this value is set to false, the trail will remain in the region
    ///          where it was created, and its shadow trails in other regions will be deleted. As a best practice, consider
    ///          using trails that log events in all regions.</p>
    public let isMultiRegionTrail: Bool?
    /// <p>Specifies whether the trail is applied to all accounts in an organization in AWS Organizations, or only for the current AWS account.
    ///          The default is false, and cannot be true unless the call is made on behalf of an AWS account that is the master account for an organization in
    ///          AWS Organizations. If the trail is not an organization trail and this is set to true, the trail will be created in all AWS accounts that belong
    ///          to the organization. If the trail is an organization trail and this is set to false, the trail will remain in the current AWS account but be
    ///          deleted from all member accounts in the organization.</p>
    public let isOrganizationTrail: Bool?
    /// <p>Specifies the KMS key ID to use to encrypt the logs delivered by CloudTrail. The
    ///          value can be an alias name prefixed by "alias/", a fully specified ARN to an alias, a fully
    ///          specified ARN to a key, or a globally unique identifier.</p>
    ///          <p>Examples:</p>
    ///          <ul>
    ///             <li>
    ///                <p>alias/MyAliasName</p>
    ///             </li>
    ///             <li>
    ///                <p>arn:aws:kms:us-east-2:123456789012:alias/MyAliasName</p>
    ///             </li>
    ///             <li>
    ///                <p>arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012</p>
    ///             </li>
    ///             <li>
    ///                <p>12345678-1234-1234-1234-123456789012</p>
    ///             </li>
    ///          </ul>
    public let kmsKeyId: String?
    /// <p>Specifies the name of the trail or trail ARN. If <code>Name</code> is a trail name, the
    ///          string must meet the following requirements:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Contain only ASCII letters (a-z, A-Z), numbers (0-9), periods (.), underscores (_), or dashes (-)</p>
    ///             </li>
    ///             <li>
    ///                <p>Start with a letter or number, and end with a letter or number</p>
    ///             </li>
    ///             <li>
    ///                <p>Be between 3 and 128 characters</p>
    ///             </li>
    ///             <li>
    ///                <p>Have no adjacent periods, underscores or dashes. Names like <code>my-_namespace</code>
    ///             and <code>my--namespace</code> are invalid.</p>
    ///             </li>
    ///             <li>
    ///                <p>Not be in IP address format (for example, 192.168.5.4)</p>
    ///             </li>
    ///          </ul>
    ///          <p>If <code>Name</code> is a trail ARN, it must be in the format:</p>
    ///             <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let name: String?
    /// <p>Specifies the name of the Amazon S3 bucket designated for publishing log files. See <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/create_trail_naming_policy.html">Amazon S3 Bucket Naming Requirements</a>.</p>
    public let s3BucketName: String?
    /// <p>Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated
    ///          for log file delivery. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html">Finding Your CloudTrail Log Files</a>. The maximum length is 200 characters.</p>
    public let s3KeyPrefix: String?
    /// <p>Specifies the name of the Amazon SNS topic defined for notification of log file delivery. The maximum length is 256 characters.</p>
    public let snsTopicName: String?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        enableLogFileValidation: Bool? = nil,
        includeGlobalServiceEvents: Bool? = nil,
        isMultiRegionTrail: Bool? = nil,
        isOrganizationTrail: Bool? = nil,
        kmsKeyId: String? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicName: String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.enableLogFileValidation = enableLogFileValidation
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicName = snsTopicName
    }
}

struct UpdateTrailInputBody: Equatable {
    public let name: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let snsTopicName: String?
    public let includeGlobalServiceEvents: Bool?
    public let isMultiRegionTrail: Bool?
    public let enableLogFileValidation: Bool?
    public let cloudWatchLogsLogGroupArn: String?
    public let cloudWatchLogsRoleArn: String?
    public let kmsKeyId: String?
    public let isOrganizationTrail: Bool?
}

extension UpdateTrailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case enableLogFileValidation = "EnableLogFileValidation"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicName = "SnsTopicName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let enableLogFileValidationDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enableLogFileValidation)
        enableLogFileValidation = enableLogFileValidationDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}

extension UpdateTrailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTrailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CloudTrailAccessNotEnabledException" : self = .cloudTrailAccessNotEnabledException(try CloudTrailAccessNotEnabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudTrailInvalidClientTokenIdException" : self = .cloudTrailInvalidClientTokenIdException(try CloudTrailInvalidClientTokenIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CloudWatchLogsDeliveryUnavailableException" : self = .cloudWatchLogsDeliveryUnavailableException(try CloudWatchLogsDeliveryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientDependencyServiceAccessPermissionException" : self = .insufficientDependencyServiceAccessPermissionException(try InsufficientDependencyServiceAccessPermissionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientEncryptionPolicyException" : self = .insufficientEncryptionPolicyException(try InsufficientEncryptionPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientS3BucketPolicyException" : self = .insufficientS3BucketPolicyException(try InsufficientS3BucketPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientSnsTopicPolicyException" : self = .insufficientSnsTopicPolicyException(try InsufficientSnsTopicPolicyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsLogGroupArnException" : self = .invalidCloudWatchLogsLogGroupArnException(try InvalidCloudWatchLogsLogGroupArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCloudWatchLogsRoleArnException" : self = .invalidCloudWatchLogsRoleArnException(try InvalidCloudWatchLogsRoleArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventSelectorsException" : self = .invalidEventSelectorsException(try InvalidEventSelectorsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidHomeRegionException" : self = .invalidHomeRegionException(try InvalidHomeRegionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidKmsKeyIdException" : self = .invalidKmsKeyIdException(try InvalidKmsKeyIdException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3BucketNameException" : self = .invalidS3BucketNameException(try InvalidS3BucketNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidS3PrefixException" : self = .invalidS3PrefixException(try InvalidS3PrefixException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSnsTopicNameException" : self = .invalidSnsTopicNameException(try InvalidSnsTopicNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTrailNameException" : self = .invalidTrailNameException(try InvalidTrailNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsException" : self = .kmsException(try KmsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyDisabledException" : self = .kmsKeyDisabledException(try KmsKeyDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KmsKeyNotFoundException" : self = .kmsKeyNotFoundException(try KmsKeyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotOrganizationMasterAccountException" : self = .notOrganizationMasterAccountException(try NotOrganizationMasterAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotPermittedException" : self = .operationNotPermittedException(try OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotInAllFeaturesModeException" : self = .organizationNotInAllFeaturesModeException(try OrganizationNotInAllFeaturesModeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationsNotInUseException" : self = .organizationsNotInUseException(try OrganizationsNotInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "S3BucketDoesNotExistException" : self = .s3BucketDoesNotExistException(try S3BucketDoesNotExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotFoundException" : self = .trailNotFoundException(try TrailNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TrailNotProvidedException" : self = .trailNotProvidedException(try TrailNotProvidedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTrailOutputError: Equatable {
    case cloudTrailAccessNotEnabledException(CloudTrailAccessNotEnabledException)
    case cloudTrailInvalidClientTokenIdException(CloudTrailInvalidClientTokenIdException)
    case cloudWatchLogsDeliveryUnavailableException(CloudWatchLogsDeliveryUnavailableException)
    case insufficientDependencyServiceAccessPermissionException(InsufficientDependencyServiceAccessPermissionException)
    case insufficientEncryptionPolicyException(InsufficientEncryptionPolicyException)
    case insufficientS3BucketPolicyException(InsufficientS3BucketPolicyException)
    case insufficientSnsTopicPolicyException(InsufficientSnsTopicPolicyException)
    case invalidCloudWatchLogsLogGroupArnException(InvalidCloudWatchLogsLogGroupArnException)
    case invalidCloudWatchLogsRoleArnException(InvalidCloudWatchLogsRoleArnException)
    case invalidEventSelectorsException(InvalidEventSelectorsException)
    case invalidHomeRegionException(InvalidHomeRegionException)
    case invalidKmsKeyIdException(InvalidKmsKeyIdException)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidS3BucketNameException(InvalidS3BucketNameException)
    case invalidS3PrefixException(InvalidS3PrefixException)
    case invalidSnsTopicNameException(InvalidSnsTopicNameException)
    case invalidTrailNameException(InvalidTrailNameException)
    case kmsException(KmsException)
    case kmsKeyDisabledException(KmsKeyDisabledException)
    case kmsKeyNotFoundException(KmsKeyNotFoundException)
    case notOrganizationMasterAccountException(NotOrganizationMasterAccountException)
    case operationNotPermittedException(OperationNotPermittedException)
    case organizationNotInAllFeaturesModeException(OrganizationNotInAllFeaturesModeException)
    case organizationsNotInUseException(OrganizationsNotInUseException)
    case s3BucketDoesNotExistException(S3BucketDoesNotExistException)
    case trailNotFoundException(TrailNotFoundException)
    case trailNotProvidedException(TrailNotProvidedException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTrailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTrailOutputResponse(cloudWatchLogsLogGroupArn: \(String(describing: cloudWatchLogsLogGroupArn)), cloudWatchLogsRoleArn: \(String(describing: cloudWatchLogsRoleArn)), includeGlobalServiceEvents: \(String(describing: includeGlobalServiceEvents)), isMultiRegionTrail: \(String(describing: isMultiRegionTrail)), isOrganizationTrail: \(String(describing: isOrganizationTrail)), kmsKeyId: \(String(describing: kmsKeyId)), logFileValidationEnabled: \(String(describing: logFileValidationEnabled)), name: \(String(describing: name)), s3BucketName: \(String(describing: s3BucketName)), s3KeyPrefix: \(String(describing: s3KeyPrefix)), snsTopicARN: \(String(describing: snsTopicARN)), snsTopicName: \(String(describing: snsTopicName)), trailARN: \(String(describing: trailARN)))"}
}

extension UpdateTrailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateTrailOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cloudWatchLogsLogGroupArn = output.cloudWatchLogsLogGroupArn
            self.cloudWatchLogsRoleArn = output.cloudWatchLogsRoleArn
            self.includeGlobalServiceEvents = output.includeGlobalServiceEvents
            self.isMultiRegionTrail = output.isMultiRegionTrail
            self.isOrganizationTrail = output.isOrganizationTrail
            self.kmsKeyId = output.kmsKeyId
            self.logFileValidationEnabled = output.logFileValidationEnabled
            self.name = output.name
            self.s3BucketName = output.s3BucketName
            self.s3KeyPrefix = output.s3KeyPrefix
            self.snsTopicARN = output.snsTopicARN
            self.snsTopicName = output.snsTopicName
            self.trailARN = output.trailARN
        } else {
            self.cloudWatchLogsLogGroupArn = nil
            self.cloudWatchLogsRoleArn = nil
            self.includeGlobalServiceEvents = nil
            self.isMultiRegionTrail = nil
            self.isOrganizationTrail = nil
            self.kmsKeyId = nil
            self.logFileValidationEnabled = nil
            self.name = nil
            self.s3BucketName = nil
            self.s3KeyPrefix = nil
            self.snsTopicARN = nil
            self.snsTopicName = nil
            self.trailARN = nil
        }
    }
}

/// <p>Returns the objects or data listed below if successful. Otherwise, returns an error.</p>
public struct UpdateTrailOutputResponse: Equatable {
    /// <p>Specifies the Amazon Resource Name (ARN) of the log group to which CloudTrail logs will be delivered.</p>
    public let cloudWatchLogsLogGroupArn: String?
    /// <p>Specifies the role for the CloudWatch Logs endpoint to assume to write to a user's log group.</p>
    public let cloudWatchLogsRoleArn: String?
    /// <p>Specifies whether the trail is publishing events from global services such as IAM to the log files.</p>
    public let includeGlobalServiceEvents: Bool?
    /// <p>Specifies whether the trail exists in one region or in all regions.</p>
    public let isMultiRegionTrail: Bool?
    /// <p>Specifies whether the trail is an organization trail.</p>
    public let isOrganizationTrail: Bool?
    /// <p>Specifies the KMS key ID that encrypts the logs delivered by CloudTrail. The value is a fully specified ARN to a KMS key in the format:</p>
    ///
    ///          <p>
    ///             <code>arn:aws:kms:us-east-2:123456789012:key/12345678-1234-1234-1234-123456789012</code>
    ///          </p>
    public let kmsKeyId: String?
    /// <p>Specifies whether log file integrity validation is enabled.</p>
    public let logFileValidationEnabled: Bool?
    /// <p>Specifies the name of the trail.</p>
    public let name: String?
    /// <p>Specifies the name of the Amazon S3 bucket designated for publishing log files.</p>
    public let s3BucketName: String?
    /// <p>Specifies the Amazon S3 key prefix that comes after the name of the bucket you have designated
    ///          for log file delivery. For more information, see <a href="https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-find-log-files.html">Finding Your CloudTrail Log Files</a>.</p>
    public let s3KeyPrefix: String?
    /// <p>Specifies the ARN of the Amazon SNS topic that CloudTrail uses to send notifications
    ///          when log files are delivered. The format of a topic ARN is:</p>
    ///          <p>
    ///             <code>arn:aws:sns:us-east-2:123456789012:MyTopic</code>
    ///          </p>
    public let snsTopicARN: String?
    /// <p>This field is no longer in use. Use SnsTopicARN.</p>
    @available(*, deprecated)
    public let snsTopicName: String?
    /// <p>Specifies the ARN of the trail that was updated. The format of a trail ARN
    ///          is:</p>
    ///          <p>
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>
    ///          </p>
    public let trailARN: String?

    public init (
        cloudWatchLogsLogGroupArn: String? = nil,
        cloudWatchLogsRoleArn: String? = nil,
        includeGlobalServiceEvents: Bool? = nil,
        isMultiRegionTrail: Bool? = nil,
        isOrganizationTrail: Bool? = nil,
        kmsKeyId: String? = nil,
        logFileValidationEnabled: Bool? = nil,
        name: String? = nil,
        s3BucketName: String? = nil,
        s3KeyPrefix: String? = nil,
        snsTopicARN: String? = nil,
        snsTopicName: String? = nil,
        trailARN: String? = nil
    )
    {
        self.cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArn
        self.cloudWatchLogsRoleArn = cloudWatchLogsRoleArn
        self.includeGlobalServiceEvents = includeGlobalServiceEvents
        self.isMultiRegionTrail = isMultiRegionTrail
        self.isOrganizationTrail = isOrganizationTrail
        self.kmsKeyId = kmsKeyId
        self.logFileValidationEnabled = logFileValidationEnabled
        self.name = name
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.snsTopicARN = snsTopicARN
        self.snsTopicName = snsTopicName
        self.trailARN = trailARN
    }
}

struct UpdateTrailOutputResponseBody: Equatable {
    public let name: String?
    public let s3BucketName: String?
    public let s3KeyPrefix: String?
    public let snsTopicName: String?
    public let snsTopicARN: String?
    public let includeGlobalServiceEvents: Bool?
    public let isMultiRegionTrail: Bool?
    public let trailARN: String?
    public let logFileValidationEnabled: Bool?
    public let cloudWatchLogsLogGroupArn: String?
    public let cloudWatchLogsRoleArn: String?
    public let kmsKeyId: String?
    public let isOrganizationTrail: Bool?
}

extension UpdateTrailOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsLogGroupArn = "CloudWatchLogsLogGroupArn"
        case cloudWatchLogsRoleArn = "CloudWatchLogsRoleArn"
        case includeGlobalServiceEvents = "IncludeGlobalServiceEvents"
        case isMultiRegionTrail = "IsMultiRegionTrail"
        case isOrganizationTrail = "IsOrganizationTrail"
        case kmsKeyId = "KmsKeyId"
        case logFileValidationEnabled = "LogFileValidationEnabled"
        case name = "Name"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case snsTopicARN = "SnsTopicARN"
        case snsTopicName = "SnsTopicName"
        case trailARN = "TrailARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let snsTopicNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicName)
        snsTopicName = snsTopicNameDecoded
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let includeGlobalServiceEventsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .includeGlobalServiceEvents)
        includeGlobalServiceEvents = includeGlobalServiceEventsDecoded
        let isMultiRegionTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isMultiRegionTrail)
        isMultiRegionTrail = isMultiRegionTrailDecoded
        let trailARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trailARN)
        trailARN = trailARNDecoded
        let logFileValidationEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .logFileValidationEnabled)
        logFileValidationEnabled = logFileValidationEnabledDecoded
        let cloudWatchLogsLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsLogGroupArn)
        cloudWatchLogsLogGroupArn = cloudWatchLogsLogGroupArnDecoded
        let cloudWatchLogsRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogsRoleArn)
        cloudWatchLogsRoleArn = cloudWatchLogsRoleArnDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let isOrganizationTrailDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isOrganizationTrail)
        isOrganizationTrail = isOrganizationTrailDecoded
    }
}
