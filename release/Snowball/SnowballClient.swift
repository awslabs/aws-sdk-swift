// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class SnowballClient {
    let client: SdkHttpClient
    let config: SnowballClientConfiguration
    let serviceName = "Snowball"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: SnowballClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class SnowballClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> SnowballClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try SnowballClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension SnowballClient: SnowballClientProtocol {
    /// <p>Cancels a cluster job. You can only cancel a cluster job while it's in the
    ///         <code>AwaitingQuorum</code> status. You'll have at least an hour after creating a cluster
    ///       job to cancel it.</p>
    public func cancelCluster(input: CancelClusterInput, completion: @escaping (SdkResult<CancelClusterOutput, CancelClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelClusterInput, CancelClusterOutput, CancelClusterOutputError>(id: "cancelCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelClusterInput, CancelClusterOutput, CancelClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelClusterInput, CancelClusterOutput, CancelClusterOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CancelCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels the specified job. You can only cancel a job before its <code>JobState</code>
    ///       value changes to <code>PreparingAppliance</code>. Requesting the <code>ListJobs</code> or
    ///         <code>DescribeJob</code> action returns a job's <code>JobState</code> as part of the
    ///       response element data returned.</p>
    public func cancelJob(input: CancelJobInput, completion: @escaping (SdkResult<CancelJobOutput, CancelJobOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelJobInput, CancelJobOutput, CancelJobOutputError>(id: "cancelJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelJobInput, CancelJobOutput, CancelJobOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CancelJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CancelJobInput, CancelJobOutput, CancelJobOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CancelJob"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an address for a Snow device to be shipped to. In most regions,
    ///       addresses are validated at the time of creation. The address you provide must be located
    ///       within the serviceable area of your region. If the address is invalid or unsupported, then an
    ///       exception is thrown.</p>
    public func createAddress(input: CreateAddressInput, completion: @escaping (SdkResult<CreateAddressOutput, CreateAddressOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAddress")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAddressInput, CreateAddressOutput, CreateAddressOutputError>(id: "createAddress")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateAddressInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAddressInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAddressInput, CreateAddressOutput, CreateAddressOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAddressInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateAddressInput, CreateAddressOutput, CreateAddressOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CreateAddress"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an empty cluster. Each cluster supports five nodes. You use the <a>CreateJob</a> action separately to create the jobs for each of these nodes. The
    ///       cluster does not ship until these five node jobs have been created.</p>
    public func createCluster(input: CreateClusterInput, completion: @escaping (SdkResult<CreateClusterOutput, CreateClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(id: "createCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateClusterInput, CreateClusterOutput, CreateClusterOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CreateCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a job to import or export data between Amazon S3 and your on-premises data
    ///       center. Your AWS account must have the right trust policies and permissions in place to create
    ///       a job for a Snow device. If you're creating a job for a node in a cluster, you only need to provide
    ///       the <code>clusterId</code> value; the other job attributes are inherited from the cluster.
    ///     </p>
    ///          <note>
    ///             <p>Only the Snowball; Edge device type is supported when ordering clustered jobs.</p>
    ///             <p>The device capacity is optional.</p>
    ///             <p>Availability of device types differ by AWS Region. For more
    ///         information about region availability, see <a href="https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/?p=ngi&loc=4">AWS Regional Services</a>.</p>
    ///          </note>
    ///
    ///          <p></p>
    ///
    ///          <p class="title">
    ///             <b>AWS Snow Family device types and their capacities.</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>Snow Family device type: <b>SNC1_SSD</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T14</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowcone </p>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Snow Family device type: <b>SNC1_HDD</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T8</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowcone </p>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>EDGE_S</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T98</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowball Edge Storage Optimized for data transfer only </p>
    ///                   </li>
    ///                </ul>
    ///
    ///
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>EDGE_CG</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T42</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowball Edge Compute Optimized with GPU</p>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>EDGE_C</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T42</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowball Edge Compute Optimized without GPU</p>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>EDGE</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T100</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Snowball Edge Storage Optimized with EC2 Compute</p>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>STANDARD</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T50</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Original Snowball device</p>
    ///                      <note>
    ///                         <p>This device is only available in the Ningxia, Beijing, and Singapore AWS Regions. </p>
    ///                      </note>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///             <li>
    ///                <p>Device type: <b>STANDARD</b>
    ///                </p>
    ///                <ul>
    ///                   <li>
    ///                      <p>Capacity: T80</p>
    ///                   </li>
    ///                   <li>
    ///                      <p>Description: Original Snowball device</p>
    ///                      <note>
    ///                         <p>This device is only available in the Ningxia, Beijing, and Singapore AWS Regions. </p>
    ///                      </note>
    ///                   </li>
    ///                </ul>
    ///                <p></p>
    ///             </li>
    ///          </ul>
    public func createJob(input: CreateJobInput, completion: @escaping (SdkResult<CreateJobOutput, CreateJobOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateJobInput, CreateJobOutput, CreateJobOutputError>(id: "createJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateJobInput, CreateJobOutput, CreateJobOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateJobInput, CreateJobOutput, CreateJobOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CreateJob"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a job with long term usage option for a device. The long term usage is a one year or three year long term pricing type for the device.
    ///       You are billed upfront and AWS give discounts for long term pricing. For detailed information see XXXXXXXX</p>
    public func createLongTermPricing(input: CreateLongTermPricingInput, completion: @escaping (SdkResult<CreateLongTermPricingOutput, CreateLongTermPricingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createLongTermPricing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateLongTermPricingInput, CreateLongTermPricingOutput, CreateLongTermPricingOutputError>(id: "createLongTermPricing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateLongTermPricingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateLongTermPricingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateLongTermPricingInput, CreateLongTermPricingOutput, CreateLongTermPricingOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateLongTermPricingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateLongTermPricingInput, CreateLongTermPricingOutput, CreateLongTermPricingOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CreateLongTermPricing"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a shipping label that will be used to return the Snow device to AWS.</p>
    public func createReturnShippingLabel(input: CreateReturnShippingLabelInput, completion: @escaping (SdkResult<CreateReturnShippingLabelOutput, CreateReturnShippingLabelOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createReturnShippingLabel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateReturnShippingLabelInput, CreateReturnShippingLabelOutput, CreateReturnShippingLabelOutputError>(id: "createReturnShippingLabel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateReturnShippingLabelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateReturnShippingLabelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateReturnShippingLabelInput, CreateReturnShippingLabelOutput, CreateReturnShippingLabelOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: CreateReturnShippingLabelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<CreateReturnShippingLabelInput, CreateReturnShippingLabelOutput, CreateReturnShippingLabelOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.CreateReturnShippingLabel"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Takes an <code>AddressId</code> and returns specific details about that address in the
    ///       form of an <code>Address</code> object.</p>
    public func describeAddress(input: DescribeAddressInput, completion: @escaping (SdkResult<DescribeAddressOutput, DescribeAddressOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAddress")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAddressInput, DescribeAddressOutput, DescribeAddressOutputError>(id: "describeAddress")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAddressInput, DescribeAddressOutput, DescribeAddressOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAddressInput, DescribeAddressOutput, DescribeAddressOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.DescribeAddress"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a specified number of <code>ADDRESS</code> objects. Calling this API in one of
    ///       the US regions will return addresses from the list of all addresses associated with this
    ///       account in all US regions.</p>
    public func describeAddresses(input: DescribeAddressesInput, completion: @escaping (SdkResult<DescribeAddressesOutput, DescribeAddressesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeAddresses")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeAddressesInput, DescribeAddressesOutput, DescribeAddressesOutputError>(id: "describeAddresses")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeAddressesInput, DescribeAddressesOutput, DescribeAddressesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeAddressesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeAddressesInput, DescribeAddressesOutput, DescribeAddressesOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.DescribeAddresses"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a specific cluster including shipping information, cluster
    ///       status, and other important metadata.</p>
    public func describeCluster(input: DescribeClusterInput, completion: @escaping (SdkResult<DescribeClusterOutput, DescribeClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeClusterInput, DescribeClusterOutput, DescribeClusterOutputError>(id: "describeCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeClusterInput, DescribeClusterOutput, DescribeClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeClusterInput, DescribeClusterOutput, DescribeClusterOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.DescribeCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a specific job including shipping information, job status,
    ///       and other important metadata. </p>
    public func describeJob(input: DescribeJobInput, completion: @escaping (SdkResult<DescribeJobOutput, DescribeJobOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeJobInput, DescribeJobOutput, DescribeJobOutputError>(id: "describeJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeJobInput, DescribeJobOutput, DescribeJobOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeJobInput, DescribeJobOutput, DescribeJobOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.DescribeJob"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Information on the shipping label of a Snow device that is being returned to AWS.</p>
    public func describeReturnShippingLabel(input: DescribeReturnShippingLabelInput, completion: @escaping (SdkResult<DescribeReturnShippingLabelOutput, DescribeReturnShippingLabelOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeReturnShippingLabel")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeReturnShippingLabelInput, DescribeReturnShippingLabelOutput, DescribeReturnShippingLabelOutputError>(id: "describeReturnShippingLabel")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeReturnShippingLabelInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeReturnShippingLabelInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeReturnShippingLabelInput, DescribeReturnShippingLabelOutput, DescribeReturnShippingLabelOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: DescribeReturnShippingLabelInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<DescribeReturnShippingLabelInput, DescribeReturnShippingLabelOutput, DescribeReturnShippingLabelOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.DescribeReturnShippingLabel"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a link to an Amazon S3 presigned URL for the manifest file associated with the
    ///       specified <code>JobId</code> value. You can access the manifest file for up to 60 minutes
    ///       after this request has been made. To access the manifest file after 60 minutes have passed,
    ///       you'll have to make another call to the <code>GetJobManifest</code> action.</p>
    ///
    ///          <p>The manifest is an encrypted file that you can download after your job enters the
    ///         <code>WithCustomer</code> status. The manifest is decrypted by using the
    ///       <code>UnlockCode</code> code value, when you pass both values to the Snow device through the
    ///       Snowball client when the client is started for the first time.</p>
    ///
    ///
    ///          <p>As a best practice, we recommend that you don't save a copy of an
    ///         <code>UnlockCode</code> value in the same location as the manifest file for that job. Saving
    ///       these separately helps prevent unauthorized parties from gaining access to the Snow device
    ///       associated with that job.</p>
    ///
    ///
    ///          <p>The credentials of a given job, including its manifest file and unlock code, expire 360
    ///       days after the job is created.</p>
    public func getJobManifest(input: GetJobManifestInput, completion: @escaping (SdkResult<GetJobManifestOutput, GetJobManifestOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getJobManifest")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetJobManifestInput, GetJobManifestOutput, GetJobManifestOutputError>(id: "getJobManifest")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetJobManifestInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetJobManifestInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetJobManifestInput, GetJobManifestOutput, GetJobManifestOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetJobManifestInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetJobManifestInput, GetJobManifestOutput, GetJobManifestOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.GetJobManifest"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns the <code>UnlockCode</code> code value for the specified job. A particular
    ///         <code>UnlockCode</code> value can be accessed for up to 360 days after the associated job
    ///       has been created.</p>
    ///
    ///          <p>The <code>UnlockCode</code> value is a 29-character code with 25 alphanumeric
    ///       characters and 4 hyphens. This code is used to decrypt the manifest file when it is passed
    ///       along with the manifest to the Snow device through the Snowball client when the client is started
    ///       for the first time.</p>
    ///
    ///          <p>As a best practice, we recommend that you don't save a copy of the
    ///         <code>UnlockCode</code> in the same location as the manifest file for that job. Saving these
    ///       separately helps prevent unauthorized parties from gaining access to the Snow device associated
    ///       with that job.</p>
    public func getJobUnlockCode(input: GetJobUnlockCodeInput, completion: @escaping (SdkResult<GetJobUnlockCodeOutput, GetJobUnlockCodeOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getJobUnlockCode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetJobUnlockCodeInput, GetJobUnlockCodeOutput, GetJobUnlockCodeOutputError>(id: "getJobUnlockCode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetJobUnlockCodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetJobUnlockCodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetJobUnlockCodeInput, GetJobUnlockCodeOutput, GetJobUnlockCodeOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetJobUnlockCodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetJobUnlockCodeInput, GetJobUnlockCodeOutput, GetJobUnlockCodeOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.GetJobUnlockCode"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the Snow Family service limit for your account, and also the
    ///       number of Snow devices your account has in use.</p>
    ///
    ///          <p>The default service limit for the number of Snow devices that you can have at one time is
    ///       1. If you want to increase your service limit, contact AWS Support.</p>
    public func getSnowballUsage(input: GetSnowballUsageInput, completion: @escaping (SdkResult<GetSnowballUsageOutput, GetSnowballUsageOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSnowballUsage")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSnowballUsageInput, GetSnowballUsageOutput, GetSnowballUsageOutputError>(id: "getSnowballUsage")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSnowballUsageInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSnowballUsageInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSnowballUsageInput, GetSnowballUsageOutput, GetSnowballUsageOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetSnowballUsageInput, GetSnowballUsageOutput, GetSnowballUsageOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.GetSnowballUsage"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an Amazon S3 presigned URL for an update file associated with a specified
    ///       <code>JobId</code>.</p>
    public func getSoftwareUpdates(input: GetSoftwareUpdatesInput, completion: @escaping (SdkResult<GetSoftwareUpdatesOutput, GetSoftwareUpdatesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSoftwareUpdates")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSoftwareUpdatesInput, GetSoftwareUpdatesOutput, GetSoftwareUpdatesOutputError>(id: "getSoftwareUpdates")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSoftwareUpdatesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSoftwareUpdatesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSoftwareUpdatesInput, GetSoftwareUpdatesOutput, GetSoftwareUpdatesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: GetSoftwareUpdatesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<GetSoftwareUpdatesInput, GetSoftwareUpdatesOutput, GetSoftwareUpdatesOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.GetSoftwareUpdates"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of <code>JobListEntry</code> objects of the specified length. Each
    ///         <code>JobListEntry</code> object is for a job in the specified cluster and contains a job's
    ///       state, a job's ID, and other information.</p>
    public func listClusterJobs(input: ListClusterJobsInput, completion: @escaping (SdkResult<ListClusterJobsOutput, ListClusterJobsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listClusterJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListClusterJobsInput, ListClusterJobsOutput, ListClusterJobsOutputError>(id: "listClusterJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListClusterJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListClusterJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListClusterJobsInput, ListClusterJobsOutput, ListClusterJobsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListClusterJobsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListClusterJobsInput, ListClusterJobsOutput, ListClusterJobsOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.ListClusterJobs"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of <code>ClusterListEntry</code> objects of the specified length. Each
    ///         <code>ClusterListEntry</code> object contains a cluster's state, a cluster's ID, and other
    ///       important status information.</p>
    public func listClusters(input: ListClustersInput, completion: @escaping (SdkResult<ListClustersOutput, ListClustersOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listClusters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListClustersInput, ListClustersOutput, ListClustersOutputError>(id: "listClusters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListClustersInput, ListClustersOutput, ListClustersOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListClustersInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListClustersInput, ListClustersOutput, ListClustersOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.ListClusters"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>This action returns a list of the different Amazon EC2 Amazon Machine Images (AMIs)
    ///       that are owned by your AWS account that would be supported for use on a Snow device.
    ///       Currently, supported AMIs are based on the CentOS 7 (x86_64) - with Updates HVM, Ubuntu Server
    ///       14.04 LTS (HVM), and Ubuntu 16.04 LTS - Xenial (HVM) images, available on the AWS
    ///       Marketplace.</p>
    public func listCompatibleImages(input: ListCompatibleImagesInput, completion: @escaping (SdkResult<ListCompatibleImagesOutput, ListCompatibleImagesOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listCompatibleImages")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListCompatibleImagesInput, ListCompatibleImagesOutput, ListCompatibleImagesOutputError>(id: "listCompatibleImages")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListCompatibleImagesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListCompatibleImagesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListCompatibleImagesInput, ListCompatibleImagesOutput, ListCompatibleImagesOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListCompatibleImagesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListCompatibleImagesInput, ListCompatibleImagesOutput, ListCompatibleImagesOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.ListCompatibleImages"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns an array of <code>JobListEntry</code> objects of the specified length. Each
    ///         <code>JobListEntry</code> object contains a job's state, a job's ID, and a value that
    ///       indicates whether the job is a job part, in the case of export jobs. Calling this API action
    ///       in one of the US regions will return jobs from the list of all jobs associated with this
    ///       account in all US regions.</p>
    public func listJobs(input: ListJobsInput, completion: @escaping (SdkResult<ListJobsOutput, ListJobsOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listJobs")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListJobsInput, ListJobsOutput, ListJobsOutputError>(id: "listJobs")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListJobsInput, ListJobsOutput, ListJobsOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListJobsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListJobsInput, ListJobsOutput, ListJobsOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.ListJobs"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all long term pricing types.</p>
    public func listLongTermPricing(input: ListLongTermPricingInput, completion: @escaping (SdkResult<ListLongTermPricingOutput, ListLongTermPricingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listLongTermPricing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListLongTermPricingInput, ListLongTermPricingOutput, ListLongTermPricingOutputError>(id: "listLongTermPricing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListLongTermPricingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListLongTermPricingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListLongTermPricingInput, ListLongTermPricingOutput, ListLongTermPricingOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: ListLongTermPricingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<ListLongTermPricingInput, ListLongTermPricingOutput, ListLongTermPricingOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.ListLongTermPricing"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>While a cluster's <code>ClusterState</code> value is in the <code>AwaitingQuorum</code>
    ///       state, you can update some of the information associated with a cluster. Once the cluster
    ///       changes to a different job state, usually 60 minutes after the cluster being created, this
    ///       action is no longer available.</p>
    public func updateCluster(input: UpdateClusterInput, completion: @escaping (SdkResult<UpdateClusterOutput, UpdateClusterOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateCluster")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(id: "updateCluster")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateClusterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateClusterInput, UpdateClusterOutput, UpdateClusterOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.UpdateCluster"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>While a job's <code>JobState</code> value is <code>New</code>, you can update some of
    ///       the information associated with a job. Once the job changes to a different job state, usually
    ///       within 60 minutes of the job being created, this action is no longer available.</p>
    public func updateJob(input: UpdateJobInput, completion: @escaping (SdkResult<UpdateJobOutput, UpdateJobOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateJob")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateJobInput, UpdateJobOutput, UpdateJobOutputError>(id: "updateJob")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateJobInput, UpdateJobOutput, UpdateJobOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateJobInput, UpdateJobOutput, UpdateJobOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.UpdateJob"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the state when a the shipment states changes to a different state.</p>
    public func updateJobShipmentState(input: UpdateJobShipmentStateInput, completion: @escaping (SdkResult<UpdateJobShipmentStateOutput, UpdateJobShipmentStateOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateJobShipmentState")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateJobShipmentStateInput, UpdateJobShipmentStateOutput, UpdateJobShipmentStateOutputError>(id: "updateJobShipmentState")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobShipmentStateInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobShipmentStateInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateJobShipmentStateInput, UpdateJobShipmentStateOutput, UpdateJobShipmentStateOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateJobShipmentStateInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateJobShipmentStateInput, UpdateJobShipmentStateOutput, UpdateJobShipmentStateOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.UpdateJobShipmentState"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the long term pricing type.</p>
    public func updateLongTermPricing(input: UpdateLongTermPricingInput, completion: @escaping (SdkResult<UpdateLongTermPricingOutput, UpdateLongTermPricingOutputError>) -> Void)
    {
        let urlPath = "/"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateLongTermPricing")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "snowball.\(config.region).amazonaws.com")
                      .withSigningName(value: "snowball")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateLongTermPricingInput, UpdateLongTermPricingOutput, UpdateLongTermPricingOutputError>(id: "updateLongTermPricing")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UpdateLongTermPricingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateLongTermPricingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateLongTermPricingInput, UpdateLongTermPricingOutput, UpdateLongTermPricingOutputError>(contentType: "application/x-amz-json-1.1"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateLongTermPricingInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        operation.serializeStep.intercept(position: .before, middleware: XAmzTargetMiddleware<UpdateLongTermPricingInput, UpdateLongTermPricingOutput, UpdateLongTermPricingOutputError>(xAmzTarget: "AWSIESnowballJobManagementService.UpdateLongTermPricing"))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
