// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension Address: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case city = "City"
        case company = "Company"
        case country = "Country"
        case isRestricted = "IsRestricted"
        case landmark = "Landmark"
        case name = "Name"
        case phoneNumber = "PhoneNumber"
        case postalCode = "PostalCode"
        case prefectureOrDistrict = "PrefectureOrDistrict"
        case stateOrProvince = "StateOrProvince"
        case street1 = "Street1"
        case street2 = "Street2"
        case street3 = "Street3"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let company = company {
            try encodeContainer.encode(company, forKey: .company)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if isRestricted != false {
            try encodeContainer.encode(isRestricted, forKey: .isRestricted)
        }
        if let landmark = landmark {
            try encodeContainer.encode(landmark, forKey: .landmark)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let prefectureOrDistrict = prefectureOrDistrict {
            try encodeContainer.encode(prefectureOrDistrict, forKey: .prefectureOrDistrict)
        }
        if let stateOrProvince = stateOrProvince {
            try encodeContainer.encode(stateOrProvince, forKey: .stateOrProvince)
        }
        if let street1 = street1 {
            try encodeContainer.encode(street1, forKey: .street1)
        }
        if let street2 = street2 {
            try encodeContainer.encode(street2, forKey: .street2)
        }
        if let street3 = street3 {
            try encodeContainer.encode(street3, forKey: .street3)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let companyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .company)
        company = companyDecoded
        let street1Decoded = try containerValues.decodeIfPresent(String.self, forKey: .street1)
        street1 = street1Decoded
        let street2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .street2)
        street2 = street2Decoded
        let street3Decoded = try containerValues.decodeIfPresent(String.self, forKey: .street3)
        street3 = street3Decoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let stateOrProvinceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateOrProvince)
        stateOrProvince = stateOrProvinceDecoded
        let prefectureOrDistrictDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefectureOrDistrict)
        prefectureOrDistrict = prefectureOrDistrictDecoded
        let landmarkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .landmark)
        landmark = landmarkDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let isRestrictedDecoded = try containerValues.decode(Bool.self, forKey: .isRestricted)
        isRestricted = isRestrictedDecoded
    }
}

extension Address: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Address(addressId: \(String(describing: addressId)), city: \(String(describing: city)), company: \(String(describing: company)), country: \(String(describing: country)), isRestricted: \(String(describing: isRestricted)), landmark: \(String(describing: landmark)), name: \(String(describing: name)), phoneNumber: \(String(describing: phoneNumber)), postalCode: \(String(describing: postalCode)), prefectureOrDistrict: \(String(describing: prefectureOrDistrict)), stateOrProvince: \(String(describing: stateOrProvince)), street1: \(String(describing: street1)), street2: \(String(describing: street2)), street3: \(String(describing: street3)))"}
}

/// <p>The address that you want the Snow device(s) associated with a specific job to
///       be shipped to. Addresses are validated at the time of creation. The address you provide must
///       be located within the serviceable area of your region. Although no individual elements of the
///         <code>Address</code> are required, if the address is invalid or unsupported, then an
///       exception is thrown.</p>
public struct Address: Equatable {
    /// <p>The unique ID for an address.</p>
    public let addressId: String?
    /// <p>The city in an address that a Snow device is to be delivered to.</p>
    public let city: String?
    /// <p>The name of the company to receive a Snow device at an address.</p>
    public let company: String?
    /// <p>The country in an address that a Snow device is to be delivered to.</p>
    public let country: String?
    /// <p>If the address you are creating is a primary address, then set this option to
    ///       true. This field is not supported in most regions.</p>
    public let isRestricted: Bool
    /// <p>This field is no longer used and the value is ignored.</p>
    public let landmark: String?
    /// <p>The name of a person to receive a Snow device at an address.</p>
    public let name: String?
    /// <p>The phone number associated with an address that a Snow device is to be delivered
    ///       to.</p>
    public let phoneNumber: String?
    /// <p>The postal code in an address that a Snow device is to be delivered to.</p>
    public let postalCode: String?
    /// <p>This field is no longer used and the value is ignored.</p>
    public let prefectureOrDistrict: String?
    /// <p>The state or province in an address that a Snow device is to be delivered to.</p>
    public let stateOrProvince: String?
    /// <p>The first line in a street address that a Snow device is to be delivered
    ///       to.</p>
    public let street1: String?
    /// <p>The second line in a street address that a Snow device is to be delivered
    ///       to.</p>
    public let street2: String?
    /// <p>The third line in a street address that a Snow device is to be delivered
    ///       to.</p>
    public let street3: String?

    public init (
        addressId: String? = nil,
        city: String? = nil,
        company: String? = nil,
        country: String? = nil,
        isRestricted: Bool = false,
        landmark: String? = nil,
        name: String? = nil,
        phoneNumber: String? = nil,
        postalCode: String? = nil,
        prefectureOrDistrict: String? = nil,
        stateOrProvince: String? = nil,
        street1: String? = nil,
        street2: String? = nil,
        street3: String? = nil
    )
    {
        self.addressId = addressId
        self.city = city
        self.company = company
        self.country = country
        self.isRestricted = isRestricted
        self.landmark = landmark
        self.name = name
        self.phoneNumber = phoneNumber
        self.postalCode = postalCode
        self.prefectureOrDistrict = prefectureOrDistrict
        self.stateOrProvince = stateOrProvince
        self.street1 = street1
        self.street2 = street2
        self.street3 = street3
    }
}

public struct CancelClusterInputBodyMiddleware: Middleware {
    public let id: String = "CancelClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelClusterInput>
    public typealias MOutput = OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelClusterOutputError>
}

extension CancelClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelClusterInput(clusterId: \(String(describing: clusterId)))"}
}

extension CancelClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct CancelClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CancelClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelClusterInput>
    public typealias MOutput = OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelClusterOutputError>
}

public struct CancelClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelClusterInput>
    public typealias MOutput = OperationOutput<CancelClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelClusterOutputError>
}

public struct CancelClusterInput: Equatable {
    /// <p>The 39-character ID for the cluster that you want to cancel, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: String?

    public init (
        clusterId: String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CancelClusterInputBody: Equatable {
    public let clusterId: String?
}

extension CancelClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension CancelClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelClusterOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelClusterOutputResponse()"}
}

extension CancelClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelClusterOutputResponse: Equatable {

    public init() {}
}

struct CancelClusterOutputResponseBody: Equatable {
}

extension CancelClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CancelJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

extension CancelJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobInput(jobId: \(String(describing: jobId)))"}
}

extension CancelJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct CancelJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelJobInput>
    public typealias MOutput = OperationOutput<CancelJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelJobOutputError>
}

public struct CancelJobInput: Equatable {
    /// <p>The 39-character job ID for the job that you want to cancel, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelJobInputBody: Equatable {
    public let jobId: String?
}

extension CancelJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CancelJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelJobOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelJobOutputResponse()"}
}

extension CancelJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelJobOutputResponse: Equatable {

    public init() {}
}

struct CancelJobOutputResponseBody: Equatable {
}

extension CancelJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ClusterLimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterLimitExceededException(message: \(String(describing: message)))"}
}

extension ClusterLimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ClusterLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Job creation failed. Currently, clusters support five nodes. If you have less than five
///       nodes for your cluster and you have more nodes to create for this cluster, try again and
///       create jobs until your cluster has exactly five notes.</p>
public struct ClusterLimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterLimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension ClusterLimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ClusterListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterListEntry(clusterId: \(String(describing: clusterId)), clusterState: \(String(describing: clusterState)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)))"}
}

/// <p>Contains a cluster's state, a cluster's ID, and other important information.</p>
public struct ClusterListEntry: Equatable {
    /// <p>The 39-character ID for the cluster that you want to list, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: String?
    /// <p>The current state of this cluster. For information about the state of a specific node,
    ///       see <a>JobListEntry$JobState</a>.</p>
    public let clusterState: ClusterState?
    /// <p>The creation date for this cluster.</p>
    public let creationDate: Date?
    /// <p>Defines an optional description of the cluster, for example <code>Environmental Data
    ///         Cluster-01</code>.</p>
    public let description: String?

    public init (
        clusterId: String? = nil,
        clusterState: ClusterState? = nil,
        creationDate: Date? = nil,
        description: String? = nil
    )
    {
        self.clusterId = clusterId
        self.clusterState = clusterState
        self.creationDate = creationDate
        self.description = description
    }
}

extension ClusterMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case clusterState = "ClusterState"
        case creationDate = "CreationDate"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let clusterState = clusterState {
            try encodeContainer.encode(clusterState.rawValue, forKey: .clusterState)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let clusterStateDecoded = try containerValues.decodeIfPresent(ClusterState.self, forKey: .clusterState)
        clusterState = clusterStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
    }
}

extension ClusterMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterMetadata(addressId: \(String(describing: addressId)), clusterId: \(String(describing: clusterId)), clusterState: \(String(describing: clusterState)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), forwardingAddressId: \(String(describing: forwardingAddressId)), jobType: \(String(describing: jobType)), kmsKeyARN: \(String(describing: kmsKeyARN)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingOption: \(String(describing: shippingOption)), snowballType: \(String(describing: snowballType)), taxDocuments: \(String(describing: taxDocuments)))"}
}

/// <p>Contains metadata about a specific cluster.</p>
public struct ClusterMetadata: Equatable {
    /// <p>The automatically generated ID for a specific address.</p>
    public let addressId: String?
    /// <p>The automatically generated ID for a cluster.</p>
    public let clusterId: String?
    /// <p>The current status of the cluster.</p>
    public let clusterState: ClusterState?
    /// <p>The creation date for this cluster.</p>
    public let creationDate: Date?
    /// <p>The optional description of the cluster.</p>
    public let description: String?
    /// <p>The ID of the address that you want a cluster shipped to, after it will be
    ///       shipped to its primary address. This field is not supported in most regions.</p>
    public let forwardingAddressId: String?
    /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
    ///       is <code>LOCAL_USE</code>.</p>
    public let jobType: JobType?
    /// <p>The <code>KmsKeyARN</code> Amazon Resource Name (ARN) associated with this cluster.
    ///       This ARN was created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
    ///       Management Service (AWS KMS).</p>
    public let kmsKeyARN: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
    ///       cluster.</p>
    public let notification: Notification?
    /// <p>The arrays of <a>JobResource</a> objects that can include updated <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
    public let resources: JobResource?
    /// <p>The role ARN associated with this cluster. This ARN was created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>
    ///       API action in AWS Identity and Access Management (IAM).</p>
    public let roleARN: String?
    /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
    ///       you'll get each device, rather it represents how quickly each device moves to
    ///       its destination while in transit. Regional shipping speeds are as follows:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries
    ///           in the EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow devices are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: ShippingOption?
    /// <p>The type of AWS Snow device to use for this cluster.
    ///       </p>
    ///          <note>
    ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
    ///          </note>
    public let snowballType: SnowballType?
    /// <p>The tax documents required in your AWS Region.</p>
    public let taxDocuments: TaxDocuments?

    public init (
        addressId: String? = nil,
        clusterId: String? = nil,
        clusterState: ClusterState? = nil,
        creationDate: Date? = nil,
        description: String? = nil,
        forwardingAddressId: String? = nil,
        jobType: JobType? = nil,
        kmsKeyARN: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingOption: ShippingOption? = nil,
        snowballType: SnowballType? = nil,
        taxDocuments: TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.clusterState = clusterState
        self.creationDate = creationDate
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

public enum ClusterState {
    case awaitingQuorum
    case cancelled
    case complete
    case inUse
    case pending
    case sdkUnknown(String)
}

extension ClusterState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ClusterState] {
        return [
            .awaitingQuorum,
            .cancelled,
            .complete,
            .inUse,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awaitingQuorum: return "AwaitingQuorum"
        case .cancelled: return "Cancelled"
        case .complete: return "Complete"
        case .inUse: return "InUse"
        case .pending: return "Pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ClusterState(rawValue: rawValue) ?? ClusterState.sdkUnknown(rawValue)
    }
}

extension CompatibleImage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiId = "AmiId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CompatibleImage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CompatibleImage(amiId: \(String(describing: amiId)), name: \(String(describing: name)))"}
}

/// <p>A JSON-formatted object that describes a compatible Amazon Machine Image (AMI),
///       including the ID and name for a Snow device AMI. This AMI is compatible with the device's
///       physical hardware requirements, and it should be able to be run in an SBE1 instance on the
///       device.</p>
public struct CompatibleImage: Equatable {
    /// <p>The unique identifier for an individual Snow device AMI.</p>
    public let amiId: String?
    /// <p>The optional name of a compatible image.</p>
    public let name: String?

    public init (
        amiId: String? = nil,
        name: String? = nil
    )
    {
        self.amiId = amiId
        self.name = name
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(conflictResource: \(String(describing: conflictResource)), message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.conflictResource = output.conflictResource
            self.message = output.message
        } else {
            self.conflictResource = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You get this exception when you call <code>CreateReturnShippingLabel</code> more than once when other requests are not completed.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var conflictResource: String?
    public var message: String?

    public init (
        conflictResource: String? = nil,
        message: String? = nil
    )
    {
        self.conflictResource = conflictResource
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let conflictResource: String?
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case conflictResource = "ConflictResource"
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conflictResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .conflictResource)
        conflictResource = conflictResourceDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateAddressInputBodyMiddleware: Middleware {
    public let id: String = "CreateAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressInput>
    public typealias MOutput = OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressOutputError>
}

extension CreateAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAddressInput(address: \(String(describing: address)))"}
}

extension CreateAddressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }
}

public struct CreateAddressInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressInput>
    public typealias MOutput = OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressOutputError>
}

public struct CreateAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAddressInput>
    public typealias MOutput = OperationOutput<CreateAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAddressOutputError>
}

public struct CreateAddressInput: Equatable {
    /// <p>The address that you want the Snow device shipped to.</p>
    public let address: Address?

    public init (
        address: Address? = nil
    )
    {
        self.address = address
    }
}

struct CreateAddressInputBody: Equatable {
    public let address: Address?
}

extension CreateAddressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .address)
        address = addressDecoded
    }
}

extension CreateAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAddressException" : self = .invalidAddressException(try InvalidAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedAddressException" : self = .unsupportedAddressException(try UnsupportedAddressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAddressOutputError: Swift.Error, Equatable {
    case invalidAddressException(InvalidAddressException)
    case unsupportedAddressException(UnsupportedAddressException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAddressOutputResponse(addressId: \(String(describing: addressId)))"}
}

extension CreateAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressId = output.addressId
        } else {
            self.addressId = nil
        }
    }
}

public struct CreateAddressOutputResponse: Equatable {
    /// <p>The automatically generated ID for a specific address. You'll use this ID when you
    ///       create a job to specify which address you want the Snow device for that job shipped to.</p>
    public let addressId: String?

    public init (
        addressId: String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct CreateAddressOutputResponseBody: Equatable {
    public let addressId: String?
}

extension CreateAddressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterInput(addressId: \(String(describing: addressId)), description: \(String(describing: description)), forwardingAddressId: \(String(describing: forwardingAddressId)), jobType: \(String(describing: jobType)), kmsKeyARN: \(String(describing: kmsKeyARN)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingOption: \(String(describing: shippingOption)), snowballType: \(String(describing: snowballType)), taxDocuments: \(String(describing: taxDocuments)))"}
}

extension CreateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Equatable {
    /// <p>The ID for the address that you want the cluster shipped to.</p>
    public let addressId: String?
    /// <p>An optional description of this specific cluster, for example <code>Environmental Data
    ///         Cluster-01</code>.</p>
    public let description: String?
    /// <p>The forwarding address ID for a cluster. This field is not supported in most
    ///       regions.</p>
    public let forwardingAddressId: String?
    /// <p>The type of job for this cluster. Currently, the only job type supported for clusters
    ///       is <code>LOCAL_USE</code>.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let jobType: JobType?
    /// <p>The <code>KmsKeyARN</code> value that you want to associate with this cluster.
    ///         <code>KmsKeyARN</code> values are created by using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS Key
    ///       Management Service (AWS KMS). </p>
    public let kmsKeyARN: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings for this
    ///       cluster.</p>
    public let notification: Notification?
    /// <p>The resources associated with the cluster job. These resources include Amazon S3
    ///       buckets and optional AWS Lambda functions written in the Python language. </p>
    public let resources: JobResource?
    /// <p>The <code>RoleARN</code> that you want to associate with this cluster.
    ///         <code>RoleArn</code> values are created by using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
    ///       Identity and Access Management (IAM).</p>
    public let roleARN: String?
    /// <p>The shipping speed for each node in this cluster. This speed doesn't dictate how soon
    ///       you'll get each Snowball Edge device, rather it represents how quickly each device moves to
    ///       its destination while in transit. Regional shipping speeds are as follows:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
    ///           EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow device are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the United States of America (US), you have access to one-day shipping and
    ///           two-day shipping.</p>
    ///             </li>
    ///          </ul>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries
    ///           in the EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow device are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: ShippingOption?
    /// <p>The type of AWS Snow Family device to use for this cluster.
    ///     </p>
    ///          <note>
    ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
    ///          </note>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballType: SnowballType?
    /// <p>The tax documents required in your AWS Region.</p>
    public let taxDocuments: TaxDocuments?

    public init (
        addressId: String? = nil,
        description: String? = nil,
        forwardingAddressId: String? = nil,
        jobType: JobType? = nil,
        kmsKeyARN: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingOption: ShippingOption? = nil,
        snowballType: SnowballType? = nil,
        taxDocuments: TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateClusterInputBody: Equatable {
    public let jobType: JobType?
    public let resources: JobResource?
    public let description: String?
    public let addressId: String?
    public let kmsKeyARN: String?
    public let roleARN: String?
    public let snowballType: SnowballType?
    public let shippingOption: ShippingOption?
    public let notification: Notification?
    public let forwardingAddressId: String?
    public let taxDocuments: TaxDocuments?
}

extension CreateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
    }
}

extension CreateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Swift.Error, Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterOutputResponse(clusterId: \(String(describing: clusterId)))"}
}

extension CreateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterId = output.clusterId
        } else {
            self.clusterId = nil
        }
    }
}

public struct CreateClusterOutputResponse: Equatable {
    /// <p>The automatically generated ID for a cluster.</p>
    public let clusterId: String?

    public init (
        clusterId: String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct CreateClusterOutputResponseBody: Equatable {
    public let clusterId: String?
}

extension CreateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

public struct CreateJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

extension CreateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobInput(addressId: \(String(describing: addressId)), clusterId: \(String(describing: clusterId)), description: \(String(describing: description)), deviceConfiguration: \(String(describing: deviceConfiguration)), forwardingAddressId: \(String(describing: forwardingAddressId)), jobType: \(String(describing: jobType)), kmsKeyARN: \(String(describing: kmsKeyARN)), longTermPricingId: \(String(describing: longTermPricingId)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingOption: \(String(describing: shippingOption)), snowballCapacityPreference: \(String(describing: snowballCapacityPreference)), snowballType: \(String(describing: snowballType)), taxDocuments: \(String(describing: taxDocuments)))"}
}

extension CreateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }
}

public struct CreateJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJobInput>
    public typealias MOutput = OperationOutput<CreateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJobOutputError>
}

public struct CreateJobInput: Equatable {
    /// <p>The ID for the address that you want the Snow device shipped to.</p>
    public let addressId: String?
    /// <p>The ID of a cluster. If you're creating a job for a node in a cluster, you need to
    ///       provide only this <code>clusterId</code> value. The other job attributes are inherited from
    ///       the cluster.</p>
    public let clusterId: String?
    /// <p>Defines an optional description of this specific job, for example <code>Important
    ///         Photos 2016-08-11</code>.</p>
    public let description: String?
    /// <p>Defines the device configuration for an AWS Snowcone job.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let deviceConfiguration: DeviceConfiguration?
    /// <p>The forwarding address ID for a job. This field is not supported in most
    ///       regions.</p>
    public let forwardingAddressId: String?
    /// <p>Defines the type of job that you're creating.
    ///       </p>
    public let jobType: JobType?
    /// <p>The <code>KmsKeyARN</code> that you want to associate with this job.
    ///         <code>KmsKeyARN</code>s are created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> AWS Key Management
    ///       Service (KMS) API action.</p>
    public let kmsKeyARN: String?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: String?
    /// <p>Defines the Amazon Simple Notification Service (Amazon SNS) notification settings for
    ///       this job.</p>
    public let notification: Notification?
    /// <p>Defines the Amazon S3 buckets associated with this job.</p>
    ///
    ///          <p>With <code>IMPORT</code> jobs, you specify the bucket or buckets that your transferred
    ///       data will be imported into.</p>
    ///
    ///          <p>With <code>EXPORT</code> jobs, you specify the bucket or buckets that your transferred
    ///       data will be exported from. Optionally, you can also specify a <code>KeyRange</code> value. If
    ///       you choose to export a range, you define the length of the range by providing either an
    ///       inclusive <code>BeginMarker</code> value, an inclusive <code>EndMarker</code> value, or both.
    ///       Ranges are UTF-8 binary sorted.</p>
    public let resources: JobResource?
    /// <p>The <code>RoleARN</code> that you want to associate with this job.
    ///       <code>RoleArn</code>s are created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> AWS Identity and
    ///       Access Management (IAM) API action.</p>
    public let roleARN: String?
    /// <p>The shipping speed for this job. This speed doesn't dictate how soon you'll get the
    ///       Snow device, rather it represents how quickly the Snow device moves to its destination while in
    ///       transit. Regional shipping speeds are as follows:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
    ///           EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow devices are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the US, you have access to one-day shipping and two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: ShippingOption?
    /// <p>If your job is being created in one of the US regions, you have the option of
    ///       specifying what size Snow device you'd like for this job. In all other regions, Snowballs come
    ///       with 80 TB in storage capacity.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballCapacityPreference: SnowballCapacity?
    /// <p>The type of AWS Snow Family device to use for this job.
    ///       </p>
    ///          <note>
    ///             <p>For cluster jobs, AWS Snow Family currently supports only the <code>EDGE</code> device type.</p>
    ///          </note>
    ///          <p>The type of AWS Snow device to use for this job. Currently, the only supported
    ///       device type for cluster jobs is <code>EDGE</code>.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/snowball/latest/developer-guide/device-differences.html">Snowball Edge Device
    ///       Options</a> in the Snowball Edge Developer Guide.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballType: SnowballType?
    /// <p>The tax documents required in your AWS Region.</p>
    public let taxDocuments: TaxDocuments?

    public init (
        addressId: String? = nil,
        clusterId: String? = nil,
        description: String? = nil,
        deviceConfiguration: DeviceConfiguration? = nil,
        forwardingAddressId: String? = nil,
        jobType: JobType? = nil,
        kmsKeyARN: String? = nil,
        longTermPricingId: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingOption: ShippingOption? = nil,
        snowballCapacityPreference: SnowballCapacity? = nil,
        snowballType: SnowballType? = nil,
        taxDocuments: TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

struct CreateJobInputBody: Equatable {
    public let jobType: JobType?
    public let resources: JobResource?
    public let description: String?
    public let addressId: String?
    public let kmsKeyARN: String?
    public let roleARN: String?
    public let snowballCapacityPreference: SnowballCapacity?
    public let shippingOption: ShippingOption?
    public let notification: Notification?
    public let clusterId: String?
    public let snowballType: SnowballType?
    public let forwardingAddressId: String?
    public let taxDocuments: TaxDocuments?
    public let deviceConfiguration: DeviceConfiguration?
    public let longTermPricingId: String?
}

extension CreateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension CreateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJobOutputError: Swift.Error, Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension CreateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct CreateJobOutputResponse: Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension CreateJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct CreateLongTermPricingInputBodyMiddleware: Middleware {
    public let id: String = "CreateLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLongTermPricingOutputError>
}

extension CreateLongTermPricingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLongTermPricingInput(isLongTermPricingAutoRenew: \(String(describing: isLongTermPricingAutoRenew)), longTermPricingType: \(String(describing: longTermPricingType)), snowballType: \(String(describing: snowballType)))"}
}

extension CreateLongTermPricingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingType = longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }
}

public struct CreateLongTermPricingInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLongTermPricingOutputError>
}

public struct CreateLongTermPricingInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLongTermPricingInput>
    public typealias MOutput = OperationOutput<CreateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLongTermPricingOutputError>
}

public struct CreateLongTermPricingInput: Equatable {
    /// <p>Specifies whether the current long term pricing type for the device should be renewed.</p>
    public let isLongTermPricingAutoRenew: Bool?
    /// <p>The type of long term pricing option you want for the device - one year or three year long term pricing.</p>
    public let longTermPricingType: LongTermPricingType?
    /// <p>The type of AWS Snow Family device to use for the long term pricing job.</p>
    public let snowballType: SnowballType?

    public init (
        isLongTermPricingAutoRenew: Bool? = nil,
        longTermPricingType: LongTermPricingType? = nil,
        snowballType: SnowballType? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingType = longTermPricingType
        self.snowballType = snowballType
    }
}

struct CreateLongTermPricingInputBody: Equatable {
    public let longTermPricingType: LongTermPricingType?
    public let isLongTermPricingAutoRenew: Bool?
    public let snowballType: SnowballType?
}

extension CreateLongTermPricingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingType = "LongTermPricingType"
        case snowballType = "SnowballType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
    }
}

extension CreateLongTermPricingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLongTermPricingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLongTermPricingOutputError: Swift.Error, Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLongTermPricingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLongTermPricingOutputResponse(longTermPricingId: \(String(describing: longTermPricingId)))"}
}

extension CreateLongTermPricingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingId = output.longTermPricingId
        } else {
            self.longTermPricingId = nil
        }
    }
}

public struct CreateLongTermPricingOutputResponse: Equatable {
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: String?

    public init (
        longTermPricingId: String? = nil
    )
    {
        self.longTermPricingId = longTermPricingId
    }
}

struct CreateLongTermPricingOutputResponseBody: Equatable {
    public let longTermPricingId: String?
}

extension CreateLongTermPricingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case longTermPricingId = "LongTermPricingId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

public struct CreateReturnShippingLabelInputBodyMiddleware: Middleware {
    public let id: String = "CreateReturnShippingLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReturnShippingLabelOutputError>
}

extension CreateReturnShippingLabelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReturnShippingLabelInput(jobId: \(String(describing: jobId)), shippingOption: \(String(describing: shippingOption)))"}
}

extension CreateReturnShippingLabelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

public struct CreateReturnShippingLabelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReturnShippingLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReturnShippingLabelOutputError>
}

public struct CreateReturnShippingLabelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReturnShippingLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<CreateReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReturnShippingLabelOutputError>
}

public struct CreateReturnShippingLabelInput: Equatable {
    /// <p>The ID for a job that you want to create the return shipping label for. For example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?
    /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon the device is returned to AWS.
    ///       This speed represents how quickly it moves to its
    ///       destination while in transit. Regional shipping speeds are as follows:</p>
    public let shippingOption: ShippingOption?

    public init (
        jobId: String? = nil,
        shippingOption: ShippingOption? = nil
    )
    {
        self.jobId = jobId
        self.shippingOption = shippingOption
    }
}

struct CreateReturnShippingLabelInputBody: Equatable {
    public let jobId: String?
    public let shippingOption: ShippingOption?
}

extension CreateReturnShippingLabelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
    }
}

extension CreateReturnShippingLabelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReturnShippingLabelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReturnShippingLabelAlreadyExistsException" : self = .returnShippingLabelAlreadyExistsException(try ReturnShippingLabelAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReturnShippingLabelOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case returnShippingLabelAlreadyExistsException(ReturnShippingLabelAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReturnShippingLabelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReturnShippingLabelOutputResponse(status: \(String(describing: status)))"}
}

extension CreateReturnShippingLabelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct CreateReturnShippingLabelOutputResponse: Equatable {
    /// <p>The status information of the task on a Snow device that is being returned to AWS.</p>
    public let status: ShippingLabelStatus?

    public init (
        status: ShippingLabelStatus? = nil
    )
    {
        self.status = status
    }
}

struct CreateReturnShippingLabelOutputResponseBody: Equatable {
    public let status: ShippingLabelStatus?
}

extension CreateReturnShippingLabelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DataTransfer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bytesTransferred = "BytesTransferred"
        case objectsTransferred = "ObjectsTransferred"
        case totalBytes = "TotalBytes"
        case totalObjects = "TotalObjects"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytesTransferred != 0 {
            try encodeContainer.encode(bytesTransferred, forKey: .bytesTransferred)
        }
        if objectsTransferred != 0 {
            try encodeContainer.encode(objectsTransferred, forKey: .objectsTransferred)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if totalObjects != 0 {
            try encodeContainer.encode(totalObjects, forKey: .totalObjects)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bytesTransferredDecoded = try containerValues.decode(Int.self, forKey: .bytesTransferred)
        bytesTransferred = bytesTransferredDecoded
        let objectsTransferredDecoded = try containerValues.decode(Int.self, forKey: .objectsTransferred)
        objectsTransferred = objectsTransferredDecoded
        let totalBytesDecoded = try containerValues.decode(Int.self, forKey: .totalBytes)
        totalBytes = totalBytesDecoded
        let totalObjectsDecoded = try containerValues.decode(Int.self, forKey: .totalObjects)
        totalObjects = totalObjectsDecoded
    }
}

extension DataTransfer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataTransfer(bytesTransferred: \(String(describing: bytesTransferred)), objectsTransferred: \(String(describing: objectsTransferred)), totalBytes: \(String(describing: totalBytes)), totalObjects: \(String(describing: totalObjects)))"}
}

/// <p>Defines the real-time status of a Snow device's data transfer while the device is at AWS.
///       This data is only available while a job has a <code>JobState</code> value of
///         <code>InProgress</code>, for both import and export jobs.</p>
public struct DataTransfer: Equatable {
    /// <p>The number of bytes transferred between a Snow device and Amazon S3.</p>
    public let bytesTransferred: Int
    /// <p>The number of objects transferred between a Snow device and Amazon S3.</p>
    public let objectsTransferred: Int
    /// <p>The total bytes of data for a transfer between a Snow device and Amazon S3. This value is
    ///       set to 0 (zero) until all the keys that will be transferred have been listed.</p>
    public let totalBytes: Int
    /// <p>The total number of objects for a transfer between a Snow device and Amazon S3. This value
    ///       is set to 0 (zero) until all the keys that will be transferred have been listed.</p>
    public let totalObjects: Int

    public init (
        bytesTransferred: Int = 0,
        objectsTransferred: Int = 0,
        totalBytes: Int = 0,
        totalObjects: Int = 0
    )
    {
        self.bytesTransferred = bytesTransferred
        self.objectsTransferred = objectsTransferred
        self.totalBytes = totalBytes
        self.totalObjects = totalObjects
    }
}

public struct DescribeAddressInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressOutputError>
}

extension DescribeAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAddressInput(addressId: \(String(describing: addressId)))"}
}

extension DescribeAddressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
    }
}

public struct DescribeAddressInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressOutputError>
}

public struct DescribeAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressInput>
    public typealias MOutput = OperationOutput<DescribeAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressOutputError>
}

public struct DescribeAddressInput: Equatable {
    /// <p>The automatically generated ID for a specific address.</p>
    public let addressId: String?

    public init (
        addressId: String? = nil
    )
    {
        self.addressId = addressId
    }
}

struct DescribeAddressInputBody: Equatable {
    public let addressId: String?
}

extension DescribeAddressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
    }
}

extension DescribeAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAddressOutputError: Swift.Error, Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAddressOutputResponse(address: \(String(describing: address)))"}
}

extension DescribeAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAddressOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.address = output.address
        } else {
            self.address = nil
        }
    }
}

public struct DescribeAddressOutputResponse: Equatable {
    /// <p>The address that you want the Snow device(s) associated with a specific job to
    ///       be shipped to.</p>
    public let address: Address?

    public init (
        address: Address? = nil
    )
    {
        self.address = address
    }
}

struct DescribeAddressOutputResponseBody: Equatable {
    public let address: Address?
}

extension DescribeAddressOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Address.self, forKey: .address)
        address = addressDecoded
    }
}

public struct DescribeAddressesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAddressesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressesOutputError>
}

extension DescribeAddressesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAddressesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAddressesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeAddressesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAddressesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressesOutputError>
}

public struct DescribeAddressesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAddressesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAddressesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAddressesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAddressesInput>
    public typealias MOutput = OperationOutput<DescribeAddressesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAddressesOutputError>
}

public struct DescribeAddressesInput: Equatable {
    /// <p>The number of <code>ADDRESS</code> objects to return.</p>
    public let maxResults: Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>ADDRESS</code> objects, you have the option of specifying a value for
    ///         <code>NextToken</code> as the starting point for your list of returned addresses.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAddressesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeAddressesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAddressesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAddressesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAddressesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAddressesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAddressesOutputResponse(addresses: \(String(describing: addresses)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeAddressesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAddressesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addresses = output.addresses
            self.nextToken = output.nextToken
        } else {
            self.addresses = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAddressesOutputResponse: Equatable {
    /// <p>The Snow device shipping addresses that were created for this account.</p>
    public let addresses: [Address]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>DescribeAddresses</code> call, your list of
    ///       returned addresses will start from this point in the array.</p>
    public let nextToken: String?

    public init (
        addresses: [Address]? = nil,
        nextToken: String? = nil
    )
    {
        self.addresses = addresses
        self.nextToken = nextToken
    }
}

struct DescribeAddressesOutputResponseBody: Equatable {
    public let addresses: [Address]?
    public let nextToken: String?
}

extension DescribeAddressesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([Address?].self, forKey: .addresses)
        var addressesDecoded0:[Address]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [Address]()
            for structure0 in addressesContainer {
                if let structure0 = structure0 {
                    addressesDecoded0?.append(structure0)
                }
            }
        }
        addresses = addressesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeClusterInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOutputError>
}

extension DescribeClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterInput(clusterId: \(String(describing: clusterId)))"}
}

extension DescribeClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
    }
}

public struct DescribeClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClusterInput>
    public typealias MOutput = OperationOutput<DescribeClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClusterOutputError>
}

public struct DescribeClusterInput: Equatable {
    /// <p>The automatically generated ID for a cluster.</p>
    public let clusterId: String?

    public init (
        clusterId: String? = nil
    )
    {
        self.clusterId = clusterId
    }
}

struct DescribeClusterInputBody: Equatable {
    public let clusterId: String?
}

extension DescribeClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
    }
}

extension DescribeClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClusterOutputError: Swift.Error, Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClusterOutputResponse(clusterMetadata: \(String(describing: clusterMetadata)))"}
}

extension DescribeClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeClusterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterMetadata = output.clusterMetadata
        } else {
            self.clusterMetadata = nil
        }
    }
}

public struct DescribeClusterOutputResponse: Equatable {
    /// <p>Information about a specific cluster, including shipping information, cluster status,
    ///       and other important metadata.</p>
    public let clusterMetadata: ClusterMetadata?

    public init (
        clusterMetadata: ClusterMetadata? = nil
    )
    {
        self.clusterMetadata = clusterMetadata
    }
}

struct DescribeClusterOutputResponseBody: Equatable {
    public let clusterMetadata: ClusterMetadata?
}

extension DescribeClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterMetadata = "ClusterMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterMetadataDecoded = try containerValues.decodeIfPresent(ClusterMetadata.self, forKey: .clusterMetadata)
        clusterMetadata = clusterMetadataDecoded
    }
}

public struct DescribeJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

extension DescribeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeJobInput>
    public typealias MOutput = OperationOutput<DescribeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeJobOutputError>
}

public struct DescribeJobInput: Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeJobInputBody: Equatable {
    public let jobId: String?
}

extension DescribeJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobOutputError: Swift.Error, Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeJobOutputResponse(jobMetadata: \(String(describing: jobMetadata)), subJobMetadata: \(String(describing: subJobMetadata)))"}
}

extension DescribeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobMetadata = output.jobMetadata
            self.subJobMetadata = output.subJobMetadata
        } else {
            self.jobMetadata = nil
            self.subJobMetadata = nil
        }
    }
}

public struct DescribeJobOutputResponse: Equatable {
    /// <p>Information about a specific job, including shipping information, job status, and other
    ///       important metadata.</p>
    public let jobMetadata: JobMetadata?
    /// <p>Information about a specific job part (in the case of an export job), including
    ///       shipping information, job status, and other important metadata.</p>
    public let subJobMetadata: [JobMetadata]?

    public init (
        jobMetadata: JobMetadata? = nil,
        subJobMetadata: [JobMetadata]? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.subJobMetadata = subJobMetadata
    }
}

struct DescribeJobOutputResponseBody: Equatable {
    public let jobMetadata: JobMetadata?
    public let subJobMetadata: [JobMetadata]?
}

extension DescribeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobMetadata = "JobMetadata"
        case subJobMetadata = "SubJobMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobMetadataDecoded = try containerValues.decodeIfPresent(JobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
        let subJobMetadataContainer = try containerValues.decodeIfPresent([JobMetadata?].self, forKey: .subJobMetadata)
        var subJobMetadataDecoded0:[JobMetadata]? = nil
        if let subJobMetadataContainer = subJobMetadataContainer {
            subJobMetadataDecoded0 = [JobMetadata]()
            for structure0 in subJobMetadataContainer {
                if let structure0 = structure0 {
                    subJobMetadataDecoded0?.append(structure0)
                }
            }
        }
        subJobMetadata = subJobMetadataDecoded0
    }
}

public struct DescribeReturnShippingLabelInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReturnShippingLabelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReturnShippingLabelOutputError>
}

extension DescribeReturnShippingLabelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReturnShippingLabelInput(jobId: \(String(describing: jobId)))"}
}

extension DescribeReturnShippingLabelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct DescribeReturnShippingLabelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReturnShippingLabelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReturnShippingLabelOutputError>
}

public struct DescribeReturnShippingLabelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReturnShippingLabelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReturnShippingLabelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReturnShippingLabelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReturnShippingLabelInput>
    public typealias MOutput = OperationOutput<DescribeReturnShippingLabelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReturnShippingLabelOutputError>
}

public struct DescribeReturnShippingLabelInput: Equatable {
    /// <p>The automatically generated ID for a job, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeReturnShippingLabelInputBody: Equatable {
    public let jobId: String?
}

extension DescribeReturnShippingLabelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension DescribeReturnShippingLabelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReturnShippingLabelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReturnShippingLabelOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReturnShippingLabelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReturnShippingLabelOutputResponse(expirationDate: \(String(describing: expirationDate)), status: \(String(describing: status)))"}
}

extension DescribeReturnShippingLabelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReturnShippingLabelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.expirationDate = output.expirationDate
            self.status = output.status
        } else {
            self.expirationDate = nil
            self.status = nil
        }
    }
}

public struct DescribeReturnShippingLabelOutputResponse: Equatable {
    /// <p>The expiration date of the current return shipping label.</p>
    public let expirationDate: Date?
    /// <p>The status information of the task on a Snow device that is being returned to AWS.</p>
    public let status: ShippingLabelStatus?

    public init (
        expirationDate: Date? = nil,
        status: ShippingLabelStatus? = nil
    )
    {
        self.expirationDate = expirationDate
        self.status = status
    }
}

struct DescribeReturnShippingLabelOutputResponseBody: Equatable {
    public let status: ShippingLabelStatus?
    public let expirationDate: Date?
}

extension DescribeReturnShippingLabelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case expirationDate = "ExpirationDate"
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ShippingLabelStatus.self, forKey: .status)
        status = statusDecoded
        let expirationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationDate)
        expirationDate = expirationDateDecoded
    }
}

extension DeviceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case snowconeDeviceConfiguration = "SnowconeDeviceConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let snowconeDeviceConfiguration = snowconeDeviceConfiguration {
            try encodeContainer.encode(snowconeDeviceConfiguration, forKey: .snowconeDeviceConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowconeDeviceConfigurationDecoded = try containerValues.decodeIfPresent(SnowconeDeviceConfiguration.self, forKey: .snowconeDeviceConfiguration)
        snowconeDeviceConfiguration = snowconeDeviceConfigurationDecoded
    }
}

extension DeviceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceConfiguration(snowconeDeviceConfiguration: \(String(describing: snowconeDeviceConfiguration)))"}
}

/// <p>The container for <code>SnowconeDeviceConfiguration</code>. </p>
public struct DeviceConfiguration: Equatable {
    /// <p>Returns information about the device configuration for an AWS Snowcone job.</p>
    public let snowconeDeviceConfiguration: SnowconeDeviceConfiguration?

    public init (
        snowconeDeviceConfiguration: SnowconeDeviceConfiguration? = nil
    )
    {
        self.snowconeDeviceConfiguration = snowconeDeviceConfiguration
    }
}

extension Ec2AmiResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amiId = "AmiId"
        case snowballAmiId = "SnowballAmiId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let snowballAmiId = snowballAmiId {
            try encodeContainer.encode(snowballAmiId, forKey: .snowballAmiId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let snowballAmiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snowballAmiId)
        snowballAmiId = snowballAmiIdDecoded
    }
}

extension Ec2AmiResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ec2AmiResource(amiId: \(String(describing: amiId)), snowballAmiId: \(String(describing: snowballAmiId)))"}
}

/// <p>A JSON-formatted object that contains the IDs for an Amazon Machine Image (AMI),
///       including the Amazon EC2 AMI ID and the Snow device AMI ID. Each AMI has these two IDs to
///       simplify identifying the AMI in both the AWS Cloud and on the device.</p>
public struct Ec2AmiResource: Equatable {
    /// <p>The ID of the AMI in Amazon EC2.</p>
    public let amiId: String?
    /// <p>The ID of the AMI on the Snow device.</p>
    public let snowballAmiId: String?

    public init (
        amiId: String? = nil,
        snowballAmiId: String? = nil
    )
    {
        self.amiId = amiId
        self.snowballAmiId = snowballAmiId
    }
}

extension Ec2RequestFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Ec2RequestFailedException(message: \(String(describing: message)))"}
}

extension Ec2RequestFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: Ec2RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your IAM user lacks the necessary Amazon EC2 permissions to perform the attempted
///       action.</p>
public struct Ec2RequestFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct Ec2RequestFailedExceptionBody: Equatable {
    public let message: String?
}

extension Ec2RequestFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EventTriggerDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventResourceARN = "EventResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventResourceARN = eventResourceARN {
            try encodeContainer.encode(eventResourceARN, forKey: .eventResourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventResourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventResourceARN)
        eventResourceARN = eventResourceARNDecoded
    }
}

extension EventTriggerDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventTriggerDefinition(eventResourceARN: \(String(describing: eventResourceARN)))"}
}

/// <p>The container for the <a>EventTriggerDefinition$EventResourceARN</a>.</p>
public struct EventTriggerDefinition: Equatable {
    /// <p>The Amazon Resource Name (ARN) for any local Amazon S3 resource that is an AWS Lambda
    ///       function's event trigger associated with this job.</p>
    public let eventResourceARN: String?

    public init (
        eventResourceARN: String? = nil
    )
    {
        self.eventResourceARN = eventResourceARN
    }
}

public struct GetJobManifestInputBodyMiddleware: Middleware {
    public let id: String = "GetJobManifestInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobManifestOutputError>
}

extension GetJobManifestInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobManifestInput(jobId: \(String(describing: jobId)))"}
}

extension GetJobManifestInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobManifestInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobManifestInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobManifestOutputError>
}

public struct GetJobManifestInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobManifestInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobManifestInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobManifestOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobManifestInput>
    public typealias MOutput = OperationOutput<GetJobManifestOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobManifestOutputError>
}

public struct GetJobManifestInput: Equatable {
    /// <p>The ID for a job that you want to get the manifest file for, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobManifestInputBody: Equatable {
    public let jobId: String?
}

extension GetJobManifestInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobManifestOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobManifestOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobManifestOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobManifestOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobManifestOutputResponse(manifestURI: \(String(describing: manifestURI)))"}
}

extension GetJobManifestOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobManifestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.manifestURI = output.manifestURI
        } else {
            self.manifestURI = nil
        }
    }
}

public struct GetJobManifestOutputResponse: Equatable {
    /// <p>The Amazon S3 presigned URL for the manifest file associated with the specified
    ///         <code>JobId</code> value.</p>
    public let manifestURI: String?

    public init (
        manifestURI: String? = nil
    )
    {
        self.manifestURI = manifestURI
    }
}

struct GetJobManifestOutputResponseBody: Equatable {
    public let manifestURI: String?
}

extension GetJobManifestOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case manifestURI = "ManifestURI"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manifestURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .manifestURI)
        manifestURI = manifestURIDecoded
    }
}

public struct GetJobUnlockCodeInputBodyMiddleware: Middleware {
    public let id: String = "GetJobUnlockCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobUnlockCodeOutputError>
}

extension GetJobUnlockCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobUnlockCodeInput(jobId: \(String(describing: jobId)))"}
}

extension GetJobUnlockCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobUnlockCodeInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobUnlockCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobUnlockCodeOutputError>
}

public struct GetJobUnlockCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobUnlockCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobUnlockCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobUnlockCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobUnlockCodeInput>
    public typealias MOutput = OperationOutput<GetJobUnlockCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobUnlockCodeOutputError>
}

public struct GetJobUnlockCodeInput: Equatable {
    /// <p>The ID for the job that you want to get the <code>UnlockCode</code> value for, for
    ///       example <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobUnlockCodeInputBody: Equatable {
    public let jobId: String?
}

extension GetJobUnlockCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobUnlockCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobUnlockCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobUnlockCodeOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobUnlockCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobUnlockCodeOutputResponse(unlockCode: \(String(describing: unlockCode)))"}
}

extension GetJobUnlockCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobUnlockCodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unlockCode = output.unlockCode
        } else {
            self.unlockCode = nil
        }
    }
}

public struct GetJobUnlockCodeOutputResponse: Equatable {
    /// <p>The <code>UnlockCode</code> value for the specified job. The <code>UnlockCode</code>
    ///       value can be accessed for up to 360 days after the job has been created.</p>
    public let unlockCode: String?

    public init (
        unlockCode: String? = nil
    )
    {
        self.unlockCode = unlockCode
    }
}

struct GetJobUnlockCodeOutputResponseBody: Equatable {
    public let unlockCode: String?
}

extension GetJobUnlockCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unlockCode = "UnlockCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unlockCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unlockCode)
        unlockCode = unlockCodeDecoded
    }
}

extension GetSnowballUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnowballUsageInput()"}
}

extension GetSnowballUsageInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSnowballUsageInputHeadersMiddleware: Middleware {
    public let id: String = "GetSnowballUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnowballUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnowballUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnowballUsageInput>
    public typealias MOutput = OperationOutput<GetSnowballUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnowballUsageOutputError>
}

public struct GetSnowballUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSnowballUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSnowballUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSnowballUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSnowballUsageInput>
    public typealias MOutput = OperationOutput<GetSnowballUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSnowballUsageOutputError>
}

public struct GetSnowballUsageInput: Equatable {

    public init() {}
}

struct GetSnowballUsageInputBody: Equatable {
}

extension GetSnowballUsageInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSnowballUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSnowballUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSnowballUsageOutputError: Swift.Error, Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSnowballUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSnowballUsageOutputResponse(snowballLimit: \(String(describing: snowballLimit)), snowballsInUse: \(String(describing: snowballsInUse)))"}
}

extension GetSnowballUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSnowballUsageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.snowballLimit = output.snowballLimit
            self.snowballsInUse = output.snowballsInUse
        } else {
            self.snowballLimit = nil
            self.snowballsInUse = nil
        }
    }
}

public struct GetSnowballUsageOutputResponse: Equatable {
    /// <p>The service limit for number of Snow devices this account can have at once. The default
    ///       service limit is 1 (one).</p>
    public let snowballLimit: Int?
    /// <p>The number of Snow devices that this account is currently using.</p>
    public let snowballsInUse: Int?

    public init (
        snowballLimit: Int? = nil,
        snowballsInUse: Int? = nil
    )
    {
        self.snowballLimit = snowballLimit
        self.snowballsInUse = snowballsInUse
    }
}

struct GetSnowballUsageOutputResponseBody: Equatable {
    public let snowballLimit: Int?
    public let snowballsInUse: Int?
}

extension GetSnowballUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case snowballLimit = "SnowballLimit"
        case snowballsInUse = "SnowballsInUse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snowballLimitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snowballLimit)
        snowballLimit = snowballLimitDecoded
        let snowballsInUseDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .snowballsInUse)
        snowballsInUse = snowballsInUseDecoded
    }
}

public struct GetSoftwareUpdatesInputBodyMiddleware: Middleware {
    public let id: String = "GetSoftwareUpdatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSoftwareUpdatesOutputError>
}

extension GetSoftwareUpdatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSoftwareUpdatesInput(jobId: \(String(describing: jobId)))"}
}

extension GetSoftwareUpdatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetSoftwareUpdatesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSoftwareUpdatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSoftwareUpdatesOutputError>
}

public struct GetSoftwareUpdatesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSoftwareUpdatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSoftwareUpdatesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSoftwareUpdatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSoftwareUpdatesInput>
    public typealias MOutput = OperationOutput<GetSoftwareUpdatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSoftwareUpdatesOutputError>
}

public struct GetSoftwareUpdatesInput: Equatable {
    /// <p>The ID for a job that you want to get the software update file for, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetSoftwareUpdatesInputBody: Equatable {
    public let jobId: String?
}

extension GetSoftwareUpdatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetSoftwareUpdatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSoftwareUpdatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSoftwareUpdatesOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSoftwareUpdatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSoftwareUpdatesOutputResponse(updatesURI: \(String(describing: updatesURI)))"}
}

extension GetSoftwareUpdatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSoftwareUpdatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.updatesURI = output.updatesURI
        } else {
            self.updatesURI = nil
        }
    }
}

public struct GetSoftwareUpdatesOutputResponse: Equatable {
    /// <p>The Amazon S3 presigned URL for the update file associated with the specified
    ///       <code>JobId</code> value. The software update will be available for 2 days after this request is made.
    ///       To access an update after the 2 days have passed, you'll have to make another call to <code>GetSoftwareUpdates</code>.</p>
    public let updatesURI: String?

    public init (
        updatesURI: String? = nil
    )
    {
        self.updatesURI = updatesURI
    }
}

struct GetSoftwareUpdatesOutputResponseBody: Equatable {
    public let updatesURI: String?
}

extension GetSoftwareUpdatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case updatesURI = "UpdatesURI"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatesURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatesURI)
        updatesURI = updatesURIDecoded
    }
}

extension INDTaxDocuments: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gSTIN = "GSTIN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gSTIN = gSTIN {
            try encodeContainer.encode(gSTIN, forKey: .gSTIN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gSTINDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gSTIN)
        gSTIN = gSTINDecoded
    }
}

extension INDTaxDocuments: CustomDebugStringConvertible {
    public var debugDescription: String {
        "INDTaxDocuments(gSTIN: \(String(describing: gSTIN)))"}
}

/// <p>The tax documents required in AWS Regions in India.</p>
public struct INDTaxDocuments: Equatable {
    /// <p>The Goods and Services Tax (GST) documents required in AWS Regions in India.</p>
    public let gSTIN: String?

    public init (
        gSTIN: String? = nil
    )
    {
        self.gSTIN = gSTIN
    }
}

extension InvalidAddressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAddressException(message: \(String(describing: message)))"}
}

extension InvalidAddressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The address provided was invalid. Check the address with your region's carrier, and try
///       again.</p>
public struct InvalidAddressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAddressExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAddressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidInputCombinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputCombinationException(message: \(String(describing: message)))"}
}

extension InvalidInputCombinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidInputCombinationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Job or cluster creation failed. One or more inputs were invalid. Confirm that the
///       <a>CreateClusterRequest$SnowballType</a> value supports your <a>CreateJobRequest$JobType</a>, and try again.</p>
public struct InvalidInputCombinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidInputCombinationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidInputCombinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidJobStateException(message: \(String(describing: message)))"}
}

extension InvalidJobStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action can't be performed because the job's current state doesn't allow that action
///       to be performed.</p>
public struct InvalidJobStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidJobStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The <code>NextToken</code> string was altered unexpectedly, and the operation has
///       stopped. Run the operation without changing the <code>NextToken</code> string, and try
///       again.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidResourceException(message: \(String(describing: message)), resourceType: \(String(describing: resourceType)))"}
}

extension InvalidResourceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource can't be found. Check the information you provided in your last
///       request, and try again.</p>
public struct InvalidResourceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The provided resource value is invalid.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceType = resourceType
    }
}

struct InvalidResourceExceptionBody: Equatable {
    public let message: String?
    public let resourceType: String?
}

extension InvalidResourceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension JobListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case description = "Description"
        case isMaster = "IsMaster"
        case jobId = "JobId"
        case jobState = "JobState"
        case jobType = "JobType"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isMaster != false {
            try encodeContainer.encode(isMaster, forKey: .isMaster)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobState = jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let isMasterDecoded = try containerValues.decode(Bool.self, forKey: .isMaster)
        isMaster = isMasterDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension JobListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobListEntry(creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), isMaster: \(String(describing: isMaster)), jobId: \(String(describing: jobId)), jobState: \(String(describing: jobState)), jobType: \(String(describing: jobType)), snowballType: \(String(describing: snowballType)))"}
}

/// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
///       that indicates whether the job is a job part, in the case of an export job.</p>
public struct JobListEntry: Equatable {
    /// <p>The creation date for this job.</p>
    public let creationDate: Date?
    /// <p>The optional description of this specific job, for example <code>Important Photos
    ///         2016-08-11</code>.</p>
    public let description: String?
    /// <p>A value that indicates that this job is a main job. A main job represents a
    ///       successful request to create an export job. Main jobs aren't associated with any Snowballs.
    ///       Instead, each main job will have at least one job part, and each job part is associated with
    ///       a Snowball. It might take some time before the job parts associated with a particular main
    ///       job are listed, because they are created after the main job is created.</p>
    public let isMaster: Bool
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?
    /// <p>The current state of this job.</p>
    public let jobState: JobState?
    /// <p>The type of job.</p>
    public let jobType: JobType?
    /// <p>The type of device used with this job.</p>
    public let snowballType: SnowballType?

    public init (
        creationDate: Date? = nil,
        description: String? = nil,
        isMaster: Bool = false,
        jobId: String? = nil,
        jobState: JobState? = nil,
        jobType: JobType? = nil,
        snowballType: SnowballType? = nil
    )
    {
        self.creationDate = creationDate
        self.description = description
        self.isMaster = isMaster
        self.jobId = jobId
        self.jobState = jobState
        self.jobType = jobType
        self.snowballType = snowballType
    }
}

extension JobLogs: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobCompletionReportURI = "JobCompletionReportURI"
        case jobFailureLogURI = "JobFailureLogURI"
        case jobSuccessLogURI = "JobSuccessLogURI"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobCompletionReportURI = jobCompletionReportURI {
            try encodeContainer.encode(jobCompletionReportURI, forKey: .jobCompletionReportURI)
        }
        if let jobFailureLogURI = jobFailureLogURI {
            try encodeContainer.encode(jobFailureLogURI, forKey: .jobFailureLogURI)
        }
        if let jobSuccessLogURI = jobSuccessLogURI {
            try encodeContainer.encode(jobSuccessLogURI, forKey: .jobSuccessLogURI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobCompletionReportURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobCompletionReportURI)
        jobCompletionReportURI = jobCompletionReportURIDecoded
        let jobSuccessLogURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobSuccessLogURI)
        jobSuccessLogURI = jobSuccessLogURIDecoded
        let jobFailureLogURIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobFailureLogURI)
        jobFailureLogURI = jobFailureLogURIDecoded
    }
}

extension JobLogs: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobLogs(jobCompletionReportURI: \(String(describing: jobCompletionReportURI)), jobFailureLogURI: \(String(describing: jobFailureLogURI)), jobSuccessLogURI: \(String(describing: jobSuccessLogURI)))"}
}

/// <p>Contains job logs. Whenever a Snow device is used to import data into or export data out of
///       Amazon S3, you'll have the option of downloading a PDF job report. Job logs are returned as a
///       part of the response syntax of the <code>DescribeJob</code> action in the
///         <code>JobMetadata</code> data type. The job logs can be accessed for up to 60 minutes after
///       this request has been made. To access any of the job logs after 60 minutes have passed, you'll
///       have to make another call to the <code>DescribeJob</code> action.</p>
///
///          <p>For import jobs, the PDF job report becomes available at the end of the import process.
///       For export jobs, your job report typically becomes available while the Snow device for your job
///       part is being delivered to you.</p>
///
///          <p>The job report provides you insight into the state of your Amazon S3 data transfer. The
///       report includes details about your job or job part for your records.</p>
///
///          <p>For deeper visibility into the status of your transferred objects, you can look at the
///       two associated logs: a success log and a failure log. The logs are saved in comma-separated
///       value (CSV) format, and the name of each log includes the ID of the job or job part that the
///       log describes.</p>
public struct JobLogs: Equatable {
    /// <p>A link to an Amazon S3 presigned URL where the job completion report is
    ///       located.</p>
    public let jobCompletionReportURI: String?
    /// <p>A link to an Amazon S3 presigned URL where the job failure log is located.</p>
    public let jobFailureLogURI: String?
    /// <p>A link to an Amazon S3 presigned URL where the job success log is located.</p>
    public let jobSuccessLogURI: String?

    public init (
        jobCompletionReportURI: String? = nil,
        jobFailureLogURI: String? = nil,
        jobSuccessLogURI: String? = nil
    )
    {
        self.jobCompletionReportURI = jobCompletionReportURI
        self.jobFailureLogURI = jobFailureLogURI
        self.jobSuccessLogURI = jobSuccessLogURI
    }
}

extension JobMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case creationDate = "CreationDate"
        case dataTransferProgress = "DataTransferProgress"
        case description = "Description"
        case deviceConfiguration = "DeviceConfiguration"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case jobLogInfo = "JobLogInfo"
        case jobState = "JobState"
        case jobType = "JobType"
        case kmsKeyARN = "KmsKeyARN"
        case longTermPricingId = "LongTermPricingId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingDetails = "ShippingDetails"
        case snowballCapacityPreference = "SnowballCapacityPreference"
        case snowballType = "SnowballType"
        case taxDocuments = "TaxDocuments"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let dataTransferProgress = dataTransferProgress {
            try encodeContainer.encode(dataTransferProgress, forKey: .dataTransferProgress)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceConfiguration = deviceConfiguration {
            try encodeContainer.encode(deviceConfiguration, forKey: .deviceConfiguration)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let jobLogInfo = jobLogInfo {
            try encodeContainer.encode(jobLogInfo, forKey: .jobLogInfo)
        }
        if let jobState = jobState {
            try encodeContainer.encode(jobState.rawValue, forKey: .jobState)
        }
        if let jobType = jobType {
            try encodeContainer.encode(jobType.rawValue, forKey: .jobType)
        }
        if let kmsKeyARN = kmsKeyARN {
            try encodeContainer.encode(kmsKeyARN, forKey: .kmsKeyARN)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingDetails = shippingDetails {
            try encodeContainer.encode(shippingDetails, forKey: .shippingDetails)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
        if let taxDocuments = taxDocuments {
            try encodeContainer.encode(taxDocuments, forKey: .taxDocuments)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStateDecoded = try containerValues.decodeIfPresent(JobState.self, forKey: .jobState)
        jobState = jobStateDecoded
        let jobTypeDecoded = try containerValues.decodeIfPresent(JobType.self, forKey: .jobType)
        jobType = jobTypeDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let kmsKeyARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyARN)
        kmsKeyARN = kmsKeyARNDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingDetailsDecoded = try containerValues.decodeIfPresent(ShippingDetails.self, forKey: .shippingDetails)
        shippingDetails = shippingDetailsDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTransferProgressDecoded = try containerValues.decodeIfPresent(DataTransfer.self, forKey: .dataTransferProgress)
        dataTransferProgress = dataTransferProgressDecoded
        let jobLogInfoDecoded = try containerValues.decodeIfPresent(JobLogs.self, forKey: .jobLogInfo)
        jobLogInfo = jobLogInfoDecoded
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
        let taxDocumentsDecoded = try containerValues.decodeIfPresent(TaxDocuments.self, forKey: .taxDocuments)
        taxDocuments = taxDocumentsDecoded
        let deviceConfigurationDecoded = try containerValues.decodeIfPresent(DeviceConfiguration.self, forKey: .deviceConfiguration)
        deviceConfiguration = deviceConfigurationDecoded
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
    }
}

extension JobMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobMetadata(addressId: \(String(describing: addressId)), clusterId: \(String(describing: clusterId)), creationDate: \(String(describing: creationDate)), dataTransferProgress: \(String(describing: dataTransferProgress)), description: \(String(describing: description)), deviceConfiguration: \(String(describing: deviceConfiguration)), forwardingAddressId: \(String(describing: forwardingAddressId)), jobId: \(String(describing: jobId)), jobLogInfo: \(String(describing: jobLogInfo)), jobState: \(String(describing: jobState)), jobType: \(String(describing: jobType)), kmsKeyARN: \(String(describing: kmsKeyARN)), longTermPricingId: \(String(describing: longTermPricingId)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingDetails: \(String(describing: shippingDetails)), snowballCapacityPreference: \(String(describing: snowballCapacityPreference)), snowballType: \(String(describing: snowballType)), taxDocuments: \(String(describing: taxDocuments)))"}
}

/// <p>Contains information about a specific job including shipping information, job status,
///       and other important metadata. This information is returned as a part of the response syntax of
///       the <code>DescribeJob</code> action.</p>
public struct JobMetadata: Equatable {
    /// <p>The ID for the address that you want the Snow device shipped to.</p>
    public let addressId: String?
    /// <p>The 39-character ID for the cluster, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: String?
    /// <p>The creation date for this job.</p>
    public let creationDate: Date?
    /// <p>A value that defines the real-time status of a Snow device's data transfer while the
    ///       device is at AWS. This data is only available while a job has a <code>JobState</code> value of
    ///         <code>InProgress</code>, for both import and export jobs.</p>
    public let dataTransferProgress: DataTransfer?
    /// <p>The description of the job, provided at job creation.</p>
    public let description: String?
    /// <p>The container for <code>SnowconeDeviceConfiguration</code>. </p>
    public let deviceConfiguration: DeviceConfiguration?
    /// <p>The ID of the address that you want a job shipped to, after it will be
    ///       shipped to its primary address. This field is not supported in most regions.</p>
    public let forwardingAddressId: String?
    /// <p>The automatically generated ID for a job, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?
    /// <p>Links to Amazon S3 presigned URLs for the job report and logs. For import jobs, the PDF
    ///       job report becomes available at the end of the import process. For export jobs, your job
    ///       report typically becomes available while the Snow device for your job part is being delivered to
    ///       you.</p>
    public let jobLogInfo: JobLogs?
    /// <p>The current status of the jobs.</p>
    public let jobState: JobState?
    /// <p>The type of job.</p>
    public let jobType: JobType?
    /// <p>The Amazon Resource Name (ARN) for the AWS Key Management Service (AWS KMS) key
    ///       associated with this job. This ARN was created using the <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateKey.html">CreateKey</a> API action in AWS
    ///       KMS.</p>
    public let kmsKeyARN: String?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: String?
    /// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings associated
    ///       with a specific job. The <code>Notification</code> object is returned as a part of the
    ///       response syntax of the <code>DescribeJob</code> action in the <code>JobMetadata</code> data
    ///       type.</p>
    public let notification: Notification?
    /// <p>An array of <code>S3Resource</code> objects. Each <code>S3Resource</code> object
    ///       represents an Amazon S3 bucket that your transferred data will be exported from or imported
    ///       into.</p>
    public let resources: JobResource?
    /// <p>The role ARN associated with this job. This ARN was created using the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>
    ///       API action in AWS Identity and Access Management (IAM).</p>
    public let roleARN: String?
    /// <p>A job's shipping information, including inbound and outbound tracking numbers and
    ///       shipping speed options.</p>
    public let shippingDetails: ShippingDetails?
    /// <p>The Snow device capacity preference for this job, specified at job creation. In US
    ///       regions, you can choose between 50 TB and 80 TB Snowballs. All other regions use 80 TB
    ///       capacity Snowballs.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballCapacityPreference: SnowballCapacity?
    /// <p>The type of device used with this job.</p>
    public let snowballType: SnowballType?
    /// <p>The metadata associated with the tax documents required in your AWS Region.</p>
    public let taxDocuments: TaxDocuments?

    public init (
        addressId: String? = nil,
        clusterId: String? = nil,
        creationDate: Date? = nil,
        dataTransferProgress: DataTransfer? = nil,
        description: String? = nil,
        deviceConfiguration: DeviceConfiguration? = nil,
        forwardingAddressId: String? = nil,
        jobId: String? = nil,
        jobLogInfo: JobLogs? = nil,
        jobState: JobState? = nil,
        jobType: JobType? = nil,
        kmsKeyARN: String? = nil,
        longTermPricingId: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingDetails: ShippingDetails? = nil,
        snowballCapacityPreference: SnowballCapacity? = nil,
        snowballType: SnowballType? = nil,
        taxDocuments: TaxDocuments? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.creationDate = creationDate
        self.dataTransferProgress = dataTransferProgress
        self.description = description
        self.deviceConfiguration = deviceConfiguration
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.jobLogInfo = jobLogInfo
        self.jobState = jobState
        self.jobType = jobType
        self.kmsKeyARN = kmsKeyARN
        self.longTermPricingId = longTermPricingId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingDetails = shippingDetails
        self.snowballCapacityPreference = snowballCapacityPreference
        self.snowballType = snowballType
        self.taxDocuments = taxDocuments
    }
}

extension JobResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ec2AmiResources = "Ec2AmiResources"
        case lambdaResources = "LambdaResources"
        case s3Resources = "S3Resources"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2AmiResources = ec2AmiResources {
            var ec2AmiResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ec2AmiResources)
            for ec2amiresourcelist0 in ec2AmiResources {
                try ec2AmiResourcesContainer.encode(ec2amiresourcelist0)
            }
        }
        if let lambdaResources = lambdaResources {
            var lambdaResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lambdaResources)
            for lambdaresourcelist0 in lambdaResources {
                try lambdaResourcesContainer.encode(lambdaresourcelist0)
            }
        }
        if let s3Resources = s3Resources {
            var s3ResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Resources)
            for s3resourcelist0 in s3Resources {
                try s3ResourcesContainer.encode(s3resourcelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcesContainer = try containerValues.decodeIfPresent([S3Resource?].self, forKey: .s3Resources)
        var s3ResourcesDecoded0:[S3Resource]? = nil
        if let s3ResourcesContainer = s3ResourcesContainer {
            s3ResourcesDecoded0 = [S3Resource]()
            for structure0 in s3ResourcesContainer {
                if let structure0 = structure0 {
                    s3ResourcesDecoded0?.append(structure0)
                }
            }
        }
        s3Resources = s3ResourcesDecoded0
        let lambdaResourcesContainer = try containerValues.decodeIfPresent([LambdaResource?].self, forKey: .lambdaResources)
        var lambdaResourcesDecoded0:[LambdaResource]? = nil
        if let lambdaResourcesContainer = lambdaResourcesContainer {
            lambdaResourcesDecoded0 = [LambdaResource]()
            for structure0 in lambdaResourcesContainer {
                if let structure0 = structure0 {
                    lambdaResourcesDecoded0?.append(structure0)
                }
            }
        }
        lambdaResources = lambdaResourcesDecoded0
        let ec2AmiResourcesContainer = try containerValues.decodeIfPresent([Ec2AmiResource?].self, forKey: .ec2AmiResources)
        var ec2AmiResourcesDecoded0:[Ec2AmiResource]? = nil
        if let ec2AmiResourcesContainer = ec2AmiResourcesContainer {
            ec2AmiResourcesDecoded0 = [Ec2AmiResource]()
            for structure0 in ec2AmiResourcesContainer {
                if let structure0 = structure0 {
                    ec2AmiResourcesDecoded0?.append(structure0)
                }
            }
        }
        ec2AmiResources = ec2AmiResourcesDecoded0
    }
}

extension JobResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobResource(ec2AmiResources: \(String(describing: ec2AmiResources)), lambdaResources: \(String(describing: lambdaResources)), s3Resources: \(String(describing: s3Resources)))"}
}

/// <p>Contains an array of AWS resource objects. Each object represents an Amazon S3 bucket,
///       an AWS Lambda function, or an Amazon Machine Image (AMI) based on Amazon EC2 that is
///       associated with a particular job.</p>
public struct JobResource: Equatable {
    /// <p>The Amazon Machine Images (AMIs) associated with this job.</p>
    public let ec2AmiResources: [Ec2AmiResource]?
    /// <p>The Python-language Lambda functions for this job.</p>
    public let lambdaResources: [LambdaResource]?
    /// <p>An array of <code>S3Resource</code> objects.</p>
    public let s3Resources: [S3Resource]?

    public init (
        ec2AmiResources: [Ec2AmiResource]? = nil,
        lambdaResources: [LambdaResource]? = nil,
        s3Resources: [S3Resource]? = nil
    )
    {
        self.ec2AmiResources = ec2AmiResources
        self.lambdaResources = lambdaResources
        self.s3Resources = s3Resources
    }
}

public enum JobState {
    case cancelled
    case complete
    case inProgress
    case inTransitToAws
    case inTransitToCustomer
    case listing
    case new
    case pending
    case preparingAppliance
    case preparingShipment
    case withAws
    case withAwsSortingFacility
    case withCustomer
    case sdkUnknown(String)
}

extension JobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobState] {
        return [
            .cancelled,
            .complete,
            .inProgress,
            .inTransitToAws,
            .inTransitToCustomer,
            .listing,
            .new,
            .pending,
            .preparingAppliance,
            .preparingShipment,
            .withAws,
            .withAwsSortingFacility,
            .withCustomer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .complete: return "Complete"
        case .inProgress: return "InProgress"
        case .inTransitToAws: return "InTransitToAWS"
        case .inTransitToCustomer: return "InTransitToCustomer"
        case .listing: return "Listing"
        case .new: return "New"
        case .pending: return "Pending"
        case .preparingAppliance: return "PreparingAppliance"
        case .preparingShipment: return "PreparingShipment"
        case .withAws: return "WithAWS"
        case .withAwsSortingFacility: return "WithAWSSortingFacility"
        case .withCustomer: return "WithCustomer"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobState(rawValue: rawValue) ?? JobState.sdkUnknown(rawValue)
    }
}

public enum JobType {
    case export
    case `import`
    case localUse
    case sdkUnknown(String)
}

extension JobType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobType] {
        return [
            .export,
            .import,
            .localUse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .export: return "EXPORT"
        case .import: return "IMPORT"
        case .localUse: return "LOCAL_USE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
    }
}

extension KMSRequestFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSRequestFailedException(message: \(String(describing: message)))"}
}

extension KMSRequestFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: KMSRequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided AWS Key Management Service key lacks the permissions to perform the
///       specified <a>CreateJob</a> or <a>UpdateJob</a> action.</p>
public struct KMSRequestFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct KMSRequestFailedExceptionBody: Equatable {
    public let message: String?
}

extension KMSRequestFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KeyRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginMarker = "BeginMarker"
        case endMarker = "EndMarker"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginMarker = beginMarker {
            try encodeContainer.encode(beginMarker, forKey: .beginMarker)
        }
        if let endMarker = endMarker {
            try encodeContainer.encode(endMarker, forKey: .endMarker)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .beginMarker)
        beginMarker = beginMarkerDecoded
        let endMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endMarker)
        endMarker = endMarkerDecoded
    }
}

extension KeyRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KeyRange(beginMarker: \(String(describing: beginMarker)), endMarker: \(String(describing: endMarker)))"}
}

/// <p>Contains a key range. For export jobs, a <code>S3Resource</code> object can have an
///       optional <code>KeyRange</code> value. The length of the range is defined at job creation, and
///       has either an inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or
///       both. Ranges are UTF-8 binary sorted.</p>
public struct KeyRange: Equatable {
    /// <p>The key that starts an optional key range for an export job. Ranges are inclusive and
    ///       UTF-8 binary sorted.</p>
    public let beginMarker: String?
    /// <p>The key that ends an optional key range for an export job. Ranges are inclusive and
    ///       UTF-8 binary sorted.</p>
    public let endMarker: String?

    public init (
        beginMarker: String? = nil,
        endMarker: String? = nil
    )
    {
        self.beginMarker = beginMarker
        self.endMarker = endMarker
    }
}

extension LambdaResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventTriggers = "EventTriggers"
        case lambdaArn = "LambdaArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTriggers = eventTriggers {
            var eventTriggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTriggers)
            for eventtriggerdefinitionlist0 in eventTriggers {
                try eventTriggersContainer.encode(eventtriggerdefinitionlist0)
            }
        }
        if let lambdaArn = lambdaArn {
            try encodeContainer.encode(lambdaArn, forKey: .lambdaArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaArn)
        lambdaArn = lambdaArnDecoded
        let eventTriggersContainer = try containerValues.decodeIfPresent([EventTriggerDefinition?].self, forKey: .eventTriggers)
        var eventTriggersDecoded0:[EventTriggerDefinition]? = nil
        if let eventTriggersContainer = eventTriggersContainer {
            eventTriggersDecoded0 = [EventTriggerDefinition]()
            for structure0 in eventTriggersContainer {
                if let structure0 = structure0 {
                    eventTriggersDecoded0?.append(structure0)
                }
            }
        }
        eventTriggers = eventTriggersDecoded0
    }
}

extension LambdaResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaResource(eventTriggers: \(String(describing: eventTriggers)), lambdaArn: \(String(describing: lambdaArn)))"}
}

/// <p>Identifies </p>
public struct LambdaResource: Equatable {
    /// <p>The array of ARNs for <a>S3Resource</a> objects to trigger the <a>LambdaResource</a> objects associated with this job.</p>
    public let eventTriggers: [EventTriggerDefinition]?
    /// <p>An Amazon Resource Name (ARN) that represents an AWS Lambda function to be triggered by
    ///       PUT object actions on the associated local Amazon S3 resource.</p>
    public let lambdaArn: String?

    public init (
        eventTriggers: [EventTriggerDefinition]? = nil,
        lambdaArn: String? = nil
    )
    {
        self.eventTriggers = eventTriggers
        self.lambdaArn = lambdaArn
    }
}

public struct ListClusterJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListClusterJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClusterJobsOutputError>
}

extension ListClusterJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClusterJobsInput(clusterId: \(String(describing: clusterId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClusterJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListClusterJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListClusterJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClusterJobsOutputError>
}

public struct ListClusterJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListClusterJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClusterJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClusterJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClusterJobsInput>
    public typealias MOutput = OperationOutput<ListClusterJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClusterJobsOutputError>
}

public struct ListClusterJobsInput: Equatable {
    /// <p>The 39-character ID for the cluster that you want to list, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: String?
    /// <p>The number of <code>JobListEntry</code> objects to return.</p>
    public let maxResults: Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
    ///       as the starting point for your returned list.</p>
    public let nextToken: String?

    public init (
        clusterId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.clusterId = clusterId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClusterJobsInputBody: Equatable {
    public let clusterId: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListClusterJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterId = "ClusterId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClusterJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClusterJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClusterJobsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClusterJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClusterJobsOutputResponse(jobListEntries: \(String(describing: jobListEntries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClusterJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClusterJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClusterJobsOutputResponse: Equatable {
    /// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
    ///       that indicates whether the job is a job part, in the case of export jobs. </p>
    public let jobListEntries: [JobListEntry]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>ListClusterJobsResult</code> call, your list
    ///       of returned jobs will start from this point in the array.</p>
    public let nextToken: String?

    public init (
        jobListEntries: [JobListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListClusterJobsOutputResponseBody: Equatable {
    public let jobListEntries: [JobListEntry]?
    public let nextToken: String?
}

extension ListClusterJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListClustersInputBodyMiddleware: Middleware {
    public let id: String = "ListClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClustersInput>
    public typealias MOutput = OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClustersOutputError>
}

extension ListClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClustersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClustersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListClustersInputHeadersMiddleware: Middleware {
    public let id: String = "ListClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClustersInput>
    public typealias MOutput = OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClustersOutputError>
}

public struct ListClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListClustersInput>
    public typealias MOutput = OperationOutput<ListClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListClustersOutputError>
}

public struct ListClustersInput: Equatable {
    /// <p>The number of <code>ClusterListEntry</code> objects to return.</p>
    public let maxResults: Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>ClusterListEntry</code> objects, you have the option of specifying
    ///         <code>NextToken</code> as the starting point for your returned list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListClustersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListClustersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListClustersOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListClustersOutputResponse(clusterListEntries: \(String(describing: clusterListEntries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListClustersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.clusterListEntries = output.clusterListEntries
            self.nextToken = output.nextToken
        } else {
            self.clusterListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListClustersOutputResponse: Equatable {
    /// <p>Each <code>ClusterListEntry</code> object contains a cluster's state, a cluster's ID,
    ///       and other important status information.</p>
    public let clusterListEntries: [ClusterListEntry]?
    /// <p>HTTP requests are stateless. If you use the automatically generated
    ///         <code>NextToken</code> value in your next <code>ClusterListEntry</code> call, your list of
    ///       returned clusters will start from this point in the array.</p>
    public let nextToken: String?

    public init (
        clusterListEntries: [ClusterListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.clusterListEntries = clusterListEntries
        self.nextToken = nextToken
    }
}

struct ListClustersOutputResponseBody: Equatable {
    public let clusterListEntries: [ClusterListEntry]?
    public let nextToken: String?
}

extension ListClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterListEntries = "ClusterListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterListEntriesContainer = try containerValues.decodeIfPresent([ClusterListEntry?].self, forKey: .clusterListEntries)
        var clusterListEntriesDecoded0:[ClusterListEntry]? = nil
        if let clusterListEntriesContainer = clusterListEntriesContainer {
            clusterListEntriesDecoded0 = [ClusterListEntry]()
            for structure0 in clusterListEntriesContainer {
                if let structure0 = structure0 {
                    clusterListEntriesDecoded0?.append(structure0)
                }
            }
        }
        clusterListEntries = clusterListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListCompatibleImagesInputBodyMiddleware: Middleware {
    public let id: String = "ListCompatibleImagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCompatibleImagesOutputError>
}

extension ListCompatibleImagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCompatibleImagesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCompatibleImagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCompatibleImagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListCompatibleImagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCompatibleImagesOutputError>
}

public struct ListCompatibleImagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCompatibleImagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCompatibleImagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCompatibleImagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCompatibleImagesInput>
    public typealias MOutput = OperationOutput<ListCompatibleImagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCompatibleImagesOutputError>
}

public struct ListCompatibleImagesInput: Equatable {
    /// <p>The maximum number of results for the list of compatible images. Currently, a Snowball
    ///       Edge device can store 10 AMIs.</p>
    public let maxResults: Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///       compatible images, you can specify a value for <code>NextToken</code> as the starting point
    ///       for your list of returned images.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListCompatibleImagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCompatibleImagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCompatibleImagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCompatibleImagesOutputError: Swift.Error, Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCompatibleImagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCompatibleImagesOutputResponse(compatibleImages: \(String(describing: compatibleImages)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCompatibleImagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListCompatibleImagesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.compatibleImages = output.compatibleImages
            self.nextToken = output.nextToken
        } else {
            self.compatibleImages = nil
            self.nextToken = nil
        }
    }
}

public struct ListCompatibleImagesOutputResponse: Equatable {
    /// <p>A JSON-formatted object that describes a compatible AMI, including the ID and name for
    ///       a Snow device AMI.</p>
    public let compatibleImages: [CompatibleImage]?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       returned images.</p>
    public let nextToken: String?

    public init (
        compatibleImages: [CompatibleImage]? = nil,
        nextToken: String? = nil
    )
    {
        self.compatibleImages = compatibleImages
        self.nextToken = nextToken
    }
}

struct ListCompatibleImagesOutputResponseBody: Equatable {
    public let compatibleImages: [CompatibleImage]?
    public let nextToken: String?
}

extension ListCompatibleImagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleImages = "CompatibleImages"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let compatibleImagesContainer = try containerValues.decodeIfPresent([CompatibleImage?].self, forKey: .compatibleImages)
        var compatibleImagesDecoded0:[CompatibleImage]? = nil
        if let compatibleImagesContainer = compatibleImagesContainer {
            compatibleImagesDecoded0 = [CompatibleImage]()
            for structure0 in compatibleImagesContainer {
                if let structure0 = structure0 {
                    compatibleImagesDecoded0?.append(structure0)
                }
            }
        }
        compatibleImages = compatibleImagesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

extension ListJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJobsInput>
    public typealias MOutput = OperationOutput<ListJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJobsOutputError>
}

public struct ListJobsInput: Equatable {
    /// <p>The number of <code>JobListEntry</code> objects to return.</p>
    public let maxResults: Int?
    /// <p>HTTP requests are stateless. To identify what object comes "next" in the list of
    ///         <code>JobListEntry</code> objects, you have the option of specifying <code>NextToken</code>
    ///       as the starting point for your returned list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJobsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJobsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJobsOutputResponse(jobListEntries: \(String(describing: jobListEntries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobListEntries = output.jobListEntries
            self.nextToken = output.nextToken
        } else {
            self.jobListEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListJobsOutputResponse: Equatable {
    /// <p>Each <code>JobListEntry</code> object contains a job's state, a job's ID, and a value
    ///       that indicates whether the job is a job part, in the case of export jobs. </p>
    public let jobListEntries: [JobListEntry]?
    /// <p>HTTP requests are stateless. If you use this automatically generated
    ///         <code>NextToken</code> value in your next <code>ListJobs</code> call, your returned
    ///         <code>JobListEntry</code> objects will start from this point in the array.</p>
    public let nextToken: String?

    public init (
        jobListEntries: [JobListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobListEntries = jobListEntries
        self.nextToken = nextToken
    }
}

struct ListJobsOutputResponseBody: Equatable {
    public let jobListEntries: [JobListEntry]?
    public let nextToken: String?
}

extension ListJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobListEntries = "JobListEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobListEntriesContainer = try containerValues.decodeIfPresent([JobListEntry?].self, forKey: .jobListEntries)
        var jobListEntriesDecoded0:[JobListEntry]? = nil
        if let jobListEntriesContainer = jobListEntriesContainer {
            jobListEntriesDecoded0 = [JobListEntry]()
            for structure0 in jobListEntriesContainer {
                if let structure0 = structure0 {
                    jobListEntriesDecoded0?.append(structure0)
                }
            }
        }
        jobListEntries = jobListEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLongTermPricingInputBodyMiddleware: Middleware {
    public let id: String = "ListLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLongTermPricingOutputError>
}

extension ListLongTermPricingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLongTermPricingInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLongTermPricingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListLongTermPricingInputHeadersMiddleware: Middleware {
    public let id: String = "ListLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLongTermPricingOutputError>
}

public struct ListLongTermPricingInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLongTermPricingInput>
    public typealias MOutput = OperationOutput<ListLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLongTermPricingOutputError>
}

public struct ListLongTermPricingInput: Equatable {
    /// <p>The maximum number of <code>ListLongTermPricing</code> objects to return.</p>
    public let maxResults: Int?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       <code>ListLongTermPricing</code> to return.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListLongTermPricingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLongTermPricingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLongTermPricingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLongTermPricingOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLongTermPricingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLongTermPricingOutputResponse(longTermPricingEntries: \(String(describing: longTermPricingEntries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListLongTermPricingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLongTermPricingOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.longTermPricingEntries = output.longTermPricingEntries
            self.nextToken = output.nextToken
        } else {
            self.longTermPricingEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListLongTermPricingOutputResponse: Equatable {
    /// <p>Each <code>LongTermPricingEntry</code> object contains a status, ID, and other information
    ///       about the <code>LongTermPricing</code> type. </p>
    public let longTermPricingEntries: [LongTermPricingListEntry]?
    /// <p>Because HTTP requests are stateless, this is the starting point for your next list of
    ///       returned <code>ListLongTermPricing</code> list.</p>
    public let nextToken: String?

    public init (
        longTermPricingEntries: [LongTermPricingListEntry]? = nil,
        nextToken: String? = nil
    )
    {
        self.longTermPricingEntries = longTermPricingEntries
        self.nextToken = nextToken
    }
}

struct ListLongTermPricingOutputResponseBody: Equatable {
    public let longTermPricingEntries: [LongTermPricingListEntry]?
    public let nextToken: String?
}

extension ListLongTermPricingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case longTermPricingEntries = "LongTermPricingEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingEntriesContainer = try containerValues.decodeIfPresent([LongTermPricingListEntry?].self, forKey: .longTermPricingEntries)
        var longTermPricingEntriesDecoded0:[LongTermPricingListEntry]? = nil
        if let longTermPricingEntriesContainer = longTermPricingEntriesContainer {
            longTermPricingEntriesDecoded0 = [LongTermPricingListEntry]()
            for structure0 in longTermPricingEntriesContainer {
                if let structure0 = structure0 {
                    longTermPricingEntriesDecoded0?.append(structure0)
                }
            }
        }
        longTermPricingEntries = longTermPricingEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LongTermPricingListEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentActiveJob = "CurrentActiveJob"
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case jobIds = "JobIds"
        case longTermPricingEndDate = "LongTermPricingEndDate"
        case longTermPricingId = "LongTermPricingId"
        case longTermPricingStartDate = "LongTermPricingStartDate"
        case longTermPricingStatus = "LongTermPricingStatus"
        case longTermPricingType = "LongTermPricingType"
        case replacementJob = "ReplacementJob"
        case snowballType = "SnowballType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentActiveJob = currentActiveJob {
            try encodeContainer.encode(currentActiveJob, forKey: .currentActiveJob)
        }
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let jobIds = jobIds {
            var jobIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIds)
            for longtermpricingassociatedjobidlist0 in jobIds {
                try jobIdsContainer.encode(longtermpricingassociatedjobidlist0)
            }
        }
        if let longTermPricingEndDate = longTermPricingEndDate {
            try encodeContainer.encode(longTermPricingEndDate.timeIntervalSince1970, forKey: .longTermPricingEndDate)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let longTermPricingStartDate = longTermPricingStartDate {
            try encodeContainer.encode(longTermPricingStartDate.timeIntervalSince1970, forKey: .longTermPricingStartDate)
        }
        if let longTermPricingStatus = longTermPricingStatus {
            try encodeContainer.encode(longTermPricingStatus, forKey: .longTermPricingStatus)
        }
        if let longTermPricingType = longTermPricingType {
            try encodeContainer.encode(longTermPricingType.rawValue, forKey: .longTermPricingType)
        }
        if let replacementJob = replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
        if let snowballType = snowballType {
            try encodeContainer.encode(snowballType.rawValue, forKey: .snowballType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let longTermPricingEndDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .longTermPricingEndDate)
        longTermPricingEndDate = longTermPricingEndDateDecoded
        let longTermPricingStartDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .longTermPricingStartDate)
        longTermPricingStartDate = longTermPricingStartDateDecoded
        let longTermPricingTypeDecoded = try containerValues.decodeIfPresent(LongTermPricingType.self, forKey: .longTermPricingType)
        longTermPricingType = longTermPricingTypeDecoded
        let currentActiveJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentActiveJob)
        currentActiveJob = currentActiveJobDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
        let longTermPricingStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingStatus)
        longTermPricingStatus = longTermPricingStatusDecoded
        let snowballTypeDecoded = try containerValues.decodeIfPresent(SnowballType.self, forKey: .snowballType)
        snowballType = snowballTypeDecoded
        let jobIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .jobIds)
        var jobIdsDecoded0:[String]? = nil
        if let jobIdsContainer = jobIdsContainer {
            jobIdsDecoded0 = [String]()
            for string0 in jobIdsContainer {
                if let string0 = string0 {
                    jobIdsDecoded0?.append(string0)
                }
            }
        }
        jobIds = jobIdsDecoded0
    }
}

extension LongTermPricingListEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LongTermPricingListEntry(currentActiveJob: \(String(describing: currentActiveJob)), isLongTermPricingAutoRenew: \(String(describing: isLongTermPricingAutoRenew)), jobIds: \(String(describing: jobIds)), longTermPricingEndDate: \(String(describing: longTermPricingEndDate)), longTermPricingId: \(String(describing: longTermPricingId)), longTermPricingStartDate: \(String(describing: longTermPricingStartDate)), longTermPricingStatus: \(String(describing: longTermPricingStatus)), longTermPricingType: \(String(describing: longTermPricingType)), replacementJob: \(String(describing: replacementJob)), snowballType: \(String(describing: snowballType)))"}
}

/// <p>Each <code>LongTermPricingListEntry</code> object contains information about a long term pricing type.</p>
public struct LongTermPricingListEntry: Equatable {
    /// <p>The current active jobs on the device the long term pricing type.</p>
    public let currentActiveJob: String?
    /// <p>If set to <code>true</code>, specifies that the current long term pricing type for the
    ///       device should be automatically renewed before the long term pricing contract expires.</p>
    public let isLongTermPricingAutoRenew: Bool?
    /// <p>The IDs of the jobs that are associated with a long term pricing type.</p>
    public let jobIds: [String]?
    /// <p>The end date the long term pricing contract.</p>
    public let longTermPricingEndDate: Date?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: String?
    /// <p>The start date of the long term pricing contract.</p>
    public let longTermPricingStartDate: Date?
    /// <p>The status of the long term pricing type.</p>
    public let longTermPricingStatus: String?
    /// <p>The type of long term pricing that was selected for the device.</p>
    public let longTermPricingType: LongTermPricingType?
    /// <p>A new device that replaces a device that is ordered with long term pricing.</p>
    public let replacementJob: String?
    /// <p>The type of AWS Snow Family device associated with this long term pricing job.</p>
    public let snowballType: SnowballType?

    public init (
        currentActiveJob: String? = nil,
        isLongTermPricingAutoRenew: Bool? = nil,
        jobIds: [String]? = nil,
        longTermPricingEndDate: Date? = nil,
        longTermPricingId: String? = nil,
        longTermPricingStartDate: Date? = nil,
        longTermPricingStatus: String? = nil,
        longTermPricingType: LongTermPricingType? = nil,
        replacementJob: String? = nil,
        snowballType: SnowballType? = nil
    )
    {
        self.currentActiveJob = currentActiveJob
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.jobIds = jobIds
        self.longTermPricingEndDate = longTermPricingEndDate
        self.longTermPricingId = longTermPricingId
        self.longTermPricingStartDate = longTermPricingStartDate
        self.longTermPricingStatus = longTermPricingStatus
        self.longTermPricingType = longTermPricingType
        self.replacementJob = replacementJob
        self.snowballType = snowballType
    }
}

public enum LongTermPricingType {
    case oneYear
    case threeYear
    case sdkUnknown(String)
}

extension LongTermPricingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LongTermPricingType] {
        return [
            .oneYear,
            .threeYear,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneYear: return "OneYear"
        case .threeYear: return "ThreeYear"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LongTermPricingType(rawValue: rawValue) ?? LongTermPricingType.sdkUnknown(rawValue)
    }
}

extension Notification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobStatesToNotify = "JobStatesToNotify"
        case notifyAll = "NotifyAll"
        case snsTopicARN = "SnsTopicARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatesToNotify = jobStatesToNotify {
            var jobStatesToNotifyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobStatesToNotify)
            for jobstatelist0 in jobStatesToNotify {
                try jobStatesToNotifyContainer.encode(jobstatelist0.rawValue)
            }
        }
        if notifyAll != false {
            try encodeContainer.encode(notifyAll, forKey: .notifyAll)
        }
        if let snsTopicARN = snsTopicARN {
            try encodeContainer.encode(snsTopicARN, forKey: .snsTopicARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicARN)
        snsTopicARN = snsTopicARNDecoded
        let jobStatesToNotifyContainer = try containerValues.decodeIfPresent([JobState?].self, forKey: .jobStatesToNotify)
        var jobStatesToNotifyDecoded0:[JobState]? = nil
        if let jobStatesToNotifyContainer = jobStatesToNotifyContainer {
            jobStatesToNotifyDecoded0 = [JobState]()
            for string0 in jobStatesToNotifyContainer {
                if let string0 = string0 {
                    jobStatesToNotifyDecoded0?.append(string0)
                }
            }
        }
        jobStatesToNotify = jobStatesToNotifyDecoded0
        let notifyAllDecoded = try containerValues.decode(Bool.self, forKey: .notifyAll)
        notifyAll = notifyAllDecoded
    }
}

extension Notification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Notification(jobStatesToNotify: \(String(describing: jobStatesToNotify)), notifyAll: \(String(describing: notifyAll)), snsTopicARN: \(String(describing: snsTopicARN)))"}
}

/// <p>The Amazon Simple Notification Service (Amazon SNS) notification settings associated
///       with a specific job. The <code>Notification</code> object is returned as a part of the
///       response syntax of the <code>DescribeJob</code> action in the <code>JobMetadata</code> data
///       type.</p>
///
///          <p>When the notification settings are defined during job creation, you can choose to
///       notify based on a specific set of job states using the <code>JobStatesToNotify</code> array of
///       strings, or you can specify that you want to have Amazon SNS notifications sent out for all
///       job states with <code>NotifyAll</code> set to true.</p>
public struct Notification: Equatable {
    /// <p>The list of job states that will trigger a notification for this job.</p>
    public let jobStatesToNotify: [JobState]?
    /// <p>Any change in job state will trigger a notification for this job.</p>
    public let notifyAll: Bool
    /// <p>The new SNS <code>TopicArn</code> that you want to associate with this job. You can
    ///       create Amazon Resource Names (ARNs) for topics by using the <a href="https://docs.aws.amazon.com/sns/latest/api/API_CreateTopic.html">CreateTopic</a> Amazon SNS API
    ///       action.</p>
    ///
    ///          <p>You can subscribe email addresses to an Amazon SNS topic through the AWS Management
    ///       Console, or by using the <a href="https://docs.aws.amazon.com/sns/latest/api/API_Subscribe.html">Subscribe</a> AWS Simple Notification Service (SNS) API action.</p>
    public let snsTopicARN: String?

    public init (
        jobStatesToNotify: [JobState]? = nil,
        notifyAll: Bool = false,
        snsTopicARN: String? = nil
    )
    {
        self.jobStatesToNotify = jobStatesToNotify
        self.notifyAll = notifyAll
        self.snsTopicARN = snsTopicARN
    }
}

extension ReturnShippingLabelAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReturnShippingLabelAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ReturnShippingLabelAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReturnShippingLabelAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You get this exception if you call <code>CreateReturnShippingLabel</code> and a valid return
///       shipping label already exists. In this case, use
///         <code>DescribeReturnShippingLabel</code> to get the url.</p>
public struct ReturnShippingLabelAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReturnShippingLabelAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ReturnShippingLabelAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension S3Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketArn = "BucketArn"
        case keyRange = "KeyRange"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketArn = bucketArn {
            try encodeContainer.encode(bucketArn, forKey: .bucketArn)
        }
        if let keyRange = keyRange {
            try encodeContainer.encode(keyRange, forKey: .keyRange)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketArn)
        bucketArn = bucketArnDecoded
        let keyRangeDecoded = try containerValues.decodeIfPresent(KeyRange.self, forKey: .keyRange)
        keyRange = keyRangeDecoded
    }
}

extension S3Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Resource(bucketArn: \(String(describing: bucketArn)), keyRange: \(String(describing: keyRange)))"}
}

/// <p>Each <code>S3Resource</code> object represents an Amazon S3 bucket that your
///       transferred data will be exported from or imported into. For export jobs, this object can have
///       an optional <code>KeyRange</code> value. The length of the range is defined at job creation,
///       and has either an inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or
///       both. Ranges are UTF-8 binary sorted.</p>
public struct S3Resource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an Amazon S3 bucket.</p>
    public let bucketArn: String?
    /// <p>For export jobs, you can provide an optional <code>KeyRange</code> within a specific
    ///       Amazon S3 bucket. The length of the range is defined at job creation, and has either an
    ///       inclusive <code>BeginMarker</code>, an inclusive <code>EndMarker</code>, or both. Ranges are
    ///       UTF-8 binary sorted.</p>
    public let keyRange: KeyRange?

    public init (
        bucketArn: String? = nil,
        keyRange: KeyRange? = nil
    )
    {
        self.bucketArn = bucketArn
        self.keyRange = keyRange
    }
}

extension Shipment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case trackingNumber = "TrackingNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let trackingNumber = trackingNumber {
            try encodeContainer.encode(trackingNumber, forKey: .trackingNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let trackingNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trackingNumber)
        trackingNumber = trackingNumberDecoded
    }
}

extension Shipment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Shipment(status: \(String(describing: status)), trackingNumber: \(String(describing: trackingNumber)))"}
}

/// <p>The <code>Status</code> and <code>TrackingNumber</code> information for an inbound or
///       outbound shipment.</p>
public struct Shipment: Equatable {
    /// <p>Status information for a shipment.</p>
    public let status: String?
    /// <p>The tracking number for this job. Using this tracking number with your region's
    ///       carrier's website, you can track a Snow device as the carrier transports it.</p>
    ///          <p>For India, the carrier is Amazon Logistics. For all other regions, UPS is the
    ///       carrier.</p>
    public let trackingNumber: String?

    public init (
        status: String? = nil,
        trackingNumber: String? = nil
    )
    {
        self.status = status
        self.trackingNumber = trackingNumber
    }
}

public enum ShipmentState {
    case received
    case returned
    case sdkUnknown(String)
}

extension ShipmentState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShipmentState] {
        return [
            .received,
            .returned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .received: return "RECEIVED"
        case .returned: return "RETURNED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShipmentState(rawValue: rawValue) ?? ShipmentState.sdkUnknown(rawValue)
    }
}

extension ShippingDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inboundShipment = "InboundShipment"
        case outboundShipment = "OutboundShipment"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inboundShipment = inboundShipment {
            try encodeContainer.encode(inboundShipment, forKey: .inboundShipment)
        }
        if let outboundShipment = outboundShipment {
            try encodeContainer.encode(outboundShipment, forKey: .outboundShipment)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let inboundShipmentDecoded = try containerValues.decodeIfPresent(Shipment.self, forKey: .inboundShipment)
        inboundShipment = inboundShipmentDecoded
        let outboundShipmentDecoded = try containerValues.decodeIfPresent(Shipment.self, forKey: .outboundShipment)
        outboundShipment = outboundShipmentDecoded
    }
}

extension ShippingDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ShippingDetails(inboundShipment: \(String(describing: inboundShipment)), outboundShipment: \(String(describing: outboundShipment)), shippingOption: \(String(describing: shippingOption)))"}
}

/// <p>A job's shipping information, including inbound and outbound tracking numbers and
///       shipping speed options.</p>
public struct ShippingDetails: Equatable {
    /// <p>The <code>Status</code> and <code>TrackingNumber</code> values for a Snow device being
    ///       returned to AWS for a particular job.</p>
    public let inboundShipment: Shipment?
    /// <p>The <code>Status</code> and <code>TrackingNumber</code> values for a Snow device being
    ///       delivered to the address that you specified for a particular job.</p>
    public let outboundShipment: Shipment?
    /// <p>The shipping speed for a particular job. This speed doesn't dictate how soon you'll get
    ///       the Snow device from the job's creation date. This speed represents how quickly it moves to its
    ///       destination while in transit. Regional shipping speeds are as follows:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>In Australia, you have access to express shipping. Typically, Snow devices shipped
    ///           express are delivered in about a day.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the European Union (EU), you have access to express shipping. Typically,
    ///           Snow devices shipped express are delivered in about a day. In addition, most countries in the
    ///           EU have access to standard shipping, which typically takes less than a week, one
    ///           way.</p>
    ///             </li>
    ///             <li>
    ///                <p>In India, Snow device are delivered in one to seven days.</p>
    ///             </li>
    ///             <li>
    ///                <p>In the United States of America (US), you have access to one-day shipping and
    ///           two-day shipping.</p>
    ///             </li>
    ///          </ul>
    public let shippingOption: ShippingOption?

    public init (
        inboundShipment: Shipment? = nil,
        outboundShipment: Shipment? = nil,
        shippingOption: ShippingOption? = nil
    )
    {
        self.inboundShipment = inboundShipment
        self.outboundShipment = outboundShipment
        self.shippingOption = shippingOption
    }
}

public enum ShippingLabelStatus {
    case failed
    case inProgress
    case succeeded
    case timedOut
    case sdkUnknown(String)
}

extension ShippingLabelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShippingLabelStatus] {
        return [
            .failed,
            .inProgress,
            .succeeded,
            .timedOut,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inProgress: return "InProgress"
        case .succeeded: return "Succeeded"
        case .timedOut: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShippingLabelStatus(rawValue: rawValue) ?? ShippingLabelStatus.sdkUnknown(rawValue)
    }
}

public enum ShippingOption {
    case express
    case nextDay
    case secondDay
    case standard
    case sdkUnknown(String)
}

extension ShippingOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ShippingOption] {
        return [
            .express,
            .nextDay,
            .secondDay,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .express: return "EXPRESS"
        case .nextDay: return "NEXT_DAY"
        case .secondDay: return "SECOND_DAY"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ShippingOption(rawValue: rawValue) ?? ShippingOption.sdkUnknown(rawValue)
    }
}

public enum SnowballCapacity {
    case noPreference
    case t100
    case t14
    case t42
    case t50
    case t8
    case t80
    case t98
    case sdkUnknown(String)
}

extension SnowballCapacity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnowballCapacity] {
        return [
            .noPreference,
            .t100,
            .t14,
            .t42,
            .t50,
            .t8,
            .t80,
            .t98,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .noPreference: return "NoPreference"
        case .t100: return "T100"
        case .t14: return "T14"
        case .t42: return "T42"
        case .t50: return "T50"
        case .t8: return "T8"
        case .t80: return "T80"
        case .t98: return "T98"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnowballCapacity(rawValue: rawValue) ?? SnowballCapacity.sdkUnknown(rawValue)
    }
}

public enum SnowballType {
    case edge
    case edgeC
    case edgeCg
    case edgeS
    case snc1Hdd
    case snc1Ssd
    case standard
    case sdkUnknown(String)
}

extension SnowballType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SnowballType] {
        return [
            .edge,
            .edgeC,
            .edgeCg,
            .edgeS,
            .snc1Hdd,
            .snc1Ssd,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .edge: return "EDGE"
        case .edgeC: return "EDGE_C"
        case .edgeCg: return "EDGE_CG"
        case .edgeS: return "EDGE_S"
        case .snc1Hdd: return "SNC1_HDD"
        case .snc1Ssd: return "SNC1_SSD"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SnowballType(rawValue: rawValue) ?? SnowballType.sdkUnknown(rawValue)
    }
}

extension SnowconeDeviceConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case wirelessConnection = "WirelessConnection"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessConnection = wirelessConnection {
            try encodeContainer.encode(wirelessConnection, forKey: .wirelessConnection)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessConnectionDecoded = try containerValues.decodeIfPresent(WirelessConnection.self, forKey: .wirelessConnection)
        wirelessConnection = wirelessConnectionDecoded
    }
}

extension SnowconeDeviceConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnowconeDeviceConfiguration(wirelessConnection: \(String(describing: wirelessConnection)))"}
}

/// <p>Specifies the device configuration for an AWS Snowcone job. </p>
public struct SnowconeDeviceConfiguration: Equatable {
    /// <p>Configures the wireless connection for the AWS Snowcone device.</p>
    public let wirelessConnection: WirelessConnection?

    public init (
        wirelessConnection: WirelessConnection? = nil
    )
    {
        self.wirelessConnection = wirelessConnection
    }
}

extension TaxDocuments: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iND = "IND"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iND = iND {
            try encodeContainer.encode(iND, forKey: .iND)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iNDDecoded = try containerValues.decodeIfPresent(INDTaxDocuments.self, forKey: .iND)
        iND = iNDDecoded
    }
}

extension TaxDocuments: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TaxDocuments(iND: \(String(describing: iND)))"}
}

/// <p>The tax documents required in your AWS Region.</p>
public struct TaxDocuments: Equatable {
    /// <p>The tax documents required in AWS Regions in India.</p>
    public let iND: INDTaxDocuments?

    public init (
        iND: INDTaxDocuments? = nil
    )
    {
        self.iND = iND
    }
}

extension UnsupportedAddressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedAddressException(message: \(String(describing: message)))"}
}

extension UnsupportedAddressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedAddressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The address is either outside the serviceable area for your region, or an error
///       occurred. Check the address with your region's carrier and try again. If the issue persists,
///       contact AWS Support.</p>
public struct UnsupportedAddressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedAddressExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedAddressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateClusterInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

extension UpdateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterInput(addressId: \(String(describing: addressId)), clusterId: \(String(describing: clusterId)), description: \(String(describing: description)), forwardingAddressId: \(String(describing: forwardingAddressId)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingOption: \(String(describing: shippingOption)))"}
}

extension UpdateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let clusterId = clusterId {
            try encodeContainer.encode(clusterId, forKey: .clusterId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
    }
}

public struct UpdateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInput: Equatable {
    /// <p>The ID of the updated <a>Address</a> object.</p>
    public let addressId: String?
    /// <p>The cluster ID of the cluster that you want to update, for example
    ///         <code>CID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let clusterId: String?
    /// <p>The updated description of this cluster.</p>
    public let description: String?
    /// <p>The updated ID for the forwarding address for a cluster. This field is not
    ///       supported in most regions.</p>
    public let forwardingAddressId: String?
    /// <p>The new or updated <a>Notification</a> object.</p>
    public let notification: Notification?
    /// <p>The updated arrays of <a>JobResource</a> objects that can include updated
    ///         <a>S3Resource</a> objects or <a>LambdaResource</a> objects.</p>
    public let resources: JobResource?
    /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this cluster.
    ///       To create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a> API action in AWS
    ///       Identity and Access Management (IAM).</p>
    public let roleARN: String?
    /// <p>The updated shipping option value of this cluster's <a>ShippingDetails</a>
    ///       object.</p>
    public let shippingOption: ShippingOption?

    public init (
        addressId: String? = nil,
        clusterId: String? = nil,
        description: String? = nil,
        forwardingAddressId: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingOption: ShippingOption? = nil
    )
    {
        self.addressId = addressId
        self.clusterId = clusterId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
    }
}

struct UpdateClusterInputBody: Equatable {
    public let clusterId: String?
    public let roleARN: String?
    public let description: String?
    public let resources: JobResource?
    public let addressId: String?
    public let shippingOption: ShippingOption?
    public let notification: Notification?
    public let forwardingAddressId: String?
}

extension UpdateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case clusterId = "ClusterId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterId)
        clusterId = clusterIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterOutputError: Swift.Error, Equatable {
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterOutputResponse()"}
}

extension UpdateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateClusterOutputResponse: Equatable {

    public init() {}
}

struct UpdateClusterOutputResponseBody: Equatable {
}

extension UpdateClusterOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateJobInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

extension UpdateJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobInput(addressId: \(String(describing: addressId)), description: \(String(describing: description)), forwardingAddressId: \(String(describing: forwardingAddressId)), jobId: \(String(describing: jobId)), notification: \(String(describing: notification)), resources: \(String(describing: resources)), roleARN: \(String(describing: roleARN)), shippingOption: \(String(describing: shippingOption)), snowballCapacityPreference: \(String(describing: snowballCapacityPreference)))"}
}

extension UpdateJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressId = addressId {
            try encodeContainer.encode(addressId, forKey: .addressId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let forwardingAddressId = forwardingAddressId {
            try encodeContainer.encode(forwardingAddressId, forKey: .forwardingAddressId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let resources = resources {
            try encodeContainer.encode(resources, forKey: .resources)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let shippingOption = shippingOption {
            try encodeContainer.encode(shippingOption.rawValue, forKey: .shippingOption)
        }
        if let snowballCapacityPreference = snowballCapacityPreference {
            try encodeContainer.encode(snowballCapacityPreference.rawValue, forKey: .snowballCapacityPreference)
        }
    }
}

public struct UpdateJobInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobInput>
    public typealias MOutput = OperationOutput<UpdateJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobOutputError>
}

public struct UpdateJobInput: Equatable {
    /// <p>The ID of the updated <a>Address</a> object.</p>
    public let addressId: String?
    /// <p>The updated description of this job's <a>JobMetadata</a> object.</p>
    public let description: String?
    /// <p>The updated ID for the forwarding address for a job. This field is not
    ///       supported in most regions.</p>
    public let forwardingAddressId: String?
    /// <p>The job ID of the job that you want to update, for example
    ///         <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?
    /// <p>The new or updated <a>Notification</a> object.</p>
    public let notification: Notification?
    /// <p>The updated <code>JobResource</code> object, or the updated <a>JobResource</a> object. </p>
    public let resources: JobResource?
    /// <p>The new role Amazon Resource Name (ARN) that you want to associate with this job. To
    ///       create a role ARN, use the <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreateRole.html">CreateRole</a>AWS Identity and Access
    ///       Management (IAM) API action.</p>
    public let roleARN: String?
    /// <p>The updated shipping option value of this job's <a>ShippingDetails</a>
    ///       object.</p>
    public let shippingOption: ShippingOption?
    /// <p>The updated <code>SnowballCapacityPreference</code> of this job's <a>JobMetadata</a> object. The 50 TB Snowballs are only available in the US
    ///       regions.</p>
    ///
    ///          <p>For more information, see
    ///       "https://docs.aws.amazon.com/snowball/latest/snowcone-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i> or
    ///       "https://docs.aws.amazon.com/snowball/latest/developer-guide/snow-device-types.html" (Snow
    ///       Family Devices and Capacity) in the <i>Snowcone User Guide</i>.</p>
    public let snowballCapacityPreference: SnowballCapacity?

    public init (
        addressId: String? = nil,
        description: String? = nil,
        forwardingAddressId: String? = nil,
        jobId: String? = nil,
        notification: Notification? = nil,
        resources: JobResource? = nil,
        roleARN: String? = nil,
        shippingOption: ShippingOption? = nil,
        snowballCapacityPreference: SnowballCapacity? = nil
    )
    {
        self.addressId = addressId
        self.description = description
        self.forwardingAddressId = forwardingAddressId
        self.jobId = jobId
        self.notification = notification
        self.resources = resources
        self.roleARN = roleARN
        self.shippingOption = shippingOption
        self.snowballCapacityPreference = snowballCapacityPreference
    }
}

struct UpdateJobInputBody: Equatable {
    public let jobId: String?
    public let roleARN: String?
    public let notification: Notification?
    public let resources: JobResource?
    public let addressId: String?
    public let shippingOption: ShippingOption?
    public let description: String?
    public let snowballCapacityPreference: SnowballCapacity?
    public let forwardingAddressId: String?
}

extension UpdateJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case addressId = "AddressId"
        case description = "Description"
        case forwardingAddressId = "ForwardingAddressId"
        case jobId = "JobId"
        case notification = "Notification"
        case resources = "Resources"
        case roleARN = "RoleARN"
        case shippingOption = "ShippingOption"
        case snowballCapacityPreference = "SnowballCapacityPreference"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(Notification.self, forKey: .notification)
        notification = notificationDecoded
        let resourcesDecoded = try containerValues.decodeIfPresent(JobResource.self, forKey: .resources)
        resources = resourcesDecoded
        let addressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .addressId)
        addressId = addressIdDecoded
        let shippingOptionDecoded = try containerValues.decodeIfPresent(ShippingOption.self, forKey: .shippingOption)
        shippingOption = shippingOptionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let snowballCapacityPreferenceDecoded = try containerValues.decodeIfPresent(SnowballCapacity.self, forKey: .snowballCapacityPreference)
        snowballCapacityPreference = snowballCapacityPreferenceDecoded
        let forwardingAddressIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .forwardingAddressId)
        forwardingAddressId = forwardingAddressIdDecoded
    }
}

extension UpdateJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterLimitExceededException" : self = .clusterLimitExceededException(try ClusterLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "Ec2RequestFailedException" : self = .ec2RequestFailedException(try Ec2RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputCombinationException" : self = .invalidInputCombinationException(try InvalidInputCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSRequestFailedException" : self = .kMSRequestFailedException(try KMSRequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobOutputError: Swift.Error, Equatable {
    case clusterLimitExceededException(ClusterLimitExceededException)
    case ec2RequestFailedException(Ec2RequestFailedException)
    case invalidInputCombinationException(InvalidInputCombinationException)
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case kMSRequestFailedException(KMSRequestFailedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobOutputResponse()"}
}

extension UpdateJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobOutputResponse: Equatable {

    public init() {}
}

struct UpdateJobOutputResponseBody: Equatable {
}

extension UpdateJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateJobShipmentStateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJobShipmentStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobShipmentStateOutputError>
}

extension UpdateJobShipmentStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobShipmentStateInput(jobId: \(String(describing: jobId)), shipmentState: \(String(describing: shipmentState)))"}
}

extension UpdateJobShipmentStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let shipmentState = shipmentState {
            try encodeContainer.encode(shipmentState.rawValue, forKey: .shipmentState)
        }
    }
}

public struct UpdateJobShipmentStateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJobShipmentStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobShipmentStateOutputError>
}

public struct UpdateJobShipmentStateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJobShipmentStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJobShipmentStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJobShipmentStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJobShipmentStateInput>
    public typealias MOutput = OperationOutput<UpdateJobShipmentStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJobShipmentStateOutputError>
}

public struct UpdateJobShipmentStateInput: Equatable {
    /// <p>The job ID of the job whose shipment date you want to update, for example
    ///       <code>JID123e4567-e89b-12d3-a456-426655440000</code>.</p>
    public let jobId: String?
    /// <p>The state of a device when it is being shipped. </p>
    ///          <p>Set to <code>RECEIVED</code> when the device arrives at your location.</p>
    ///          <p>Set to <code>RETURNED</code> when you have returned the device to AWS.</p>
    public let shipmentState: ShipmentState?

    public init (
        jobId: String? = nil,
        shipmentState: ShipmentState? = nil
    )
    {
        self.jobId = jobId
        self.shipmentState = shipmentState
    }
}

struct UpdateJobShipmentStateInputBody: Equatable {
    public let jobId: String?
    public let shipmentState: ShipmentState?
}

extension UpdateJobShipmentStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case shipmentState = "ShipmentState"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let shipmentStateDecoded = try containerValues.decodeIfPresent(ShipmentState.self, forKey: .shipmentState)
        shipmentState = shipmentStateDecoded
    }
}

extension UpdateJobShipmentStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJobShipmentStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJobShipmentStateOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJobShipmentStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJobShipmentStateOutputResponse()"}
}

extension UpdateJobShipmentStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateJobShipmentStateOutputResponse: Equatable {

    public init() {}
}

struct UpdateJobShipmentStateOutputResponseBody: Equatable {
}

extension UpdateJobShipmentStateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLongTermPricingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLongTermPricingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLongTermPricingOutputError>
}

extension UpdateLongTermPricingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLongTermPricingInput(isLongTermPricingAutoRenew: \(String(describing: isLongTermPricingAutoRenew)), longTermPricingId: \(String(describing: longTermPricingId)), replacementJob: \(String(describing: replacementJob)))"}
}

extension UpdateLongTermPricingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isLongTermPricingAutoRenew = isLongTermPricingAutoRenew {
            try encodeContainer.encode(isLongTermPricingAutoRenew, forKey: .isLongTermPricingAutoRenew)
        }
        if let longTermPricingId = longTermPricingId {
            try encodeContainer.encode(longTermPricingId, forKey: .longTermPricingId)
        }
        if let replacementJob = replacementJob {
            try encodeContainer.encode(replacementJob, forKey: .replacementJob)
        }
    }
}

public struct UpdateLongTermPricingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLongTermPricingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLongTermPricingOutputError>
}

public struct UpdateLongTermPricingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLongTermPricingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLongTermPricingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLongTermPricingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLongTermPricingInput>
    public typealias MOutput = OperationOutput<UpdateLongTermPricingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLongTermPricingOutputError>
}

public struct UpdateLongTermPricingInput: Equatable {
    /// <p>If set to <code>true</code>, specifies that the current long term pricing type for the
    ///       device should be automatically renewed before the long term pricing contract expires.</p>
    public let isLongTermPricingAutoRenew: Bool?
    /// <p>The ID of the long term pricing type for the device.</p>
    public let longTermPricingId: String?
    /// <p>Specifies that a device that is ordered with long term pricing should be replaced with a new device.</p>
    public let replacementJob: String?

    public init (
        isLongTermPricingAutoRenew: Bool? = nil,
        longTermPricingId: String? = nil,
        replacementJob: String? = nil
    )
    {
        self.isLongTermPricingAutoRenew = isLongTermPricingAutoRenew
        self.longTermPricingId = longTermPricingId
        self.replacementJob = replacementJob
    }
}

struct UpdateLongTermPricingInputBody: Equatable {
    public let longTermPricingId: String?
    public let replacementJob: String?
    public let isLongTermPricingAutoRenew: Bool?
}

extension UpdateLongTermPricingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case isLongTermPricingAutoRenew = "IsLongTermPricingAutoRenew"
        case longTermPricingId = "LongTermPricingId"
        case replacementJob = "ReplacementJob"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longTermPricingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longTermPricingId)
        longTermPricingId = longTermPricingIdDecoded
        let replacementJobDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replacementJob)
        replacementJob = replacementJobDecoded
        let isLongTermPricingAutoRenewDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isLongTermPricingAutoRenew)
        isLongTermPricingAutoRenew = isLongTermPricingAutoRenewDecoded
    }
}

extension UpdateLongTermPricingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLongTermPricingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidResourceException" : self = .invalidResourceException(try InvalidResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLongTermPricingOutputError: Swift.Error, Equatable {
    case invalidResourceException(InvalidResourceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLongTermPricingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLongTermPricingOutputResponse()"}
}

extension UpdateLongTermPricingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLongTermPricingOutputResponse: Equatable {

    public init() {}
}

struct UpdateLongTermPricingOutputResponseBody: Equatable {
}

extension UpdateLongTermPricingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension WirelessConnection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isWifiEnabled = "IsWifiEnabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isWifiEnabled != false {
            try encodeContainer.encode(isWifiEnabled, forKey: .isWifiEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isWifiEnabledDecoded = try containerValues.decode(Bool.self, forKey: .isWifiEnabled)
        isWifiEnabled = isWifiEnabledDecoded
    }
}

extension WirelessConnection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessConnection(isWifiEnabled: \(String(describing: isWifiEnabled)))"}
}

/// <p>Configures the wireless connection on an AWS Snowcone device.</p>
public struct WirelessConnection: Equatable {
    /// <p>Enables the Wi-Fi adapter on an AWS Snowcone device.</p>
    public let isWifiEnabled: Bool

    public init (
        isWifiEnabled: Bool = false
    )
    {
        self.isWifiEnabled = isWifiEnabled
    }
}
