// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum ChangeType {
    case immediate
    case requiresReboot
    case sdkUnknown(String)
}

extension ChangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChangeType] {
        return [
            .immediate,
            .requiresReboot,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .immediate: return "IMMEDIATE"
        case .requiresReboot: return "REQUIRES_REBOOT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
    }
}

extension Cluster: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activeNodes = "ActiveNodes"
        case clusterArn = "ClusterArn"
        case clusterDiscoveryEndpoint = "ClusterDiscoveryEndpoint"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeIdsToRemove = "NodeIdsToRemove"
        case nodeType = "NodeType"
        case nodes = "Nodes"
        case notificationConfiguration = "NotificationConfiguration"
        case parameterGroup = "ParameterGroup"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case sSEDescription = "SSEDescription"
        case securityGroups = "SecurityGroups"
        case status = "Status"
        case subnetGroup = "SubnetGroup"
        case totalNodes = "TotalNodes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeNodes = activeNodes {
            try encodeContainer.encode(activeNodes, forKey: .activeNodes)
        }
        if let clusterArn = clusterArn {
            try encodeContainer.encode(clusterArn, forKey: .clusterArn)
        }
        if let clusterDiscoveryEndpoint = clusterDiscoveryEndpoint {
            try encodeContainer.encode(clusterDiscoveryEndpoint, forKey: .clusterDiscoveryEndpoint)
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let nodes = nodes {
            var nodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodes)
            for nodelist0 in nodes {
                try nodesContainer.encode(nodelist0)
            }
        }
        if let notificationConfiguration = notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let parameterGroup = parameterGroup {
            try encodeContainer.encode(parameterGroup, forKey: .parameterGroup)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let sSEDescription = sSEDescription {
            try encodeContainer.encode(sSEDescription, forKey: .sSEDescription)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroupmembershiplist0 in securityGroups {
                try securityGroupsContainer.encode(securitygroupmembershiplist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let subnetGroup = subnetGroup {
            try encodeContainer.encode(subnetGroup, forKey: .subnetGroup)
        }
        if let totalNodes = totalNodes {
            try encodeContainer.encode(totalNodes, forKey: .totalNodes)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let clusterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterArn)
        clusterArn = clusterArnDecoded
        let totalNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalNodes)
        totalNodes = totalNodesDecoded
        let activeNodesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .activeNodes)
        activeNodes = activeNodesDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
        let clusterDiscoveryEndpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .clusterDiscoveryEndpoint)
        clusterDiscoveryEndpoint = clusterDiscoveryEndpointDecoded
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
        let nodesContainer = try containerValues.decodeIfPresent([Node?].self, forKey: .nodes)
        var nodesDecoded0:[Node]? = nil
        if let nodesContainer = nodesContainer {
            nodesDecoded0 = [Node]()
            for structure0 in nodesContainer {
                if let structure0 = structure0 {
                    nodesDecoded0?.append(structure0)
                }
            }
        }
        nodes = nodesDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
        let subnetGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([SecurityGroupMembership?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[SecurityGroupMembership]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [SecurityGroupMembership]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupDecoded = try containerValues.decodeIfPresent(ParameterGroupStatus.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
        let sSEDescriptionDecoded = try containerValues.decodeIfPresent(SSEDescription.self, forKey: .sSEDescription)
        sSEDescription = sSEDescriptionDecoded
    }
}

extension Cluster: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Cluster(activeNodes: \(String(describing: activeNodes)), clusterArn: \(String(describing: clusterArn)), clusterDiscoveryEndpoint: \(String(describing: clusterDiscoveryEndpoint)), clusterName: \(String(describing: clusterName)), description: \(String(describing: description)), iamRoleArn: \(String(describing: iamRoleArn)), nodeIdsToRemove: \(String(describing: nodeIdsToRemove)), nodeType: \(String(describing: nodeType)), nodes: \(String(describing: nodes)), notificationConfiguration: \(String(describing: notificationConfiguration)), parameterGroup: \(String(describing: parameterGroup)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), sSEDescription: \(String(describing: sSEDescription)), securityGroups: \(String(describing: securityGroups)), status: \(String(describing: status)), subnetGroup: \(String(describing: subnetGroup)), totalNodes: \(String(describing: totalNodes)))"}
}

/// <p>Contains all of the attributes of a specific DAX cluster.</p>
public struct Cluster: Equatable {
    /// <p>The number of nodes in the cluster that are active (i.e., capable of serving
    ///             requests).</p>
    public let activeNodes: Int?
    /// <p>The Amazon Resource Name (ARN) that uniquely identifies the cluster.
    ///         </p>
    public let clusterArn: String?
    /// <p>The configuration endpoint for this DAX cluster, consisting of a DNS name and a
    ///             port number. Client applications can specify this endpoint, rather than an individual
    ///             node endpoint, and allow the DAX client software to intelligently route requests and
    ///             responses to nodes in the DAX cluster.</p>
    public let clusterDiscoveryEndpoint: Endpoint?
    /// <p>The name of the DAX cluster.</p>
    public let clusterName: String?
    /// <p>The description of the cluster.</p>
    public let description: String?
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX
    ///             will assume this role and use the role's permissions to access DynamoDB on your
    ///             behalf.</p>
    public let iamRoleArn: String?
    /// <p>A list of nodes to be removed from the cluster.</p>
    public let nodeIdsToRemove: [String]?
    /// <p>The node type for the nodes in the cluster. (All nodes in a DAX cluster are of
    ///             the same type.)</p>
    public let nodeType: String?
    /// <p>A list of nodes that are currently in the cluster.</p>
    public let nodes: [Node]?
    /// <p>Describes a notification topic and its status. Notification topics are used for
    ///             publishing DAX events to subscribers using Amazon Simple Notification Service
    ///             (SNS).</p>
    public let notificationConfiguration: NotificationConfiguration?
    /// <p>The parameter group being used by nodes in the cluster.</p>
    public let parameterGroup: ParameterGroupStatus?
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For
    ///             example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than
    ///             30 minutes, and is performed automatically within the maintenance window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
    public let sSEDescription: SSEDescription?
    /// <p>A list of security groups, and the status of each, for the nodes in the cluster.</p>
    public let securityGroups: [SecurityGroupMembership]?
    /// <p>The current status of the cluster.</p>
    public let status: String?
    /// <p>The subnet group where the DAX cluster is running.</p>
    public let subnetGroup: String?
    /// <p>The total number of nodes in the cluster.</p>
    public let totalNodes: Int?

    public init (
        activeNodes: Int? = nil,
        clusterArn: String? = nil,
        clusterDiscoveryEndpoint: Endpoint? = nil,
        clusterName: String? = nil,
        description: String? = nil,
        iamRoleArn: String? = nil,
        nodeIdsToRemove: [String]? = nil,
        nodeType: String? = nil,
        nodes: [Node]? = nil,
        notificationConfiguration: NotificationConfiguration? = nil,
        parameterGroup: ParameterGroupStatus? = nil,
        preferredMaintenanceWindow: String? = nil,
        sSEDescription: SSEDescription? = nil,
        securityGroups: [SecurityGroupMembership]? = nil,
        status: String? = nil,
        subnetGroup: String? = nil,
        totalNodes: Int? = nil
    )
    {
        self.activeNodes = activeNodes
        self.clusterArn = clusterArn
        self.clusterDiscoveryEndpoint = clusterDiscoveryEndpoint
        self.clusterName = clusterName
        self.description = description
        self.iamRoleArn = iamRoleArn
        self.nodeIdsToRemove = nodeIdsToRemove
        self.nodeType = nodeType
        self.nodes = nodes
        self.notificationConfiguration = notificationConfiguration
        self.parameterGroup = parameterGroup
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.sSEDescription = sSEDescription
        self.securityGroups = securityGroups
        self.status = status
        self.subnetGroup = subnetGroup
        self.totalNodes = totalNodes
    }
}

extension ClusterAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ClusterAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClusterAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You already have a DAX cluster with the given identifier.</p>
public struct ClusterAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ClusterAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterNotFoundFault(message: \(String(describing: message)))"}
}

extension ClusterNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClusterNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested cluster ID does not refer to an existing DAX cluster.</p>
public struct ClusterNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ClusterNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClusterQuotaForCustomerExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClusterQuotaForCustomerExceededFault(message: \(String(describing: message)))"}
}

extension ClusterQuotaForCustomerExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ClusterQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of DAX clusters for your AWS
///             account.</p>
public struct ClusterQuotaForCustomerExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ClusterQuotaForCustomerExceededFaultBody: Equatable {
    public let message: String?
}

extension ClusterQuotaForCustomerExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateClusterInputBodyMiddleware: Middleware {
    public let id: String = "CreateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

extension CreateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterInput(availabilityZones: \(String(describing: availabilityZones)), clusterName: \(String(describing: clusterName)), description: \(String(describing: description)), iamRoleArn: \(String(describing: iamRoleArn)), nodeType: \(String(describing: nodeType)), notificationTopicArn: \(String(describing: notificationTopicArn)), parameterGroupName: \(String(describing: parameterGroupName)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), replicationFactor: \(String(describing: replicationFactor)), sSESpecification: \(String(describing: sSESpecification)), securityGroupIds: \(String(describing: securityGroupIds)), subnetGroupName: \(String(describing: subnetGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if replicationFactor != 0 {
            try encodeContainer.encode(replicationFactor, forKey: .replicationFactor)
        }
        if let sSESpecification = sSESpecification {
            try encodeContainer.encode(sSESpecification, forKey: .sSESpecification)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateClusterInput>
    public typealias MOutput = OperationOutput<CreateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateClusterOutputError>
}

public struct CreateClusterInput: Equatable {
    /// <p>The Availability Zones (AZs) in which the cluster nodes will reside after the cluster
    ///          has been created or updated. If provided, the length of this list must equal the <code>ReplicationFactor</code> parameter.
    ///          If you omit this parameter, DAX will spread the nodes across Availability Zones for the highest availability.</p>
    public let availabilityZones: [String]?
    /// <p>The cluster identifier. This parameter is stored as a lowercase
    ///             string.</p>
    ///         <p>
    ///             <b>Constraints:</b>
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>A name must contain from 1 to 20 alphanumeric characters or
    ///                     hyphens.</p>
    ///             </li>
    ///             <li>
    ///                 <p>The first character must be a letter.</p>
    ///             </li>
    ///             <li>
    ///                 <p>A name cannot end with a hyphen or contain two consecutive
    ///                     hyphens.</p>
    ///             </li>
    ///          </ul>
    public let clusterName: String?
    /// <p>A description of the cluster.</p>
    public let description: String?
    /// <p>A valid Amazon Resource Name (ARN) that identifies an IAM role. At runtime, DAX
    ///             will assume this role and use the role's permissions to access DynamoDB on your
    ///             behalf.</p>
    public let iamRoleArn: String?
    /// <p>The compute and memory capacity of the nodes in the cluster.</p>
    public let nodeType: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon SNS topic to which notifications will
    ///             be sent.</p>
    ///         <note>
    ///             <p>The Amazon SNS topic owner must be same as the DAX cluster owner.</p>
    ///         </note>
    public let notificationTopicArn: String?
    /// <p>The parameter group to be associated with the DAX cluster.</p>
    public let parameterGroupName: String?
    /// <p>Specifies the weekly time range during which maintenance on the DAX cluster is
    ///             performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock
    ///             UTC). The minimum maintenance window is a 60 minute period. Valid values for
    ///                 <code>ddd</code> are:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>sun</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>mon</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>tue</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>wed</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>thu</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>fri</code>
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>sat</code>
    ///                 </p>
    ///             </li>
    ///          </ul>
    ///         <p>Example: <code>sun:05:00-sun:09:00</code>
    ///         </p>
    ///         <note>
    ///             <p>If you don't specify a preferred maintenance window when you create or modify a
    ///                 cache cluster, DAX assigns a 60-minute maintenance window on a randomly selected day
    ///                 of the week.</p>
    ///          </note>
    public let preferredMaintenanceWindow: String?
    /// <p>The number of nodes in the DAX cluster. A replication factor of 1 will
    ///             create a single-node cluster, without any read replicas. For additional fault tolerance,
    ///             you can create a multiple node cluster with one or more read replicas. To do this, set
    ///                 <code>ReplicationFactor</code> to a number between 3 (one primary and two read replicas) and 10 (one primary and nine read replicas).
    ///                  <code>If the AvailabilityZones</code> parameter is provided, its length must equal the <code>ReplicationFactor</code>.</p>
    ///         <note>
    ///             <p>AWS recommends that you have at least two read replicas per cluster.</p>
    ///          </note>
    public let replicationFactor: Int
    /// <p>Represents the settings used to enable server-side encryption on the cluster.</p>
    public let sSESpecification: SSESpecification?
    /// <p>A list of security group IDs to be assigned to each node in the DAX cluster. (Each of the
    ///              security group ID is system-generated.)</p>
    ///         <p>If this parameter is not specified, DAX assigns the default VPC security group to
    ///             each node.</p>
    public let securityGroupIds: [String]?
    /// <p>The name of the subnet group to be used for the replication group.</p>
    ///         <important>
    ///             <p>DAX clusters can only run in an Amazon VPC environment. All of the subnets
    ///                 that you specify in a subnet group must exist in the same VPC.</p>
    ///         </important>
    public let subnetGroupName: String?
    /// <p>A set of tags to associate with the DAX cluster.  </p>
    public let tags: [Tag]?

    public init (
        availabilityZones: [String]? = nil,
        clusterName: String? = nil,
        description: String? = nil,
        iamRoleArn: String? = nil,
        nodeType: String? = nil,
        notificationTopicArn: String? = nil,
        parameterGroupName: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        replicationFactor: Int = 0,
        sSESpecification: SSESpecification? = nil,
        securityGroupIds: [String]? = nil,
        subnetGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.description = description
        self.iamRoleArn = iamRoleArn
        self.nodeType = nodeType
        self.notificationTopicArn = notificationTopicArn
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.replicationFactor = replicationFactor
        self.sSESpecification = sSESpecification
        self.securityGroupIds = securityGroupIds
        self.subnetGroupName = subnetGroupName
        self.tags = tags
    }
}

struct CreateClusterInputBody: Equatable {
    public let clusterName: String?
    public let nodeType: String?
    public let description: String?
    public let replicationFactor: Int
    public let availabilityZones: [String]?
    public let subnetGroupName: String?
    public let securityGroupIds: [String]?
    public let preferredMaintenanceWindow: String?
    public let notificationTopicArn: String?
    public let iamRoleArn: String?
    public let parameterGroupName: String?
    public let tags: [Tag]?
    public let sSESpecification: SSESpecification?
}

extension CreateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case description = "Description"
        case iamRoleArn = "IamRoleArn"
        case nodeType = "NodeType"
        case notificationTopicArn = "NotificationTopicArn"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case replicationFactor = "ReplicationFactor"
        case sSESpecification = "SSESpecification"
        case securityGroupIds = "SecurityGroupIds"
        case subnetGroupName = "SubnetGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let replicationFactorDecoded = try containerValues.decode(Int.self, forKey: .replicationFactor)
        replicationFactor = replicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let sSESpecificationDecoded = try containerValues.decodeIfPresent(SSESpecification.self, forKey: .sSESpecification)
        sSESpecification = sSESpecificationDecoded
    }
}

extension CreateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterAlreadyExistsFault" : self = .clusterAlreadyExistsFault(try ClusterAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClusterQuotaForCustomerExceededFault" : self = .clusterQuotaForCustomerExceededFault(try ClusterQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateClusterOutputError: Equatable {
    case clusterAlreadyExistsFault(ClusterAlreadyExistsFault)
    case clusterQuotaForCustomerExceededFault(ClusterQuotaForCustomerExceededFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension CreateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct CreateClusterOutputResponse: Equatable {
    /// <p>A description of the DAX cluster that you have created.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct CreateClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension CreateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct CreateParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParameterGroupOutputError>
}

extension CreateParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParameterGroupInput(description: \(String(describing: description)), parameterGroupName: \(String(describing: parameterGroupName)))"}
}

extension CreateParameterGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct CreateParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateParameterGroupInput>
    public typealias MOutput = OperationOutput<CreateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateParameterGroupOutputError>
}

public struct CreateParameterGroupInput: Equatable {
    /// <p>A description of the parameter group.</p>
    public let description: String?
    /// <p>The name of the parameter group to apply to all of the clusters in this replication
    ///             group.</p>
    public let parameterGroupName: String?

    public init (
        description: String? = nil,
        parameterGroupName: String? = nil
    )
    {
        self.description = description
        self.parameterGroupName = parameterGroupName
    }
}

struct CreateParameterGroupInputBody: Equatable {
    public let parameterGroupName: String?
    public let description: String?
}

extension CreateParameterGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupAlreadyExistsFault" : self = .parameterGroupAlreadyExistsFault(try ParameterGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupQuotaExceededFault" : self = .parameterGroupQuotaExceededFault(try ParameterGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateParameterGroupOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupAlreadyExistsFault(ParameterGroupAlreadyExistsFault)
    case parameterGroupQuotaExceededFault(ParameterGroupQuotaExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateParameterGroupOutputResponse(parameterGroup: \(String(describing: parameterGroup)))"}
}

extension CreateParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct CreateParameterGroupOutputResponse: Equatable {
    /// <p>Represents the output of a <i>CreateParameterGroup</i>
    ///             action.</p>
    public let parameterGroup: ParameterGroup?

    public init (
        parameterGroup: ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct CreateParameterGroupOutputResponseBody: Equatable {
    public let parameterGroup: ParameterGroup?
}

extension CreateParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct CreateSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubnetGroupOutputError>
}

extension CreateSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubnetGroupInput(description: \(String(describing: description)), subnetGroupName: \(String(describing: subnetGroupName)), subnetIds: \(String(describing: subnetIds)))"}
}

extension CreateSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct CreateSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSubnetGroupInput>
    public typealias MOutput = OperationOutput<CreateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSubnetGroupOutputError>
}

public struct CreateSubnetGroupInput: Equatable {
    /// <p>A description for the subnet group</p>
    public let description: String?
    /// <p>A name for the subnet group. This value is stored as a lowercase string. </p>
    public let subnetGroupName: String?
    /// <p>A list of VPC subnet IDs for the subnet group.</p>
    public let subnetIds: [String]?

    public init (
        description: String? = nil,
        subnetGroupName: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct CreateSubnetGroupInputBody: Equatable {
    public let subnetGroupName: String?
    public let description: String?
    public let subnetIds: [String]?
}

extension CreateSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension CreateSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupAlreadyExistsFault" : self = .subnetGroupAlreadyExistsFault(try SubnetGroupAlreadyExistsFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupQuotaExceededFault" : self = .subnetGroupQuotaExceededFault(try SubnetGroupQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSubnetGroupOutputError: Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupAlreadyExistsFault(SubnetGroupAlreadyExistsFault)
    case subnetGroupQuotaExceededFault(SubnetGroupQuotaExceededFault)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSubnetGroupOutputResponse(subnetGroup: \(String(describing: subnetGroup)))"}
}

extension CreateSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct CreateSubnetGroupOutputResponse: Equatable {
    /// <p>Represents the output of a <i>CreateSubnetGroup</i>
    ///             operation.</p>
    public let subnetGroup: SubnetGroup?

    public init (
        subnetGroup: SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct CreateSubnetGroupOutputResponseBody: Equatable {
    public let subnetGroup: SubnetGroup?
}

extension CreateSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}

public struct DecreaseReplicationFactorInputBodyMiddleware: Middleware {
    public let id: String = "DecreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseReplicationFactorOutputError>
}

extension DecreaseReplicationFactorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecreaseReplicationFactorInput(availabilityZones: \(String(describing: availabilityZones)), clusterName: \(String(describing: clusterName)), newReplicationFactor: \(String(describing: newReplicationFactor)), nodeIdsToRemove: \(String(describing: nodeIdsToRemove)))"}
}

extension DecreaseReplicationFactorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
        if let nodeIdsToRemove = nodeIdsToRemove {
            var nodeIdsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToRemove)
            for nodeidentifierlist0 in nodeIdsToRemove {
                try nodeIdsToRemoveContainer.encode(nodeidentifierlist0)
            }
        }
    }
}

public struct DecreaseReplicationFactorInputHeadersMiddleware: Middleware {
    public let id: String = "DecreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInputQueryItemMiddleware: Middleware {
    public let id: String = "DecreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<DecreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<DecreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecreaseReplicationFactorOutputError>
}

public struct DecreaseReplicationFactorInput: Equatable {
    /// <p>The Availability Zone(s) from which to remove nodes.</p>
    public let availabilityZones: [String]?
    /// <p>The name of the DAX cluster from which you want to remove nodes.</p>
    public let clusterName: String?
    /// <p>The new number of nodes for the DAX cluster.</p>
    public let newReplicationFactor: Int
    /// <p>The unique identifiers of the nodes to be removed from the cluster.</p>
    public let nodeIdsToRemove: [String]?

    public init (
        availabilityZones: [String]? = nil,
        clusterName: String? = nil,
        newReplicationFactor: Int = 0,
        nodeIdsToRemove: [String]? = nil
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
        self.nodeIdsToRemove = nodeIdsToRemove
    }
}

struct DecreaseReplicationFactorInputBody: Equatable {
    public let clusterName: String?
    public let newReplicationFactor: Int
    public let availabilityZones: [String]?
    public let nodeIdsToRemove: [String]?
}

extension DecreaseReplicationFactorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
        case nodeIdsToRemove = "NodeIdsToRemove"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let nodeIdsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nodeIdsToRemove)
        var nodeIdsToRemoveDecoded0:[String]? = nil
        if let nodeIdsToRemoveContainer = nodeIdsToRemoveContainer {
            nodeIdsToRemoveDecoded0 = [String]()
            for string0 in nodeIdsToRemoveContainer {
                if let string0 = string0 {
                    nodeIdsToRemoveDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToRemove = nodeIdsToRemoveDecoded0
    }
}

extension DecreaseReplicationFactorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DecreaseReplicationFactorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecreaseReplicationFactorOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecreaseReplicationFactorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecreaseReplicationFactorOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension DecreaseReplicationFactorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DecreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DecreaseReplicationFactorOutputResponse: Equatable {
    /// <p>A description of the DAX cluster, after you have decreased its replication
    ///             factor.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DecreaseReplicationFactorOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension DecreaseReplicationFactorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteClusterInputBodyMiddleware: Middleware {
    public let id: String = "DeleteClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

extension DeleteClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterInput(clusterName: \(String(describing: clusterName)))"}
}

extension DeleteClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
    }
}

public struct DeleteClusterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteClusterInput>
    public typealias MOutput = OperationOutput<DeleteClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteClusterOutputError>
}

public struct DeleteClusterInput: Equatable {
    /// <p>The name of the cluster to be deleted.</p>
    public let clusterName: String?

    public init (
        clusterName: String? = nil
    )
    {
        self.clusterName = clusterName
    }
}

struct DeleteClusterInputBody: Equatable {
    public let clusterName: String?
}

extension DeleteClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
    }
}

extension DeleteClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension DeleteClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct DeleteClusterOutputResponse: Equatable {
    /// <p>A description of the DAX cluster that is being deleted.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct DeleteClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension DeleteClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct DeleteParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterGroupOutputError>
}

extension DeleteParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParameterGroupInput(parameterGroupName: \(String(describing: parameterGroupName)))"}
}

extension DeleteParameterGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }
}

public struct DeleteParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteParameterGroupInput>
    public typealias MOutput = OperationOutput<DeleteParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteParameterGroupOutputError>
}

public struct DeleteParameterGroupInput: Equatable {
    /// <p>The name of the parameter group to delete.</p>
    public let parameterGroupName: String?

    public init (
        parameterGroupName: String? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
    }
}

struct DeleteParameterGroupInputBody: Equatable {
    public let parameterGroupName: String?
}

extension DeleteParameterGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
    }
}

extension DeleteParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteParameterGroupOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteParameterGroupOutputResponse(deletionMessage: \(String(describing: deletionMessage)))"}
}

extension DeleteParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteParameterGroupOutputResponse: Equatable {
    /// <p>A user-specified message for this action (i.e., a reason for deleting the parameter
    ///             group).</p>
    public let deletionMessage: String?

    public init (
        deletionMessage: String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteParameterGroupOutputResponseBody: Equatable {
    public let deletionMessage: String?
}

extension DeleteParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DeleteSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubnetGroupOutputError>
}

extension DeleteSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubnetGroupInput(subnetGroupName: \(String(describing: subnetGroupName)))"}
}

extension DeleteSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
    }
}

public struct DeleteSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSubnetGroupInput>
    public typealias MOutput = OperationOutput<DeleteSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSubnetGroupOutputError>
}

public struct DeleteSubnetGroupInput: Equatable {
    /// <p>The name of the subnet group to delete.</p>
    public let subnetGroupName: String?

    public init (
        subnetGroupName: String? = nil
    )
    {
        self.subnetGroupName = subnetGroupName
    }
}

struct DeleteSubnetGroupInputBody: Equatable {
    public let subnetGroupName: String?
}

extension DeleteSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subnetGroupName = "SubnetGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
    }
}

extension DeleteSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupInUseFault" : self = .subnetGroupInUseFault(try SubnetGroupInUseFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSubnetGroupOutputError: Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupInUseFault(SubnetGroupInUseFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSubnetGroupOutputResponse(deletionMessage: \(String(describing: deletionMessage)))"}
}

extension DeleteSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deletionMessage = output.deletionMessage
        } else {
            self.deletionMessage = nil
        }
    }
}

public struct DeleteSubnetGroupOutputResponse: Equatable {
    /// <p>A user-specified message for this action (i.e., a reason for deleting the subnet
    ///             group).</p>
    public let deletionMessage: String?

    public init (
        deletionMessage: String? = nil
    )
    {
        self.deletionMessage = deletionMessage
    }
}

struct DeleteSubnetGroupOutputResponseBody: Equatable {
    public let deletionMessage: String?
}

extension DeleteSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deletionMessage = "DeletionMessage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deletionMessage)
        deletionMessage = deletionMessageDecoded
    }
}

public struct DescribeClustersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeClustersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

extension DescribeClustersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersInput(clusterNames: \(String(describing: clusterNames)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeClustersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterNames = clusterNames {
            var clusterNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .clusterNames)
            for clusternamelist0 in clusterNames {
                try clusterNamesContainer.encode(clusternamelist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeClustersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeClustersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeClustersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeClustersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeClustersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeClustersInput>
    public typealias MOutput = OperationOutput<DescribeClustersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeClustersOutputError>
}

public struct DescribeClustersInput: Equatable {
    /// <p>The names of the DAX clusters being described.</p>
    public let clusterNames: [String]?
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?

    public init (
        clusterNames: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.clusterNames = clusterNames
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeClustersInputBody: Equatable {
    public let clusterNames: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeClustersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterNames = "ClusterNames"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .clusterNames)
        var clusterNamesDecoded0:[String]? = nil
        if let clusterNamesContainer = clusterNamesContainer {
            clusterNamesDecoded0 = [String]()
            for string0 in clusterNamesContainer {
                if let string0 = string0 {
                    clusterNamesDecoded0?.append(string0)
                }
            }
        }
        clusterNames = clusterNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeClustersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeClustersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeClustersOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeClustersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeClustersOutputResponse(clusters: \(String(describing: clusters)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeClustersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeClustersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.clusters = output.clusters
            self.nextToken = output.nextToken
        } else {
            self.clusters = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeClustersOutputResponse: Equatable {
    /// <p>The descriptions of your DAX clusters, in response to a
    ///             <i>DescribeClusters</i> request.</p>
    public let clusters: [Cluster]?
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?

    public init (
        clusters: [Cluster]? = nil,
        nextToken: String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

struct DescribeClustersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let clusters: [Cluster]?
}

extension DescribeClustersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusters = "Clusters"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let clustersContainer = try containerValues.decodeIfPresent([Cluster?].self, forKey: .clusters)
        var clustersDecoded0:[Cluster]? = nil
        if let clustersContainer = clustersContainer {
            clustersDecoded0 = [Cluster]()
            for structure0 in clustersContainer {
                if let structure0 = structure0 {
                    clustersDecoded0?.append(structure0)
                }
            }
        }
        clusters = clustersDecoded0
    }
}

public struct DescribeDefaultParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeDefaultParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultParametersOutputError>
}

extension DescribeDefaultParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultParametersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeDefaultParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct DescribeDefaultParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDefaultParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDefaultParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDefaultParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDefaultParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDefaultParametersInput>
    public typealias MOutput = OperationOutput<DescribeDefaultParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDefaultParametersOutputError>
}

public struct DescribeDefaultParametersInput: Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeDefaultParametersInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeDefaultParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeDefaultParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultParametersOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDefaultParametersOutputResponse(nextToken: \(String(describing: nextToken)), parameters: \(String(describing: parameters)))"}
}

extension DescribeDefaultParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDefaultParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeDefaultParametersOutputResponse: Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?
    /// <p>A list of parameters.  Each element in the list represents one parameter.</p>
    public let parameters: [Parameter]?

    public init (
        nextToken: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeDefaultParametersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let parameters: [Parameter]?
}

extension DescribeDefaultParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(duration: \(String(describing: duration)), endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sourceName: \(String(describing: sourceName)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Equatable {
    /// <p>The number of minutes' worth of events to retrieve.</p>
    public let duration: Int?
    /// <p>The end of the time interval for which to retrieve events, specified in ISO 8601
    ///             format.</p>
    public let endTime: Date?
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The identifier of the event source for which events will be returned. If not
    ///             specified, then all sources are included in the response.</p>
    public let sourceName: String?
    /// <p>The event source to retrieve events for. If no value is specified, all events are
    ///             returned.</p>
    public let sourceType: SourceType?
    /// <p>The beginning of the time interval to retrieve events for, specified in ISO 8601
    ///             format.</p>
    public let startTime: Date?

    public init (
        duration: Int? = nil,
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sourceName: String? = nil,
        sourceType: SourceType? = nil,
        startTime: Date? = nil
    )
    {
        self.duration = duration
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceName = sourceName
        self.sourceType = sourceType
        self.startTime = startTime
    }
}

struct DescribeEventsInputBody: Equatable {
    public let sourceName: String?
    public let sourceType: SourceType?
    public let startTime: Date?
    public let endTime: Date?
    public let duration: Int?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let durationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .duration)
        duration = durationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(events: \(String(describing: events)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Equatable {
    /// <p>An array of events.  Each element in the array represents one event.</p>
    public let events: [Event]?
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?

    public init (
        events: [Event]? = nil,
        nextToken: String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let events: [Event]?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let eventsContainer = try containerValues.decodeIfPresent([Event?].self, forKey: .events)
        var eventsDecoded0:[Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

public struct DescribeParameterGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeParameterGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParameterGroupsOutputError>
}

extension DescribeParameterGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParameterGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), parameterGroupNames: \(String(describing: parameterGroupNames)))"}
}

extension DescribeParameterGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupNames = parameterGroupNames {
            var parameterGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterGroupNames)
            for parametergroupnamelist0 in parameterGroupNames {
                try parameterGroupNamesContainer.encode(parametergroupnamelist0)
            }
        }
    }
}

public struct DescribeParameterGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeParameterGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeParameterGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParameterGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParameterGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParameterGroupsInput>
    public typealias MOutput = OperationOutput<DescribeParameterGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParameterGroupsOutputError>
}

public struct DescribeParameterGroupsInput: Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The names of the parameter groups.</p>
    public let parameterGroupNames: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parameterGroupNames: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupNames = parameterGroupNames
    }
}

struct DescribeParameterGroupsInputBody: Equatable {
    public let parameterGroupNames: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeParameterGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupNames = "ParameterGroupNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .parameterGroupNames)
        var parameterGroupNamesDecoded0:[String]? = nil
        if let parameterGroupNamesContainer = parameterGroupNamesContainer {
            parameterGroupNamesDecoded0 = [String]()
            for string0 in parameterGroupNamesContainer {
                if let string0 = string0 {
                    parameterGroupNamesDecoded0?.append(string0)
                }
            }
        }
        parameterGroupNames = parameterGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParameterGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParameterGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParameterGroupsOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParameterGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParameterGroupsOutputResponse(nextToken: \(String(describing: nextToken)), parameterGroups: \(String(describing: parameterGroups)))"}
}

extension DescribeParameterGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeParameterGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameterGroups = output.parameterGroups
        } else {
            self.nextToken = nil
            self.parameterGroups = nil
        }
    }
}

public struct DescribeParameterGroupsOutputResponse: Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?
    /// <p>An array of parameter groups.  Each element in the array represents one parameter group.</p>
    public let parameterGroups: [ParameterGroup]?

    public init (
        nextToken: String? = nil,
        parameterGroups: [ParameterGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameterGroups = parameterGroups
    }
}

struct DescribeParameterGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let parameterGroups: [ParameterGroup]?
}

extension DescribeParameterGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameterGroups = "ParameterGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parameterGroupsContainer = try containerValues.decodeIfPresent([ParameterGroup?].self, forKey: .parameterGroups)
        var parameterGroupsDecoded0:[ParameterGroup]? = nil
        if let parameterGroupsContainer = parameterGroupsContainer {
            parameterGroupsDecoded0 = [ParameterGroup]()
            for structure0 in parameterGroupsContainer {
                if let structure0 = structure0 {
                    parameterGroupsDecoded0?.append(structure0)
                }
            }
        }
        parameterGroups = parameterGroupsDecoded0
    }
}

public struct DescribeParametersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

extension DescribeParametersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParametersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), parameterGroupName: \(String(describing: parameterGroupName)), source: \(String(describing: source)))"}
}

extension DescribeParametersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }
}

public struct DescribeParametersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeParametersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeParametersInput>
    public typealias MOutput = OperationOutput<DescribeParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeParametersOutputError>
}

public struct DescribeParametersInput: Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///         <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: String?
    /// <p>How the parameter is defined. For example, <code>system</code> denotes a
    ///             system-defined parameter.</p>
    public let source: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        parameterGroupName: String? = nil,
        source: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.parameterGroupName = parameterGroupName
        self.source = source
    }
}

struct DescribeParametersInputBody: Equatable {
    public let parameterGroupName: String?
    public let source: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeParametersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case parameterGroupName = "ParameterGroupName"
        case source = "Source"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeParametersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeParametersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeParametersOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeParametersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeParametersOutputResponse(nextToken: \(String(describing: nextToken)), parameters: \(String(describing: parameters)))"}
}

extension DescribeParametersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeParametersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.parameters = output.parameters
        } else {
            self.nextToken = nil
            self.parameters = nil
        }
    }
}

public struct DescribeParametersOutputResponse: Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?
    /// <p>A list of parameters within a parameter group.  Each element in the list represents one parameter.</p>
    public let parameters: [Parameter]?

    public init (
        nextToken: String? = nil,
        parameters: [Parameter]? = nil
    )
    {
        self.nextToken = nextToken
        self.parameters = parameters
    }
}

struct DescribeParametersOutputResponseBody: Equatable {
    public let nextToken: String?
    public let parameters: [Parameter]?
}

extension DescribeParametersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case parameters = "Parameters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Parameter?].self, forKey: .parameters)
        var parametersDecoded0:[Parameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Parameter]()
            for structure0 in parametersContainer {
                if let structure0 = structure0 {
                    parametersDecoded0?.append(structure0)
                }
            }
        }
        parameters = parametersDecoded0
    }
}

public struct DescribeSubnetGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeSubnetGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubnetGroupsOutputError>
}

extension DescribeSubnetGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubnetGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), subnetGroupNames: \(String(describing: subnetGroupNames)))"}
}

extension DescribeSubnetGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let subnetGroupNames = subnetGroupNames {
            var subnetGroupNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetGroupNames)
            for subnetgroupnamelist0 in subnetGroupNames {
                try subnetGroupNamesContainer.encode(subnetgroupnamelist0)
            }
        }
    }
}

public struct DescribeSubnetGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeSubnetGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeSubnetGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeSubnetGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeSubnetGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeSubnetGroupsInput>
    public typealias MOutput = OperationOutput<DescribeSubnetGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeSubnetGroupsOutputError>
}

public struct DescribeSubnetGroupsInput: Equatable {
    /// <p>The maximum number of results to include in the response. If more results exist
    ///             than the specified <code>MaxResults</code> value, a token is included in the response so
    ///             that the remaining results can be retrieved.</p>
    ///             <p>The value for <code>MaxResults</code> must be between 20 and 100.</p>
    public let maxResults: Int?
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token, up to the value specified by
    ///             <code>MaxResults</code>.</p>
    public let nextToken: String?
    /// <p>The name of the subnet group.</p>
    public let subnetGroupNames: [String]?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        subnetGroupNames: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subnetGroupNames = subnetGroupNames
    }
}

struct DescribeSubnetGroupsInputBody: Equatable {
    public let subnetGroupNames: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension DescribeSubnetGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case subnetGroupNames = "SubnetGroupNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetGroupNames)
        var subnetGroupNamesDecoded0:[String]? = nil
        if let subnetGroupNamesContainer = subnetGroupNamesContainer {
            subnetGroupNamesDecoded0 = [String]()
            for string0 in subnetGroupNamesContainer {
                if let string0 = string0 {
                    subnetGroupNamesDecoded0?.append(string0)
                }
            }
        }
        subnetGroupNames = subnetGroupNamesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubnetGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubnetGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSubnetGroupsOutputError: Equatable {
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubnetGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeSubnetGroupsOutputResponse(nextToken: \(String(describing: nextToken)), subnetGroups: \(String(describing: subnetGroups)))"}
}

extension DescribeSubnetGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeSubnetGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.subnetGroups = output.subnetGroups
        } else {
            self.nextToken = nil
            self.subnetGroups = nil
        }
    }
}

public struct DescribeSubnetGroupsOutputResponse: Equatable {
    /// <p>Provides an identifier to allow retrieval of paginated results.</p>
    public let nextToken: String?
    /// <p>An array of subnet groups.  Each element in the array represents a single subnet group.</p>
    public let subnetGroups: [SubnetGroup]?

    public init (
        nextToken: String? = nil,
        subnetGroups: [SubnetGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.subnetGroups = subnetGroups
    }
}

struct DescribeSubnetGroupsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let subnetGroups: [SubnetGroup]?
}

extension DescribeSubnetGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case subnetGroups = "SubnetGroups"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let subnetGroupsContainer = try containerValues.decodeIfPresent([SubnetGroup?].self, forKey: .subnetGroups)
        var subnetGroupsDecoded0:[SubnetGroup]? = nil
        if let subnetGroupsContainer = subnetGroupsContainer {
            subnetGroupsDecoded0 = [SubnetGroup]()
            for structure0 in subnetGroupsContainer {
                if let structure0 = structure0 {
                    subnetGroupsDecoded0?.append(structure0)
                }
            }
        }
        subnetGroups = subnetGroupsDecoded0
    }
}

extension Endpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case port = "Port"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
    }
}

extension Endpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Endpoint(address: \(String(describing: address)), port: \(String(describing: port)))"}
}

/// <p>Represents the information required for client programs to connect to the
///             configuration endpoint for a DAX cluster, or to an individual node within the
///             cluster.</p>
public struct Endpoint: Equatable {
    /// <p>The DNS hostname of the endpoint.</p>
    public let address: String?
    /// <p>The port number that applications should use to connect to the endpoint.</p>
    public let port: Int

    public init (
        address: String? = nil,
        port: Int = 0
    )
    {
        self.address = address
        self.port = port
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date = "Date"
        case message = "Message"
        case sourceName = "SourceName"
        case sourceType = "SourceType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(date: \(String(describing: date)), message: \(String(describing: message)), sourceName: \(String(describing: sourceName)), sourceType: \(String(describing: sourceType)))"}
}

/// <p>Represents a single occurrence of something interesting within the system. Some
///             examples of events are creating a DAX cluster, adding or removing a node, or rebooting
///             a node.</p>
public struct Event: Equatable {
    /// <p>The date and time when the event occurred.</p>
    public let date: Date?
    /// <p>A user-defined message associated with the event.</p>
    public let message: String?
    /// <p>The source of the event. For example, if the event occurred at the node level, the
    ///             source would be the node ID.</p>
    public let sourceName: String?
    /// <p>Specifies the origin of this event - a cluster, a parameter group, a node ID,
    ///             etc.</p>
    public let sourceType: SourceType?

    public init (
        date: Date? = nil,
        message: String? = nil,
        sourceName: String? = nil,
        sourceType: SourceType? = nil
    )
    {
        self.date = date
        self.message = message
        self.sourceName = sourceName
        self.sourceType = sourceType
    }
}

public struct IncreaseReplicationFactorInputBodyMiddleware: Middleware {
    public let id: String = "IncreaseReplicationFactorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseReplicationFactorOutputError>
}

extension IncreaseReplicationFactorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncreaseReplicationFactorInput(availabilityZones: \(String(describing: availabilityZones)), clusterName: \(String(describing: clusterName)), newReplicationFactor: \(String(describing: newReplicationFactor)))"}
}

extension IncreaseReplicationFactorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzonelist0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzonelist0)
            }
        }
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if newReplicationFactor != 0 {
            try encodeContainer.encode(newReplicationFactor, forKey: .newReplicationFactor)
        }
    }
}

public struct IncreaseReplicationFactorInputHeadersMiddleware: Middleware {
    public let id: String = "IncreaseReplicationFactorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInputQueryItemMiddleware: Middleware {
    public let id: String = "IncreaseReplicationFactorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<IncreaseReplicationFactorInput>,
                  next: H) -> Swift.Result<OperationOutput<IncreaseReplicationFactorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<IncreaseReplicationFactorInput>
    public typealias MOutput = OperationOutput<IncreaseReplicationFactorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<IncreaseReplicationFactorOutputError>
}

public struct IncreaseReplicationFactorInput: Equatable {
    /// <p>The Availability Zones (AZs) in which the cluster nodes will be created. All nodes
    ///             belonging to the cluster are placed in these Availability Zones. Use this parameter if you want
    ///             to distribute the nodes across multiple AZs.</p>
    public let availabilityZones: [String]?
    /// <p>The name of the DAX cluster that will receive additional nodes.</p>
    public let clusterName: String?
    /// <p>The new number of nodes for the DAX cluster.</p>
    public let newReplicationFactor: Int

    public init (
        availabilityZones: [String]? = nil,
        clusterName: String? = nil,
        newReplicationFactor: Int = 0
    )
    {
        self.availabilityZones = availabilityZones
        self.clusterName = clusterName
        self.newReplicationFactor = newReplicationFactor
    }
}

struct IncreaseReplicationFactorInputBody: Equatable {
    public let clusterName: String?
    public let newReplicationFactor: Int
    public let availabilityZones: [String]?
}

extension IncreaseReplicationFactorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case availabilityZones = "AvailabilityZones"
        case clusterName = "ClusterName"
        case newReplicationFactor = "NewReplicationFactor"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let newReplicationFactorDecoded = try containerValues.decode(Int.self, forKey: .newReplicationFactor)
        newReplicationFactor = newReplicationFactorDecoded
        let availabilityZonesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
    }
}

extension IncreaseReplicationFactorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension IncreaseReplicationFactorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InsufficientClusterCapacityFault" : self = .insufficientClusterCapacityFault(try InsufficientClusterCapacityFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidVPCNetworkStateFault" : self = .invalidVPCNetworkStateFault(try InvalidVPCNetworkStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForClusterExceededFault" : self = .nodeQuotaForClusterExceededFault(try NodeQuotaForClusterExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeQuotaForCustomerExceededFault" : self = .nodeQuotaForCustomerExceededFault(try NodeQuotaForCustomerExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum IncreaseReplicationFactorOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case insufficientClusterCapacityFault(InsufficientClusterCapacityFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidVPCNetworkStateFault(InvalidVPCNetworkStateFault)
    case nodeQuotaForClusterExceededFault(NodeQuotaForClusterExceededFault)
    case nodeQuotaForCustomerExceededFault(NodeQuotaForCustomerExceededFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension IncreaseReplicationFactorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncreaseReplicationFactorOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension IncreaseReplicationFactorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IncreaseReplicationFactorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct IncreaseReplicationFactorOutputResponse: Equatable {
    /// <p>A description of the DAX cluster. with its new replication factor.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct IncreaseReplicationFactorOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension IncreaseReplicationFactorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension InsufficientClusterCapacityFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InsufficientClusterCapacityFault(message: \(String(describing: message)))"}
}

extension InsufficientClusterCapacityFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InsufficientClusterCapacityFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There are not enough system resources to create the cluster you requested (or to
///             resize an already-existing cluster). </p>
public struct InsufficientClusterCapacityFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InsufficientClusterCapacityFaultBody: Equatable {
    public let message: String?
}

extension InsufficientClusterCapacityFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidARNFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidARNFault(message: \(String(describing: message)))"}
}

extension InvalidARNFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidARNFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Amazon Resource Name (ARN) supplied in the request is not valid.</p>
public struct InvalidARNFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidARNFaultBody: Equatable {
    public let message: String?
}

extension InvalidARNFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClusterStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClusterStateFault(message: \(String(describing: message)))"}
}

extension InvalidClusterStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidClusterStateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested DAX cluster is not in the <i>available</i>
///             state.</p>
public struct InvalidClusterStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClusterStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidClusterStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterCombinationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterCombinationException(message: \(String(describing: message)))"}
}

extension InvalidParameterCombinationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterCombinationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Two or more incompatible parameters were specified.</p>
public struct InvalidParameterCombinationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterCombinationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterCombinationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterGroupStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterGroupStateFault(message: \(String(describing: message)))"}
}

extension InvalidParameterGroupStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterGroupStateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more parameters in a parameter group are in an invalid state.</p>
public struct InvalidParameterGroupStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterGroupStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidParameterGroupStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The value for a parameter is invalid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnet(message: \(String(describing: message)))"}
}

extension InvalidSubnet: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSubnetBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An invalid subnet identifier was specified.</p>
public struct InvalidSubnet: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSubnetBody: Equatable {
    public let message: String?
}

extension InvalidSubnetBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidVPCNetworkStateFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidVPCNetworkStateFault(message: \(String(describing: message)))"}
}

extension InvalidVPCNetworkStateFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidVPCNetworkStateFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The VPC network is in an invalid state.</p>
public struct InvalidVPCNetworkStateFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidVPCNetworkStateFaultBody: Equatable {
    public let message: String?
}

extension InvalidVPCNetworkStateFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum IsModifiable {
    case conditional
    case `false`
    case `true`
    case sdkUnknown(String)
}

extension IsModifiable : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IsModifiable] {
        return [
            .conditional,
            .false,
            .true,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .conditional: return "CONDITIONAL"
        case .false: return "FALSE"
        case .true: return "TRUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IsModifiable(rawValue: rawValue) ?? IsModifiable.sdkUnknown(rawValue)
    }
}

public struct ListTagsInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(nextToken: \(String(describing: nextToken)), resourceName: \(String(describing: resourceName)))"}
}

extension ListTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>An optional token returned from a prior request. Use this token for pagination of
    ///             results from this action. If this parameter is specified, the response includes only
    ///             results beyond the token.</p>
    public let nextToken: String?
    /// <p>The name of the DAX resource to which the tags belong.</p>
    public let resourceName: String?

    public init (
        nextToken: String? = nil,
        resourceName: String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceName = resourceName
    }
}

struct ListTagsInputBody: Equatable {
    public let resourceName: String?
    public let nextToken: String?
}

extension ListTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>If this value is present, there are additional results to be displayed.  To retrieve them, call
    ///             <code>ListTags</code> again, with <code>NextToken</code> set to this value.</p>
    public let nextToken: String?
    /// <p>A list of tags currently associated with the DAX cluster.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Node: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case endpoint = "Endpoint"
        case nodeCreateTime = "NodeCreateTime"
        case nodeId = "NodeId"
        case nodeStatus = "NodeStatus"
        case parameterGroupStatus = "ParameterGroupStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let nodeCreateTime = nodeCreateTime {
            try encodeContainer.encode(nodeCreateTime.timeIntervalSince1970, forKey: .nodeCreateTime)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
        if let nodeStatus = nodeStatus {
            try encodeContainer.encode(nodeStatus, forKey: .nodeStatus)
        }
        if let parameterGroupStatus = parameterGroupStatus {
            try encodeContainer.encode(parameterGroupStatus, forKey: .parameterGroupStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Endpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let nodeCreateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .nodeCreateTime)
        nodeCreateTime = nodeCreateTimeDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let nodeStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeStatus)
        nodeStatus = nodeStatusDecoded
        let parameterGroupStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupStatus)
        parameterGroupStatus = parameterGroupStatusDecoded
    }
}

extension Node: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Node(availabilityZone: \(String(describing: availabilityZone)), endpoint: \(String(describing: endpoint)), nodeCreateTime: \(String(describing: nodeCreateTime)), nodeId: \(String(describing: nodeId)), nodeStatus: \(String(describing: nodeStatus)), parameterGroupStatus: \(String(describing: parameterGroupStatus)))"}
}

/// <p>Represents an individual node within a DAX cluster.</p>
public struct Node: Equatable {
    /// <p>The Availability Zone (AZ) in which the node has been deployed.</p>
    public let availabilityZone: String?
    /// <p>The endpoint for the node, consisting of a DNS name and a port number. Client
    ///             applications can connect directly to a node endpoint, if desired (as an alternative to
    ///             allowing DAX client software to intelligently route requests and responses to nodes in
    ///             the DAX cluster.</p>
    public let endpoint: Endpoint?
    /// <p>The date and time (in UNIX epoch format) when the node was launched.</p>
    public let nodeCreateTime: Date?
    /// <p>A system-generated identifier for the node.</p>
    public let nodeId: String?
    /// <p>The current status of the node. For example: <code>available</code>.</p>
    public let nodeStatus: String?
    /// <p>The status of the parameter group associated with this node. For example,
    ///                 <code>in-sync</code>.</p>
    public let parameterGroupStatus: String?

    public init (
        availabilityZone: String? = nil,
        endpoint: Endpoint? = nil,
        nodeCreateTime: Date? = nil,
        nodeId: String? = nil,
        nodeStatus: String? = nil,
        parameterGroupStatus: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.endpoint = endpoint
        self.nodeCreateTime = nodeCreateTime
        self.nodeId = nodeId
        self.nodeStatus = nodeStatus
        self.parameterGroupStatus = parameterGroupStatus
    }
}

extension NodeNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeNotFoundFault(message: \(String(describing: message)))"}
}

extension NodeNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NodeNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>None of the nodes in the cluster have the given node ID.</p>
public struct NodeNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NodeNotFoundFaultBody: Equatable {
    public let message: String?
}

extension NodeNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForClusterExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeQuotaForClusterExceededFault(message: \(String(describing: message)))"}
}

extension NodeQuotaForClusterExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NodeQuotaForClusterExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of nodes for a DAX
///             cluster.</p>
public struct NodeQuotaForClusterExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForClusterExceededFaultBody: Equatable {
    public let message: String?
}

extension NodeQuotaForClusterExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeQuotaForCustomerExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeQuotaForCustomerExceededFault(message: \(String(describing: message)))"}
}

extension NodeQuotaForCustomerExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NodeQuotaForCustomerExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of nodes for your AWS
///             account.</p>
public struct NodeQuotaForCustomerExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NodeQuotaForCustomerExceededFaultBody: Equatable {
    public let message: String?
}

extension NodeQuotaForCustomerExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NodeTypeSpecificValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeType = "NodeType"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension NodeTypeSpecificValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NodeTypeSpecificValue(nodeType: \(String(describing: nodeType)), value: \(String(describing: value)))"}
}

/// <p>Represents a parameter value that is applicable to a particular node
///             type.</p>
public struct NodeTypeSpecificValue: Equatable {
    /// <p>A node type to which the parameter value applies.</p>
    public let nodeType: String?
    /// <p>The parameter value for this node type.</p>
    public let value: String?

    public init (
        nodeType: String? = nil,
        value: String? = nil
    )
    {
        self.nodeType = nodeType
        self.value = value
    }
}

extension NotificationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
        case topicStatus = "TopicStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
        if let topicStatus = topicStatus {
            try encodeContainer.encode(topicStatus, forKey: .topicStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let topicStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicStatus)
        topicStatus = topicStatusDecoded
    }
}

extension NotificationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationConfiguration(topicArn: \(String(describing: topicArn)), topicStatus: \(String(describing: topicStatus)))"}
}

/// <p>Describes a notification topic and its status. Notification topics are used for
///             publishing DAX events to subscribers using Amazon Simple Notification Service
///             (SNS).</p>
public struct NotificationConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) that identifies the topic. </p>
    public let topicArn: String?
    /// <p>The current state of the topic.</p>
    public let topicStatus: String?

    public init (
        topicArn: String? = nil,
        topicStatus: String? = nil
    )
    {
        self.topicArn = topicArn
        self.topicStatus = topicStatus
    }
}

extension Parameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedValues = "AllowedValues"
        case changeType = "ChangeType"
        case dataType = "DataType"
        case description = "Description"
        case isModifiable = "IsModifiable"
        case nodeTypeSpecificValues = "NodeTypeSpecificValues"
        case parameterName = "ParameterName"
        case parameterType = "ParameterType"
        case parameterValue = "ParameterValue"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedValues = allowedValues {
            try encodeContainer.encode(allowedValues, forKey: .allowedValues)
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType, forKey: .dataType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isModifiable = isModifiable {
            try encodeContainer.encode(isModifiable.rawValue, forKey: .isModifiable)
        }
        if let nodeTypeSpecificValues = nodeTypeSpecificValues {
            var nodeTypeSpecificValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeTypeSpecificValues)
            for nodetypespecificvaluelist0 in nodeTypeSpecificValues {
                try nodeTypeSpecificValuesContainer.encode(nodetypespecificvaluelist0)
            }
        }
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(ParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
        let nodeTypeSpecificValuesContainer = try containerValues.decodeIfPresent([NodeTypeSpecificValue?].self, forKey: .nodeTypeSpecificValues)
        var nodeTypeSpecificValuesDecoded0:[NodeTypeSpecificValue]? = nil
        if let nodeTypeSpecificValuesContainer = nodeTypeSpecificValuesContainer {
            nodeTypeSpecificValuesDecoded0 = [NodeTypeSpecificValue]()
            for structure0 in nodeTypeSpecificValuesContainer {
                if let structure0 = structure0 {
                    nodeTypeSpecificValuesDecoded0?.append(structure0)
                }
            }
        }
        nodeTypeSpecificValues = nodeTypeSpecificValuesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let allowedValuesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedValues)
        allowedValues = allowedValuesDecoded
        let isModifiableDecoded = try containerValues.decodeIfPresent(IsModifiable.self, forKey: .isModifiable)
        isModifiable = isModifiableDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
    }
}

extension Parameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Parameter(allowedValues: \(String(describing: allowedValues)), changeType: \(String(describing: changeType)), dataType: \(String(describing: dataType)), description: \(String(describing: description)), isModifiable: \(String(describing: isModifiable)), nodeTypeSpecificValues: \(String(describing: nodeTypeSpecificValues)), parameterName: \(String(describing: parameterName)), parameterType: \(String(describing: parameterType)), parameterValue: \(String(describing: parameterValue)), source: \(String(describing: source)))"}
}

/// <p>Describes an individual setting that controls some aspect of DAX
///             behavior.</p>
public struct Parameter: Equatable {
    /// <p>A range of values within which the parameter can be set.</p>
    public let allowedValues: String?
    /// <p>The conditions under which changes to this parameter can be applied. For example,
    ///                 <code>requires-reboot</code> indicates that a new value for this parameter will only
    ///             take effect if a node is rebooted.</p>
    public let changeType: ChangeType?
    /// <p>The data type of the parameter. For example, <code>integer</code>:</p>
    public let dataType: String?
    /// <p>A description of the parameter</p>
    public let description: String?
    /// <p>Whether the customer is allowed to modify the parameter.</p>
    public let isModifiable: IsModifiable?
    /// <p>A list of node types, and specific parameter values for each node.</p>
    public let nodeTypeSpecificValues: [NodeTypeSpecificValue]?
    /// <p>The name of the parameter.</p>
    public let parameterName: String?
    /// <p>Determines whether the parameter can be applied to any nodes, or only nodes of a
    ///             particular type.</p>
    public let parameterType: ParameterType?
    /// <p>The value for the parameter.</p>
    public let parameterValue: String?
    /// <p>How the parameter is defined. For example, <code>system</code> denotes a
    ///             system-defined parameter.</p>
    public let source: String?

    public init (
        allowedValues: String? = nil,
        changeType: ChangeType? = nil,
        dataType: String? = nil,
        description: String? = nil,
        isModifiable: IsModifiable? = nil,
        nodeTypeSpecificValues: [NodeTypeSpecificValue]? = nil,
        parameterName: String? = nil,
        parameterType: ParameterType? = nil,
        parameterValue: String? = nil,
        source: String? = nil
    )
    {
        self.allowedValues = allowedValues
        self.changeType = changeType
        self.dataType = dataType
        self.description = description
        self.isModifiable = isModifiable
        self.nodeTypeSpecificValues = nodeTypeSpecificValues
        self.parameterName = parameterName
        self.parameterType = parameterType
        self.parameterValue = parameterValue
        self.source = source
    }
}

extension ParameterGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ParameterGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterGroup(description: \(String(describing: description)), parameterGroupName: \(String(describing: parameterGroupName)))"}
}

/// <p>A named set of parameters that are applied to all of the nodes in a DAX
///             cluster.</p>
public struct ParameterGroup: Equatable {
    /// <p>A description of the parameter group.</p>
    public let description: String?
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: String?

    public init (
        description: String? = nil,
        parameterGroupName: String? = nil
    )
    {
        self.description = description
        self.parameterGroupName = parameterGroupName
    }
}

extension ParameterGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension ParameterGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter group already exists.</p>
public struct ParameterGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension ParameterGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension ParameterGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified parameter group does not exist.</p>
public struct ParameterGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ParameterGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension ParameterGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ParameterGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have attempted to exceed the maximum number of parameter groups.</p>
public struct ParameterGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ParameterGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension ParameterGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ParameterGroupStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeIdsToReboot = "NodeIdsToReboot"
        case parameterApplyStatus = "ParameterApplyStatus"
        case parameterGroupName = "ParameterGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeIdsToReboot = nodeIdsToReboot {
            var nodeIdsToRebootContainer = encodeContainer.nestedUnkeyedContainer(forKey: .nodeIdsToReboot)
            for nodeidentifierlist0 in nodeIdsToReboot {
                try nodeIdsToRebootContainer.encode(nodeidentifierlist0)
            }
        }
        if let parameterApplyStatus = parameterApplyStatus {
            try encodeContainer.encode(parameterApplyStatus, forKey: .parameterApplyStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterApplyStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterApplyStatus)
        parameterApplyStatus = parameterApplyStatusDecoded
        let nodeIdsToRebootContainer = try containerValues.decodeIfPresent([String?].self, forKey: .nodeIdsToReboot)
        var nodeIdsToRebootDecoded0:[String]? = nil
        if let nodeIdsToRebootContainer = nodeIdsToRebootContainer {
            nodeIdsToRebootDecoded0 = [String]()
            for string0 in nodeIdsToRebootContainer {
                if let string0 = string0 {
                    nodeIdsToRebootDecoded0?.append(string0)
                }
            }
        }
        nodeIdsToReboot = nodeIdsToRebootDecoded0
    }
}

extension ParameterGroupStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterGroupStatus(nodeIdsToReboot: \(String(describing: nodeIdsToReboot)), parameterApplyStatus: \(String(describing: parameterApplyStatus)), parameterGroupName: \(String(describing: parameterGroupName)))"}
}

/// <p>The status of a parameter group.</p>
public struct ParameterGroupStatus: Equatable {
    /// <p>The node IDs of one or more nodes to be rebooted.</p>
    public let nodeIdsToReboot: [String]?
    /// <p>The status of parameter updates. </p>
    public let parameterApplyStatus: String?
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: String?

    public init (
        nodeIdsToReboot: [String]? = nil,
        parameterApplyStatus: String? = nil,
        parameterGroupName: String? = nil
    )
    {
        self.nodeIdsToReboot = nodeIdsToReboot
        self.parameterApplyStatus = parameterApplyStatus
        self.parameterGroupName = parameterGroupName
    }
}

extension ParameterNameValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterName = "ParameterName"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension ParameterNameValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ParameterNameValue(parameterName: \(String(describing: parameterName)), parameterValue: \(String(describing: parameterValue)))"}
}

/// <p>An individual DAX parameter.</p>
public struct ParameterNameValue: Equatable {
    /// <p>The name of the parameter.</p>
    public let parameterName: String?
    /// <p>The value of the parameter.</p>
    public let parameterValue: String?

    public init (
        parameterName: String? = nil,
        parameterValue: String? = nil
    )
    {
        self.parameterName = parameterName
        self.parameterValue = parameterValue
    }
}

public enum ParameterType {
    case `default`
    case nodeTypeSpecific
    case sdkUnknown(String)
}

extension ParameterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ParameterType] {
        return [
            .default,
            .nodeTypeSpecific,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .default: return "DEFAULT"
        case .nodeTypeSpecific: return "NODE_TYPE_SPECIFIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
    }
}

public struct RebootNodeInputBodyMiddleware: Middleware {
    public let id: String = "RebootNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootNodeInput>
    public typealias MOutput = OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootNodeOutputError>
}

extension RebootNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootNodeInput(clusterName: \(String(describing: clusterName)), nodeId: \(String(describing: nodeId)))"}
}

extension RebootNodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let nodeId = nodeId {
            try encodeContainer.encode(nodeId, forKey: .nodeId)
        }
    }
}

public struct RebootNodeInputHeadersMiddleware: Middleware {
    public let id: String = "RebootNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootNodeInput>
    public typealias MOutput = OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootNodeOutputError>
}

public struct RebootNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "RebootNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RebootNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<RebootNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RebootNodeInput>
    public typealias MOutput = OperationOutput<RebootNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RebootNodeOutputError>
}

public struct RebootNodeInput: Equatable {
    /// <p>The name of the DAX cluster containing the node to be rebooted.</p>
    public let clusterName: String?
    /// <p>The system-assigned ID of the node to be rebooted.</p>
    public let nodeId: String?

    public init (
        clusterName: String? = nil,
        nodeId: String? = nil
    )
    {
        self.clusterName = clusterName
        self.nodeId = nodeId
    }
}

struct RebootNodeInputBody: Equatable {
    public let clusterName: String?
    public let nodeId: String?
}

extension RebootNodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case nodeId = "NodeId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let nodeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeId)
        nodeId = nodeIdDecoded
    }
}

extension RebootNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RebootNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NodeNotFoundFault" : self = .nodeNotFoundFault(try NodeNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RebootNodeOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case nodeNotFoundFault(NodeNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension RebootNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RebootNodeOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension RebootNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RebootNodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct RebootNodeOutputResponse: Equatable {
    /// <p>A description of the DAX cluster after a node has been rebooted.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct RebootNodeOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension RebootNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

extension SSEDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSEStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SSEDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSEDescription(status: \(String(describing: status)))"}
}

/// <p>The description of the server-side encryption status on the specified DAX cluster.</p>
public struct SSEDescription: Equatable {
    /// <p>The current state of server-side encryption:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLING</code> - Server-side encryption is being enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ENABLED</code> - Server-side encryption is enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLING</code> - Server-side encryption is being disabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DISABLED</code> - Server-side encryption is disabled.</p>
    ///             </li>
    ///          </ul>
    public let status: SSEStatus?

    public init (
        status: SSEStatus? = nil
    )
    {
        self.status = status
    }
}

extension SSESpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension SSESpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSESpecification(enabled: \(String(describing: enabled)))"}
}

/// <p>Represents the settings used to enable server-side encryption.</p>
public struct SSESpecification: Equatable {
    /// <p>Indicates whether server-side encryption is enabled (true) or disabled (false) on the cluster.</p>
    public let enabled: Bool?

    public init (
        enabled: Bool? = nil
    )
    {
        self.enabled = enabled
    }
}

public enum SSEStatus {
    case disabled
    case disabling
    case enabled
    case enabling
    case sdkUnknown(String)
}

extension SSEStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SSEStatus] {
        return [
            .disabled,
            .disabling,
            .enabled,
            .enabling,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .disabling: return "DISABLING"
        case .enabled: return "ENABLED"
        case .enabling: return "ENABLING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SSEStatus(rawValue: rawValue) ?? SSEStatus.sdkUnknown(rawValue)
    }
}

extension SecurityGroupMembership: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIdentifier = "SecurityGroupIdentifier"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIdentifier = securityGroupIdentifier {
            try encodeContainer.encode(securityGroupIdentifier, forKey: .securityGroupIdentifier)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .securityGroupIdentifier)
        securityGroupIdentifier = securityGroupIdentifierDecoded
        let statusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .status)
        status = statusDecoded
    }
}

extension SecurityGroupMembership: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroupMembership(securityGroupIdentifier: \(String(describing: securityGroupIdentifier)), status: \(String(describing: status)))"}
}

/// <p>An individual VPC security group and its status.</p>
public struct SecurityGroupMembership: Equatable {
    /// <p>The unique ID for this security group.</p>
    public let securityGroupIdentifier: String?
    /// <p>The status of this security group.</p>
    public let status: String?

    public init (
        securityGroupIdentifier: String? = nil,
        status: String? = nil
    )
    {
        self.securityGroupIdentifier = securityGroupIdentifier
        self.status = status
    }
}

extension ServiceLinkedRoleNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceLinkedRoleNotFoundFault(message: \(String(describing: message)))"}
}

extension ServiceLinkedRoleNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceLinkedRoleNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified service linked role (SLR) was not found.</p>
public struct ServiceLinkedRoleNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceLinkedRoleNotFoundFaultBody: Equatable {
    public let message: String?
}

extension ServiceLinkedRoleNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SourceType {
    case cluster
    case parameterGroup
    case subnetGroup
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .cluster,
            .parameterGroup,
            .subnetGroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cluster: return "CLUSTER"
        case .parameterGroup: return "PARAMETER_GROUP"
        case .subnetGroup: return "SUBNET_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension Subnet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetAvailabilityZone = "SubnetAvailabilityZone"
        case subnetIdentifier = "SubnetIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetAvailabilityZone = subnetAvailabilityZone {
            try encodeContainer.encode(subnetAvailabilityZone, forKey: .subnetAvailabilityZone)
        }
        if let subnetIdentifier = subnetIdentifier {
            try encodeContainer.encode(subnetIdentifier, forKey: .subnetIdentifier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetIdentifier)
        subnetIdentifier = subnetIdentifierDecoded
        let subnetAvailabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetAvailabilityZone)
        subnetAvailabilityZone = subnetAvailabilityZoneDecoded
    }
}

extension Subnet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subnet(subnetAvailabilityZone: \(String(describing: subnetAvailabilityZone)), subnetIdentifier: \(String(describing: subnetIdentifier)))"}
}

/// <p>Represents the subnet associated with a DAX cluster. This parameter refers to
///             subnets defined in Amazon Virtual Private Cloud (Amazon VPC) and used with
///             DAX.</p>
public struct Subnet: Equatable {
    /// <p>The Availability Zone (AZ) for the subnet.</p>
    public let subnetAvailabilityZone: String?
    /// <p>The system-assigned identifier for the subnet.</p>
    public let subnetIdentifier: String?

    public init (
        subnetAvailabilityZone: String? = nil,
        subnetIdentifier: String? = nil
    )
    {
        self.subnetAvailabilityZone = subnetAvailabilityZone
        self.subnetIdentifier = subnetIdentifier
    }
}

extension SubnetGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnets = "Subnets"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for subnetlist0 in subnets {
                try subnetsContainer.encode(subnetlist0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let subnetsContainer = try containerValues.decodeIfPresent([Subnet?].self, forKey: .subnets)
        var subnetsDecoded0:[Subnet]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [Subnet]()
            for structure0 in subnetsContainer {
                if let structure0 = structure0 {
                    subnetsDecoded0?.append(structure0)
                }
            }
        }
        subnets = subnetsDecoded0
    }
}

extension SubnetGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetGroup(description: \(String(describing: description)), subnetGroupName: \(String(describing: subnetGroupName)), subnets: \(String(describing: subnets)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Represents the output of one of the following actions:</p>
///         <ul>
///             <li>
///                 <p>
///                     <i>CreateSubnetGroup</i>
///                 </p>
///             </li>
///             <li>
///                 <p>
///                     <i>ModifySubnetGroup</i>
///                 </p>
///             </li>
///          </ul>
public struct SubnetGroup: Equatable {
    /// <p>The description of the subnet group.</p>
    public let description: String?
    /// <p>The name of the subnet group.</p>
    public let subnetGroupName: String?
    /// <p>A list of subnets associated with the subnet group. </p>
    public let subnets: [Subnet]?
    /// <p>The Amazon Virtual Private Cloud identifier (VPC ID) of the subnet group.</p>
    public let vpcId: String?

    public init (
        description: String? = nil,
        subnetGroupName: String? = nil,
        subnets: [Subnet]? = nil,
        vpcId: String? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnets = subnets
        self.vpcId = vpcId
    }
}

extension SubnetGroupAlreadyExistsFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetGroupAlreadyExistsFault(message: \(String(describing: message)))"}
}

extension SubnetGroupAlreadyExistsFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetGroupAlreadyExistsFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet group already exists.</p>
public struct SubnetGroupAlreadyExistsFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupAlreadyExistsFaultBody: Equatable {
    public let message: String?
}

extension SubnetGroupAlreadyExistsFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupInUseFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetGroupInUseFault(message: \(String(describing: message)))"}
}

extension SubnetGroupInUseFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetGroupInUseFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified subnet group is currently in use.</p>
public struct SubnetGroupInUseFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupInUseFaultBody: Equatable {
    public let message: String?
}

extension SubnetGroupInUseFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetGroupNotFoundFault(message: \(String(describing: message)))"}
}

extension SubnetGroupNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetGroupNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet group name does not refer to an existing subnet
///             group.</p>
public struct SubnetGroupNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupNotFoundFaultBody: Equatable {
    public let message: String?
}

extension SubnetGroupNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetGroupQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetGroupQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SubnetGroupQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetGroupQuotaExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of
///             subnets in a subnet group.</p>
public struct SubnetGroupQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetGroupQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SubnetGroupQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetInUse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetInUse(message: \(String(describing: message)))"}
}

extension SubnetInUse: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetInUseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested subnet is being used by another subnet group.</p>
public struct SubnetInUse: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetInUseBody: Equatable {
    public let message: String?
}

extension SubnetInUseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubnetQuotaExceededFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetQuotaExceededFault(message: \(String(describing: message)))"}
}

extension SubnetQuotaExceededFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetQuotaExceededFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request cannot be processed because it would exceed the allowed number of
///             subnets in a subnet group.</p>
public struct SubnetQuotaExceededFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct SubnetQuotaExceededFaultBody: Equatable {
    public let message: String?
}

extension SubnetQuotaExceededFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A description of a tag.  Every tag is a key-value pair. You can add up to 50 tags to a single
///             DAX cluster.</p>
///         <p>AWS-assigned tag names and values are automatically assigned the <code>aws:</code>
///             prefix, which the user cannot assign. AWS-assigned tag names do not count towards the
///             tag limit of 50. User-assigned tag names have the prefix <code>user:</code>.</p>
///         <p>You cannot backdate the application of a tag.</p>
public struct Tag: Equatable {
    /// <p>The key for the tag.  Tag keys are case sensitive. Every DAX cluster can only have
    ///             one tag with the same key. If you try to add an existing tag (same key), the
    ///             existing tag value will be updated to the new value.</p>
    public let key: String?
    /// <p>The value of the tag. Tag values are case-sensitive and can be null. </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TagNotFoundFault: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagNotFoundFault(message: \(String(describing: message)))"}
}

extension TagNotFoundFault: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagNotFoundFaultBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tag does not exist.</p>
public struct TagNotFoundFault: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagNotFoundFaultBody: Equatable {
    public let message: String?
}

extension TagNotFoundFaultBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagQuotaPerResourceExceeded: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagQuotaPerResourceExceeded(message: \(String(describing: message)))"}
}

extension TagQuotaPerResourceExceeded: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagQuotaPerResourceExceededBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded the maximum number of tags for this DAX cluster.</p>
public struct TagQuotaPerResourceExceeded: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagQuotaPerResourceExceededBody: Equatable {
    public let message: String?
}

extension TagQuotaPerResourceExceededBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceName: \(String(describing: resourceName)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The name of the DAX resource to which tags should be added.</p>
    public let resourceName: String?
    /// <p>The tags to be assigned to the DAX resource. </p>
    public let tags: [Tag]?

    public init (
        resourceName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceName = resourceName
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceName: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagQuotaPerResourceExceeded" : self = .tagQuotaPerResourceExceeded(try TagQuotaPerResourceExceeded(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagQuotaPerResourceExceeded(TagQuotaPerResourceExceeded)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TagResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct TagResourceOutputResponse: Equatable {
    /// <p>The list of tags that are associated with the DAX resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct TagResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceName: \(String(describing: resourceName)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceName = resourceName {
            try encodeContainer.encode(resourceName, forKey: .resourceName)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for keylist0 in tagKeys {
                try tagKeysContainer.encode(keylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The name of the DAX resource from which the tags should be removed.</p>
    public let resourceName: String?
    /// <p>A list of tag keys. If the DAX cluster has any tags with these keys, then the tags are removed from the cluster.</p>
    public let tagKeys: [String]?

    public init (
        resourceName: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceName = resourceName
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceName: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceName = "ResourceName"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidARNFault" : self = .invalidARNFault(try InvalidARNFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagNotFoundFault" : self = .tagNotFoundFault(try TagNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidARNFault(InvalidARNFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case tagNotFoundFault(TagNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UntagResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct UntagResourceOutputResponse: Equatable {
    /// <p>The tag keys that have been removed from the cluster.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct UntagResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension UntagResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateClusterInputBodyMiddleware: Middleware {
    public let id: String = "UpdateClusterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

extension UpdateClusterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterInput(clusterName: \(String(describing: clusterName)), description: \(String(describing: description)), notificationTopicArn: \(String(describing: notificationTopicArn)), notificationTopicStatus: \(String(describing: notificationTopicStatus)), parameterGroupName: \(String(describing: parameterGroupName)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), securityGroupIds: \(String(describing: securityGroupIds)))"}
}

extension UpdateClusterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clusterName = clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let notificationTopicArn = notificationTopicArn {
            try encodeContainer.encode(notificationTopicArn, forKey: .notificationTopicArn)
        }
        if let notificationTopicStatus = notificationTopicStatus {
            try encodeContainer.encode(notificationTopicStatus, forKey: .notificationTopicStatus)
        }
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupidentifierlist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupidentifierlist0)
            }
        }
    }
}

public struct UpdateClusterInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateClusterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateClusterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateClusterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateClusterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateClusterInput>
    public typealias MOutput = OperationOutput<UpdateClusterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateClusterOutputError>
}

public struct UpdateClusterInput: Equatable {
    /// <p>The name of the DAX cluster to be modified.</p>
    public let clusterName: String?
    /// <p>A description of the changes being made to the cluster.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the topic.</p>
    public let notificationTopicArn: String?
    /// <p>The current state of the topic.</p>
    public let notificationTopicStatus: String?
    /// <p>The name of a parameter group for this cluster.</p>
    public let parameterGroupName: String?
    /// <p>A range of time when maintenance of DAX cluster software will be performed. For
    ///             example: <code>sun:01:00-sun:09:00</code>. Cluster maintenance normally takes less than
    ///             30 minutes, and is performed automatically within the maintenance window.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>A list of user-specified security group IDs to be assigned to each node in the DAX cluster.  If this parameter is not
    ///             specified, DAX assigns the default VPC security group to each node.</p>
    public let securityGroupIds: [String]?

    public init (
        clusterName: String? = nil,
        description: String? = nil,
        notificationTopicArn: String? = nil,
        notificationTopicStatus: String? = nil,
        parameterGroupName: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        securityGroupIds: [String]? = nil
    )
    {
        self.clusterName = clusterName
        self.description = description
        self.notificationTopicArn = notificationTopicArn
        self.notificationTopicStatus = notificationTopicStatus
        self.parameterGroupName = parameterGroupName
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
    }
}

struct UpdateClusterInputBody: Equatable {
    public let clusterName: String?
    public let description: String?
    public let preferredMaintenanceWindow: String?
    public let notificationTopicArn: String?
    public let notificationTopicStatus: String?
    public let parameterGroupName: String?
    public let securityGroupIds: [String]?
}

extension UpdateClusterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clusterName = "ClusterName"
        case description = "Description"
        case notificationTopicArn = "NotificationTopicArn"
        case notificationTopicStatus = "NotificationTopicStatus"
        case parameterGroupName = "ParameterGroupName"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let notificationTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationTopicArn)
        notificationTopicArn = notificationTopicArnDecoded
        let notificationTopicStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .notificationTopicStatus)
        notificationTopicStatus = notificationTopicStatusDecoded
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateClusterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateClusterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ClusterNotFoundFault" : self = .clusterNotFoundFault(try ClusterNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidClusterStateFault" : self = .invalidClusterStateFault(try InvalidClusterStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateClusterOutputError: Equatable {
    case clusterNotFoundFault(ClusterNotFoundFault)
    case invalidClusterStateFault(InvalidClusterStateFault)
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateClusterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateClusterOutputResponse(cluster: \(String(describing: cluster)))"}
}

extension UpdateClusterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateClusterOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cluster = output.cluster
        } else {
            self.cluster = nil
        }
    }
}

public struct UpdateClusterOutputResponse: Equatable {
    /// <p>A description of the DAX cluster, after it has been modified.</p>
    public let cluster: Cluster?

    public init (
        cluster: Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

struct UpdateClusterOutputResponseBody: Equatable {
    public let cluster: Cluster?
}

extension UpdateClusterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cluster = "Cluster"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterDecoded = try containerValues.decodeIfPresent(Cluster.self, forKey: .cluster)
        cluster = clusterDecoded
    }
}

public struct UpdateParameterGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateParameterGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParameterGroupOutputError>
}

extension UpdateParameterGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateParameterGroupInput(parameterGroupName: \(String(describing: parameterGroupName)), parameterNameValues: \(String(describing: parameterNameValues)))"}
}

extension UpdateParameterGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterGroupName = parameterGroupName {
            try encodeContainer.encode(parameterGroupName, forKey: .parameterGroupName)
        }
        if let parameterNameValues = parameterNameValues {
            var parameterNameValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .parameterNameValues)
            for parameternamevaluelist0 in parameterNameValues {
                try parameterNameValuesContainer.encode(parameternamevaluelist0)
            }
        }
    }
}

public struct UpdateParameterGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateParameterGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateParameterGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateParameterGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateParameterGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateParameterGroupInput>
    public typealias MOutput = OperationOutput<UpdateParameterGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateParameterGroupOutputError>
}

public struct UpdateParameterGroupInput: Equatable {
    /// <p>The name of the parameter group.</p>
    public let parameterGroupName: String?
    /// <p>An array of name-value pairs for the parameters in the group. Each element in the
    ///             array represents a single parameter.</p>
    public let parameterNameValues: [ParameterNameValue]?

    public init (
        parameterGroupName: String? = nil,
        parameterNameValues: [ParameterNameValue]? = nil
    )
    {
        self.parameterGroupName = parameterGroupName
        self.parameterNameValues = parameterNameValues
    }
}

struct UpdateParameterGroupInputBody: Equatable {
    public let parameterGroupName: String?
    public let parameterNameValues: [ParameterNameValue]?
}

extension UpdateParameterGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroupName = "ParameterGroupName"
        case parameterNameValues = "ParameterNameValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .parameterGroupName)
        parameterGroupName = parameterGroupNameDecoded
        let parameterNameValuesContainer = try containerValues.decodeIfPresent([ParameterNameValue?].self, forKey: .parameterNameValues)
        var parameterNameValuesDecoded0:[ParameterNameValue]? = nil
        if let parameterNameValuesContainer = parameterNameValuesContainer {
            parameterNameValuesDecoded0 = [ParameterNameValue]()
            for structure0 in parameterNameValuesContainer {
                if let structure0 = structure0 {
                    parameterNameValuesDecoded0?.append(structure0)
                }
            }
        }
        parameterNameValues = parameterNameValuesDecoded0
    }
}

extension UpdateParameterGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateParameterGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterCombinationException" : self = .invalidParameterCombinationException(try InvalidParameterCombinationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterGroupStateFault" : self = .invalidParameterGroupStateFault(try InvalidParameterGroupStateFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ParameterGroupNotFoundFault" : self = .parameterGroupNotFoundFault(try ParameterGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateParameterGroupOutputError: Equatable {
    case invalidParameterCombinationException(InvalidParameterCombinationException)
    case invalidParameterGroupStateFault(InvalidParameterGroupStateFault)
    case invalidParameterValueException(InvalidParameterValueException)
    case parameterGroupNotFoundFault(ParameterGroupNotFoundFault)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateParameterGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateParameterGroupOutputResponse(parameterGroup: \(String(describing: parameterGroup)))"}
}

extension UpdateParameterGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateParameterGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.parameterGroup = output.parameterGroup
        } else {
            self.parameterGroup = nil
        }
    }
}

public struct UpdateParameterGroupOutputResponse: Equatable {
    /// <p>The parameter group that has been modified.</p>
    public let parameterGroup: ParameterGroup?

    public init (
        parameterGroup: ParameterGroup? = nil
    )
    {
        self.parameterGroup = parameterGroup
    }
}

struct UpdateParameterGroupOutputResponseBody: Equatable {
    public let parameterGroup: ParameterGroup?
}

extension UpdateParameterGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case parameterGroup = "ParameterGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterGroupDecoded = try containerValues.decodeIfPresent(ParameterGroup.self, forKey: .parameterGroup)
        parameterGroup = parameterGroupDecoded
    }
}

public struct UpdateSubnetGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSubnetGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetGroupOutputError>
}

extension UpdateSubnetGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubnetGroupInput(description: \(String(describing: description)), subnetGroupName: \(String(describing: subnetGroupName)), subnetIds: \(String(describing: subnetIds)))"}
}

extension UpdateSubnetGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let subnetGroupName = subnetGroupName {
            try encodeContainer.encode(subnetGroupName, forKey: .subnetGroupName)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetidentifierlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetidentifierlist0)
            }
        }
    }
}

public struct UpdateSubnetGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSubnetGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSubnetGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSubnetGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSubnetGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSubnetGroupInput>
    public typealias MOutput = OperationOutput<UpdateSubnetGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSubnetGroupOutputError>
}

public struct UpdateSubnetGroupInput: Equatable {
    /// <p>A description of the subnet group.</p>
    public let description: String?
    /// <p>The name of the subnet group.</p>
    public let subnetGroupName: String?
    /// <p>A list of subnet IDs in the subnet group.</p>
    public let subnetIds: [String]?

    public init (
        description: String? = nil,
        subnetGroupName: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.description = description
        self.subnetGroupName = subnetGroupName
        self.subnetIds = subnetIds
    }
}

struct UpdateSubnetGroupInputBody: Equatable {
    public let subnetGroupName: String?
    public let description: String?
    public let subnetIds: [String]?
}

extension UpdateSubnetGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case subnetGroupName = "SubnetGroupName"
        case subnetIds = "SubnetIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetGroupName)
        subnetGroupName = subnetGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
    }
}

extension UpdateSubnetGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubnetGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidSubnet" : self = .invalidSubnet(try InvalidSubnet(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceLinkedRoleNotFoundFault" : self = .serviceLinkedRoleNotFoundFault(try ServiceLinkedRoleNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetGroupNotFoundFault" : self = .subnetGroupNotFoundFault(try SubnetGroupNotFoundFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetInUse" : self = .subnetInUse(try SubnetInUse(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetQuotaExceededFault" : self = .subnetQuotaExceededFault(try SubnetQuotaExceededFault(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSubnetGroupOutputError: Equatable {
    case invalidSubnet(InvalidSubnet)
    case serviceLinkedRoleNotFoundFault(ServiceLinkedRoleNotFoundFault)
    case subnetGroupNotFoundFault(SubnetGroupNotFoundFault)
    case subnetInUse(SubnetInUse)
    case subnetQuotaExceededFault(SubnetQuotaExceededFault)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubnetGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSubnetGroupOutputResponse(subnetGroup: \(String(describing: subnetGroup)))"}
}

extension UpdateSubnetGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSubnetGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subnetGroup = output.subnetGroup
        } else {
            self.subnetGroup = nil
        }
    }
}

public struct UpdateSubnetGroupOutputResponse: Equatable {
    /// <p>The subnet group that has been modified.</p>
    public let subnetGroup: SubnetGroup?

    public init (
        subnetGroup: SubnetGroup? = nil
    )
    {
        self.subnetGroup = subnetGroup
    }
}

struct UpdateSubnetGroupOutputResponseBody: Equatable {
    public let subnetGroup: SubnetGroup?
}

extension UpdateSubnetGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subnetGroup = "SubnetGroup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetGroupDecoded = try containerValues.decodeIfPresent(SubnetGroup.self, forKey: .subnetGroup)
        subnetGroup = subnetGroupDecoded
    }
}
