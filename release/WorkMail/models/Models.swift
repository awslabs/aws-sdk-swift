// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessControlRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprangelist0 in ipRanges {
                try ipRangesContainer.encode(iprangelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for actionslist0 in notActions {
                try notActionsContainer.encode(actionslist0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprangelist0 in notIpRanges {
                try notIpRangesContainer.encode(iprangelist0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for useridlist0 in notUserIds {
                try notUserIdsContainer.encode(useridlist0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for useridlist0 in userIds {
                try userIdsContainer.encode(useridlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notActions)
        var notActionsDecoded0:[String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userIds)
        var userIdsDecoded0:[String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension AccessControlRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessControlRule(actions: \(String(describing: actions)), dateCreated: \(String(describing: dateCreated)), dateModified: \(String(describing: dateModified)), description: \(String(describing: description)), effect: \(String(describing: effect)), ipRanges: \(String(describing: ipRanges)), name: \(String(describing: name)), notActions: \(String(describing: notActions)), notIpRanges: \(String(describing: notIpRanges)), notUserIds: \(String(describing: notUserIds)), userIds: \(String(describing: userIds)))"}
}

/// <p>A rule that controls access to an Amazon WorkMail organization.</p>
public struct AccessControlRule: Equatable {
    /// <p>Access protocol actions to include in the rule. Valid values include
    ///             <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>,
    ///             <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    public let actions: [String]?
    /// <p>The date that the rule was created.</p>
    public let dateCreated: Date?
    /// <p>The date that the rule was modified.</p>
    public let dateModified: Date?
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>The rule effect.</p>
    public let effect: AccessControlRuleEffect?
    /// <p>IPv4 CIDR ranges to include in the rule.</p>
    public let ipRanges: [String]?
    /// <p>The rule name.</p>
    public let name: String?
    /// <p>Access protocol actions to exclude from the rule. Valid values include
    ///             <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>,
    ///             <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    public let notActions: [String]?
    /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
    public let notIpRanges: [String]?
    /// <p>User IDs to exclude from the rule.</p>
    public let notUserIds: [String]?
    /// <p>User IDs to include in the rule.</p>
    public let userIds: [String]?

    public init (
        actions: [String]? = nil,
        dateCreated: Date? = nil,
        dateModified: Date? = nil,
        description: String? = nil,
        effect: AccessControlRuleEffect? = nil,
        ipRanges: [String]? = nil,
        name: String? = nil,
        notActions: [String]? = nil,
        notIpRanges: [String]? = nil,
        notUserIds: [String]? = nil,
        userIds: [String]? = nil
    )
    {
        self.actions = actions
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.effect = effect
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.userIds = userIds
    }
}

public enum AccessControlRuleEffect {
    case allow
    case deny
    case sdkUnknown(String)
}

extension AccessControlRuleEffect : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessControlRuleEffect] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessControlRuleEffect(rawValue: rawValue) ?? AccessControlRuleEffect.sdkUnknown(rawValue)
    }
}

public struct AssociateDelegateToResourceInputBodyMiddleware: Middleware {
    public let id: String = "AssociateDelegateToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDelegateToResourceOutputError>
}

extension AssociateDelegateToResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDelegateToResourceInput(entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension AssociateDelegateToResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateDelegateToResourceInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateDelegateToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateDelegateToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInput: Equatable {
    /// <p>The member (user or group) to associate to the resource.</p>
    public let entityId: String?
    /// <p>The organization under which the resource exists.</p>
    public let organizationId: String?
    /// <p>The resource for which members (users or groups) are associated.</p>
    public let resourceId: String?

    public init (
        entityId: String? = nil,
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct AssociateDelegateToResourceInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
    public let entityId: String?
}

extension AssociateDelegateToResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension AssociateDelegateToResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDelegateToResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDelegateToResourceOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDelegateToResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateDelegateToResourceOutputResponse()"}
}

extension AssociateDelegateToResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDelegateToResourceOutputResponse: Equatable {

    public init() {}
}

struct AssociateDelegateToResourceOutputResponseBody: Equatable {
}

extension AssociateDelegateToResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateMemberToGroupInputBodyMiddleware: Middleware {
    public let id: String = "AssociateMemberToGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberToGroupOutputError>
}

extension AssociateMemberToGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMemberToGroupInput(groupId: \(String(describing: groupId)), memberId: \(String(describing: memberId)), organizationId: \(String(describing: organizationId)))"}
}

extension AssociateMemberToGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct AssociateMemberToGroupInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateMemberToGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateMemberToGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInput: Equatable {
    /// <p>The group to which the member (user or group) is associated.</p>
    public let groupId: String?
    /// <p>The member (user or group) to associate to the group.</p>
    public let memberId: String?
    /// <p>The organization under which the group exists.</p>
    public let organizationId: String?

    public init (
        groupId: String? = nil,
        memberId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct AssociateMemberToGroupInputBody: Equatable {
    public let organizationId: String?
    public let groupId: String?
    public let memberId: String?
}

extension AssociateMemberToGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension AssociateMemberToGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberToGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMemberToGroupOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberToGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateMemberToGroupOutputResponse()"}
}

extension AssociateMemberToGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMemberToGroupOutputResponse: Equatable {

    public init() {}
}

struct AssociateMemberToGroupOutputResponseBody: Equatable {
}

extension AssociateMemberToGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension BookingOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoAcceptRequests = "AutoAcceptRequests"
        case autoDeclineConflictingRequests = "AutoDeclineConflictingRequests"
        case autoDeclineRecurringRequests = "AutoDeclineRecurringRequests"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoAcceptRequests != false {
            try encodeContainer.encode(autoAcceptRequests, forKey: .autoAcceptRequests)
        }
        if autoDeclineConflictingRequests != false {
            try encodeContainer.encode(autoDeclineConflictingRequests, forKey: .autoDeclineConflictingRequests)
        }
        if autoDeclineRecurringRequests != false {
            try encodeContainer.encode(autoDeclineRecurringRequests, forKey: .autoDeclineRecurringRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAcceptRequestsDecoded = try containerValues.decode(Bool.self, forKey: .autoAcceptRequests)
        autoAcceptRequests = autoAcceptRequestsDecoded
        let autoDeclineRecurringRequestsDecoded = try containerValues.decode(Bool.self, forKey: .autoDeclineRecurringRequests)
        autoDeclineRecurringRequests = autoDeclineRecurringRequestsDecoded
        let autoDeclineConflictingRequestsDecoded = try containerValues.decode(Bool.self, forKey: .autoDeclineConflictingRequests)
        autoDeclineConflictingRequests = autoDeclineConflictingRequestsDecoded
    }
}

extension BookingOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BookingOptions(autoAcceptRequests: \(String(describing: autoAcceptRequests)), autoDeclineConflictingRequests: \(String(describing: autoDeclineConflictingRequests)), autoDeclineRecurringRequests: \(String(describing: autoDeclineRecurringRequests)))"}
}

/// <p>At least one delegate must be associated to the resource to disable automatic replies
///          from the resource.</p>
public struct BookingOptions: Equatable {
    /// <p>The resource's ability to automatically reply to requests. If disabled, delegates
    ///          must be associated to the resource.</p>
    public let autoAcceptRequests: Bool
    /// <p>The resource's ability to automatically decline any conflicting requests.</p>
    public let autoDeclineConflictingRequests: Bool
    /// <p>The resource's ability to automatically decline any recurring requests.</p>
    public let autoDeclineRecurringRequests: Bool

    public init (
        autoAcceptRequests: Bool = false,
        autoDeclineConflictingRequests: Bool = false,
        autoDeclineRecurringRequests: Bool = false
    )
    {
        self.autoAcceptRequests = autoAcceptRequests
        self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
        self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
    }
}

public struct CancelMailboxExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CancelMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMailboxExportJobOutputError>
}

extension CancelMailboxExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMailboxExportJobInput(clientToken: \(String(describing: clientToken)), jobId: \(String(describing: jobId)), organizationId: \(String(describing: organizationId)))"}
}

extension CancelMailboxExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CancelMailboxExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CancelMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInput: Equatable {
    /// <p>The idempotency token for the client request.</p>
    public var clientToken: String?
    /// <p>The job ID.</p>
    public let jobId: String?
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        clientToken: String? = nil,
        jobId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct CancelMailboxExportJobInputBody: Equatable {
    public let clientToken: String?
    public let jobId: String?
    public let organizationId: String?
}

extension CancelMailboxExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension CancelMailboxExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMailboxExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMailboxExportJobOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMailboxExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelMailboxExportJobOutputResponse()"}
}

extension CancelMailboxExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelMailboxExportJobOutputResponse: Equatable {

    public init() {}
}

struct CancelMailboxExportJobOutputResponseBody: Equatable {
}

extension CancelMailboxExportJobOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasInput(alias: \(String(describing: alias)), entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)))"}
}

extension CreateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInput: Equatable {
    /// <p>The alias to add to the member set.</p>
    public let alias: String?
    /// <p>The member (user or group) to which this alias is added.</p>
    public let entityId: String?
    /// <p>The organization under which the member (user or group) exists.</p>
    public let organizationId: String?

    public init (
        alias: String? = nil,
        entityId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct CreateAliasInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let alias: String?
}

extension CreateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Equatable {
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasOutputResponse()"}
}

extension CreateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateAliasOutputResponse: Equatable {

    public init() {}
}

struct CreateAliasOutputResponseBody: Equatable {
}

extension CreateAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupInput(name: \(String(describing: name)), organizationId: \(String(describing: organizationId)))"}
}

extension CreateGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGroupInput>
    public typealias MOutput = OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Equatable {
    /// <p>The name of the group.</p>
    public let name: String?
    /// <p>The organization under which the group is to be created.</p>
    public let organizationId: String?

    public init (
        name: String? = nil,
        organizationId: String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct CreateGroupInputBody: Equatable {
    public let organizationId: String?
    public let name: String?
}

extension CreateGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGroupOutputResponse(groupId: \(String(describing: groupId)))"}
}

extension CreateGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateGroupOutputResponse: Equatable {
    /// <p>The identifier of the group.</p>
    public let groupId: String?

    public init (
        groupId: String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateGroupOutputResponseBody: Equatable {
    public let groupId: String?
}

extension CreateGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

public struct CreateMobileDeviceAccessRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMobileDeviceAccessRuleOutputError>
}

extension CreateMobileDeviceAccessRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMobileDeviceAccessRuleInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), deviceModels: \(String(describing: deviceModels)), deviceOperatingSystems: \(String(describing: deviceOperatingSystems)), deviceTypes: \(String(describing: deviceTypes)), deviceUserAgents: \(String(describing: deviceUserAgents)), effect: \(String(describing: effect)), name: \(String(describing: name)), notDeviceModels: \(String(describing: notDeviceModels)), notDeviceOperatingSystems: \(String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(String(describing: notDeviceTypes)), notDeviceUserAgents: \(String(describing: notDeviceUserAgents)), organizationId: \(String(describing: organizationId)))"}
}

extension CreateMobileDeviceAccessRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateMobileDeviceAccessRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInput: Equatable {
    /// <p>The idempotency token for the client request.</p>
    public var clientToken: String?
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>Device models that the rule will match.</p>
    public let deviceModels: [String]?
    /// <p>Device operating systems that the rule will match.</p>
    public let deviceOperatingSystems: [String]?
    /// <p>Device types that the rule will match.</p>
    public let deviceTypes: [String]?
    /// <p>Device user agents that the rule will match.</p>
    public let deviceUserAgents: [String]?
    /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
    public let effect: MobileDeviceAccessRuleEffect?
    /// <p>The rule name.</p>
    public let name: String?
    /// <p>Device models that the rule <b>will not</b> match. All other device models will match.</p>
    public let notDeviceModels: [String]?
    /// <p>Device operating systems that the rule <b>will not</b> match. All other device operating systems will match.</p>
    public let notDeviceOperatingSystems: [String]?
    /// <p>Device types that the rule <b>will not</b> match. All other device types will match.</p>
    public let notDeviceTypes: [String]?
    /// <p>Device user agents that the rule <b>will not</b> match. All other device user agents will match.</p>
    public let notDeviceUserAgents: [String]?
    /// <p>The Amazon WorkMail organization under which the rule will be created.</p>
    public let organizationId: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        deviceModels: [String]? = nil,
        deviceOperatingSystems: [String]? = nil,
        deviceTypes: [String]? = nil,
        deviceUserAgents: [String]? = nil,
        effect: MobileDeviceAccessRuleEffect? = nil,
        name: String? = nil,
        notDeviceModels: [String]? = nil,
        notDeviceOperatingSystems: [String]? = nil,
        notDeviceTypes: [String]? = nil,
        notDeviceUserAgents: [String]? = nil,
        organizationId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct CreateMobileDeviceAccessRuleInputBody: Equatable {
    public let organizationId: String?
    public let clientToken: String?
    public let name: String?
    public let description: String?
    public let effect: MobileDeviceAccessRuleEffect?
    public let deviceTypes: [String]?
    public let notDeviceTypes: [String]?
    public let deviceModels: [String]?
    public let notDeviceModels: [String]?
    public let deviceOperatingSystems: [String]?
    public let notDeviceOperatingSystems: [String]?
    public let deviceUserAgents: [String]?
    public let notDeviceUserAgents: [String]?
}

extension CreateMobileDeviceAccessRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension CreateMobileDeviceAccessRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMobileDeviceAccessRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMobileDeviceAccessRuleOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMobileDeviceAccessRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMobileDeviceAccessRuleOutputResponse(mobileDeviceAccessRuleId: \(String(describing: mobileDeviceAccessRuleId)))"}
}

extension CreateMobileDeviceAccessRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateMobileDeviceAccessRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mobileDeviceAccessRuleId = output.mobileDeviceAccessRuleId
        } else {
            self.mobileDeviceAccessRuleId = nil
        }
    }
}

public struct CreateMobileDeviceAccessRuleOutputResponse: Equatable {
    /// <p>The identifier for the newly created mobile device access rule.</p>
    public let mobileDeviceAccessRuleId: String?

    public init (
        mobileDeviceAccessRuleId: String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
    }
}

struct CreateMobileDeviceAccessRuleOutputResponseBody: Equatable {
    public let mobileDeviceAccessRuleId: String?
}

extension CreateMobileDeviceAccessRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

public struct CreateOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "CreateOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOrganizationOutputError>
}

extension CreateOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOrganizationInput(alias: \(String(describing: alias)), clientToken: \(String(describing: clientToken)), directoryId: \(String(describing: directoryId)), domains: \(String(describing: domains)), enableInteroperability: \(String(describing: enableInteroperability)), kmsKeyArn: \(String(describing: kmsKeyArn)))"}
}

extension CreateOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domains0 in domains {
                try domainsContainer.encode(domains0)
            }
        }
        if enableInteroperability != false {
            try encodeContainer.encode(enableInteroperability, forKey: .enableInteroperability)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

public struct CreateOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInput: Equatable {
    /// <p>The organization alias.</p>
    public let alias: String?
    /// <p>The idempotency token associated with the request.</p>
    public var clientToken: String?
    /// <p>The AWS Directory Service directory ID.</p>
    public let directoryId: String?
    /// <p>The email domains to associate with the organization.</p>
    public let domains: [Domain]?
    /// <p>When <code>true</code>, allows organization interoperability between Amazon WorkMail and Microsoft Exchange. Can only be set to <code>true</code> if an AD Connector directory ID is included in the request.</p>
    public let enableInteroperability: Bool
    /// <p>The Amazon Resource Name (ARN) of a customer managed master key from AWS
    ///          KMS.</p>
    public let kmsKeyArn: String?

    public init (
        alias: String? = nil,
        clientToken: String? = nil,
        directoryId: String? = nil,
        domains: [Domain]? = nil,
        enableInteroperability: Bool = false,
        kmsKeyArn: String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.domains = domains
        self.enableInteroperability = enableInteroperability
        self.kmsKeyArn = kmsKeyArn
    }
}

struct CreateOrganizationInputBody: Equatable {
    public let directoryId: String?
    public let alias: String?
    public let clientToken: String?
    public let domains: [Domain]?
    public let kmsKeyArn: String?
    public let enableInteroperability: Bool
}

extension CreateOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([Domain?].self, forKey: .domains)
        var domainsDecoded0:[Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let enableInteroperabilityDecoded = try containerValues.decode(Bool.self, forKey: .enableInteroperability)
        enableInteroperability = enableInteroperabilityDecoded
    }
}

extension CreateOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryInUseException" : self = .directoryInUseException(try DirectoryInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOrganizationOutputError: Equatable {
    case directoryInUseException(DirectoryInUseException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case nameAvailabilityException(NameAvailabilityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateOrganizationOutputResponse(organizationId: \(String(describing: organizationId)))"}
}

extension CreateOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.organizationId = output.organizationId
        } else {
            self.organizationId = nil
        }
    }
}

public struct CreateOrganizationOutputResponse: Equatable {
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        organizationId: String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct CreateOrganizationOutputResponseBody: Equatable {
    public let organizationId: String?
}

extension CreateOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

public struct CreateResourceInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

extension CreateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceInput(name: \(String(describing: name)), organizationId: \(String(describing: organizationId)), type: \(String(describing: type)))"}
}

extension CreateResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

public struct CreateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceInput>
    public typealias MOutput = OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceOutputError>
}

public struct CreateResourceInput: Equatable {
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The identifier associated with the organization for which the resource is
    ///          created.</p>
    public let organizationId: String?
    /// <p>The type of the new resource. The available types are <code>equipment</code> and
    ///             <code>room</code>.</p>
    public let type: ResourceType?

    public init (
        name: String? = nil,
        organizationId: String? = nil,
        type: ResourceType? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
        self.type = type
    }
}

struct CreateResourceInputBody: Equatable {
    public let organizationId: String?
    public let name: String?
    public let type: ResourceType?
}

extension CreateResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceOutputResponse(resourceId: \(String(describing: resourceId)))"}
}

extension CreateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
        }
    }
}

public struct CreateResourceOutputResponse: Equatable {
    /// <p>The identifier of the new resource.</p>
    public let resourceId: String?

    public init (
        resourceId: String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct CreateResourceOutputResponseBody: Equatable {
    public let resourceId: String?
}

extension CreateResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

public struct CreateUserInputBodyMiddleware: Middleware {
    public let id: String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

extension CreateUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserInput(displayName: \(String(describing: displayName)), name: \(String(describing: name)), organizationId: \(String(describing: organizationId)), password: \(String(describing: password)))"}
}

extension CreateUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: Middleware {
    public let id: String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateUserInput>
    public typealias MOutput = OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Equatable {
    /// <p>The display name for the new user.</p>
    public let displayName: String?
    /// <p>The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.</p>
    public let name: String?
    /// <p>The identifier of the organization for which the user is created.</p>
    public let organizationId: String?
    /// <p>The password for the new user.</p>
    public let password: String?

    public init (
        displayName: String? = nil,
        name: String? = nil,
        organizationId: String? = nil,
        password: String? = nil
    )
    {
        self.displayName = displayName
        self.name = name
        self.organizationId = organizationId
        self.password = password
    }
}

struct CreateUserInputBody: Equatable {
    public let organizationId: String?
    public let name: String?
    public let displayName: String?
    public let password: String?
}

extension CreateUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateUserOutputResponse(userId: \(String(describing: userId)))"}
}

extension CreateUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Equatable {
    /// <p>The identifier for the new user.</p>
    public let userId: String?

    public init (
        userId: String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Equatable {
    public let userId: String?
}

extension CreateUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension Delegate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MemberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension Delegate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Delegate(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>The name of the attribute, which is one of the values defined in the UserAttribute
///          enumeration.</p>
public struct Delegate: Equatable {
    /// <p>The identifier for the user or group associated as the resource's delegate.</p>
    public let id: String?
    /// <p>The type of the delegate: user or group.</p>
    public let type: MemberType?

    public init (
        id: String? = nil,
        type: MemberType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

public struct DeleteAccessControlRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAccessControlRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessControlRuleOutputError>
}

extension DeleteAccessControlRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessControlRuleInput(name: \(String(describing: name)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteAccessControlRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteAccessControlRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAccessControlRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAccessControlRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInput: Equatable {
    /// <p>The name of the access control rule.</p>
    public let name: String?
    /// <p>The identifier for the organization.</p>
    public let organizationId: String?

    public init (
        name: String? = nil,
        organizationId: String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct DeleteAccessControlRuleInputBody: Equatable {
    public let organizationId: String?
    public let name: String?
}

extension DeleteAccessControlRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAccessControlRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessControlRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessControlRuleOutputError: Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessControlRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAccessControlRuleOutputResponse()"}
}

extension DeleteAccessControlRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessControlRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteAccessControlRuleOutputResponseBody: Equatable {
}

extension DeleteAccessControlRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAliasInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

extension DeleteAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasInput(alias: \(String(describing: alias)), entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInput: Equatable {
    /// <p>The aliases to be removed from the user's set of aliases. Duplicate entries in the
    ///          list are collapsed into single entries (the list is transformed into a set).</p>
    public let alias: String?
    /// <p>The identifier for the member (user or group) from which to have the aliases
    ///          removed.</p>
    public let entityId: String?
    /// <p>The identifier for the organization under which the user exists.</p>
    public let organizationId: String?

    public init (
        alias: String? = nil,
        entityId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeleteAliasInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let alias: String?
}

extension DeleteAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension DeleteAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasOutputResponse()"}
}

extension DeleteAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteAliasOutputResponseBody: Equatable {
}

extension DeleteAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteGroupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupInput(groupId: \(String(describing: groupId)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Equatable {
    /// <p>The identifier of the group to be deleted.</p>
    public let groupId: String?
    /// <p>The organization that contains the group.</p>
    public let organizationId: String?

    public init (
        groupId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DeleteGroupInputBody: Equatable {
    public let organizationId: String?
    public let groupId: String?
}

extension DeleteGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Equatable {
}

extension DeleteGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteMailboxPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMailboxPermissionsOutputError>
}

extension DeleteMailboxPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMailboxPermissionsInput(entityId: \(String(describing: entityId)), granteeId: \(String(describing: granteeId)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteMailboxPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteMailboxPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInput: Equatable {
    /// <p>The identifier of the member (user or group) that owns the mailbox.</p>
    public let entityId: String?
    /// <p>The identifier of the member (user or group) for which to delete granted
    ///          permissions.</p>
    public let granteeId: String?
    /// <p>The identifier of the organization under which the member (user or group)
    ///          exists.</p>
    public let organizationId: String?

    public init (
        entityId: String? = nil,
        granteeId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
    }
}

struct DeleteMailboxPermissionsInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let granteeId: String?
}

extension DeleteMailboxPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
    }
}

extension DeleteMailboxPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMailboxPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMailboxPermissionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMailboxPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMailboxPermissionsOutputResponse()"}
}

extension DeleteMailboxPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMailboxPermissionsOutputResponse: Equatable {

    public init() {}
}

struct DeleteMailboxPermissionsOutputResponseBody: Equatable {
}

extension DeleteMailboxPermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteMobileDeviceAccessRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

extension DeleteMobileDeviceAccessRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMobileDeviceAccessRuleInput(mobileDeviceAccessRuleId: \(String(describing: mobileDeviceAccessRuleId)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteMobileDeviceAccessRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteMobileDeviceAccessRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInput: Equatable {
    /// <p>The identifier of the rule to be deleted.</p>
    public let mobileDeviceAccessRuleId: String?
    /// <p>The Amazon WorkMail organization under which the rule will be deleted.</p>
    public let organizationId: String?

    public init (
        mobileDeviceAccessRuleId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.organizationId = organizationId
    }
}

struct DeleteMobileDeviceAccessRuleInputBody: Equatable {
    public let organizationId: String?
    public let mobileDeviceAccessRuleId: String?
}

extension DeleteMobileDeviceAccessRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

extension DeleteMobileDeviceAccessRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMobileDeviceAccessRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMobileDeviceAccessRuleOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMobileDeviceAccessRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMobileDeviceAccessRuleOutputResponse()"}
}

extension DeleteMobileDeviceAccessRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMobileDeviceAccessRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteMobileDeviceAccessRuleOutputResponseBody: Equatable {
}

extension DeleteMobileDeviceAccessRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationOutputError>
}

extension DeleteOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationInput(clientToken: \(String(describing: clientToken)), deleteDirectory: \(String(describing: deleteDirectory)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if deleteDirectory != false {
            try encodeContainer.encode(deleteDirectory, forKey: .deleteDirectory)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInput: Equatable {
    /// <p>The idempotency token associated with the request.</p>
    public var clientToken: String?
    /// <p>If true, deletes the AWS Directory Service directory associated with the organization.</p>
    public let deleteDirectory: Bool
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        clientToken: String? = nil,
        deleteDirectory: Bool = false,
        organizationId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.deleteDirectory = deleteDirectory
        self.organizationId = organizationId
    }
}

struct DeleteOrganizationInputBody: Equatable {
    public let clientToken: String?
    public let organizationId: String?
    public let deleteDirectory: Bool
}

extension DeleteOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deleteDirectoryDecoded = try containerValues.decode(Bool.self, forKey: .deleteDirectory)
        deleteDirectory = deleteDirectoryDecoded
    }
}

extension DeleteOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOrganizationOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteOrganizationOutputResponse(organizationId: \(String(describing: organizationId)), state: \(String(describing: state)))"}
}

extension DeleteOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DeleteOrganizationOutputResponse: Equatable {
    /// <p>The organization ID.</p>
    public let organizationId: String?
    /// <p>The state of the organization.</p>
    public let state: String?

    public init (
        organizationId: String? = nil,
        state: String? = nil
    )
    {
        self.organizationId = organizationId
        self.state = state
    }
}

struct DeleteOrganizationOutputResponseBody: Equatable {
    public let organizationId: String?
    public let state: String?
}

extension DeleteOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DeleteResourceInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceOutputError>
}

extension DeleteResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceInput(organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension DeleteResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DeleteResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInput: Equatable {
    /// <p>The identifier associated with the organization from which the resource is
    ///          deleted.</p>
    public let organizationId: String?
    /// <p>The identifier of the resource to be deleted.</p>
    public let resourceId: String?

    public init (
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DeleteResourceInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
}

extension DeleteResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceOutputError: Equatable {
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourceOutputResponse()"}
}

extension DeleteResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourceOutputResponseBody: Equatable {
}

extension DeleteResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRetentionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionPolicyOutputError>
}

extension DeleteRetentionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRetentionPolicyInput(id: \(String(describing: id)), organizationId: \(String(describing: organizationId)))"}
}

extension DeleteRetentionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteRetentionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInput: Equatable {
    /// <p>The retention policy ID.</p>
    public let id: String?
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        id: String? = nil,
        organizationId: String? = nil
    )
    {
        self.id = id
        self.organizationId = organizationId
    }
}

struct DeleteRetentionPolicyInputBody: Equatable {
    public let organizationId: String?
    public let id: String?
}

extension DeleteRetentionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRetentionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRetentionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRetentionPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRetentionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRetentionPolicyOutputResponse()"}
}

extension DeleteRetentionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRetentionPolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteRetentionPolicyOutputResponseBody: Equatable {
}

extension DeleteRetentionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: Middleware {
    public let id: String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserInput(organizationId: \(String(describing: organizationId)), userId: \(String(describing: userId)))"}
}

extension DeleteUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserInput>
    public typealias MOutput = OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Equatable {
    /// <p>The organization that contains the user to be deleted.</p>
    public let organizationId: String?
    /// <p>The identifier of the user to be deleted.</p>
    public let userId: String?

    public init (
        organizationId: String? = nil,
        userId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Equatable {
    public let organizationId: String?
    public let userId: String?
}

extension DeleteUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Equatable {
}

extension DeleteUserOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterFromWorkMailInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterFromWorkMailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterFromWorkMailOutputError>
}

extension DeregisterFromWorkMailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterFromWorkMailInput(entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)))"}
}

extension DeregisterFromWorkMailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeregisterFromWorkMailInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterFromWorkMailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterFromWorkMailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInput: Equatable {
    /// <p>The identifier for the member (user or group) to be updated.</p>
    public let entityId: String?
    /// <p>The identifier for the organization under which the Amazon WorkMail entity exists.</p>
    public let organizationId: String?

    public init (
        entityId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeregisterFromWorkMailInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
}

extension DeregisterFromWorkMailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DeregisterFromWorkMailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterFromWorkMailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterFromWorkMailOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterFromWorkMailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterFromWorkMailOutputResponse()"}
}

extension DeregisterFromWorkMailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterFromWorkMailOutputResponse: Equatable {

    public init() {}
}

struct DeregisterFromWorkMailOutputResponseBody: Equatable {
}

extension DeregisterFromWorkMailOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeGroupInputBodyMiddleware: Middleware {
    public let id: String = "DescribeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupOutputError>
}

extension DescribeGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupInput(groupId: \(String(describing: groupId)), organizationId: \(String(describing: organizationId)))"}
}

extension DescribeGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInput: Equatable {
    /// <p>The identifier for the group to be described.</p>
    public let groupId: String?
    /// <p>The identifier for the organization under which the group exists.</p>
    public let organizationId: String?

    public init (
        groupId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DescribeGroupInputBody: Equatable {
    public let organizationId: String?
    public let groupId: String?
}

extension DescribeGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGroupOutputResponse(disabledDate: \(String(describing: disabledDate)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), groupId: \(String(describing: groupId)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension DescribeGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.groupId = output.groupId
            self.name = output.name
            self.state = output.state
        } else {
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.groupId = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeGroupOutputResponse: Equatable {
    /// <p>The date and time when a user was deregistered from WorkMail, in UNIX epoch time
    ///          format.</p>
    public let disabledDate: Date?
    /// <p>The email of the described group.</p>
    public let email: String?
    /// <p>The date and time when a user was registered to WorkMail, in UNIX epoch time
    ///          format.</p>
    public let enabledDate: Date?
    /// <p>The identifier of the described group.</p>
    public let groupId: String?
    /// <p>The name of the described group.</p>
    public let name: String?
    /// <p>The state of the user: enabled (registered to Amazon WorkMail) or disabled (deregistered or
    ///          never registered to WorkMail).</p>
    public let state: EntityState?

    public init (
        disabledDate: Date? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        groupId: String? = nil,
        name: String? = nil,
        state: EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.groupId = groupId
        self.name = name
        self.state = state
    }
}

struct DescribeGroupOutputResponseBody: Equatable {
    public let groupId: String?
    public let name: String?
    public let email: String?
    public let state: EntityState?
    public let enabledDate: Date?
    public let disabledDate: Date?
}

extension DescribeGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case groupId = "GroupId"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

public struct DescribeMailboxExportJobInputBodyMiddleware: Middleware {
    public let id: String = "DescribeMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMailboxExportJobOutputError>
}

extension DescribeMailboxExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMailboxExportJobInput(jobId: \(String(describing: jobId)), organizationId: \(String(describing: organizationId)))"}
}

extension DescribeMailboxExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeMailboxExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInput: Equatable {
    /// <p>The mailbox export job ID.</p>
    public let jobId: String?
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        jobId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct DescribeMailboxExportJobInputBody: Equatable {
    public let jobId: String?
    public let organizationId: String?
}

extension DescribeMailboxExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeMailboxExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMailboxExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMailboxExportJobOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMailboxExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMailboxExportJobOutputResponse(description: \(String(describing: description)), endTime: \(String(describing: endTime)), entityId: \(String(describing: entityId)), errorInfo: \(String(describing: errorInfo)), estimatedProgress: \(String(describing: estimatedProgress)), kmsKeyArn: \(String(describing: kmsKeyArn)), roleArn: \(String(describing: roleArn)), s3BucketName: \(String(describing: s3BucketName)), s3Path: \(String(describing: s3Path)), s3Prefix: \(String(describing: s3Prefix)), startTime: \(String(describing: startTime)), state: \(String(describing: state)))"}
}

extension DescribeMailboxExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.endTime = output.endTime
            self.entityId = output.entityId
            self.errorInfo = output.errorInfo
            self.estimatedProgress = output.estimatedProgress
            self.kmsKeyArn = output.kmsKeyArn
            self.roleArn = output.roleArn
            self.s3BucketName = output.s3BucketName
            self.s3Path = output.s3Path
            self.s3Prefix = output.s3Prefix
            self.startTime = output.startTime
            self.state = output.state
        } else {
            self.description = nil
            self.endTime = nil
            self.entityId = nil
            self.errorInfo = nil
            self.estimatedProgress = 0
            self.kmsKeyArn = nil
            self.roleArn = nil
            self.s3BucketName = nil
            self.s3Path = nil
            self.s3Prefix = nil
            self.startTime = nil
            self.state = nil
        }
    }
}

public struct DescribeMailboxExportJobOutputResponse: Equatable {
    /// <p>The mailbox export job description.</p>
    public let description: String?
    /// <p>The mailbox export job end timestamp.</p>
    public let endTime: Date?
    /// <p>The identifier of the user or resource associated with the mailbox.</p>
    public let entityId: String?
    /// <p>Error information for failed mailbox export jobs.</p>
    public let errorInfo: String?
    /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
    public let estimatedProgress: Int
    /// <p>The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS)
    ///          key that encrypts the exported mailbox content.</p>
    public let kmsKeyArn: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple
    ///          Storage Service (Amazon S3) bucket.</p>
    public let roleArn: String?
    /// <p>The name of the S3 bucket.</p>
    public let s3BucketName: String?
    /// <p>The path to the S3 bucket and file that the mailbox export job is exporting
    ///          to.</p>
    public let s3Path: String?
    /// <p>The S3 bucket prefix.</p>
    public let s3Prefix: String?
    /// <p>The mailbox export job start timestamp.</p>
    public let startTime: Date?
    /// <p>The state of the mailbox export job.</p>
    public let state: MailboxExportJobState?

    public init (
        description: String? = nil,
        endTime: Date? = nil,
        entityId: String? = nil,
        errorInfo: String? = nil,
        estimatedProgress: Int = 0,
        kmsKeyArn: String? = nil,
        roleArn: String? = nil,
        s3BucketName: String? = nil,
        s3Path: String? = nil,
        s3Prefix: String? = nil,
        startTime: Date? = nil,
        state: MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.errorInfo = errorInfo
        self.estimatedProgress = estimatedProgress
        self.kmsKeyArn = kmsKeyArn
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.s3Prefix = s3Prefix
        self.startTime = startTime
        self.state = state
    }
}

struct DescribeMailboxExportJobOutputResponseBody: Equatable {
    public let entityId: String?
    public let description: String?
    public let roleArn: String?
    public let kmsKeyArn: String?
    public let s3BucketName: String?
    public let s3Prefix: String?
    public let s3Path: String?
    public let estimatedProgress: Int
    public let state: MailboxExportJobState?
    public let errorInfo: String?
    public let startTime: Date?
    public let endTime: Date?
}

extension DescribeMailboxExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case errorInfo = "ErrorInfo"
        case estimatedProgress = "EstimatedProgress"
        case kmsKeyArn = "KmsKeyArn"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case s3Prefix = "S3Prefix"
        case startTime = "StartTime"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decode(Int.self, forKey: .estimatedProgress)
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct DescribeOrganizationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationOutputError>
}

extension DescribeOrganizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationInput(organizationId: \(String(describing: organizationId)))"}
}

extension DescribeOrganizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeOrganizationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInput: Equatable {
    /// <p>The identifier for the organization to be described.</p>
    public let organizationId: String?

    public init (
        organizationId: String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeOrganizationInputBody: Equatable {
    public let organizationId: String?
}

extension DescribeOrganizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeOrganizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeOrganizationOutputResponse(aRN: \(String(describing: aRN)), alias: \(String(describing: alias)), completedDate: \(String(describing: completedDate)), defaultMailDomain: \(String(describing: defaultMailDomain)), directoryId: \(String(describing: directoryId)), directoryType: \(String(describing: directoryType)), errorMessage: \(String(describing: errorMessage)), organizationId: \(String(describing: organizationId)), state: \(String(describing: state)))"}
}

extension DescribeOrganizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aRN = output.aRN
            self.alias = output.alias
            self.completedDate = output.completedDate
            self.defaultMailDomain = output.defaultMailDomain
            self.directoryId = output.directoryId
            self.directoryType = output.directoryType
            self.errorMessage = output.errorMessage
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.aRN = nil
            self.alias = nil
            self.completedDate = nil
            self.defaultMailDomain = nil
            self.directoryId = nil
            self.directoryType = nil
            self.errorMessage = nil
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DescribeOrganizationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the organization.</p>
    public let aRN: String?
    /// <p>The alias for an organization.</p>
    public let alias: String?
    /// <p>The date at which the organization became usable in the WorkMail context, in UNIX epoch
    ///          time format.</p>
    public let completedDate: Date?
    /// <p>The default mail domain associated with the organization.</p>
    public let defaultMailDomain: String?
    /// <p>The identifier for the directory associated with an Amazon WorkMail organization.</p>
    public let directoryId: String?
    /// <p>The type of directory associated with the WorkMail organization.</p>
    public let directoryType: String?
    /// <p>(Optional) The error message indicating if unexpected behavior was encountered with
    ///          regards to the organization.</p>
    public let errorMessage: String?
    /// <p>The identifier of an organization.</p>
    public let organizationId: String?
    /// <p>The state of an organization.</p>
    public let state: String?

    public init (
        aRN: String? = nil,
        alias: String? = nil,
        completedDate: Date? = nil,
        defaultMailDomain: String? = nil,
        directoryId: String? = nil,
        directoryType: String? = nil,
        errorMessage: String? = nil,
        organizationId: String? = nil,
        state: String? = nil
    )
    {
        self.aRN = aRN
        self.alias = alias
        self.completedDate = completedDate
        self.defaultMailDomain = defaultMailDomain
        self.directoryId = directoryId
        self.directoryType = directoryType
        self.errorMessage = errorMessage
        self.organizationId = organizationId
        self.state = state
    }
}

struct DescribeOrganizationOutputResponseBody: Equatable {
    public let organizationId: String?
    public let alias: String?
    public let state: String?
    public let directoryId: String?
    public let directoryType: String?
    public let defaultMailDomain: String?
    public let completedDate: Date?
    public let errorMessage: String?
    public let aRN: String?
}

extension DescribeOrganizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aRN = "ARN"
        case alias = "Alias"
        case completedDate = "CompletedDate"
        case defaultMailDomain = "DefaultMailDomain"
        case directoryId = "DirectoryId"
        case directoryType = "DirectoryType"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let completedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedDate)
        completedDate = completedDateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

public struct DescribeResourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

extension DescribeResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceInput(organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension DescribeResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DescribeResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInput: Equatable {
    /// <p>The identifier associated with the organization for which the resource is
    ///          described.</p>
    public let organizationId: String?
    /// <p>The identifier of the resource to be described.</p>
    public let resourceId: String?

    public init (
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DescribeResourceInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
}

extension DescribeResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceOutputResponse(bookingOptions: \(String(describing: bookingOptions)), disabledDate: \(String(describing: disabledDate)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), name: \(String(describing: name)), resourceId: \(String(describing: resourceId)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

extension DescribeResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.bookingOptions = output.bookingOptions
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.resourceId = output.resourceId
            self.state = output.state
            self.type = output.type
        } else {
            self.bookingOptions = nil
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.resourceId = nil
            self.state = nil
            self.type = nil
        }
    }
}

public struct DescribeResourceOutputResponse: Equatable {
    /// <p>The booking options for the described resource.</p>
    public let bookingOptions: BookingOptions?
    /// <p>The date and time when a resource was disabled from WorkMail, in UNIX epoch time
    ///          format.</p>
    public let disabledDate: Date?
    /// <p>The email of the described resource.</p>
    public let email: String?
    /// <p>The date and time when a resource was enabled for WorkMail, in UNIX epoch time
    ///          format.</p>
    public let enabledDate: Date?
    /// <p>The name of the described resource.</p>
    public let name: String?
    /// <p>The identifier of the described resource.</p>
    public let resourceId: String?
    /// <p>The state of the resource: enabled (registered to Amazon WorkMail), disabled (deregistered
    ///          or never registered to WorkMail), or deleted.</p>
    public let state: EntityState?
    /// <p>The type of the described resource.</p>
    public let type: ResourceType?

    public init (
        bookingOptions: BookingOptions? = nil,
        disabledDate: Date? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        name: String? = nil,
        resourceId: String? = nil,
        state: EntityState? = nil,
        type: ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.resourceId = resourceId
        self.state = state
        self.type = type
    }
}

struct DescribeResourceOutputResponseBody: Equatable {
    public let resourceId: String?
    public let email: String?
    public let name: String?
    public let type: ResourceType?
    public let bookingOptions: BookingOptions?
    public let state: EntityState?
    public let enabledDate: Date?
    public let disabledDate: Date?
}

extension DescribeResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bookingOptions = "BookingOptions"
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case resourceId = "ResourceId"
        case state = "State"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .type)
        type = typeDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

public struct DescribeUserInputBodyMiddleware: Middleware {
    public let id: String = "DescribeUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

extension DescribeUserInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserInput(organizationId: \(String(describing: organizationId)), userId: \(String(describing: userId)))"}
}

extension DescribeUserInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DescribeUserInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeUserInput>
    public typealias MOutput = OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Equatable {
    /// <p>The identifier for the organization under which the user exists.</p>
    public let organizationId: String?
    /// <p>The identifier for the user to be described.</p>
    public let userId: String?

    public init (
        organizationId: String? = nil,
        userId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Equatable {
    public let organizationId: String?
    public let userId: String?
}

extension DescribeUserInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeUserOutputResponse(disabledDate: \(String(describing: disabledDate)), displayName: \(String(describing: displayName)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), name: \(String(describing: name)), state: \(String(describing: state)), userId: \(String(describing: userId)), userRole: \(String(describing: userRole)))"}
}

extension DescribeUserOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.disabledDate = output.disabledDate
            self.displayName = output.displayName
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.state = output.state
            self.userId = output.userId
            self.userRole = output.userRole
        } else {
            self.disabledDate = nil
            self.displayName = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.state = nil
            self.userId = nil
            self.userRole = nil
        }
    }
}

public struct DescribeUserOutputResponse: Equatable {
    /// <p>The date and time at which the user was disabled for Amazon WorkMail usage, in UNIX epoch
    ///          time format.</p>
    public let disabledDate: Date?
    /// <p>The display name of the user.</p>
    public let displayName: String?
    /// <p>The email of the user.</p>
    public let email: String?
    /// <p>The date and time at which the user was enabled for Amazon WorkMail usage, in UNIX epoch
    ///          time format.</p>
    public let enabledDate: Date?
    /// <p>The name for the user.</p>
    public let name: String?
    /// <p>The state of a user: enabled (registered to Amazon WorkMail) or disabled (deregistered or
    ///          never registered to WorkMail).</p>
    public let state: EntityState?
    /// <p>The identifier for the described user.</p>
    public let userId: String?
    /// <p>In certain cases, other entities are modeled as users. If interoperability is
    ///          enabled, resources are imported into Amazon WorkMail as users. Because different WorkMail
    ///          organizations rely on different directory types, administrators can distinguish between an
    ///          unregistered user (account is disabled and has a user role) and the directory
    ///          administrators. The values are USER, RESOURCE, and SYSTEM_USER.</p>
    public let userRole: UserRole?

    public init (
        disabledDate: Date? = nil,
        displayName: String? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        name: String? = nil,
        state: EntityState? = nil,
        userId: String? = nil,
        userRole: UserRole? = nil
    )
    {
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.state = state
        self.userId = userId
        self.userRole = userRole
    }
}

struct DescribeUserOutputResponseBody: Equatable {
    public let userId: String?
    public let name: String?
    public let email: String?
    public let displayName: String?
    public let state: EntityState?
    public let userRole: UserRole?
    public let enabledDate: Date?
    public let disabledDate: Date?
}

extension DescribeUserOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case state = "State"
        case userId = "UserId"
        case userRole = "UserRole"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension DirectoryInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryInUseException(message: \(String(describing: message)))"}
}

extension DirectoryInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The directory is already in use by another WorkMail organization in the same account and Region.</p>
public struct DirectoryInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryInUseExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryServiceAuthenticationFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryServiceAuthenticationFailedException(message: \(String(describing: message)))"}
}

extension DirectoryServiceAuthenticationFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryServiceAuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The directory service doesn't recognize the credentials supplied by WorkMail.</p>
public struct DirectoryServiceAuthenticationFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryServiceAuthenticationFailedExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryServiceAuthenticationFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectoryUnavailableException(message: \(String(describing: message)))"}
}

extension DirectoryUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The directory is unavailable. It might be located in another Region or deleted.</p>
public struct DirectoryUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension DirectoryUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DisassociateDelegateFromResourceInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateDelegateFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDelegateFromResourceOutputError>
}

extension DisassociateDelegateFromResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDelegateFromResourceInput(entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension DisassociateDelegateFromResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DisassociateDelegateFromResourceInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateDelegateFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateDelegateFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInput: Equatable {
    /// <p>The identifier for the member (user, group) to be removed from the resource's
    ///          delegates.</p>
    public let entityId: String?
    /// <p>The identifier for the organization under which the resource exists.</p>
    public let organizationId: String?
    /// <p>The identifier of the resource from which delegates' set members are removed.
    ///       </p>
    public let resourceId: String?

    public init (
        entityId: String? = nil,
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DisassociateDelegateFromResourceInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
    public let entityId: String?
}

extension DisassociateDelegateFromResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DisassociateDelegateFromResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDelegateFromResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDelegateFromResourceOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDelegateFromResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateDelegateFromResourceOutputResponse()"}
}

extension DisassociateDelegateFromResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDelegateFromResourceOutputResponse: Equatable {

    public init() {}
}

struct DisassociateDelegateFromResourceOutputResponseBody: Equatable {
}

extension DisassociateDelegateFromResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateMemberFromGroupInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateMemberFromGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberFromGroupOutputError>
}

extension DisassociateMemberFromGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberFromGroupInput(groupId: \(String(describing: groupId)), memberId: \(String(describing: memberId)), organizationId: \(String(describing: organizationId)))"}
}

extension DisassociateMemberFromGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DisassociateMemberFromGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateMemberFromGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateMemberFromGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInput: Equatable {
    /// <p>The identifier for the group from which members are removed.</p>
    public let groupId: String?
    /// <p>The identifier for the member to be removed to the group.</p>
    public let memberId: String?
    /// <p>The identifier for the organization under which the group exists.</p>
    public let organizationId: String?

    public init (
        groupId: String? = nil,
        memberId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct DisassociateMemberFromGroupInputBody: Equatable {
    public let organizationId: String?
    public let groupId: String?
    public let memberId: String?
}

extension DisassociateMemberFromGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension DisassociateMemberFromGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberFromGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberFromGroupOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberFromGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateMemberFromGroupOutputResponse()"}
}

extension DisassociateMemberFromGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberFromGroupOutputResponse: Equatable {

    public init() {}
}

struct DisassociateMemberFromGroupOutputResponseBody: Equatable {
}

extension DisassociateMemberFromGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Domain: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case domainName = "DomainName"
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension Domain: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Domain(domainName: \(String(describing: domainName)), hostedZoneId: \(String(describing: hostedZoneId)))"}
}

/// <p>The domain to associate with an Amazon WorkMail organization.</p>
///          <p>When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html">Adding a domain</a> in the <i>Amazon WorkMail Administrator Guide</i>.</p>
public struct Domain: Equatable {
    /// <p>The fully qualified domain name.</p>
    public let domainName: String?
    /// <p>The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.</p>
    public let hostedZoneId: String?

    public init (
        domainName: String? = nil,
        hostedZoneId: String? = nil
    )
    {
        self.domainName = domainName
        self.hostedZoneId = hostedZoneId
    }
}

extension EmailAddressInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailAddressInUseException(message: \(String(describing: message)))"}
}

extension EmailAddressInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EmailAddressInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The email address that you're trying to assign is already created for a different
///          user, group, or resource.</p>
public struct EmailAddressInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EmailAddressInUseExceptionBody: Equatable {
    public let message: String?
}

extension EmailAddressInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyRegisteredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityAlreadyRegisteredException(message: \(String(describing: message)))"}
}

extension EntityAlreadyRegisteredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user, group, or resource that you're trying to register is already
///          registered.</p>
public struct EntityAlreadyRegisteredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyRegisteredExceptionBody: Equatable {
    public let message: String?
}

extension EntityAlreadyRegisteredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityNotFoundException(message: \(String(describing: message)))"}
}

extension EntityNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The identifier supplied for the user, group, or resource does not exist in your
///          organization.</p>
public struct EntityNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension EntityNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EntityState {
    case deleted
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension EntityState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EntityState] {
        return [
            .deleted,
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleted: return "DELETED"
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EntityState(rawValue: rawValue) ?? EntityState.sdkUnknown(rawValue)
    }
}

extension EntityStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EntityStateException(message: \(String(describing: message)))"}
}

extension EntityStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EntityStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are performing an operation on a user, group, or resource that isn't in the
///          expected state, such as trying to delete an active user.</p>
public struct EntityStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct EntityStateExceptionBody: Equatable {
    public let message: String?
}

extension EntityStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FolderConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case name = "Name"
        case period = "Period"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let period = period {
            try encodeContainer.encode(period, forKey: .period)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(FolderName.self, forKey: .name)
        name = nameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(RetentionAction.self, forKey: .action)
        action = actionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension FolderConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FolderConfiguration(action: \(String(describing: action)), name: \(String(describing: name)), period: \(String(describing: period)))"}
}

/// <p>The configuration applied to an organization's folders by its retention
///          policy.</p>
public struct FolderConfiguration: Equatable {
    /// <p>The action to take on the folder contents at the end of the folder configuration
    ///          period.</p>
    public let action: RetentionAction?
    /// <p>The folder name.</p>
    public let name: FolderName?
    /// <p>The period of time at which the folder configuration action is applied.</p>
    public let period: Int?

    public init (
        action: RetentionAction? = nil,
        name: FolderName? = nil,
        period: Int? = nil
    )
    {
        self.action = action
        self.name = name
        self.period = period
    }
}

public enum FolderName {
    case deletedItems
    case drafts
    case inbox
    case junkEmail
    case sentItems
    case sdkUnknown(String)
}

extension FolderName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FolderName] {
        return [
            .deletedItems,
            .drafts,
            .inbox,
            .junkEmail,
            .sentItems,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deletedItems: return "DELETED_ITEMS"
        case .drafts: return "DRAFTS"
        case .inbox: return "INBOX"
        case .junkEmail: return "JUNK_EMAIL"
        case .sentItems: return "SENT_ITEMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FolderName(rawValue: rawValue) ?? FolderName.sdkUnknown(rawValue)
    }
}

public struct GetAccessControlEffectInputBodyMiddleware: Middleware {
    public let id: String = "GetAccessControlEffectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessControlEffectOutputError>
}

extension GetAccessControlEffectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessControlEffectInput(action: \(String(describing: action)), ipAddress: \(String(describing: ipAddress)), organizationId: \(String(describing: organizationId)), userId: \(String(describing: userId)))"}
}

extension GetAccessControlEffectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetAccessControlEffectInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessControlEffectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessControlEffectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInput: Equatable {
    /// <p>The access protocol action. Valid values include <code>ActiveSync</code>,
    ///             <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>, <code>SMTP</code>,
    ///             <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    public let action: String?
    /// <p>The IPv4 address.</p>
    public let ipAddress: String?
    /// <p>The identifier for the organization.</p>
    public let organizationId: String?
    /// <p>The user ID.</p>
    public let userId: String?

    public init (
        action: String? = nil,
        ipAddress: String? = nil,
        organizationId: String? = nil,
        userId: String? = nil
    )
    {
        self.action = action
        self.ipAddress = ipAddress
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetAccessControlEffectInputBody: Equatable {
    public let organizationId: String?
    public let ipAddress: String?
    public let action: String?
    public let userId: String?
}

extension GetAccessControlEffectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetAccessControlEffectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessControlEffectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessControlEffectOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessControlEffectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessControlEffectOutputResponse(effect: \(String(describing: effect)), matchedRules: \(String(describing: matchedRules)))"}
}

extension GetAccessControlEffectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessControlEffectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetAccessControlEffectOutputResponse: Equatable {
    /// <p>The rule effect.</p>
    public let effect: AccessControlRuleEffect?
    /// <p>The rules that match the given parameters, resulting in an effect.</p>
    public let matchedRules: [String]?

    public init (
        effect: AccessControlRuleEffect? = nil,
        matchedRules: [String]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetAccessControlEffectOutputResponseBody: Equatable {
    public let effect: AccessControlRuleEffect?
    public let matchedRules: [String]?
}

extension GetAccessControlEffectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[String]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [String]()
            for string0 in matchedRulesContainer {
                if let string0 = string0 {
                    matchedRulesDecoded0?.append(string0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

public struct GetDefaultRetentionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "GetDefaultRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultRetentionPolicyOutputError>
}

extension GetDefaultRetentionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDefaultRetentionPolicyInput(organizationId: \(String(describing: organizationId)))"}
}

extension GetDefaultRetentionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct GetDefaultRetentionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetDefaultRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDefaultRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInput: Equatable {
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        organizationId: String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct GetDefaultRetentionPolicyInputBody: Equatable {
    public let organizationId: String?
}

extension GetDefaultRetentionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetDefaultRetentionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultRetentionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDefaultRetentionPolicyOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultRetentionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDefaultRetentionPolicyOutputResponse(description: \(String(describing: description)), folderConfigurations: \(String(describing: folderConfigurations)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

extension GetDefaultRetentionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDefaultRetentionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.folderConfigurations = output.folderConfigurations
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.folderConfigurations = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetDefaultRetentionPolicyOutputResponse: Equatable {
    /// <p>The retention policy description.</p>
    public let description: String?
    /// <p>The retention policy folder configurations.</p>
    public let folderConfigurations: [FolderConfiguration]?
    /// <p>The retention policy ID.</p>
    public let id: String?
    /// <p>The retention policy name.</p>
    public let name: String?

    public init (
        description: String? = nil,
        folderConfigurations: [FolderConfiguration]? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
    }
}

struct GetDefaultRetentionPolicyOutputResponseBody: Equatable {
    public let id: String?
    public let name: String?
    public let description: String?
    public let folderConfigurations: [FolderConfiguration]?
}

extension GetDefaultRetentionPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

public struct GetMailboxDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetMailboxDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMailboxDetailsOutputError>
}

extension GetMailboxDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMailboxDetailsInput(organizationId: \(String(describing: organizationId)), userId: \(String(describing: userId)))"}
}

extension GetMailboxDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetMailboxDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetMailboxDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMailboxDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInput: Equatable {
    /// <p>The identifier for the organization that contains the user whose mailbox details are
    ///          being requested.</p>
    public let organizationId: String?
    /// <p>The identifier for the user whose mailbox details are being requested.</p>
    public let userId: String?

    public init (
        organizationId: String? = nil,
        userId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMailboxDetailsInputBody: Equatable {
    public let organizationId: String?
    public let userId: String?
}

extension GetMailboxDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetMailboxDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMailboxDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMailboxDetailsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMailboxDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMailboxDetailsOutputResponse(mailboxQuota: \(String(describing: mailboxQuota)), mailboxSize: \(String(describing: mailboxSize)))"}
}

extension GetMailboxDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMailboxDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.mailboxQuota = output.mailboxQuota
            self.mailboxSize = output.mailboxSize
        } else {
            self.mailboxQuota = nil
            self.mailboxSize = 0.0
        }
    }
}

public struct GetMailboxDetailsOutputResponse: Equatable {
    /// <p>The maximum allowed mailbox size, in MB, for the specified user.</p>
    public let mailboxQuota: Int?
    /// <p>The current mailbox size, in MB, for the specified user.</p>
    public let mailboxSize: Double

    public init (
        mailboxQuota: Int? = nil,
        mailboxSize: Double = 0.0
    )
    {
        self.mailboxQuota = mailboxQuota
        self.mailboxSize = mailboxSize
    }
}

struct GetMailboxDetailsOutputResponseBody: Equatable {
    public let mailboxQuota: Int?
    public let mailboxSize: Double
}

extension GetMailboxDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mailboxQuota = "MailboxQuota"
        case mailboxSize = "MailboxSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
        let mailboxSizeDecoded = try containerValues.decode(Double.self, forKey: .mailboxSize)
        mailboxSize = mailboxSizeDecoded
    }
}

public struct GetMobileDeviceAccessEffectInputBodyMiddleware: Middleware {
    public let id: String = "GetMobileDeviceAccessEffectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMobileDeviceAccessEffectOutputError>
}

extension GetMobileDeviceAccessEffectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMobileDeviceAccessEffectInput(deviceModel: \(String(describing: deviceModel)), deviceOperatingSystem: \(String(describing: deviceOperatingSystem)), deviceType: \(String(describing: deviceType)), deviceUserAgent: \(String(describing: deviceUserAgent)), organizationId: \(String(describing: organizationId)))"}
}

extension GetMobileDeviceAccessEffectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceModel = deviceModel {
            try encodeContainer.encode(deviceModel, forKey: .deviceModel)
        }
        if let deviceOperatingSystem = deviceOperatingSystem {
            try encodeContainer.encode(deviceOperatingSystem, forKey: .deviceOperatingSystem)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let deviceUserAgent = deviceUserAgent {
            try encodeContainer.encode(deviceUserAgent, forKey: .deviceUserAgent)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct GetMobileDeviceAccessEffectInputHeadersMiddleware: Middleware {
    public let id: String = "GetMobileDeviceAccessEffectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInputQueryItemMiddleware: Middleware {
    public let id: String = "GetMobileDeviceAccessEffectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInput: Equatable {
    /// <p>Device model the simulated user will report.</p>
    public let deviceModel: String?
    /// <p>Device operating system the simulated user will report.</p>
    public let deviceOperatingSystem: String?
    /// <p>Device type the simulated user will report.</p>
    public let deviceType: String?
    /// <p>Device user agent the simulated user will report.</p>
    public let deviceUserAgent: String?
    /// <p>The Amazon WorkMail organization to simulate the access effect for.</p>
    public let organizationId: String?

    public init (
        deviceModel: String? = nil,
        deviceOperatingSystem: String? = nil,
        deviceType: String? = nil,
        deviceUserAgent: String? = nil,
        organizationId: String? = nil
    )
    {
        self.deviceModel = deviceModel
        self.deviceOperatingSystem = deviceOperatingSystem
        self.deviceType = deviceType
        self.deviceUserAgent = deviceUserAgent
        self.organizationId = organizationId
    }
}

struct GetMobileDeviceAccessEffectInputBody: Equatable {
    public let organizationId: String?
    public let deviceType: String?
    public let deviceModel: String?
    public let deviceOperatingSystem: String?
    public let deviceUserAgent: String?
}

extension GetMobileDeviceAccessEffectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceModel)
        deviceModel = deviceModelDecoded
        let deviceOperatingSystemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceOperatingSystem)
        deviceOperatingSystem = deviceOperatingSystemDecoded
        let deviceUserAgentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceUserAgent)
        deviceUserAgent = deviceUserAgentDecoded
    }
}

extension GetMobileDeviceAccessEffectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMobileDeviceAccessEffectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMobileDeviceAccessEffectOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMobileDeviceAccessEffectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetMobileDeviceAccessEffectOutputResponse(effect: \(String(describing: effect)), matchedRules: \(String(describing: matchedRules)))"}
}

extension GetMobileDeviceAccessEffectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetMobileDeviceAccessEffectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetMobileDeviceAccessEffectOutputResponse: Equatable {
    /// <p>The effect of the simulated access, <code>ALLOW</code> or <code>DENY</code>, after evaluating mobile device access rules in the Amazon WorkMail organization for the simulated
    ///          user parameters.</p>
    public let effect: MobileDeviceAccessRuleEffect?
    /// <p>A list of the rules which matched the simulated user input and produced the effect.</p>
    public let matchedRules: [MobileDeviceAccessMatchedRule]?

    public init (
        effect: MobileDeviceAccessRuleEffect? = nil,
        matchedRules: [MobileDeviceAccessMatchedRule]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetMobileDeviceAccessEffectOutputResponseBody: Equatable {
    public let effect: MobileDeviceAccessRuleEffect?
    public let matchedRules: [MobileDeviceAccessMatchedRule]?
}

extension GetMobileDeviceAccessEffectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([MobileDeviceAccessMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[MobileDeviceAccessMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [MobileDeviceAccessMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(disabledDate: \(String(describing: disabledDate)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), id: \(String(describing: id)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>The representation of an Amazon WorkMail group.</p>
public struct Group: Equatable {
    /// <p>The date indicating when the group was disabled from Amazon WorkMail use.</p>
    public let disabledDate: Date?
    /// <p>The email of the group.</p>
    public let email: String?
    /// <p>The date indicating when the group was enabled for Amazon WorkMail use.</p>
    public let enabledDate: Date?
    /// <p>The identifier of the group.</p>
    public let id: String?
    /// <p>The name of the group.</p>
    public let name: String?
    /// <p>The state of the group, which can be ENABLED, DISABLED, or DELETED.</p>
    public let state: EntityState?

    public init (
        disabledDate: Date? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        state: EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.id = id
        self.name = name
        self.state = state
    }
}

extension InvalidConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The configuration for a resource isn't valid. A resource must either be able to
///          auto-respond to requests or have at least one delegate associated that can do so on its
///          behalf.</p>
public struct InvalidConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the input parameters don't match the service's restrictions.</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidPasswordException(message: \(String(describing: message)))"}
}

extension InvalidPasswordException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The supplied password doesn't match the minimum security constraints, such as length
///          or use of special characters.</p>
public struct InvalidPasswordException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Equatable {
    public let message: String?
}

extension InvalidPasswordExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeds the limit of the resource.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccessControlRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListAccessControlRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessControlRulesOutputError>
}

extension ListAccessControlRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessControlRulesInput(organizationId: \(String(describing: organizationId)))"}
}

extension ListAccessControlRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListAccessControlRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessControlRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessControlRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInput: Equatable {
    /// <p>The identifier for the organization.</p>
    public let organizationId: String?

    public init (
        organizationId: String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListAccessControlRulesInputBody: Equatable {
    public let organizationId: String?
}

extension ListAccessControlRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListAccessControlRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessControlRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessControlRulesOutputError: Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessControlRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessControlRulesOutputResponse(rules: \(String(describing: rules)))"}
}

extension ListAccessControlRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessControlRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListAccessControlRulesOutputResponse: Equatable {
    /// <p>The access control rules.</p>
    public let rules: [AccessControlRule]?

    public init (
        rules: [AccessControlRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListAccessControlRulesOutputResponseBody: Equatable {
    public let rules: [AccessControlRule]?
}

extension ListAccessControlRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([AccessControlRule?].self, forKey: .rules)
        var rulesDecoded0:[AccessControlRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [AccessControlRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListAliasesInputBodyMiddleware: Middleware {
    public let id: String = "ListAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

extension ListAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesInput(entityId: \(String(describing: entityId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListAliasesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInput: Equatable {
    /// <p>The identifier for the entity for which to list the aliases.</p>
    public let entityId: String?
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization under which the entity exists.</p>
    public let organizationId: String?

    public init (
        entityId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAliasesInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAliasesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesOutputResponse(aliases: \(String(describing: aliases)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

public struct ListAliasesOutputResponse: Equatable {
    /// <p>The entity's paginated aliases.</p>
    public let aliases: [String]?
    /// <p>The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.</p>
    public let nextToken: String?

    public init (
        aliases: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct ListAliasesOutputResponseBody: Equatable {
    public let aliases: [String]?
    public let nextToken: String?
}

extension ListAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .aliases)
        var aliasesDecoded0:[String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGroupMembersInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupMembersOutputError>
}

extension ListGroupMembersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupMembersInput(groupId: \(String(describing: groupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListGroupMembersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListGroupMembersInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInput: Equatable {
    /// <p>The identifier for the group to which the members (users or groups) are
    ///          associated.</p>
    public let groupId: String?
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p> The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization under which the group exists.</p>
    public let organizationId: String?

    public init (
        groupId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupMembersInputBody: Equatable {
    public let organizationId: String?
    public let groupId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListGroupMembersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupMembersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupMembersOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupMembersOutputResponse(members: \(String(describing: members)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupMembersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupMembersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembersOutputResponse: Equatable {
    /// <p>The members associated to the group.</p>
    public let members: [Member]?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?

    public init (
        members: [Member]? = nil,
        nextToken: String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListGroupMembersOutputResponseBody: Equatable {
    public let members: [Member]?
    public let nextToken: String?
}

extension ListGroupMembersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([Member?].self, forKey: .members)
        var membersDecoded0:[Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGroupsInputBodyMiddleware: Middleware {
    public let id: String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGroupsInput>
    public typealias MOutput = OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization under which the groups exist.</p>
    public let organizationId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupsInputBody: Equatable {
    public let organizationId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGroupsOutputResponse(groups: \(String(describing: groups)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Equatable {
    /// <p>The overview of groups for an organization.</p>
    public let groups: [Group]?
    /// <p>The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.</p>
    public let nextToken: String?

    public init (
        groups: [Group]? = nil,
        nextToken: String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Equatable {
    public let groups: [Group]?
    public let nextToken: String?
}

extension ListGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([Group?].self, forKey: .groups)
        var groupsDecoded0:[Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMailboxExportJobsInputBodyMiddleware: Middleware {
    public let id: String = "ListMailboxExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxExportJobsOutputError>
}

extension ListMailboxExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMailboxExportJobsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListMailboxExportJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMailboxExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMailboxExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMailboxExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results.</p>
    public let nextToken: String?
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxExportJobsInputBody: Equatable {
    public let organizationId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListMailboxExportJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMailboxExportJobsOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMailboxExportJobsOutputResponse(jobs: \(String(describing: jobs)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMailboxExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMailboxExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailboxExportJobsOutputResponse: Equatable {
    /// <p>The mailbox export job details.</p>
    public let jobs: [MailboxExportJob]?
    /// <p>The token to use to retrieve the next page of results.</p>
    public let nextToken: String?

    public init (
        jobs: [MailboxExportJob]? = nil,
        nextToken: String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMailboxExportJobsOutputResponseBody: Equatable {
    public let jobs: [MailboxExportJob]?
    public let nextToken: String?
}

extension ListMailboxExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([MailboxExportJob?].self, forKey: .jobs)
        var jobsDecoded0:[MailboxExportJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [MailboxExportJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMailboxPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "ListMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxPermissionsOutputError>
}

extension ListMailboxPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMailboxPermissionsInput(entityId: \(String(describing: entityId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListMailboxPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMailboxPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInput: Equatable {
    /// <p>The identifier of the user, group, or resource for which to list mailbox
    ///          permissions.</p>
    public let entityId: String?
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier of the organization under which the user, group, or resource
    ///          exists.</p>
    public let organizationId: String?

    public init (
        entityId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxPermissionsInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListMailboxPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMailboxPermissionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMailboxPermissionsOutputResponse(nextToken: \(String(describing: nextToken)), permissions: \(String(describing: permissions)))"}
}

extension ListMailboxPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMailboxPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListMailboxPermissionsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.</p>
    public let nextToken: String?
    /// <p>One page of the user, group, or resource mailbox permissions.</p>
    public let permissions: [Permission]?

    public init (
        nextToken: String? = nil,
        permissions: [Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListMailboxPermissionsOutputResponseBody: Equatable {
    public let permissions: [Permission]?
    public let nextToken: String?
}

extension ListMailboxPermissionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMobileDeviceAccessRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListMobileDeviceAccessRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMobileDeviceAccessRulesOutputError>
}

extension ListMobileDeviceAccessRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMobileDeviceAccessRulesInput(organizationId: \(String(describing: organizationId)))"}
}

extension ListMobileDeviceAccessRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMobileDeviceAccessRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListMobileDeviceAccessRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMobileDeviceAccessRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInput: Equatable {
    /// <p>The Amazon WorkMail organization for which to list the rules.</p>
    public let organizationId: String?

    public init (
        organizationId: String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListMobileDeviceAccessRulesInputBody: Equatable {
    public let organizationId: String?
}

extension ListMobileDeviceAccessRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListMobileDeviceAccessRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMobileDeviceAccessRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMobileDeviceAccessRulesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMobileDeviceAccessRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMobileDeviceAccessRulesOutputResponse(rules: \(String(describing: rules)))"}
}

extension ListMobileDeviceAccessRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMobileDeviceAccessRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListMobileDeviceAccessRulesOutputResponse: Equatable {
    /// <p>The list of mobile device access rules that exist under the specified Amazon WorkMail organization.</p>
    public let rules: [MobileDeviceAccessRule]?

    public init (
        rules: [MobileDeviceAccessRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListMobileDeviceAccessRulesOutputResponseBody: Equatable {
    public let rules: [MobileDeviceAccessRule]?
}

extension ListMobileDeviceAccessRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([MobileDeviceAccessRule?].self, forKey: .rules)
        var rulesDecoded0:[MobileDeviceAccessRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [MobileDeviceAccessRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListOrganizationsInputBodyMiddleware: Middleware {
    public let id: String = "ListOrganizationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationsOutputError>
}

extension ListOrganizationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListOrganizationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOrganizationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListOrganizationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListOrganizationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationsInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListOrganizationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOrganizationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationsOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListOrganizationsOutputResponse(nextToken: \(String(describing: nextToken)), organizationSummaries: \(String(describing: organizationSummaries)))"}
}

extension ListOrganizationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListOrganizationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.organizationSummaries = output.organizationSummaries
        } else {
            self.nextToken = nil
            self.organizationSummaries = nil
        }
    }
}

public struct ListOrganizationsOutputResponse: Equatable {
    /// <p>The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.</p>
    public let nextToken: String?
    /// <p>The overview of owned organizations presented as a list of organization
    ///          summaries.</p>
    public let organizationSummaries: [OrganizationSummary]?

    public init (
        nextToken: String? = nil,
        organizationSummaries: [OrganizationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationSummaries = organizationSummaries
    }
}

struct ListOrganizationsOutputResponseBody: Equatable {
    public let organizationSummaries: [OrganizationSummary]?
    public let nextToken: String?
}

extension ListOrganizationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case organizationSummaries = "OrganizationSummaries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSummariesContainer = try containerValues.decodeIfPresent([OrganizationSummary?].self, forKey: .organizationSummaries)
        var organizationSummariesDecoded0:[OrganizationSummary]? = nil
        if let organizationSummariesContainer = organizationSummariesContainer {
            organizationSummariesDecoded0 = [OrganizationSummary]()
            for structure0 in organizationSummariesContainer {
                if let structure0 = structure0 {
                    organizationSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationSummaries = organizationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceDelegatesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourceDelegatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDelegatesOutputError>
}

extension ListResourceDelegatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDelegatesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension ListResourceDelegatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListResourceDelegatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourceDelegatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourceDelegatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInput: Equatable {
    /// <p>The number of maximum results in a page.</p>
    public let maxResults: Int?
    /// <p>The token used to paginate through the delegates associated with a
    ///          resource.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization that contains the resource for which delegates
    ///          are listed.</p>
    public let organizationId: String?
    /// <p>The identifier for the resource whose delegates are listed.</p>
    public let resourceId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct ListResourceDelegatesInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourceDelegatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDelegatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDelegatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDelegatesOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDelegatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourceDelegatesOutputResponse(delegates: \(String(describing: delegates)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResourceDelegatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourceDelegatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.delegates = output.delegates
            self.nextToken = output.nextToken
        } else {
            self.delegates = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDelegatesOutputResponse: Equatable {
    /// <p>One page of the resource's delegates.</p>
    public let delegates: [Delegate]?
    /// <p>The token used to paginate through the delegates associated with a resource. While
    ///          results are still available, it has an associated value. When the last page is reached, the
    ///          token is empty. </p>
    public let nextToken: String?

    public init (
        delegates: [Delegate]? = nil,
        nextToken: String? = nil
    )
    {
        self.delegates = delegates
        self.nextToken = nextToken
    }
}

struct ListResourceDelegatesOutputResponseBody: Equatable {
    public let delegates: [Delegate]?
    public let nextToken: String?
}

extension ListResourceDelegatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delegates = "Delegates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatesContainer = try containerValues.decodeIfPresent([Delegate?].self, forKey: .delegates)
        var delegatesDecoded0:[Delegate]? = nil
        if let delegatesContainer = delegatesContainer {
            delegatesDecoded0 = [Delegate]()
            for structure0 in delegatesContainer {
                if let structure0 = structure0 {
                    delegatesDecoded0?.append(structure0)
                }
            }
        }
        delegates = delegatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResourcesInput>
    public typealias MOutput = OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization under which the resources exist.</p>
    public let organizationId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListResourcesInputBody: Equatable {
    public let organizationId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResourcesOutputResponse(nextToken: \(String(describing: nextToken)), resources: \(String(describing: resources)))"}
}

extension ListResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Equatable {
    /// <p> The token used to paginate through all the organization's resources. While results
    ///          are still available, it has an associated value. When the last page is reached, the token
    ///          is empty.</p>
    public let nextToken: String?
    /// <p>One page of the organization's resource representation.</p>
    public let resources: [Resource]?

    public init (
        nextToken: String? = nil,
        resources: [Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Equatable {
    public let resources: [Resource]?
    public let nextToken: String?
}

extension ListResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case resources = "Resources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resources)
        var resourcesDecoded0:[Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tag key-value pairs.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListUsersInputBodyMiddleware: Middleware {
    public let id: String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

extension ListUsersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), organizationId: \(String(describing: organizationId)))"}
}

extension ListUsersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: Middleware {
    public let id: String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListUsersInput>
    public typealias MOutput = OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.</p>
    public let nextToken: String?
    /// <p>The identifier for the organization under which the users exist.</p>
    public let organizationId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        organizationId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListUsersInputBody: Equatable {
    public let organizationId: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListUsersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUsersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListUsersOutputResponse(nextToken: \(String(describing: nextToken)), users: \(String(describing: users)))"}
}

extension ListUsersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Equatable {
    /// <p> The token to use to retrieve the next page of results. This value is `null` when
    ///          there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The overview of users for an organization.</p>
    public let users: [User]?

    public init (
        nextToken: String? = nil,
        users: [User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Equatable {
    public let users: [User]?
    public let nextToken: String?
}

extension ListUsersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([User?].self, forKey: .users)
        var usersDecoded0:[User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MailDomainNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailDomainNotFoundException(message: \(String(describing: message)))"}
}

extension MailDomainNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MailDomainNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>For an email or alias to be created in Amazon WorkMail, the included domain must be defined
///          in the organization.</p>
public struct MailDomainNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension MailDomainNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailDomainStateException(message: \(String(describing: message)))"}
}

extension MailDomainStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MailDomainStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>After a domain has been added to the organization, it must be verified. The domain is
///          not yet verified.</p>
public struct MailDomainStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainStateExceptionBody: Equatable {
    public let message: String?
}

extension MailDomainStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailboxExportJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case estimatedProgress = "EstimatedProgress"
        case jobId = "JobId"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case startTime = "StartTime"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if estimatedProgress != 0 {
            try encodeContainer.encode(estimatedProgress, forKey: .estimatedProgress)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decode(Int.self, forKey: .estimatedProgress)
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension MailboxExportJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MailboxExportJob(description: \(String(describing: description)), endTime: \(String(describing: endTime)), entityId: \(String(describing: entityId)), estimatedProgress: \(String(describing: estimatedProgress)), jobId: \(String(describing: jobId)), s3BucketName: \(String(describing: s3BucketName)), s3Path: \(String(describing: s3Path)), startTime: \(String(describing: startTime)), state: \(String(describing: state)))"}
}

/// <p>The details of a mailbox export job, including the user or resource ID associated
///          with the mailbox and the S3 bucket that the mailbox contents are exported to.</p>
public struct MailboxExportJob: Equatable {
    /// <p>The mailbox export job description.</p>
    public let description: String?
    /// <p>The mailbox export job end timestamp.</p>
    public let endTime: Date?
    /// <p>The identifier of the user or resource associated with the mailbox.</p>
    public let entityId: String?
    /// <p>The estimated progress of the mailbox export job, in percentage points.</p>
    public let estimatedProgress: Int
    /// <p>The identifier of the mailbox export job.</p>
    public let jobId: String?
    /// <p>The name of the S3 bucket.</p>
    public let s3BucketName: String?
    /// <p>The path to the S3 bucket and file that the mailbox export job exports to.</p>
    public let s3Path: String?
    /// <p>The mailbox export job start timestamp.</p>
    public let startTime: Date?
    /// <p>The state of the mailbox export job.</p>
    public let state: MailboxExportJobState?

    public init (
        description: String? = nil,
        endTime: Date? = nil,
        entityId: String? = nil,
        estimatedProgress: Int = 0,
        jobId: String? = nil,
        s3BucketName: String? = nil,
        s3Path: String? = nil,
        startTime: Date? = nil,
        state: MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.estimatedProgress = estimatedProgress
        self.jobId = jobId
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.startTime = startTime
        self.state = state
    }
}

public enum MailboxExportJobState {
    case cancelled
    case completed
    case failed
    case running
    case sdkUnknown(String)
}

extension MailboxExportJobState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MailboxExportJobState] {
        return [
            .cancelled,
            .completed,
            .failed,
            .running,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MailboxExportJobState(rawValue: rawValue) ?? MailboxExportJobState.sdkUnknown(rawValue)
    }
}

extension Member: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MemberType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension Member: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Member(disabledDate: \(String(describing: disabledDate)), enabledDate: \(String(describing: enabledDate)), id: \(String(describing: id)), name: \(String(describing: name)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

/// <p>The representation of a user or group.</p>
public struct Member: Equatable {
    /// <p>The date indicating when the member was disabled from Amazon WorkMail use.</p>
    public let disabledDate: Date?
    /// <p>The date indicating when the member was enabled for Amazon WorkMail use.</p>
    public let enabledDate: Date?
    /// <p>The identifier of the member.</p>
    public let id: String?
    /// <p>The name of the member.</p>
    public let name: String?
    /// <p>The state of the member, which can be ENABLED, DISABLED, or DELETED.</p>
    public let state: EntityState?
    /// <p>A member can be a user or group.</p>
    public let type: MemberType?

    public init (
        disabledDate: Date? = nil,
        enabledDate: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        state: EntityState? = nil,
        type: MemberType? = nil
    )
    {
        self.disabledDate = disabledDate
        self.enabledDate = enabledDate
        self.id = id
        self.name = name
        self.state = state
        self.type = type
    }
}

public enum MemberType {
    case group
    case user
    case sdkUnknown(String)
}

extension MemberType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MemberType] {
        return [
            .group,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .group: return "GROUP"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
    }
}

extension MobileDeviceAccessMatchedRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension MobileDeviceAccessMatchedRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MobileDeviceAccessMatchedRule(mobileDeviceAccessRuleId: \(String(describing: mobileDeviceAccessRuleId)), name: \(String(describing: name)))"}
}

/// <p>The rule that a simulated user matches.</p>
public struct MobileDeviceAccessMatchedRule: Equatable {
    /// <p>Identifier of the rule that a simulated user matches.</p>
    public let mobileDeviceAccessRuleId: String?
    /// <p>Name of a rule that a simulated user matches.</p>
    public let name: String?

    public init (
        mobileDeviceAccessRuleId: String? = nil,
        name: String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
    }
}

extension MobileDeviceAccessRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension MobileDeviceAccessRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MobileDeviceAccessRule(dateCreated: \(String(describing: dateCreated)), dateModified: \(String(describing: dateModified)), description: \(String(describing: description)), deviceModels: \(String(describing: deviceModels)), deviceOperatingSystems: \(String(describing: deviceOperatingSystems)), deviceTypes: \(String(describing: deviceTypes)), deviceUserAgents: \(String(describing: deviceUserAgents)), effect: \(String(describing: effect)), mobileDeviceAccessRuleId: \(String(describing: mobileDeviceAccessRuleId)), name: \(String(describing: name)), notDeviceModels: \(String(describing: notDeviceModels)), notDeviceOperatingSystems: \(String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(String(describing: notDeviceTypes)), notDeviceUserAgents: \(String(describing: notDeviceUserAgents)))"}
}

/// <p>A rule that controls access to mobile devices for an Amazon WorkMail group.</p>
public struct MobileDeviceAccessRule: Equatable {
    /// <p>The date and time at which an access rule was created.</p>
    public let dateCreated: Date?
    /// <p>The date and time at which an access rule was modified.</p>
    public let dateModified: Date?
    /// <p>The description of a mobile access rule.</p>
    public let description: String?
    /// <p>Device models that a rule will match.</p>
    public let deviceModels: [String]?
    /// <p>Device operating systems that a rule will match.</p>
    public let deviceOperatingSystems: [String]?
    /// <p>Device types that a rule will match. </p>
    public let deviceTypes: [String]?
    /// <p>Device user agents that a rule will match.</p>
    public let deviceUserAgents: [String]?
    /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
    public let effect: MobileDeviceAccessRuleEffect?
    /// <p>The ID assigned to a mobile access rule. </p>
    public let mobileDeviceAccessRuleId: String?
    /// <p>The name of a mobile access rule.</p>
    public let name: String?
    /// <p>Device models that a rule <b>will not</b> match. All other device models will match.</p>
    public let notDeviceModels: [String]?
    /// <p>Device operating systems that a rule <b>will not</b> match. All other device types will match.</p>
    public let notDeviceOperatingSystems: [String]?
    /// <p>Device types that a rule <b>will not</b> match. All other device types will match.</p>
    public let notDeviceTypes: [String]?
    /// <p>Device user agents that a rule <b>will not</b> match. All other device user agents will match.</p>
    public let notDeviceUserAgents: [String]?

    public init (
        dateCreated: Date? = nil,
        dateModified: Date? = nil,
        description: String? = nil,
        deviceModels: [String]? = nil,
        deviceOperatingSystems: [String]? = nil,
        deviceTypes: [String]? = nil,
        deviceUserAgents: [String]? = nil,
        effect: MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: String? = nil,
        name: String? = nil,
        notDeviceModels: [String]? = nil,
        notDeviceOperatingSystems: [String]? = nil,
        notDeviceTypes: [String]? = nil,
        notDeviceUserAgents: [String]? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
    }
}

public enum MobileDeviceAccessRuleEffect {
    case allow
    case deny
    case sdkUnknown(String)
}

extension MobileDeviceAccessRuleEffect : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MobileDeviceAccessRuleEffect] {
        return [
            .allow,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allow: return "ALLOW"
        case .deny: return "DENY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MobileDeviceAccessRuleEffect(rawValue: rawValue) ?? MobileDeviceAccessRuleEffect.sdkUnknown(rawValue)
    }
}

extension NameAvailabilityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NameAvailabilityException(message: \(String(describing: message)))"}
}

extension NameAvailabilityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NameAvailabilityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The user, group, or resource name isn't unique in Amazon WorkMail.</p>
public struct NameAvailabilityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NameAvailabilityExceptionBody: Equatable {
    public let message: String?
}

extension NameAvailabilityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationNotFoundException(message: \(String(describing: message)))"}
}

extension OrganizationNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An operation received a valid organization identifier that either doesn't belong or
///          exist in the system.</p>
public struct OrganizationNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationStateException(message: \(String(describing: message)))"}
}

extension OrganizationStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OrganizationStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The organization must have a valid state to perform certain
///          operations on the organization or its members.</p>
public struct OrganizationStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationStateExceptionBody: Equatable {
    public let message: String?
}

extension OrganizationStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alias = "Alias"
        case defaultMailDomain = "DefaultMailDomain"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let defaultMailDomain = defaultMailDomain {
            try encodeContainer.encode(defaultMailDomain, forKey: .defaultMailDomain)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(String.self, forKey: .alias)
        alias = aliasDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
    }
}

extension OrganizationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OrganizationSummary(alias: \(String(describing: alias)), defaultMailDomain: \(String(describing: defaultMailDomain)), errorMessage: \(String(describing: errorMessage)), organizationId: \(String(describing: organizationId)), state: \(String(describing: state)))"}
}

/// <p>The representation of an organization.</p>
public struct OrganizationSummary: Equatable {
    /// <p>The alias associated with the organization.</p>
    public let alias: String?
    /// <p>The default email domain associated with the organization.</p>
    public let defaultMailDomain: String?
    /// <p>The error message associated with the organization. It is only present if unexpected
    ///          behavior has occurred with regards to the organization. It provides insight or solutions
    ///          regarding unexpected behavior.</p>
    public let errorMessage: String?
    /// <p>The identifier associated with the organization.</p>
    public let organizationId: String?
    /// <p>The state associated with the organization.</p>
    public let state: String?

    public init (
        alias: String? = nil,
        defaultMailDomain: String? = nil,
        errorMessage: String? = nil,
        organizationId: String? = nil,
        state: String? = nil
    )
    {
        self.alias = alias
        self.defaultMailDomain = defaultMailDomain
        self.errorMessage = errorMessage
        self.organizationId = organizationId
        self.state = state
    }
}

extension Permission: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case granteeId = "GranteeId"
        case granteeType = "GranteeType"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let granteeType = granteeType {
            try encodeContainer.encode(granteeType.rawValue, forKey: .granteeType)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissionvalues0 in permissionValues {
                try permissionValuesContainer.encode(permissionvalues0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let granteeTypeDecoded = try containerValues.decodeIfPresent(MemberType.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [PermissionType]()
            for string0 in permissionValuesContainer {
                if let string0 = string0 {
                    permissionValuesDecoded0?.append(string0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension Permission: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Permission(granteeId: \(String(describing: granteeId)), granteeType: \(String(describing: granteeType)), permissionValues: \(String(describing: permissionValues)))"}
}

/// <p>Permission granted to a user, group, or resource to access a certain aspect of
///          another user, group, or resource mailbox.</p>
public struct Permission: Equatable {
    /// <p>The identifier of the user, group, or resource to which the permissions are
    ///          granted.</p>
    public let granteeId: String?
    /// <p>The type of user, group, or resource referred to in GranteeId.</p>
    public let granteeType: MemberType?
    /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as
    ///          the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF
    ///          allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not
    ///          mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full
    ///          access to the mailbox, irrespective of other folder-level permissions set on the
    ///          mailbox.</p>
    public let permissionValues: [PermissionType]?

    public init (
        granteeId: String? = nil,
        granteeType: MemberType? = nil,
        permissionValues: [PermissionType]? = nil
    )
    {
        self.granteeId = granteeId
        self.granteeType = granteeType
        self.permissionValues = permissionValues
    }
}

public enum PermissionType {
    case fullAccess
    case sendAs
    case sendOnBehalf
    case sdkUnknown(String)
}

extension PermissionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PermissionType] {
        return [
            .fullAccess,
            .sendAs,
            .sendOnBehalf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullAccess: return "FULL_ACCESS"
        case .sendAs: return "SEND_AS"
        case .sendOnBehalf: return "SEND_ON_BEHALF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
    }
}

public struct PutAccessControlRuleInputBodyMiddleware: Middleware {
    public let id: String = "PutAccessControlRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessControlRuleOutputError>
}

extension PutAccessControlRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessControlRuleInput(actions: \(String(describing: actions)), description: \(String(describing: description)), effect: \(String(describing: effect)), ipRanges: \(String(describing: ipRanges)), name: \(String(describing: name)), notActions: \(String(describing: notActions)), notIpRanges: \(String(describing: notIpRanges)), notUserIds: \(String(describing: notUserIds)), organizationId: \(String(describing: organizationId)), userIds: \(String(describing: userIds)))"}
}

extension PutAccessControlRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprangelist0 in ipRanges {
                try ipRangesContainer.encode(iprangelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for actionslist0 in notActions {
                try notActionsContainer.encode(actionslist0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprangelist0 in notIpRanges {
                try notIpRangesContainer.encode(iprangelist0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for useridlist0 in notUserIds {
                try notUserIdsContainer.encode(useridlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for useridlist0 in userIds {
                try userIdsContainer.encode(useridlist0)
            }
        }
    }
}

public struct PutAccessControlRuleInputHeadersMiddleware: Middleware {
    public let id: String = "PutAccessControlRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "PutAccessControlRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInput: Equatable {
    /// <p>Access protocol actions to include in the rule. Valid values include
    ///             <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>,
    ///             <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    public let actions: [String]?
    /// <p>The rule description.</p>
    public let description: String?
    /// <p>The rule effect.</p>
    public let effect: AccessControlRuleEffect?
    /// <p>IPv4 CIDR ranges to include in the rule.</p>
    public let ipRanges: [String]?
    /// <p>The rule name.</p>
    public let name: String?
    /// <p>Access protocol actions to exclude from the rule. Valid values include
    ///             <code>ActiveSync</code>, <code>AutoDiscover</code>, <code>EWS</code>, <code>IMAP</code>,
    ///             <code>SMTP</code>, <code>WindowsOutlook</code>, and <code>WebMail</code>.</p>
    public let notActions: [String]?
    /// <p>IPv4 CIDR ranges to exclude from the rule.</p>
    public let notIpRanges: [String]?
    /// <p>User IDs to exclude from the rule.</p>
    public let notUserIds: [String]?
    /// <p>The identifier of the organization.</p>
    public let organizationId: String?
    /// <p>User IDs to include in the rule.</p>
    public let userIds: [String]?

    public init (
        actions: [String]? = nil,
        description: String? = nil,
        effect: AccessControlRuleEffect? = nil,
        ipRanges: [String]? = nil,
        name: String? = nil,
        notActions: [String]? = nil,
        notIpRanges: [String]? = nil,
        notUserIds: [String]? = nil,
        organizationId: String? = nil,
        userIds: [String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.effect = effect
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.organizationId = organizationId
        self.userIds = userIds
    }
}

struct PutAccessControlRuleInputBody: Equatable {
    public let name: String?
    public let effect: AccessControlRuleEffect?
    public let description: String?
    public let ipRanges: [String]?
    public let notIpRanges: [String]?
    public let actions: [String]?
    public let notActions: [String]?
    public let userIds: [String]?
    public let notUserIds: [String]?
    public let organizationId: String?
}

extension PutAccessControlRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notActions)
        var notActionsDecoded0:[String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .userIds)
        var userIdsDecoded0:[String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension PutAccessControlRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccessControlRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccessControlRuleOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessControlRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutAccessControlRuleOutputResponse()"}
}

extension PutAccessControlRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessControlRuleOutputResponse: Equatable {

    public init() {}
}

struct PutAccessControlRuleOutputResponseBody: Equatable {
}

extension PutAccessControlRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutMailboxPermissionsInputBodyMiddleware: Middleware {
    public let id: String = "PutMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMailboxPermissionsOutputError>
}

extension PutMailboxPermissionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMailboxPermissionsInput(entityId: \(String(describing: entityId)), granteeId: \(String(describing: granteeId)), organizationId: \(String(describing: organizationId)), permissionValues: \(String(describing: permissionValues)))"}
}

extension PutMailboxPermissionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissionvalues0 in permissionValues {
                try permissionValuesContainer.encode(permissionvalues0.rawValue)
            }
        }
    }
}

public struct PutMailboxPermissionsInputHeadersMiddleware: Middleware {
    public let id: String = "PutMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInput: Equatable {
    /// <p>The identifier of the user, group, or resource for which to update mailbox
    ///          permissions.</p>
    public let entityId: String?
    /// <p>The identifier of the user, group, or resource to which to grant the
    ///          permissions.</p>
    public let granteeId: String?
    /// <p>The identifier of the organization under which the user, group, or resource
    ///          exists.</p>
    public let organizationId: String?
    /// <p>The permissions granted to the grantee. SEND_AS allows the grantee to send email as
    ///          the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF
    ///          allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not
    ///          mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full
    ///          access to the mailbox, irrespective of other folder-level permissions set on the
    ///          mailbox.</p>
    public let permissionValues: [PermissionType]?

    public init (
        entityId: String? = nil,
        granteeId: String? = nil,
        organizationId: String? = nil,
        permissionValues: [PermissionType]? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
        self.permissionValues = permissionValues
    }
}

struct PutMailboxPermissionsInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let granteeId: String?
    public let permissionValues: [PermissionType]?
}

extension PutMailboxPermissionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [PermissionType]()
            for string0 in permissionValuesContainer {
                if let string0 = string0 {
                    permissionValuesDecoded0?.append(string0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension PutMailboxPermissionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMailboxPermissionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMailboxPermissionsOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMailboxPermissionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutMailboxPermissionsOutputResponse()"}
}

extension PutMailboxPermissionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutMailboxPermissionsOutputResponse: Equatable {

    public init() {}
}

struct PutMailboxPermissionsOutputResponseBody: Equatable {
}

extension PutMailboxPermissionsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRetentionPolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionPolicyOutputError>
}

extension PutRetentionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRetentionPolicyInput(description: \(String(describing: description)), folderConfigurations: \(String(describing: folderConfigurations)), id: \(String(describing: id)), name: \(String(describing: name)), organizationId: \(String(describing: organizationId)))"}
}

extension PutRetentionPolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let folderConfigurations = folderConfigurations {
            var folderConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderConfigurations)
            for folderconfigurations0 in folderConfigurations {
                try folderConfigurationsContainer.encode(folderconfigurations0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct PutRetentionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInput: Equatable {
    /// <p>The retention policy description.</p>
    public let description: String?
    /// <p>The retention policy folder configurations.</p>
    public let folderConfigurations: [FolderConfiguration]?
    /// <p>The retention policy ID.</p>
    public let id: String?
    /// <p>The retention policy name.</p>
    public let name: String?
    /// <p>The organization ID.</p>
    public let organizationId: String?

    public init (
        description: String? = nil,
        folderConfigurations: [FolderConfiguration]? = nil,
        id: String? = nil,
        name: String? = nil,
        organizationId: String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
        self.organizationId = organizationId
    }
}

struct PutRetentionPolicyInputBody: Equatable {
    public let organizationId: String?
    public let id: String?
    public let name: String?
    public let description: String?
    public let folderConfigurations: [FolderConfiguration]?
}

extension PutRetentionPolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

extension PutRetentionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRetentionPolicyOutputError: Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRetentionPolicyOutputResponse()"}
}

extension PutRetentionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutRetentionPolicyOutputResponse: Equatable {

    public init() {}
}

struct PutRetentionPolicyOutputResponseBody: Equatable {
}

extension PutRetentionPolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RegisterToWorkMailInputBodyMiddleware: Middleware {
    public let id: String = "RegisterToWorkMailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterToWorkMailOutputError>
}

extension RegisterToWorkMailInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterToWorkMailInput(email: \(String(describing: email)), entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)))"}
}

extension RegisterToWorkMailInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct RegisterToWorkMailInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterToWorkMailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterToWorkMailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInput: Equatable {
    /// <p>The email for the user, group, or resource to be updated.</p>
    public let email: String?
    /// <p>The identifier for the user, group, or resource to be updated.</p>
    public let entityId: String?
    /// <p>The identifier for the organization under which the user, group, or resource
    ///          exists.</p>
    public let organizationId: String?

    public init (
        email: String? = nil,
        entityId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct RegisterToWorkMailInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let email: String?
}

extension RegisterToWorkMailInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension RegisterToWorkMailOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterToWorkMailOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyRegisteredException" : self = .entityAlreadyRegisteredException(try EntityAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterToWorkMailOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityAlreadyRegisteredException(EntityAlreadyRegisteredException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterToWorkMailOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterToWorkMailOutputResponse()"}
}

extension RegisterToWorkMailOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterToWorkMailOutputResponse: Equatable {

    public init() {}
}

struct RegisterToWorkMailOutputResponseBody: Equatable {
}

extension RegisterToWorkMailOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ReservedNameException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservedNameException(message: \(String(describing: message)))"}
}

extension ReservedNameException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ReservedNameExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This user, group, or resource name is not allowed in Amazon WorkMail.</p>
public struct ReservedNameException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNameExceptionBody: Equatable {
    public let message: String?
}

extension ReservedNameExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetPasswordInputBodyMiddleware: Middleware {
    public let id: String = "ResetPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetPasswordOutputError>
}

extension ResetPasswordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetPasswordInput(organizationId: \(String(describing: organizationId)), password: \(String(describing: password)), userId: \(String(describing: userId)))"}
}

extension ResetPasswordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct ResetPasswordInputHeadersMiddleware: Middleware {
    public let id: String = "ResetPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInput: Equatable {
    /// <p>The identifier of the organization that contains the user for which the password is
    ///          reset.</p>
    public let organizationId: String?
    /// <p>The new password for the user.</p>
    public let password: String?
    /// <p>The identifier of the user for whom the password is reset.</p>
    public let userId: String?

    public init (
        organizationId: String? = nil,
        password: String? = nil,
        userId: String? = nil
    )
    {
        self.organizationId = organizationId
        self.password = password
        self.userId = userId
    }
}

struct ResetPasswordInputBody: Equatable {
    public let organizationId: String?
    public let userId: String?
    public let password: String?
}

extension ResetPasswordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ResetPasswordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetPasswordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetPasswordOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetPasswordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetPasswordOutputResponse()"}
}

extension ResetPasswordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResetPasswordOutputResponse: Equatable {

    public init() {}
}

struct ResetPasswordOutputResponseBody: Equatable {
}

extension ResetPasswordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(disabledDate: \(String(describing: disabledDate)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), id: \(String(describing: id)), name: \(String(describing: name)), state: \(String(describing: state)), type: \(String(describing: type)))"}
}

/// <p>The representation of a resource.</p>
public struct Resource: Equatable {
    /// <p>The date indicating when the resource was disabled from Amazon WorkMail use.</p>
    public let disabledDate: Date?
    /// <p>The email of the resource.</p>
    public let email: String?
    /// <p>The date indicating when the resource was enabled for Amazon WorkMail use.</p>
    public let enabledDate: Date?
    /// <p>The identifier of the resource.</p>
    public let id: String?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The state of the resource, which can be ENABLED, DISABLED, or DELETED.</p>
    public let state: EntityState?
    /// <p>The type of the resource: equipment or room.</p>
    public let type: ResourceType?

    public init (
        disabledDate: Date? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        state: EntityState? = nil,
        type: ResourceType? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.id = id
        self.name = name
        self.state = state
        self.type = type
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource cannot be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ResourceType {
    case equipment
    case room
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .equipment,
            .room,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .equipment: return "EQUIPMENT"
        case .room: return "ROOM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

public enum RetentionAction {
    case delete
    case `none`
    case permanentlyDelete
    case sdkUnknown(String)
}

extension RetentionAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RetentionAction] {
        return [
            .delete,
            .none,
            .permanentlyDelete,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .none: return "NONE"
        case .permanentlyDelete: return "PERMANENTLY_DELETE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RetentionAction(rawValue: rawValue) ?? RetentionAction.sdkUnknown(rawValue)
    }
}

public struct StartMailboxExportJobInputBodyMiddleware: Middleware {
    public let id: String = "StartMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMailboxExportJobOutputError>
}

extension StartMailboxExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMailboxExportJobInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), entityId: \(String(describing: entityId)), kmsKeyArn: \(String(describing: kmsKeyArn)), organizationId: \(String(describing: organizationId)), roleArn: \(String(describing: roleArn)), s3BucketName: \(String(describing: s3BucketName)), s3Prefix: \(String(describing: s3Prefix)))"}
}

extension StartMailboxExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }
}

public struct StartMailboxExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInput: Equatable {
    /// <p>The idempotency token for the client request.</p>
    public var clientToken: String?
    /// <p>The mailbox export job description.</p>
    public let description: String?
    /// <p>The identifier of the user or resource associated with the mailbox.</p>
    public let entityId: String?
    /// <p>The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS)
    ///          key that encrypts the exported mailbox content.</p>
    public let kmsKeyArn: String?
    /// <p>The identifier associated with the organization.</p>
    public let organizationId: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3
    ///          bucket.</p>
    public let roleArn: String?
    /// <p>The name of the S3 bucket.</p>
    public let s3BucketName: String?
    /// <p>The S3 bucket prefix.</p>
    public let s3Prefix: String?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        entityId: String? = nil,
        kmsKeyArn: String? = nil,
        organizationId: String? = nil,
        roleArn: String? = nil,
        s3BucketName: String? = nil,
        s3Prefix: String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.entityId = entityId
        self.kmsKeyArn = kmsKeyArn
        self.organizationId = organizationId
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
    }
}

struct StartMailboxExportJobInputBody: Equatable {
    public let clientToken: String?
    public let organizationId: String?
    public let entityId: String?
    public let description: String?
    public let roleArn: String?
    public let kmsKeyArn: String?
    public let s3BucketName: String?
    public let s3Prefix: String?
}

extension StartMailboxExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension StartMailboxExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMailboxExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMailboxExportJobOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMailboxExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMailboxExportJobOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartMailboxExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMailboxExportJobOutputResponse: Equatable {
    /// <p>The job ID.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMailboxExportJobOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartMailboxExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag applied to a resource.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag.</p>
    public let key: String?
    /// <p>The value of the tag.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceARN: String?
    /// <p>The tag key-value pairs.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource can have up to 50 user-applied tags.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedOperationException(message: \(String(describing: message)))"}
}

extension UnsupportedOperationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't perform a write operation against a read-only directory.</p>
public struct UnsupportedOperationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Equatable {
    public let message: String?
}

extension UnsupportedOperationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The resource ARN.</p>
    public let resourceARN: String?
    /// <p>The tag keys.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMailboxQuotaInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMailboxQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMailboxQuotaOutputError>
}

extension UpdateMailboxQuotaInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMailboxQuotaInput(mailboxQuota: \(String(describing: mailboxQuota)), organizationId: \(String(describing: organizationId)), userId: \(String(describing: userId)))"}
}

extension UpdateMailboxQuotaInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mailboxQuota = mailboxQuota {
            try encodeContainer.encode(mailboxQuota, forKey: .mailboxQuota)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct UpdateMailboxQuotaInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMailboxQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMailboxQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInput: Equatable {
    /// <p>The updated mailbox quota, in MB, for the specified user.</p>
    public let mailboxQuota: Int?
    /// <p>The identifier for the organization that contains the user for whom to update the
    ///          mailbox quota.</p>
    public let organizationId: String?
    /// <p>The identifer for the user for whom to update the mailbox quota.</p>
    public let userId: String?

    public init (
        mailboxQuota: Int? = nil,
        organizationId: String? = nil,
        userId: String? = nil
    )
    {
        self.mailboxQuota = mailboxQuota
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct UpdateMailboxQuotaInputBody: Equatable {
    public let organizationId: String?
    public let userId: String?
    public let mailboxQuota: Int?
}

extension UpdateMailboxQuotaInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
    }
}

extension UpdateMailboxQuotaOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMailboxQuotaOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMailboxQuotaOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMailboxQuotaOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMailboxQuotaOutputResponse()"}
}

extension UpdateMailboxQuotaOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMailboxQuotaOutputResponse: Equatable {

    public init() {}
}

struct UpdateMailboxQuotaOutputResponseBody: Equatable {
}

extension UpdateMailboxQuotaOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateMobileDeviceAccessRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

extension UpdateMobileDeviceAccessRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMobileDeviceAccessRuleInput(description: \(String(describing: description)), deviceModels: \(String(describing: deviceModels)), deviceOperatingSystems: \(String(describing: deviceOperatingSystems)), deviceTypes: \(String(describing: deviceTypes)), deviceUserAgents: \(String(describing: deviceUserAgents)), effect: \(String(describing: effect)), mobileDeviceAccessRuleId: \(String(describing: mobileDeviceAccessRuleId)), name: \(String(describing: name)), notDeviceModels: \(String(describing: notDeviceModels)), notDeviceOperatingSystems: \(String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(String(describing: notDeviceTypes)), notDeviceUserAgents: \(String(describing: notDeviceUserAgents)), organizationId: \(String(describing: organizationId)))"}
}

extension UpdateMobileDeviceAccessRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UpdateMobileDeviceAccessRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInput: Equatable {
    /// <p>The updated rule description.</p>
    public let description: String?
    /// <p>Device models that the updated rule will match.</p>
    public let deviceModels: [String]?
    /// <p>Device operating systems that the updated rule will match.</p>
    public let deviceOperatingSystems: [String]?
    /// <p>Device types that the updated rule will match.</p>
    public let deviceTypes: [String]?
    /// <p>User agents that the updated rule will match.</p>
    public let deviceUserAgents: [String]?
    /// <p>The effect of the rule when it matches. Allowed values are <code>ALLOW</code> or <code>DENY</code>.</p>
    public let effect: MobileDeviceAccessRuleEffect?
    /// <p>The identifier of the rule to be updated.</p>
    public let mobileDeviceAccessRuleId: String?
    /// <p>The updated rule name.</p>
    public let name: String?
    /// <p>Device models that the updated rule <b>will not</b> match. All other device models will match.</p>
    public let notDeviceModels: [String]?
    /// <p>Device operating systems that the updated rule <b>will not</b> match. All other device operating systems will match.</p>
    public let notDeviceOperatingSystems: [String]?
    /// <p>Device types that the updated rule <b>will not</b> match. All other device types will match.</p>
    public let notDeviceTypes: [String]?
    /// <p>User agents that the updated rule <b>will not</b> match. All other user agents will match.</p>
    public let notDeviceUserAgents: [String]?
    /// <p>The Amazon WorkMail organization under which the rule will be updated.</p>
    public let organizationId: String?

    public init (
        description: String? = nil,
        deviceModels: [String]? = nil,
        deviceOperatingSystems: [String]? = nil,
        deviceTypes: [String]? = nil,
        deviceUserAgents: [String]? = nil,
        effect: MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: String? = nil,
        name: String? = nil,
        notDeviceModels: [String]? = nil,
        notDeviceOperatingSystems: [String]? = nil,
        notDeviceTypes: [String]? = nil,
        notDeviceUserAgents: [String]? = nil,
        organizationId: String? = nil
    )
    {
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct UpdateMobileDeviceAccessRuleInputBody: Equatable {
    public let organizationId: String?
    public let mobileDeviceAccessRuleId: String?
    public let name: String?
    public let description: String?
    public let effect: MobileDeviceAccessRuleEffect?
    public let deviceTypes: [String]?
    public let notDeviceTypes: [String]?
    public let deviceModels: [String]?
    public let notDeviceModels: [String]?
    public let deviceOperatingSystems: [String]?
    public let notDeviceOperatingSystems: [String]?
    public let deviceUserAgents: [String]?
    public let notDeviceUserAgents: [String]?
}

extension UpdateMobileDeviceAccessRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension UpdateMobileDeviceAccessRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMobileDeviceAccessRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMobileDeviceAccessRuleOutputError: Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMobileDeviceAccessRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMobileDeviceAccessRuleOutputResponse()"}
}

extension UpdateMobileDeviceAccessRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMobileDeviceAccessRuleOutputResponse: Equatable {

    public init() {}
}

struct UpdateMobileDeviceAccessRuleOutputResponseBody: Equatable {
}

extension UpdateMobileDeviceAccessRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePrimaryEmailAddressInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePrimaryEmailAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePrimaryEmailAddressOutputError>
}

extension UpdatePrimaryEmailAddressInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePrimaryEmailAddressInput(email: \(String(describing: email)), entityId: \(String(describing: entityId)), organizationId: \(String(describing: organizationId)))"}
}

extension UpdatePrimaryEmailAddressInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UpdatePrimaryEmailAddressInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePrimaryEmailAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePrimaryEmailAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInput: Equatable {
    /// <p>The value of the email to be updated as primary.</p>
    public let email: String?
    /// <p>The user, group, or resource to update.</p>
    public let entityId: String?
    /// <p>The organization that contains the user, group, or resource to update.</p>
    public let organizationId: String?

    public init (
        email: String? = nil,
        entityId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct UpdatePrimaryEmailAddressInputBody: Equatable {
    public let organizationId: String?
    public let entityId: String?
    public let email: String?
}

extension UpdatePrimaryEmailAddressInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
    }
}

extension UpdatePrimaryEmailAddressOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePrimaryEmailAddressOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePrimaryEmailAddressOutputError: Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePrimaryEmailAddressOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePrimaryEmailAddressOutputResponse()"}
}

extension UpdatePrimaryEmailAddressOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePrimaryEmailAddressOutputResponse: Equatable {

    public init() {}
}

struct UpdatePrimaryEmailAddressOutputResponseBody: Equatable {
}

extension UpdatePrimaryEmailAddressOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateResourceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

extension UpdateResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceInput(bookingOptions: \(String(describing: bookingOptions)), name: \(String(describing: name)), organizationId: \(String(describing: organizationId)), resourceId: \(String(describing: resourceId)))"}
}

extension UpdateResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bookingOptions = bookingOptions {
            try encodeContainer.encode(bookingOptions, forKey: .bookingOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct UpdateResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInput: Equatable {
    /// <p>The resource's booking options to be updated.</p>
    public let bookingOptions: BookingOptions?
    /// <p>The name of the resource to be updated.</p>
    public let name: String?
    /// <p>The identifier associated with the organization for which the resource is
    ///          updated.</p>
    public let organizationId: String?
    /// <p>The identifier of the resource to be updated.</p>
    public let resourceId: String?

    public init (
        bookingOptions: BookingOptions? = nil,
        name: String? = nil,
        organizationId: String? = nil,
        resourceId: String? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.name = name
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct UpdateResourceInputBody: Equatable {
    public let organizationId: String?
    public let resourceId: String?
    public let name: String?
    public let bookingOptions: BookingOptions?
}

extension UpdateResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
    }
}

extension UpdateResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceOutputError: Equatable {
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidConfigurationException(InvalidConfigurationException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResourceOutputResponse()"}
}

extension UpdateResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceOutputResponse: Equatable {

    public init() {}
}

struct UpdateResourceOutputResponseBody: Equatable {
}

extension UpdateResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension User: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userRole = userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension User: CustomDebugStringConvertible {
    public var debugDescription: String {
        "User(disabledDate: \(String(describing: disabledDate)), displayName: \(String(describing: displayName)), email: \(String(describing: email)), enabledDate: \(String(describing: enabledDate)), id: \(String(describing: id)), name: \(String(describing: name)), state: \(String(describing: state)), userRole: \(String(describing: userRole)))"}
}

/// <p>The representation of an Amazon WorkMail user.</p>
public struct User: Equatable {
    /// <p>The date indicating when the user was disabled from Amazon WorkMail use.</p>
    public let disabledDate: Date?
    /// <p>The display name of the user.</p>
    public let displayName: String?
    /// <p>The email of the user.</p>
    public let email: String?
    /// <p>The date indicating when the user was enabled for Amazon WorkMail use.</p>
    public let enabledDate: Date?
    /// <p>The identifier of the user.</p>
    public let id: String?
    /// <p>The name of the user.</p>
    public let name: String?
    /// <p>The state of the user, which can be ENABLED, DISABLED, or DELETED.</p>
    public let state: EntityState?
    /// <p>The role of the user.</p>
    public let userRole: UserRole?

    public init (
        disabledDate: Date? = nil,
        displayName: String? = nil,
        email: String? = nil,
        enabledDate: Date? = nil,
        id: String? = nil,
        name: String? = nil,
        state: EntityState? = nil,
        userRole: UserRole? = nil
    )
    {
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.id = id
        self.name = name
        self.state = state
        self.userRole = userRole
    }
}

public enum UserRole {
    case resource
    case systemUser
    case user
    case sdkUnknown(String)
}

extension UserRole : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UserRole] {
        return [
            .resource,
            .systemUser,
            .user,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .resource: return "RESOURCE"
        case .systemUser: return "SYSTEM_USER"
        case .user: return "USER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
    }
}
