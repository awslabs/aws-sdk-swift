// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AmplifyUiBuilderClientTypes.Component: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case createdAt
        case environmentName
        case id
        case modifiedAt
        case name
        case overrides
        case properties
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentbindingproperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentbindingproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchildlist0 in children {
                try childrenContainer.encode(componentchildlist0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentcollectionproperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentcollectionproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.iso8601WithoutFractionalSeconds(), forKey: .createdAt)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.iso8601WithoutFractionalSeconds(), forKey: .modifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentoverrides0) in overrides {
                try overridesContainer.encode(componentoverrides0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentproperties0) in properties {
                try propertiesContainer.encode(componentproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariants0 in variants {
                try variantsContainer.encode(componentvariants0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUiBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUiBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUiBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let modifiedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifiedAt)
        var modifiedAtDecoded: ClientRuntime.Date? = nil
        if let modifiedAtDateString = modifiedAtDateString {
            let modifiedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            modifiedAtDecoded = modifiedAtFormatter.date(from: modifiedAtDateString)
        }
        modifiedAt = modifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Contains the configuration settings for a user interface (UI) element for an Amplify app. A component is configured as a primary, stand-alone UI element. Use ComponentChild to configure an instance of a Component. A ComponentChild instance inherits the configuration of the main Component.
    public struct Component: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The information to connect a component's properties to data at runtime.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of the component's ComponentChild instances.
        public var children: [AmplifyUiBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for the component's properties. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The time that the component was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the component was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component's properties that can be overriden in a customized instance of the component.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the component's variants. A variant is a unique style configuration of a main component.
        /// This member is required.
        public var variants: [AmplifyUiBuilderClientTypes.ComponentVariant]?

        public init (
            appId: Swift.String? = nil,
            bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUiBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.appId = appId
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case defaultValue
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValueProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Represents the data binding configuration for a component at runtime. You can use ComponentBindingPropertiesValue to add exposed properties to a component to allow different values to be entered when a component is reused in different places in an app.
    public struct ComponentBindingPropertiesValue: Swift.Equatable {
        /// Describes the properties to customize with data at runtime.
        public var bindingProperties: AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValueProperties?
        /// The default value of the property.
        public var defaultValue: Swift.String?
        /// The property type.
        public var type: Swift.String?

        public init (
            bindingProperties: AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValueProperties? = nil,
            defaultValue: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.defaultValue = defaultValue
            self.type = type
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValueProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case defaultValue
        case field
        case key
        case model
        case predicates
        case userAttribute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicates = predicates {
            var predicatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .predicates)
            for predicatelist0 in predicates {
                try predicatesContainer.encode(predicatelist0)
            }
        }
        if let userAttribute = userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let predicatesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.Predicate?].self, forKey: .predicates)
        var predicatesDecoded0:[AmplifyUiBuilderClientTypes.Predicate]? = nil
        if let predicatesContainer = predicatesContainer {
            predicatesDecoded0 = [AmplifyUiBuilderClientTypes.Predicate]()
            for structure0 in predicatesContainer {
                if let structure0 = structure0 {
                    predicatesDecoded0?.append(structure0)
                }
            }
        }
        predicates = predicatesDecoded0
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Represents the data binding configuration for a specific property using data stored in Amazon Web Services. For Amazon Web Services connected properties, you can bind a property to data stored in an Amazon S3 bucket, an Amplify DataStore model or an authenticated user attribute.
    public struct ComponentBindingPropertiesValueProperties: Swift.Equatable {
        /// An Amazon S3 bucket.
        public var bucket: Swift.String?
        /// The default value to assign to the property.
        public var defaultValue: Swift.String?
        /// The field to bind the data to.
        public var field: Swift.String?
        /// The storage key for an Amazon S3 bucket.
        public var key: Swift.String?
        /// An Amplify DataStore model.
        public var model: Swift.String?
        /// A list of predicates for binding a component's properties to data.
        public var predicates: [AmplifyUiBuilderClientTypes.Predicate]?
        /// An authenticated user attribute.
        public var userAttribute: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            defaultValue: Swift.String? = nil,
            field: Swift.String? = nil,
            key: Swift.String? = nil,
            model: Swift.String? = nil,
            predicates: [AmplifyUiBuilderClientTypes.Predicate]? = nil,
            userAttribute: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.defaultValue = defaultValue
            self.field = field
            self.key = key
            self.model = model
            self.predicates = predicates
            self.userAttribute = userAttribute
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentChild: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case componentType
        case name
        case properties
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchildlist0 in children {
                try childrenContainer.encode(componentchildlist0)
            }
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentproperties0) in properties {
                try propertiesContainer.encode(componentproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUiBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUiBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// A nested UI configuration within a parent Component.
    public struct ComponentChild: Swift.Equatable {
        /// The list of ComponentChild instances for this component.
        public var children: [AmplifyUiBuilderClientTypes.ComponentChild]?
        /// The type of the child component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The name of the child component.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties of the child component.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]?

        public init (
            children: [AmplifyUiBuilderClientTypes.ComponentChild]? = nil,
            componentType: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        )
        {
            self.children = children
            self.componentType = componentType
            self.name = name
            self.properties = properties
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentConditionProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `else` = "else"
        case field
        case operand
        case `operator` = "operator"
        case property
        case then
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `else` = `else` {
            try encodeContainer.encode(`else`.value, forKey: .`else`)
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let property = property {
            try encodeContainer.encode(property, forKey: .property)
        }
        if let then = then {
            try encodeContainer.encode(then.value, forKey: .then)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
        let thenDecoded = try containerValues.decodeIfPresent(Box<AmplifyUiBuilderClientTypes.ComponentProperty>.self, forKey: .then)
        then = thenDecoded
        let elseDecoded = try containerValues.decodeIfPresent(Box<AmplifyUiBuilderClientTypes.ComponentProperty>.self, forKey: .else)
        `else` = elseDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Represents a conditional expression to set a component property. Use ComponentConditionProperty to set a property to different values conditionally, based on the value of another property.
    public struct ComponentConditionProperty: Swift.Equatable {
        /// The value to assign to the property if the condition is not met.
        public var `else`: Box<AmplifyUiBuilderClientTypes.ComponentProperty>?
        /// The name of a field. Specify this when the property is a data model.
        public var field: Swift.String?
        /// The value of the property to evaluate.
        public var operand: Swift.String?
        /// The operator to use to perform the evaluation, such as eq to represent equals.
        public var `operator`: Swift.String?
        /// The name of the conditional property.
        public var property: Swift.String?
        /// The value to assign to the property if the condition is met.
        public var then: Box<AmplifyUiBuilderClientTypes.ComponentProperty>?

        public init (
            `else`: Box<AmplifyUiBuilderClientTypes.ComponentProperty>? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            property: Swift.String? = nil,
            then: Box<AmplifyUiBuilderClientTypes.ComponentProperty>? = nil
        )
        {
            self.`else` = `else`
            self.field = field
            self.operand = operand
            self.`operator` = `operator`
            self.property = property
            self.then = then
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentDataConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identifiers
        case model
        case predicate
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifiers = identifiers {
            var identifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identifiers)
            for identifierlist0 in identifiers {
                try identifiersContainer.encode(identifierlist0)
            }
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let predicate = predicate {
            try encodeContainer.encode(predicate, forKey: .predicate)
        }
        if let sort = sort {
            var sortContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sort)
            for sortpropertylist0 in sort {
                try sortContainer.encode(sortpropertylist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let sortContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.SortProperty?].self, forKey: .sort)
        var sortDecoded0:[AmplifyUiBuilderClientTypes.SortProperty]? = nil
        if let sortContainer = sortContainer {
            sortDecoded0 = [AmplifyUiBuilderClientTypes.SortProperty]()
            for structure0 in sortContainer {
                if let structure0 = structure0 {
                    sortDecoded0?.append(structure0)
                }
            }
        }
        sort = sortDecoded0
        let predicateDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Predicate.self, forKey: .predicate)
        predicate = predicateDecoded
        let identifiersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .identifiers)
        var identifiersDecoded0:[Swift.String]? = nil
        if let identifiersContainer = identifiersContainer {
            identifiersDecoded0 = [Swift.String]()
            for string0 in identifiersContainer {
                if let string0 = string0 {
                    identifiersDecoded0?.append(string0)
                }
            }
        }
        identifiers = identifiersDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the configuration for binding a component's properties to data.
    public struct ComponentDataConfiguration: Swift.Equatable {
        /// A list of IDs to use to bind data to a component. Use this property to bind specifically chosen data, rather than data retrieved from a query.
        public var identifiers: [Swift.String]?
        /// The name of the data model to use to bind data to a component.
        /// This member is required.
        public var model: Swift.String?
        /// Represents the conditional logic to use when binding data to a component. Use this property to retrieve only a subset of the data in a collection.
        public var predicate: AmplifyUiBuilderClientTypes.Predicate?
        /// Describes how to sort the component's properties.
        public var sort: [AmplifyUiBuilderClientTypes.SortProperty]?

        public init (
            identifiers: [Swift.String]? = nil,
            model: Swift.String? = nil,
            predicate: AmplifyUiBuilderClientTypes.Predicate? = nil,
            sort: [AmplifyUiBuilderClientTypes.SortProperty]? = nil
        )
        {
            self.identifiers = identifiers
            self.model = model
            self.predicate = predicate
            self.sort = sort
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case bindings
        case collectionBindingProperties
        case concat
        case condition
        case configured
        case defaultValue
        case event
        case importedValue
        case model
        case type
        case userAttribute
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            try encodeContainer.encode(bindingProperties, forKey: .bindingProperties)
        }
        if let bindings = bindings {
            var bindingsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindings)
            for (dictKey0, formbindings0) in bindings {
                try bindingsContainer.encode(formbindings0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let collectionBindingProperties = collectionBindingProperties {
            try encodeContainer.encode(collectionBindingProperties, forKey: .collectionBindingProperties)
        }
        if let concat = concat {
            var concatContainer = encodeContainer.nestedUnkeyedContainer(forKey: .concat)
            for componentpropertylist0 in concat {
                try concatContainer.encode(componentpropertylist0)
            }
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let configured = configured {
            try encodeContainer.encode(configured, forKey: .configured)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let importedValue = importedValue {
            try encodeContainer.encode(importedValue, forKey: .importedValue)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userAttribute = userAttribute {
            try encodeContainer.encode(userAttribute, forKey: .userAttribute)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let bindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .bindingProperties)
        bindingProperties = bindingPropertiesDecoded
        let collectionBindingPropertiesDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties.self, forKey: .collectionBindingProperties)
        collectionBindingProperties = collectionBindingPropertiesDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let bindingsContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.FormBindingElement?].self, forKey: .bindings)
        var bindingsDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.FormBindingElement]? = nil
        if let bindingsContainer = bindingsContainer {
            bindingsDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.FormBindingElement]()
            for (key0, formbindingelement0) in bindingsContainer {
                if let formbindingelement0 = formbindingelement0 {
                    bindingsDecoded0?[key0] = formbindingelement0
                }
            }
        }
        bindings = bindingsDecoded0
        let eventDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .event)
        event = eventDecoded
        let userAttributeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAttribute)
        userAttribute = userAttributeDecoded
        let concatContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentProperty?].self, forKey: .concat)
        var concatDecoded0:[AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        if let concatContainer = concatContainer {
            concatDecoded0 = [AmplifyUiBuilderClientTypes.ComponentProperty]()
            for structure0 in concatContainer {
                if let structure0 = structure0 {
                    concatDecoded0?.append(structure0)
                }
            }
        }
        concat = concatDecoded0
        let conditionDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ComponentConditionProperty.self, forKey: .condition)
        condition = conditionDecoded
        let configuredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .configured)
        configured = configuredDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let importedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedValue)
        importedValue = importedValueDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the configuration for all of a component's properties. Use ComponentProperty to specify the values to render or bind by default.
    public struct ComponentProperty: Swift.Equatable {
        /// The information to bind the component property to data at runtime.
        public var bindingProperties: AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties?
        /// The information to bind the component property to form data.
        public var bindings: [Swift.String:AmplifyUiBuilderClientTypes.FormBindingElement]?
        /// The information to bind the component property to data at runtime. Use this for collection components.
        public var collectionBindingProperties: AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties?
        /// A list of component properties to concatenate to create the value to assign to this component property.
        public var concat: [AmplifyUiBuilderClientTypes.ComponentProperty]?
        /// The conditional expression to use to assign a value to the component property..
        public var condition: AmplifyUiBuilderClientTypes.ComponentConditionProperty?
        /// Specifies whether the user configured the property in Amplify Studio after importing it.
        public var configured: Swift.Bool?
        /// The default value to assign to the component property.
        public var defaultValue: Swift.String?
        /// An event that occurs in your app. Use this for workflow data binding.
        public var event: Swift.String?
        /// The default value assigned to property when the component is imported into an app.
        public var importedValue: Swift.String?
        /// The data model to use to assign a value to the component property.
        public var model: Swift.String?
        /// The component type.
        public var type: Swift.String?
        /// An authenticated user attribute to use to assign a value to the component property.
        public var userAttribute: Swift.String?
        /// The value to assign to the component property.
        public var value: Swift.String?

        public init (
            bindingProperties: AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            bindings: [Swift.String:AmplifyUiBuilderClientTypes.FormBindingElement]? = nil,
            collectionBindingProperties: AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties? = nil,
            concat: [AmplifyUiBuilderClientTypes.ComponentProperty]? = nil,
            condition: AmplifyUiBuilderClientTypes.ComponentConditionProperty? = nil,
            configured: Swift.Bool? = nil,
            defaultValue: Swift.String? = nil,
            event: Swift.String? = nil,
            importedValue: Swift.String? = nil,
            model: Swift.String? = nil,
            type: Swift.String? = nil,
            userAttribute: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.bindings = bindings
            self.collectionBindingProperties = collectionBindingProperties
            self.concat = concat
            self.condition = condition
            self.configured = configured
            self.defaultValue = defaultValue
            self.event = event
            self.importedValue = importedValue
            self.model = model
            self.type = type
            self.userAttribute = userAttribute
            self.value = value
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentPropertyBindingProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case field
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let property = property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Associates a component property to a binding property. This enables exposed properties on the top level component to propagate data to the component's property values.
    public struct ComponentPropertyBindingProperties: Swift.Equatable {
        /// The data field to bind the property to.
        public var field: Swift.String?
        /// The component property to bind to the data field.
        /// This member is required.
        public var property: Swift.String?

        public init (
            field: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.field = field
            self.property = property
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case componentType
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Contains a summary of a component. This is a read-only data type that is returned by ListComponents.
    public struct ComponentSummary: Swift.Equatable {
        /// The unique ID of the Amplify app associated with the component.
        /// This member is required.
        public var appId: Swift.String?
        /// The component type.
        /// This member is required.
        public var componentType: Swift.String?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The unique ID of the component.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the component.
        /// This member is required.
        public var name: Swift.String?

        public init (
            appId: Swift.String? = nil,
            componentType: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.componentType = componentType
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUiBuilderClientTypes.ComponentVariant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overrides
        case variantValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentoverrides0) in overrides {
                try overridesContainer.encode(componentoverrides0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variantValues = variantValues {
            var variantValuesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variantValues)
            for (dictKey0, componentvariantvalues0) in variantValues {
                try variantValuesContainer.encode(componentvariantvalues0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variantValuesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variantValues)
        var variantValuesDecoded0: [Swift.String:Swift.String]? = nil
        if let variantValuesContainer = variantValuesContainer {
            variantValuesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in variantValuesContainer {
                if let string0 = string0 {
                    variantValuesDecoded0?[key0] = string0
                }
            }
        }
        variantValues = variantValuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the style configuration of a unique variation of a main component.
    public struct ComponentVariant: Swift.Equatable {
        /// The properties of the component variant that can be overriden when customizing an instance of the component.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// The combination of variants that comprise this variant.
        public var variantValues: [Swift.String:Swift.String]?

        public init (
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            variantValues: [Swift.String:Swift.String]? = nil
        )
        {
            self.overrides = overrides
            self.variantValues = variantValues
        }
    }

}

extension AmplifyUiBuilderClientTypes.CreateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case name
        case overrides
        case properties
        case sourceId
        case tags
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentbindingproperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentbindingproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchildlist0 in children {
                try childrenContainer.encode(componentchildlist0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentcollectionproperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentcollectionproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentoverrides0) in overrides {
                try overridesContainer.encode(componentoverrides0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentproperties0) in properties {
                try propertiesContainer.encode(componentproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariants0 in variants {
                try variantsContainer.encode(componentvariants0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUiBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUiBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUiBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Represents all of the information that is required to create a component.
    public struct CreateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        /// This member is required.
        public var bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// A list of child components that are instances of the main component.
        public var children: [AmplifyUiBuilderClientTypes.ComponentChild]?
        /// The data binding configuration for customizing a component's properties. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]?
        /// The component type. This can be an Amplify custom UI component or another custom component.
        /// This member is required.
        public var componentType: Swift.String?
        /// The name of the component
        /// This member is required.
        public var name: Swift.String?
        /// Describes the component properties that can be overriden to customize an instance of the component.
        /// This member is required.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        /// This member is required.
        public var properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// One or more key-value pairs to use when tagging the component data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of the unique variants of this component.
        /// This member is required.
        public var variants: [AmplifyUiBuilderClientTypes.ComponentVariant]?

        public init (
            bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUiBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil,
            sourceId: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            variants: [AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.sourceId = sourceId
            self.tags = tags
            self.variants = variants
        }
    }

}

public struct CreateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let componentToCreate = input.operationInput.componentToCreate {
                let componentToCreatedata = try encoder.encode(componentToCreate)
                let componentToCreatebody = ClientRuntime.HttpBody.data(componentToCreatedata)
                input.builder.withBody(componentToCreatebody)
            } else {
                let componentToCreatedata = try encoder.encode(input.operationInput)
                let componentToCreatebody = ClientRuntime.HttpBody.data(componentToCreatedata)
                input.builder.withBody(componentToCreatebody)
            }
        } catch let err {
            throw SdkError<CreateComponentOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentToCreate = componentToCreate {
            try encodeContainer.encode(componentToCreate, forKey: .componentToCreate)
        }
    }
}

extension CreateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientToken = clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension CreateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct CreateComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app to associate with the component.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// Represents the configuration of the component to create.
    /// This member is required.
    public var componentToCreate: AmplifyUiBuilderClientTypes.CreateComponentData?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        componentToCreate: AmplifyUiBuilderClientTypes.CreateComponentData? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.componentToCreate = componentToCreate
        self.environmentName = environmentName
    }
}

struct CreateComponentInputBody: Swift.Equatable {
    let componentToCreate: AmplifyUiBuilderClientTypes.CreateComponentData?
}

extension CreateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case componentToCreate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.CreateComponentData.self, forKey: .componentToCreate)
        componentToCreate = componentToCreateDecoded
    }
}

extension CreateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct CreateComponentOutputResponse: Swift.Equatable {
    /// Describes the configuration of the new component.
    public var entity: AmplifyUiBuilderClientTypes.Component?

    public init (
        entity: AmplifyUiBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateComponentOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUiBuilderClientTypes.Component?
}

extension CreateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUiBuilderClientTypes.CreateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalueslist0 in overrides {
                try overridesContainer.encode(themevalueslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalueslist0 in values {
                try valuesContainer.encode(themevalueslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Represents all of the information that is required to create a theme.
    public struct CreateThemeData: Swift.Equatable {
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize an instance of the theme.
        public var overrides: [AmplifyUiBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme data.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that denes the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUiBuilderClientTypes.ThemeValues]?

        public init (
            name: Swift.String? = nil,
            overrides: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

public struct CreateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<CreateThemeOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let themeToCreate = input.operationInput.themeToCreate {
                let themeToCreatedata = try encoder.encode(themeToCreate)
                let themeToCreatebody = ClientRuntime.HttpBody.data(themeToCreatedata)
                input.builder.withBody(themeToCreatebody)
            } else {
                let themeToCreatedata = try encoder.encode(input.operationInput)
                let themeToCreatebody = ClientRuntime.HttpBody.data(themeToCreatedata)
                input.builder.withBody(themeToCreatebody)
            }
        } catch let err {
            throw SdkError<CreateThemeOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension CreateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let themeToCreate = themeToCreate {
            try encodeContainer.encode(themeToCreate, forKey: .themeToCreate)
        }
    }
}

extension CreateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientToken = clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension CreateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct CreateThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// Represents the configuration of the theme to create.
    /// This member is required.
    public var themeToCreate: AmplifyUiBuilderClientTypes.CreateThemeData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        themeToCreate: AmplifyUiBuilderClientTypes.CreateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.themeToCreate = themeToCreate
    }
}

struct CreateThemeInputBody: Swift.Equatable {
    let themeToCreate: AmplifyUiBuilderClientTypes.CreateThemeData?
}

extension CreateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case themeToCreate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeToCreateDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.CreateThemeData.self, forKey: .themeToCreate)
        themeToCreate = themeToCreateDecoded
    }
}

extension CreateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct CreateThemeOutputResponse: Swift.Equatable {
    /// Describes the configuration of the new theme.
    public var entity: AmplifyUiBuilderClientTypes.Theme?

    public init (
        entity: AmplifyUiBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct CreateThemeOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUiBuilderClientTypes.Theme?
}

extension CreateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension DeleteComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct DeleteComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the component to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteComponentInputBody: Swift.Equatable {
}

extension DeleteComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Swift.Equatable {

}

extension DeleteThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct DeleteThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app associated with the theme to delete.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the theme to delete.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct DeleteThemeInputBody: Swift.Equatable {
}

extension DeleteThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThemeOutputResponse: Swift.Equatable {

}

public struct ExchangeCodeForTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExchangeCodeForTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<ExchangeCodeForTokenOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let request = input.operationInput.request {
                let requestdata = try encoder.encode(request)
                let requestbody = ClientRuntime.HttpBody.data(requestdata)
                input.builder.withBody(requestbody)
            } else {
                let requestdata = try encoder.encode(input.operationInput)
                let requestbody = ClientRuntime.HttpBody.data(requestdata)
                input.builder.withBody(requestbody)
            }
        } catch let err {
            throw SdkError<ExchangeCodeForTokenOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExchangeCodeForTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExchangeCodeForTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension ExchangeCodeForTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let request = request {
            try encodeContainer.encode(request, forKey: .request)
        }
    }
}

extension ExchangeCodeForTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())"
    }
}

public struct ExchangeCodeForTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUiBuilderClientTypes.TokenProviders?
    /// Describes the configuration of the request.
    /// This member is required.
    public var request: AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody?

    public init (
        provider: AmplifyUiBuilderClientTypes.TokenProviders? = nil,
        request: AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.request = request
    }
}

struct ExchangeCodeForTokenInputBody: Swift.Equatable {
    let request: AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody?
}

extension ExchangeCodeForTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case request
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody.self, forKey: .request)
        request = requestDecoded
    }
}

extension ExchangeCodeForTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExchangeCodeForTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExchangeCodeForTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExchangeCodeForTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenOutputResponse(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\", refreshToken: \"CONTENT_REDACTED\")"}
}

extension ExchangeCodeForTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExchangeCodeForTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
            self.refreshToken = output.refreshToken
        } else {
            self.accessToken = nil
            self.expiresIn = nil
            self.refreshToken = nil
        }
    }
}

public struct ExchangeCodeForTokenOutputResponse: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?
    /// The token to use to refresh a previously issued access token that might have expired.
    /// This member is required.
    public var refreshToken: Swift.String?

    public init (
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil,
        refreshToken: Swift.String? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
        self.refreshToken = refreshToken
    }
}

struct ExchangeCodeForTokenOutputResponseBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
    let refreshToken: Swift.String?
}

extension ExchangeCodeForTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
        case refreshToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
        let refreshTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .refreshToken)
        refreshToken = refreshTokenDecoded
    }
}

extension AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case redirectUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let redirectUri = redirectUri {
            try encodeContainer.encode(redirectUri, forKey: .redirectUri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let redirectUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .redirectUri)
        redirectUri = redirectUriDecoded
    }
}

extension AmplifyUiBuilderClientTypes.ExchangeCodeForTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExchangeCodeForTokenRequestBody(redirectUri: \(Swift.String(describing: redirectUri)), code: \"CONTENT_REDACTED\")"}
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the configuration of a request to exchange an access code for a token.
    public struct ExchangeCodeForTokenRequestBody: Swift.Equatable {
        /// The access code to send in the request.
        /// This member is required.
        public var code: Swift.String?
        /// The location of the application that will receive the access code.
        /// This member is required.
        public var redirectUri: Swift.String?

        public init (
            code: Swift.String? = nil,
            redirectUri: Swift.String? = nil
        )
        {
            self.code = code
            self.redirectUri = redirectUri
        }
    }

}

extension ExportComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ExportComponentsInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export components to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct ExportComponentsInputBody: Swift.Equatable {
}

extension ExportComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
        } else {
            self.entities = nil
        }
    }
}

public struct ExportComponentsOutputResponse: Swift.Equatable {
    /// Represents the configuration of the exported components.
    /// This member is required.
    public var entities: [AmplifyUiBuilderClientTypes.Component]?

    public init (
        entities: [AmplifyUiBuilderClientTypes.Component]? = nil
    )
    {
        self.entities = entities
    }
}

struct ExportComponentsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUiBuilderClientTypes.Component]?
}

extension ExportComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.Component?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUiBuilderClientTypes.Component]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUiBuilderClientTypes.Component]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension ExportThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/export/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ExportThemesInput: Swift.Equatable {
    /// The unique ID of the Amplify app to export the themes to.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
    }
}

struct ExportThemesInputBody: Swift.Equatable {
}

extension ExportThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ExportThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportThemesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
        } else {
            self.entities = nil
        }
    }
}

public struct ExportThemesOutputResponse: Swift.Equatable {
    /// Represents the configuration of the exported themes.
    /// This member is required.
    public var entities: [AmplifyUiBuilderClientTypes.Theme]?

    public init (
        entities: [AmplifyUiBuilderClientTypes.Theme]? = nil
    )
    {
        self.entities = entities
    }
}

struct ExportThemesOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUiBuilderClientTypes.Theme]?
}

extension ExportThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.Theme?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUiBuilderClientTypes.Theme]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUiBuilderClientTypes.Theme]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
    }
}

extension AmplifyUiBuilderClientTypes.FormBindingElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case element
        case property
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let element = element {
            try encodeContainer.encode(element, forKey: .element)
        }
        if let property = property {
            try encodeContainer.encode(property, forKey: .property)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let elementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .element)
        element = elementDecoded
        let propertyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .property)
        property = propertyDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes how to bind a component property to form data.
    public struct FormBindingElement: Swift.Equatable {
        /// The name of the component to retrieve a value from.
        /// This member is required.
        public var element: Swift.String?
        /// The property to retrieve a value from.
        /// This member is required.
        public var property: Swift.String?

        public init (
            element: Swift.String? = nil,
            property: Swift.String? = nil
        )
        {
            self.element = element
            self.property = property
        }
    }

}

extension GetComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct GetComponentInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID of the component.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetComponentInputBody: Swift.Equatable {
}

extension GetComponentInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.component = output
            } else {
                self.component = nil
            }
        } else {
            self.component = nil
        }
    }
}

public struct GetComponentOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the component.
    public var component: AmplifyUiBuilderClientTypes.Component?

    public init (
        component: AmplifyUiBuilderClientTypes.Component? = nil
    )
    {
        self.component = component
    }
}

struct GetComponentOutputResponseBody: Swift.Equatable {
    let component: AmplifyUiBuilderClientTypes.Component?
}

extension GetComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Component.self, forKey: .component)
        component = componentDecoded
    }
}

extension GetThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct GetThemeInput: Swift.Equatable {
    /// The unique ID of the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.id = id
    }
}

struct GetThemeInputBody: Swift.Equatable {
}

extension GetThemeInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.theme = output
            } else {
                self.theme = nil
            }
        } else {
            self.theme = nil
        }
    }
}

public struct GetThemeOutputResponse: Swift.Equatable {
    /// Represents the configuration settings for the theme.
    public var theme: AmplifyUiBuilderClientTypes.Theme?

    public init (
        theme: AmplifyUiBuilderClientTypes.Theme? = nil
    )
    {
        self.theme = theme
    }
}

struct GetThemeOutputResponseBody: Swift.Equatable {
    let theme: AmplifyUiBuilderClientTypes.Theme?
}

extension GetThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case theme
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let themeDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Theme.self, forKey: .theme)
        theme = themeDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal error has occurred. Please retry your request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An invalid or out-of-range value was supplied for the input parameter.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListComponentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components"
    }
}

public struct ListComponentsInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of components to retrieve.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListComponentsInputBody: Swift.Equatable {
}

extension ListComponentsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListComponentsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Swift.Equatable {
    /// The list of components for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUiBuilderClientTypes.ComponentSummary]?
    /// The pagination token that's included if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUiBuilderClientTypes.ComponentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUiBuilderClientTypes.ComponentSummary]?
    let nextToken: Swift.String?
}

extension ListComponentsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUiBuilderClientTypes.ComponentSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUiBuilderClientTypes.ComponentSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListThemesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListThemesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes"
    }
}

public struct ListThemesInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The name of the backend environment that is a part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The maximum number of theme results to return in the response.
    public var maxResults: Swift.Int
    /// The token to request the next page of results.
    public var nextToken: Swift.String?

    public init (
        appId: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.appId = appId
        self.environmentName = environmentName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThemesInputBody: Swift.Equatable {
}

extension ListThemesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThemesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThemesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListThemesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThemesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListThemesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct ListThemesOutputResponse: Swift.Equatable {
    /// The list of themes for the Amplify app.
    /// This member is required.
    public var entities: [AmplifyUiBuilderClientTypes.ThemeSummary]?
    /// The pagination token that's returned if more results are available.
    public var nextToken: Swift.String?

    public init (
        entities: [AmplifyUiBuilderClientTypes.ThemeSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct ListThemesOutputResponseBody: Swift.Equatable {
    let entities: [AmplifyUiBuilderClientTypes.ThemeSummary]?
    let nextToken: Swift.String?
}

extension ListThemesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeSummary?].self, forKey: .entities)
        var entitiesDecoded0:[AmplifyUiBuilderClientTypes.ThemeSummary]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeSummary]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AmplifyUiBuilderClientTypes.Predicate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case and
        case field
        case operand
        case `operator` = "operator"
        case or
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for predicatelist0 in and {
                try andContainer.encode(predicatelist0)
            }
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
        if let operand = operand {
            try encodeContainer.encode(operand, forKey: .operand)
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`, forKey: .`operator`)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for predicatelist0 in or {
                try orContainer.encode(predicatelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.Predicate?].self, forKey: .or)
        var orDecoded0:[AmplifyUiBuilderClientTypes.Predicate]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [AmplifyUiBuilderClientTypes.Predicate]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.Predicate?].self, forKey: .and)
        var andDecoded0:[AmplifyUiBuilderClientTypes.Predicate]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [AmplifyUiBuilderClientTypes.Predicate]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let operatorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operator)
        `operator` = operatorDecoded
        let operandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operand)
        operand = operandDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Stores information for generating Amplify DataStore queries. Use a Predicate to retrieve a subset of the data in a collection.
    public struct Predicate: Swift.Equatable {
        /// A list of predicates to combine logically.
        public var and: [AmplifyUiBuilderClientTypes.Predicate]?
        /// The field to query.
        public var field: Swift.String?
        /// The value to use when performing the evaluation.
        public var operand: Swift.String?
        /// The operator to use to perform the evaluation.
        public var `operator`: Swift.String?
        /// A list of predicates to combine logically.
        public var or: [AmplifyUiBuilderClientTypes.Predicate]?

        public init (
            and: [AmplifyUiBuilderClientTypes.Predicate]? = nil,
            field: Swift.String? = nil,
            operand: Swift.String? = nil,
            `operator`: Swift.String? = nil,
            or: [AmplifyUiBuilderClientTypes.Predicate]? = nil
        )
        {
            self.and = and
            self.field = field
            self.operand = operand
            self.`operator` = `operator`
            self.or = or
        }
    }

}

public struct RefreshTokenInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RefreshTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RefreshTokenInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<RefreshTokenOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let refreshTokenBody = input.operationInput.refreshTokenBody {
                let refreshTokenBodydata = try encoder.encode(refreshTokenBody)
                let refreshTokenBodybody = ClientRuntime.HttpBody.data(refreshTokenBodydata)
                input.builder.withBody(refreshTokenBodybody)
            } else {
                let refreshTokenBodydata = try encoder.encode(input.operationInput)
                let refreshTokenBodybody = ClientRuntime.HttpBody.data(refreshTokenBodydata)
                input.builder.withBody(refreshTokenBodybody)
            }
        } catch let err {
            throw SdkError<RefreshTokenOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RefreshTokenInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RefreshTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension RefreshTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let refreshTokenBody = refreshTokenBody {
            try encodeContainer.encode(refreshTokenBody, forKey: .refreshTokenBody)
        }
    }
}

extension RefreshTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let provider = provider else {
            return nil
        }
        return "/tokens/\(provider.rawValue.urlPercentEncoding())/refresh"
    }
}

public struct RefreshTokenInput: Swift.Equatable {
    /// The third-party provider for the token. The only valid value is figma.
    /// This member is required.
    public var provider: AmplifyUiBuilderClientTypes.TokenProviders?
    /// Information about the refresh token request.
    /// This member is required.
    public var refreshTokenBody: AmplifyUiBuilderClientTypes.RefreshTokenRequestBody?

    public init (
        provider: AmplifyUiBuilderClientTypes.TokenProviders? = nil,
        refreshTokenBody: AmplifyUiBuilderClientTypes.RefreshTokenRequestBody? = nil
    )
    {
        self.provider = provider
        self.refreshTokenBody = refreshTokenBody
    }
}

struct RefreshTokenInputBody: Swift.Equatable {
    let refreshTokenBody: AmplifyUiBuilderClientTypes.RefreshTokenRequestBody?
}

extension RefreshTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case refreshTokenBody
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let refreshTokenBodyDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.RefreshTokenRequestBody.self, forKey: .refreshTokenBody)
        refreshTokenBody = refreshTokenBodyDecoded
    }
}

extension RefreshTokenOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RefreshTokenOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RefreshTokenOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RefreshTokenOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenOutputResponse(expiresIn: \(Swift.String(describing: expiresIn)), accessToken: \"CONTENT_REDACTED\")"}
}

extension RefreshTokenOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RefreshTokenOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessToken = output.accessToken
            self.expiresIn = output.expiresIn
        } else {
            self.accessToken = nil
            self.expiresIn = nil
        }
    }
}

public struct RefreshTokenOutputResponse: Swift.Equatable {
    /// The access token.
    /// This member is required.
    public var accessToken: Swift.String?
    /// The date and time when the new access token expires.
    /// This member is required.
    public var expiresIn: Swift.Int?

    public init (
        accessToken: Swift.String? = nil,
        expiresIn: Swift.Int? = nil
    )
    {
        self.accessToken = accessToken
        self.expiresIn = expiresIn
    }
}

struct RefreshTokenOutputResponseBody: Swift.Equatable {
    let accessToken: Swift.String?
    let expiresIn: Swift.Int?
}

extension RefreshTokenOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessToken
        case expiresIn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessToken)
        accessToken = accessTokenDecoded
        let expiresInDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiresIn)
        expiresIn = expiresInDecoded
    }
}

extension AmplifyUiBuilderClientTypes.RefreshTokenRequestBody: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension AmplifyUiBuilderClientTypes.RefreshTokenRequestBody: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RefreshTokenRequestBody(token: \"CONTENT_REDACTED\")"}
}

extension AmplifyUiBuilderClientTypes {
    /// Describes a refresh token.
    public struct RefreshTokenRequestBody: Swift.Equatable {
        /// The token to use to refresh a previously issued access token that might have expired.
        /// This member is required.
        public var token: Swift.String?

        public init (
            token: Swift.String? = nil
        )
        {
            self.token = token
        }
    }

}

extension ResourceConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in the request conflicts with an existing resource.
public struct ResourceConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource does not exist, or access was denied.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You exceeded your service quota. Service quotas, also referred to as limits, are the maximum number of service resources or operations for your Amazon Web Services account.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    public enum SortDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortDirection] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortDirection(rawValue: rawValue) ?? SortDirection.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUiBuilderClientTypes.SortProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case direction
        case field
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let direction = direction {
            try encodeContainer.encode(direction.rawValue, forKey: .direction)
        }
        if let field = field {
            try encodeContainer.encode(field, forKey: .field)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .field)
        field = fieldDecoded
        let directionDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.SortDirection.self, forKey: .direction)
        direction = directionDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes how to sort the data that you bind to a component.
    public struct SortProperty: Swift.Equatable {
        /// The direction of the sort, either ascending or descending.
        /// This member is required.
        public var direction: AmplifyUiBuilderClientTypes.SortDirection?
        /// The field to perform the sort on.
        /// This member is required.
        public var field: Swift.String?

        public init (
            direction: AmplifyUiBuilderClientTypes.SortDirection? = nil,
            field: Swift.String? = nil
        )
        {
            self.direction = direction
            self.field = field
        }
    }

}

extension AmplifyUiBuilderClientTypes.Theme: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case createdAt
        case environmentName
        case id
        case modifiedAt
        case name
        case overrides
        case tags
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.iso8601WithoutFractionalSeconds(), forKey: .createdAt)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let modifiedAt = modifiedAt {
            try encodeContainer.encode(modifiedAt.iso8601WithoutFractionalSeconds(), forKey: .modifiedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalueslist0 in overrides {
                try overridesContainer.encode(themevalueslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalueslist0 in values {
                try valuesContainer.encode(themevalueslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        var createdAtDecoded: ClientRuntime.Date? = nil
        if let createdAtDateString = createdAtDateString {
            let createdAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            createdAtDecoded = createdAtFormatter.date(from: createdAtDateString)
        }
        createdAt = createdAtDecoded
        let modifiedAtDateString = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modifiedAt)
        var modifiedAtDecoded: ClientRuntime.Date? = nil
        if let modifiedAtDateString = modifiedAtDateString {
            let modifiedAtFormatter = ClientRuntime.DateFormatter.iso8601DateFormatterWithoutFractionalSeconds
            modifiedAtDecoded = modifiedAtFormatter.date(from: modifiedAtDateString)
        }
        modifiedAt = modifiedAtDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// A theme is a collection of style settings that apply globally to the components associated with an Amplify application.
    public struct Theme: Swift.Equatable {
        /// The unique ID for the Amplify app associated with the theme.
        /// This member is required.
        public var appId: Swift.String?
        /// The time that the theme was created.
        /// This member is required.
        public var createdAt: ClientRuntime.Date?
        /// The name of the backend environment that is a part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID for the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The time that the theme was modified.
        public var modifiedAt: ClientRuntime.Date?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize a theme.
        public var overrides: [AmplifyUiBuilderClientTypes.ThemeValues]?
        /// One or more key-value pairs to use when tagging the theme.
        public var tags: [Swift.String:Swift.String]?
        /// A list of key-value pairs that defines the properties of the theme.
        /// This member is required.
        public var values: [AmplifyUiBuilderClientTypes.ThemeValues]?

        public init (
            appId: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            values: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.appId = appId
            self.createdAt = createdAt
            self.environmentName = environmentName
            self.id = id
            self.modifiedAt = modifiedAt
            self.name = name
            self.overrides = overrides
            self.tags = tags
            self.values = values
        }
    }

}

extension AmplifyUiBuilderClientTypes.ThemeSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case environmentName
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let environmentName = environmentName {
            try encodeContainer.encode(environmentName, forKey: .environmentName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let environmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentName)
        environmentName = environmentNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the basic information about a theme.
    public struct ThemeSummary: Swift.Equatable {
        /// The unique ID for the app associated with the theme summary.
        /// This member is required.
        public var appId: Swift.String?
        /// The name of the backend environment that is part of the Amplify app.
        /// This member is required.
        public var environmentName: Swift.String?
        /// The ID of the theme.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the theme.
        /// This member is required.
        public var name: Swift.String?

        public init (
            appId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appId = appId
            self.environmentName = environmentName
            self.id = id
            self.name = name
        }
    }

}

extension AmplifyUiBuilderClientTypes.ThemeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case children
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for themevalueslist0 in children {
                try childrenContainer.encode(themevalueslist0)
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Describes the configuration of a theme's properties.
    public struct ThemeValue: Swift.Equatable {
        /// A list of key-value pairs that define the theme's properties.
        public var children: [AmplifyUiBuilderClientTypes.ThemeValues]?
        /// The value of a theme property.
        public var value: Swift.String?

        public init (
            children: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil,
            value: Swift.String? = nil
        )
        {
            self.children = children
            self.value = value
        }
    }

}

extension AmplifyUiBuilderClientTypes.ThemeValues: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.ThemeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AmplifyUiBuilderClientTypes {
    /// A key-value pair that defines a property of a theme.
    public struct ThemeValues: Swift.Equatable {
        /// The name of the property.
        public var key: Swift.String?
        /// The value of the property.
        public var value: AmplifyUiBuilderClientTypes.ThemeValue?

        public init (
            key: Swift.String? = nil,
            value: AmplifyUiBuilderClientTypes.ThemeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AmplifyUiBuilderClientTypes {
    public enum TokenProviders: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The figma token provider.
        case figma
        case sdkUnknown(Swift.String)

        public static var allCases: [TokenProviders] {
            return [
                .figma,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .figma: return "figma"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TokenProviders(rawValue: rawValue) ?? TokenProviders.sdkUnknown(rawValue)
        }
    }
}

extension AmplifyUiBuilderClientTypes.UpdateComponentData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bindingProperties
        case children
        case collectionProperties
        case componentType
        case id
        case name
        case overrides
        case properties
        case sourceId
        case variants
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bindingProperties = bindingProperties {
            var bindingPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .bindingProperties)
            for (dictKey0, componentbindingproperties0) in bindingProperties {
                try bindingPropertiesContainer.encode(componentbindingproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let children = children {
            var childrenContainer = encodeContainer.nestedUnkeyedContainer(forKey: .children)
            for componentchildlist0 in children {
                try childrenContainer.encode(componentchildlist0)
            }
        }
        if let collectionProperties = collectionProperties {
            var collectionPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .collectionProperties)
            for (dictKey0, componentcollectionproperties0) in collectionProperties {
                try collectionPropertiesContainer.encode(componentcollectionproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let componentType = componentType {
            try encodeContainer.encode(componentType, forKey: .componentType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .overrides)
            for (dictKey0, componentoverrides0) in overrides {
                try overridesContainer.encode(componentoverrides0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .properties)
            for (dictKey0, componentproperties0) in properties {
                try propertiesContainer.encode(componentproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let variants = variants {
            var variantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variants)
            for componentvariants0 in variants {
                try variantsContainer.encode(componentvariants0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let componentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .componentType)
        componentType = componentTypeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentProperty?].self, forKey: .properties)
        var propertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]()
            for (key0, componentproperty0) in propertiesContainer {
                if let componentproperty0 = componentproperty0 {
                    propertiesDecoded0?[key0] = componentproperty0
                }
            }
        }
        properties = propertiesDecoded0
        let childrenContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentChild?].self, forKey: .children)
        var childrenDecoded0:[AmplifyUiBuilderClientTypes.ComponentChild]? = nil
        if let childrenContainer = childrenContainer {
            childrenDecoded0 = [AmplifyUiBuilderClientTypes.ComponentChild]()
            for structure0 in childrenContainer {
                if let structure0 = structure0 {
                    childrenDecoded0?.append(structure0)
                }
            }
        }
        children = childrenDecoded0
        let variantsContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ComponentVariant?].self, forKey: .variants)
        var variantsDecoded0:[AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        if let variantsContainer = variantsContainer {
            variantsDecoded0 = [AmplifyUiBuilderClientTypes.ComponentVariant]()
            for structure0 in variantsContainer {
                if let structure0 = structure0 {
                    variantsDecoded0?.append(structure0)
                }
            }
        }
        variants = variantsDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .overrides)
        var overridesDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, componentoverridesvalue0) in overridesContainer {
                var componentoverridesvalue0Decoded0: [Swift.String: Swift.String]? = nil
                if let componentoverridesvalue0 = componentoverridesvalue0 {
                    componentoverridesvalue0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, string1) in componentoverridesvalue0 {
                        if let string1 = string1 {
                            componentoverridesvalue0Decoded0?[key1] = string1
                        }
                    }
                }
                overridesDecoded0?[key0] = componentoverridesvalue0Decoded0
            }
        }
        overrides = overridesDecoded0
        let bindingPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue?].self, forKey: .bindingProperties)
        var bindingPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil
        if let bindingPropertiesContainer = bindingPropertiesContainer {
            bindingPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]()
            for (key0, componentbindingpropertiesvalue0) in bindingPropertiesContainer {
                if let componentbindingpropertiesvalue0 = componentbindingpropertiesvalue0 {
                    bindingPropertiesDecoded0?[key0] = componentbindingpropertiesvalue0
                }
            }
        }
        bindingProperties = bindingPropertiesDecoded0
        let collectionPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: AmplifyUiBuilderClientTypes.ComponentDataConfiguration?].self, forKey: .collectionProperties)
        var collectionPropertiesDecoded0: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil
        if let collectionPropertiesContainer = collectionPropertiesContainer {
            collectionPropertiesDecoded0 = [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]()
            for (key0, componentdataconfiguration0) in collectionPropertiesContainer {
                if let componentdataconfiguration0 = componentdataconfiguration0 {
                    collectionPropertiesDecoded0?[key0] = componentdataconfiguration0
                }
            }
        }
        collectionProperties = collectionPropertiesDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Updates and saves all of the information about a component, based on component ID.
    public struct UpdateComponentData: Swift.Equatable {
        /// The data binding information for the component's properties.
        public var bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]?
        /// The components that are instances of the main component.
        public var children: [AmplifyUiBuilderClientTypes.ComponentChild]?
        /// The configuration for binding a component's properties to a data model. Use this for a collection component.
        public var collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]?
        /// The type of the component. This can be an Amplify custom UI component or another custom component.
        public var componentType: Swift.String?
        /// The unique ID of the component to update.
        public var id: Swift.String?
        /// The name of the component to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the component.
        public var overrides: [Swift.String:[Swift.String:Swift.String]]?
        /// Describes the component's properties.
        public var properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]?
        /// The unique ID of the component in its original source system, such as Figma.
        public var sourceId: Swift.String?
        /// A list of the unique variants of the main component being updated.
        public var variants: [AmplifyUiBuilderClientTypes.ComponentVariant]?

        public init (
            bindingProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentBindingPropertiesValue]? = nil,
            children: [AmplifyUiBuilderClientTypes.ComponentChild]? = nil,
            collectionProperties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentDataConfiguration]? = nil,
            componentType: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [Swift.String:[Swift.String:Swift.String]]? = nil,
            properties: [Swift.String:AmplifyUiBuilderClientTypes.ComponentProperty]? = nil,
            sourceId: Swift.String? = nil,
            variants: [AmplifyUiBuilderClientTypes.ComponentVariant]? = nil
        )
        {
            self.bindingProperties = bindingProperties
            self.children = children
            self.collectionProperties = collectionProperties
            self.componentType = componentType
            self.id = id
            self.name = name
            self.overrides = overrides
            self.properties = properties
            self.sourceId = sourceId
            self.variants = variants
        }
    }

}

public struct UpdateComponentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateComponentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateComponentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedComponent = input.operationInput.updatedComponent {
                let updatedComponentdata = try encoder.encode(updatedComponent)
                let updatedComponentbody = ClientRuntime.HttpBody.data(updatedComponentdata)
                input.builder.withBody(updatedComponentbody)
            } else {
                let updatedComponentdata = try encoder.encode(input.operationInput)
                let updatedComponentbody = ClientRuntime.HttpBody.data(updatedComponentdata)
                input.builder.withBody(updatedComponentbody)
            }
        } catch let err {
            throw SdkError<UpdateComponentOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateComponentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedComponent = updatedComponent {
            try encodeContainer.encode(updatedComponent, forKey: .updatedComponent)
        }
    }
}

extension UpdateComponentInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientToken = clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdateComponentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/components/\(id.urlPercentEncoding())"
    }
}

public struct UpdateComponentInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the component.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated component.
    /// This member is required.
    public var updatedComponent: AmplifyUiBuilderClientTypes.UpdateComponentData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedComponent: AmplifyUiBuilderClientTypes.UpdateComponentData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedComponent = updatedComponent
    }
}

struct UpdateComponentInputBody: Swift.Equatable {
    let updatedComponent: AmplifyUiBuilderClientTypes.UpdateComponentData?
}

extension UpdateComponentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedComponent
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedComponentDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.UpdateComponentData.self, forKey: .updatedComponent)
        updatedComponent = updatedComponentDecoded
    }
}

extension UpdateComponentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateComponentOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Component = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateComponentOutputResponse: Swift.Equatable {
    /// Describes the configuration of the updated component.
    public var entity: AmplifyUiBuilderClientTypes.Component?

    public init (
        entity: AmplifyUiBuilderClientTypes.Component? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateComponentOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUiBuilderClientTypes.Component?
}

extension UpdateComponentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Component.self, forKey: .entity)
        entity = entityDecoded
    }
}

extension AmplifyUiBuilderClientTypes.UpdateThemeData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case overrides
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for themevalueslist0 in overrides {
                try overridesContainer.encode(themevalueslist0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for themevalueslist0 in values {
                try valuesContainer.encode(themevalueslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .values)
        var valuesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
        let overridesContainer = try containerValues.decodeIfPresent([AmplifyUiBuilderClientTypes.ThemeValues?].self, forKey: .overrides)
        var overridesDecoded0:[AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [AmplifyUiBuilderClientTypes.ThemeValues]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
    }
}

extension AmplifyUiBuilderClientTypes {
    /// Saves the data binding information for a theme.
    public struct UpdateThemeData: Swift.Equatable {
        /// The unique ID of the theme to update.
        public var id: Swift.String?
        /// The name of the theme to update.
        public var name: Swift.String?
        /// Describes the properties that can be overriden to customize the theme.
        public var overrides: [AmplifyUiBuilderClientTypes.ThemeValues]?
        /// A list of key-value pairs that define the theme's properties.
        /// This member is required.
        public var values: [AmplifyUiBuilderClientTypes.ThemeValues]?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            overrides: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil,
            values: [AmplifyUiBuilderClientTypes.ThemeValues]? = nil
        )
        {
            self.id = id
            self.name = name
            self.overrides = overrides
            self.values = values
        }
    }

}

public struct UpdateThemeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateThemeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateThemeInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<UpdateThemeOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        do {
            let encoder = context.getEncoder()
            if let updatedTheme = input.operationInput.updatedTheme {
                let updatedThemedata = try encoder.encode(updatedTheme)
                let updatedThemebody = ClientRuntime.HttpBody.data(updatedThemedata)
                input.builder.withBody(updatedThemebody)
            } else {
                let updatedThemedata = try encoder.encode(input.operationInput)
                let updatedThemebody = ClientRuntime.HttpBody.data(updatedThemedata)
                input.builder.withBody(updatedThemebody)
            }
        } catch let err {
            throw SdkError<UpdateThemeOutputError>.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription))
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateThemeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateThemeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension UpdateThemeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updatedTheme = updatedTheme {
            try encodeContainer.encode(updatedTheme, forKey: .updatedTheme)
        }
    }
}

extension UpdateThemeInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let clientToken = clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension UpdateThemeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appId = appId else {
            return nil
        }
        guard let environmentName = environmentName else {
            return nil
        }
        guard let id = id else {
            return nil
        }
        return "/app/\(appId.urlPercentEncoding())/environment/\(environmentName.urlPercentEncoding())/themes/\(id.urlPercentEncoding())"
    }
}

public struct UpdateThemeInput: Swift.Equatable {
    /// The unique ID for the Amplify app.
    /// This member is required.
    public var appId: Swift.String?
    /// The unique client token.
    public var clientToken: Swift.String?
    /// The name of the backend environment that is part of the Amplify app.
    /// This member is required.
    public var environmentName: Swift.String?
    /// The unique ID for the theme.
    /// This member is required.
    public var id: Swift.String?
    /// The configuration of the updated theme.
    /// This member is required.
    public var updatedTheme: AmplifyUiBuilderClientTypes.UpdateThemeData?

    public init (
        appId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentName: Swift.String? = nil,
        id: Swift.String? = nil,
        updatedTheme: AmplifyUiBuilderClientTypes.UpdateThemeData? = nil
    )
    {
        self.appId = appId
        self.clientToken = clientToken
        self.environmentName = environmentName
        self.id = id
        self.updatedTheme = updatedTheme
    }
}

struct UpdateThemeInputBody: Swift.Equatable {
    let updatedTheme: AmplifyUiBuilderClientTypes.UpdateThemeData?
}

extension UpdateThemeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case updatedTheme
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updatedThemeDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.UpdateThemeData.self, forKey: .updatedTheme)
        updatedTheme = updatedThemeDecoded
    }
}

extension UpdateThemeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThemeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateThemeOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case invalidParameterException(InvalidParameterException)
    case resourceConflictException(ResourceConflictException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThemeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body {
            let data = reader.toBytes().toData()
            if let responseDecoder = decoder {
                let output: AmplifyUiBuilderClientTypes.Theme = try responseDecoder.decode(responseBody: data)
                self.entity = output
            } else {
                self.entity = nil
            }
        } else {
            self.entity = nil
        }
    }
}

public struct UpdateThemeOutputResponse: Swift.Equatable {
    /// Describes the configuration of the updated theme.
    public var entity: AmplifyUiBuilderClientTypes.Theme?

    public init (
        entity: AmplifyUiBuilderClientTypes.Theme? = nil
    )
    {
        self.entity = entity
    }
}

struct UpdateThemeOutputResponseBody: Swift.Equatable {
    let entity: AmplifyUiBuilderClientTypes.Theme?
}

extension UpdateThemeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entity
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityDecoded = try containerValues.decodeIfPresent(AmplifyUiBuilderClientTypes.Theme.self, forKey: .entity)
        entity = entityDecoded
    }
}
