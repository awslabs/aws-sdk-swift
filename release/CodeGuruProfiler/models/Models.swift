// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum ActionGroup {
    /// Permission group type for Agent APIs - ConfigureAgent, PostAgentProfile
    case agentPermissions
    case sdkUnknown(String)
}

extension ActionGroup : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionGroup] {
        return [
            .agentPermissions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentPermissions: return "agentPermissions"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionGroup(rawValue: rawValue) ?? ActionGroup.sdkUnknown(rawValue)
    }
}

public struct AddNotificationChannelsInputBodyMiddleware: Middleware {
    public let id: String = "AddNotificationChannelsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelsOutputError>
}

extension AddNotificationChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddNotificationChannelsInput(channels: \(String(describing: channels)), profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension AddNotificationChannelsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channels
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0)
            }
        }
    }
}

public struct AddNotificationChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "AddNotificationChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelsOutputError>
}

public struct AddNotificationChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddNotificationChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddNotificationChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddNotificationChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddNotificationChannelsInput>
    public typealias MOutput = OperationOutput<AddNotificationChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddNotificationChannelsOutputError>
}

/// <p>The structure representing the AddNotificationChannelsRequest.</p>
public struct AddNotificationChannelsInput: Equatable {
    /// <p>One or 2 channels to report to when anomalies are detected.</p>
    public let channels: Set<Channel>?
    /// <p>The name of the profiling group that we are setting up notifications for.</p>
    public let profilingGroupName: String?

    public init (
        channels: Set<Channel>? = nil,
        profilingGroupName: String? = nil
    )
    {
        self.channels = channels
        self.profilingGroupName = profilingGroupName
    }
}

struct AddNotificationChannelsInputBody: Equatable {
    public let channels: Set<Channel>?
}

extension AddNotificationChannelsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channels
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent(Set<Channel>.self, forKey: .channels)
        var channelsDecoded0:Set<Channel>? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = Set<Channel>()
            for structure0 in channelsContainer {
                channelsDecoded0?.insert(structure0)
            }
        }
        channels = channelsDecoded0
    }
}

extension AddNotificationChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddNotificationChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddNotificationChannelsOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddNotificationChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddNotificationChannelsOutputResponse(notificationConfiguration: \(String(describing: notificationConfiguration)))"}
}

extension AddNotificationChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddNotificationChannelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the AddNotificationChannelsResponse.</p>
public struct AddNotificationChannelsOutputResponse: Equatable {
    /// <p>The new notification configuration for this profiling group.</p>
    public let notificationConfiguration: NotificationConfiguration?

    public init (
        notificationConfiguration: NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct AddNotificationChannelsOutputResponseBody: Equatable {
    public let notificationConfiguration: NotificationConfiguration?
}

extension AddNotificationChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension AgentConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentParameters
        case periodInSeconds
        case shouldProfile
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentParameters = agentParameters {
            var agentParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .agentParameters)
            for (dictKey0, agentparameters0) in agentParameters {
                try agentParametersContainer.encode(agentparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let periodInSeconds = periodInSeconds {
            try encodeContainer.encode(periodInSeconds, forKey: .periodInSeconds)
        }
        if let shouldProfile = shouldProfile {
            try encodeContainer.encode(shouldProfile, forKey: .shouldProfile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let shouldProfileDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .shouldProfile)
        shouldProfile = shouldProfileDecoded
        let periodInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .periodInSeconds)
        periodInSeconds = periodInSecondsDecoded
        let agentParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .agentParameters)
        var agentParametersDecoded0: [String:String]? = nil
        if let agentParametersContainer = agentParametersContainer {
            agentParametersDecoded0 = [String:String]()
            for (key0, string0) in agentParametersContainer {
                if let string0 = string0 {
                    agentParametersDecoded0?[key0] = string0
                }
            }
        }
        agentParameters = agentParametersDecoded0
    }
}

extension AgentConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentConfiguration(agentParameters: \(String(describing: agentParameters)), periodInSeconds: \(String(describing: periodInSeconds)), shouldProfile: \(String(describing: shouldProfile)))"}
}

/// <p>
///          The response of <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
///                <code>ConfigureAgent</code>
///             </a> that
///          specifies if an agent profiles or not and for how long to return profiling data.
///       </p>
public struct AgentConfiguration: Equatable {
    /// <p>
    ///          Parameters used by the profiler. The valid parameters are:
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>MaxStackDepth</code> - The maximum depth of the stacks in the code that is represented in
    ///                the profile. For example, if CodeGuru Profiler finds a method <code>A</code>,
    ///                which calls method <code>B</code>, which calls method <code>C</code>, which
    ///                calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is
    ///                set to 2, then the profiler evaluates <code>A</code> and <code>B</code>.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MemoryUsageLimitPercent</code> - The percentage of memory that is used by the
    ///                profiler.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>MinimumTimeForReportingInMilliseconds</code> - The minimum time in milliseconds between
    ///                sending reports.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReportingIntervalInMilliseconds</code> - The reporting interval in milliseconds used
    ///                to report profiles.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SamplingIntervalInMilliseconds</code> - The sampling interval in milliseconds that is used to
    ///                profile samples.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let agentParameters: [String:String]?
    /// <p>
    ///          How long a profiling agent should send profiling data using
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
    ///                <code>ConfigureAgent</code>
    ///             </a>.
    ///          For example, if this is set to 300, the profiling agent calls <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
    ///                <code>ConfigureAgent</code>
    ///             </a>
    ///          every 5 minutes to submit the profiled data collected during that period.
    ///       </p>
    public let periodInSeconds: Int?
    /// <p>
    ///          A <code>Boolean</code> that specifies whether the profiling agent collects profiling data or not. Set to <code>true</code>
    ///         to enable profiling.
    ///       </p>
    public let shouldProfile: Bool?

    public init (
        agentParameters: [String:String]? = nil,
        periodInSeconds: Int? = nil,
        shouldProfile: Bool? = nil
    )
    {
        self.agentParameters = agentParameters
        self.periodInSeconds = periodInSeconds
        self.shouldProfile = shouldProfile
    }
}

extension AgentOrchestrationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case profilingEnabled
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profilingEnabled = profilingEnabled {
            try encodeContainer.encode(profilingEnabled, forKey: .profilingEnabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .profilingEnabled)
        profilingEnabled = profilingEnabledDecoded
    }
}

extension AgentOrchestrationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentOrchestrationConfig(profilingEnabled: \(String(describing: profilingEnabled)))"}
}

/// <p>
///          Specifies whether profiling is enabled or disabled for a profiling group. It
///          is used by <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ConfigureAgent.html">
///                <code>ConfigureAgent</code>
///             </a>
///          to enable or disable profiling for a profiling group.
///       </p>
public struct AgentOrchestrationConfig: Equatable {
    /// <p>
    ///          A <code>Boolean</code> that specifies whether the profiling agent collects profiling data or not. Set to <code>true</code>
    ///          to enable profiling.
    ///       </p>
    public let profilingEnabled: Bool?

    public init (
        profilingEnabled: Bool? = nil
    )
    {
        self.profilingEnabled = profilingEnabled
    }
}

public enum AgentParameterField {
    /// Maximum stack depth to be captured by the CodeGuru Profiler.
    case maxStackDepth
    /// Percentage of memory to be used by CodeGuru profiler. Minimum of 30MB is required for the agent.
    case memoryUsageLimitPercent
    /// Minimum time in milliseconds between sending reports.
    case minimumTimeForReportingInMilliseconds
    /// Reporting interval in milliseconds used to report profiles.
    case reportingIntervalInMilliseconds
    /// Sampling interval in milliseconds used to sample profiles.
    case samplingIntervalInMilliseconds
    case sdkUnknown(String)
}

extension AgentParameterField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AgentParameterField] {
        return [
            .maxStackDepth,
            .memoryUsageLimitPercent,
            .minimumTimeForReportingInMilliseconds,
            .reportingIntervalInMilliseconds,
            .samplingIntervalInMilliseconds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .maxStackDepth: return "MaxStackDepth"
        case .memoryUsageLimitPercent: return "MemoryUsageLimitPercent"
        case .minimumTimeForReportingInMilliseconds: return "MinimumTimeForReportingInMilliseconds"
        case .reportingIntervalInMilliseconds: return "ReportingIntervalInMilliseconds"
        case .samplingIntervalInMilliseconds: return "SamplingIntervalInMilliseconds"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AgentParameterField(rawValue: rawValue) ?? AgentParameterField.sdkUnknown(rawValue)
    }
}

extension AggregatedProfileTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case period
        case start
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let period = period {
            try encodeContainer.encode(period.rawValue, forKey: .period)
        }
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .start)
        start = startDecoded
        let periodDecoded = try containerValues.decodeIfPresent(AggregationPeriod.self, forKey: .period)
        period = periodDecoded
    }
}

extension AggregatedProfileTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AggregatedProfileTime(period: \(String(describing: period)), start: \(String(describing: start)))"}
}

/// <p>
///          Specifies the aggregation period and aggregation start time for
///          an aggregated profile. An aggregated profile is used to collect posted agent profiles
///          during an aggregation period. There are three possible aggregation periods (1 day,
///          1 hour, or 5 minutes).
///       </p>
public struct AggregatedProfileTime: Equatable {
    /// <p>
    ///          The aggregation period. This indicates the period during which an aggregation profile
    ///          collects posted agent profiles for a profiling group. Use one of three valid
    ///          durations that are specified using the ISO 8601 format.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let period: AggregationPeriod?
    /// <p>
    ///          The time that aggregation of posted agent profiles for a profiling group starts. The aggregation profile
    ///          contains profiles posted by the agent starting at this time for an aggregation period
    ///          specified by the <code>period</code> property of the <code>AggregatedProfileTime</code>
    ///          object.
    ///       </p>
    ///          <p>
    ///          Specify <code>start</code> using the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let start: Date?

    public init (
        period: AggregationPeriod? = nil,
        start: Date? = nil
    )
    {
        self.period = period
        self.start = start
    }
}

public enum AggregationPeriod {
    /// Period of one day.
    case p1d
    /// Period of one hour.
    case pt1h
    /// Period of five minutes.
    case pt5m
    case sdkUnknown(String)
}

extension AggregationPeriod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AggregationPeriod] {
        return [
            .p1d,
            .pt1h,
            .pt5m,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .p1d: return "P1D"
        case .pt1h: return "PT1H"
        case .pt5m: return "PT5M"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AggregationPeriod(rawValue: rawValue) ?? AggregationPeriod.sdkUnknown(rawValue)
    }
}

extension Anomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instances
        case metric
        case reason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instances = instances {
            var instancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instances)
            for anomalyinstances0 in instances {
                try instancesContainer.encode(anomalyinstances0)
            }
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Metric.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
        let instancesContainer = try containerValues.decodeIfPresent([AnomalyInstance?].self, forKey: .instances)
        var instancesDecoded0:[AnomalyInstance]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [AnomalyInstance]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
    }
}

extension Anomaly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Anomaly(instances: \(String(describing: instances)), metric: \(String(describing: metric)), reason: \(String(describing: reason)))"}
}

/// <p>
///             Details about an anomaly in a specific metric of application profile. The anomaly is detected using
///             analysis of the metric data over a period of time.
///         </p>
public struct Anomaly: Equatable {
    /// <p>
    ///             A list of the instances of the detected anomalies during the requested period.
    ///         </p>
    public let instances: [AnomalyInstance]?
    /// <p>
    ///             Details about the metric that the analysis used when it detected the anomaly.
    ///             The metric includes the name of the frame that was analyzed with the type and
    ///             thread states used to derive the metric value for that frame.
    ///         </p>
    public let metric: Metric?
    /// <p>The reason for which metric was flagged as anomalous.</p>
    public let reason: String?

    public init (
        instances: [AnomalyInstance]? = nil,
        metric: Metric? = nil,
        reason: String? = nil
    )
    {
        self.instances = instances
        self.metric = metric
        self.reason = reason
    }
}

extension AnomalyInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case id
        case startTime
        case userFeedback
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let userFeedback = userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(UserFeedback.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
    }
}

extension AnomalyInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyInstance(endTime: \(String(describing: endTime)), id: \(String(describing: id)), startTime: \(String(describing: startTime)), userFeedback: \(String(describing: userFeedback)))"}
}

/// <p>The specific duration in which the metric is flagged as anomalous.</p>
public struct AnomalyInstance: Equatable {
    /// <p>
    ///             The end time of the period during which the metric is flagged as anomalous.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let endTime: Date?
    /// <p>
    ///             The universally unique identifier (UUID) of an instance of an anomaly in a metric.
    ///         </p>
    public let id: String?
    /// <p>
    ///             The start time of the period during which the metric is flagged as anomalous.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let startTime: Date?
    /// <p>Feedback type on a specific instance of anomaly submitted by the user.</p>
    public let userFeedback: UserFeedback?

    public init (
        endTime: Date? = nil,
        id: String? = nil,
        startTime: Date? = nil,
        userFeedback: UserFeedback? = nil
    )
    {
        self.endTime = endTime
        self.id = id
        self.startTime = startTime
        self.userFeedback = userFeedback
    }
}

public struct BatchGetFrameMetricDataInputBodyMiddleware: Middleware {
    public let id: String = "BatchGetFrameMetricDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetFrameMetricDataOutputError>
}

extension BatchGetFrameMetricDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetFrameMetricDataInput(endTime: \(String(describing: endTime)), frameMetrics: \(String(describing: frameMetrics)), period: \(String(describing: period)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)), targetResolution: \(String(describing: targetResolution)))"}
}

extension BatchGetFrameMetricDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frameMetrics
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetrics = frameMetrics {
            var frameMetricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .frameMetrics)
            for framemetrics0 in frameMetrics {
                try frameMetricsContainer.encode(framemetrics0)
            }
        }
    }
}

public struct BatchGetFrameMetricDataInputHeadersMiddleware: Middleware {
    public let id: String = "BatchGetFrameMetricDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetFrameMetricDataOutputError>
}

public struct BatchGetFrameMetricDataInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchGetFrameMetricDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchGetFrameMetricDataInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchGetFrameMetricDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let period = input.operationInput.period {
            let periodQueryItem = URLQueryItem(name: "period".urlPercentEncoding(), value: String(period).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let targetResolution = input.operationInput.targetResolution {
            let targetResolutionQueryItem = URLQueryItem(name: "targetResolution".urlPercentEncoding(), value: String(targetResolution.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(targetResolutionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchGetFrameMetricDataInput>
    public typealias MOutput = OperationOutput<BatchGetFrameMetricDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchGetFrameMetricDataOutputError>
}

/// <p>The structure representing the BatchGetFrameMetricDataRequest.</p>
public struct BatchGetFrameMetricDataInput: Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: Date?
    /// <p>
    ///          The details of the metrics that are used to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the
    ///          frame, and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetrics: [FrameMetric]?
    /// <p>
    ///          The duration of the frame metrics used to return the time series values.
    ///          Specify using the ISO 8601 format. The maximum period duration
    ///          is one day (<code>PT24H</code> or <code>P1D</code>).
    ///       </p>
    public let period: String?
    /// <p>
    ///          The name of the profiling group associated with the
    ///          the frame metrics used to return the time series values.
    ///       </p>
    public let profilingGroupName: String?
    /// <p>
    ///          The start time of the time period for the frame metrics used to return the time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: Date?
    /// <p>The requested resolution of time steps for the returned time series of values.
    ///          If the requested target resolution is not available due to data not being retained we provide a best effort
    ///          result by falling back to the most granular available resolution after the target resolution.
    ///          There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let targetResolution: AggregationPeriod?

    public init (
        endTime: Date? = nil,
        frameMetrics: [FrameMetric]? = nil,
        period: String? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil,
        targetResolution: AggregationPeriod? = nil
    )
    {
        self.endTime = endTime
        self.frameMetrics = frameMetrics
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
        self.targetResolution = targetResolution
    }
}

struct BatchGetFrameMetricDataInputBody: Equatable {
    public let frameMetrics: [FrameMetric]?
}

extension BatchGetFrameMetricDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case frameMetrics
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricsContainer = try containerValues.decodeIfPresent([FrameMetric?].self, forKey: .frameMetrics)
        var frameMetricsDecoded0:[FrameMetric]? = nil
        if let frameMetricsContainer = frameMetricsContainer {
            frameMetricsDecoded0 = [FrameMetric]()
            for structure0 in frameMetricsContainer {
                if let structure0 = structure0 {
                    frameMetricsDecoded0?.append(structure0)
                }
            }
        }
        frameMetrics = frameMetricsDecoded0
    }
}

extension BatchGetFrameMetricDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetFrameMetricDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchGetFrameMetricDataOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetFrameMetricDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchGetFrameMetricDataOutputResponse(endTime: \(String(describing: endTime)), endTimes: \(String(describing: endTimes)), frameMetricData: \(String(describing: frameMetricData)), resolution: \(String(describing: resolution)), startTime: \(String(describing: startTime)), unprocessedEndTimes: \(String(describing: unprocessedEndTimes)))"}
}

extension BatchGetFrameMetricDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchGetFrameMetricDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.endTimes = output.endTimes
            self.frameMetricData = output.frameMetricData
            self.resolution = output.resolution
            self.startTime = output.startTime
            self.unprocessedEndTimes = output.unprocessedEndTimes
        } else {
            self.endTime = nil
            self.endTimes = nil
            self.frameMetricData = nil
            self.resolution = nil
            self.startTime = nil
            self.unprocessedEndTimes = nil
        }
    }
}

/// <p>The structure representing the BatchGetFrameMetricDataResponse.</p>
public struct BatchGetFrameMetricDataOutputResponse: Equatable {
    /// <p>
    ///          The end time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let endTime: Date?
    /// <p>
    ///          List of instances, or time steps, in the time series. For example, if the
    ///          <code>period</code> is one day (<code>PT24H)</code>), and the <code>resolution</code>
    ///          is five minutes (<code>PT5M</code>), then there are 288 <code>endTimes</code> in the
    ///          list that are each five minutes appart.
    ///       </p>
    public let endTimes: [TimestampStructure]?
    /// <p>Details of the metrics to request a time series of values. The metric includes
    ///          the name of the frame, the aggregation type to calculate the metric value for the frame,
    ///          and the thread states to use to get the count for the metric value of the frame.</p>
    public let frameMetricData: [FrameMetricDatum]?
    /// <p>Resolution or granularity of the profile data used to generate the time series.
    ///          This is the value used to jump through time steps in a time series. There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let resolution: AggregationPeriod?
    /// <p>
    ///          The start time of the time period for the returned time series values.
    ///          This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let startTime: Date?
    /// <p>List of instances which remained unprocessed. This will create a missing time step in the list of end times.</p>
    public let unprocessedEndTimes: [String:[TimestampStructure]]?

    public init (
        endTime: Date? = nil,
        endTimes: [TimestampStructure]? = nil,
        frameMetricData: [FrameMetricDatum]? = nil,
        resolution: AggregationPeriod? = nil,
        startTime: Date? = nil,
        unprocessedEndTimes: [String:[TimestampStructure]]? = nil
    )
    {
        self.endTime = endTime
        self.endTimes = endTimes
        self.frameMetricData = frameMetricData
        self.resolution = resolution
        self.startTime = startTime
        self.unprocessedEndTimes = unprocessedEndTimes
    }
}

struct BatchGetFrameMetricDataOutputResponseBody: Equatable {
    public let startTime: Date?
    public let endTime: Date?
    public let resolution: AggregationPeriod?
    public let endTimes: [TimestampStructure]?
    public let unprocessedEndTimes: [String:[TimestampStructure]]?
    public let frameMetricData: [FrameMetricDatum]?
}

extension BatchGetFrameMetricDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case endTimes
        case frameMetricData
        case resolution
        case startTime
        case unprocessedEndTimes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(AggregationPeriod.self, forKey: .resolution)
        resolution = resolutionDecoded
        let endTimesContainer = try containerValues.decodeIfPresent([TimestampStructure?].self, forKey: .endTimes)
        var endTimesDecoded0:[TimestampStructure]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [TimestampStructure]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let unprocessedEndTimesContainer = try containerValues.decodeIfPresent([String: [TimestampStructure?]?].self, forKey: .unprocessedEndTimes)
        var unprocessedEndTimesDecoded0: [String:[TimestampStructure]]? = nil
        if let unprocessedEndTimesContainer = unprocessedEndTimesContainer {
            unprocessedEndTimesDecoded0 = [String:[TimestampStructure]]()
            for (key0, listoftimestamps0) in unprocessedEndTimesContainer {
                var listoftimestamps0Decoded0: [TimestampStructure]? = nil
                if let listoftimestamps0 = listoftimestamps0 {
                    listoftimestamps0Decoded0 = [TimestampStructure]()
                    for structure1 in listoftimestamps0 {
                        if let structure1 = structure1 {
                            listoftimestamps0Decoded0?.append(structure1)
                        }
                    }
                }
                unprocessedEndTimesDecoded0?[key0] = listoftimestamps0Decoded0
            }
        }
        unprocessedEndTimes = unprocessedEndTimesDecoded0
        let frameMetricDataContainer = try containerValues.decodeIfPresent([FrameMetricDatum?].self, forKey: .frameMetricData)
        var frameMetricDataDecoded0:[FrameMetricDatum]? = nil
        if let frameMetricDataContainer = frameMetricDataContainer {
            frameMetricDataDecoded0 = [FrameMetricDatum]()
            for structure0 in frameMetricDataContainer {
                if let structure0 = structure0 {
                    frameMetricDataDecoded0?.append(structure0)
                }
            }
        }
        frameMetricData = frameMetricDataDecoded0
    }
}

extension Channel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventPublishers
        case id
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventPublishers = eventPublishers {
            var eventPublishersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventPublishers)
            for eventpublishers0 in eventPublishers {
                try eventPublishersContainer.encode(eventpublishers0.rawValue)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let uriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uri)
        uri = uriDecoded
        let eventPublishersContainer = try containerValues.decodeIfPresent(Set<EventPublisher>.self, forKey: .eventPublishers)
        var eventPublishersDecoded0:Set<EventPublisher>? = nil
        if let eventPublishersContainer = eventPublishersContainer {
            eventPublishersDecoded0 = Set<EventPublisher>()
            for string0 in eventPublishersContainer {
                eventPublishersDecoded0?.insert(string0)
            }
        }
        eventPublishers = eventPublishersDecoded0
    }
}

extension Channel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Channel(eventPublishers: \(String(describing: eventPublishers)), id: \(String(describing: id)), uri: \(String(describing: uri)))"}
}

/// <p>Notification medium for users to get alerted for events that occur in application profile. We support SNS topic as a notification channel.</p>
public struct Channel: Equatable, Hashable {
    /// <p>List of publishers for different type of events that may be detected in an application from the profile. Anomaly detection is the only event publisher in Profiler.</p>
    public let eventPublishers: Set<EventPublisher>?
    /// <p>Unique identifier for each <code>Channel</code> in the notification configuration of a Profiling Group. A random UUID for channelId is used when adding a channel to the notification configuration if not specified in the request.</p>
    public let id: String?
    /// <p>Unique arn of the resource to be used for notifications. We support a valid SNS topic arn as a channel uri.</p>
    public let uri: String?

    public init (
        eventPublishers: Set<EventPublisher>? = nil,
        id: String? = nil,
        uri: String? = nil
    )
    {
        self.eventPublishers = eventPublishers
        self.id = id
        self.uri = uri
    }
}

public enum ComputePlatform {
    /// Compute platform meant to used for AWS Lambda.
    case awslambda
    /// Compute platform meant to used for all usecases (like EC2, Fargate, physical servers etc.) but AWS Lambda.
    case `default`
    case sdkUnknown(String)
}

extension ComputePlatform : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ComputePlatform] {
        return [
            .awslambda,
            .default,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awslambda: return "AWSLambda"
        case .default: return "Default"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ComputePlatform(rawValue: rawValue) ?? ComputePlatform.sdkUnknown(rawValue)
    }
}

public struct ConfigureAgentInputBodyMiddleware: Middleware {
    public let id: String = "ConfigureAgentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureAgentOutputError>
}

extension ConfigureAgentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureAgentInput(fleetInstanceId: \(String(describing: fleetInstanceId)), metadata: \(String(describing: metadata)), profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension ConfigureAgentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fleetInstanceId
        case metadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fleetInstanceId = fleetInstanceId {
            try encodeContainer.encode(fleetInstanceId, forKey: .fleetInstanceId)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metadata)
            for (dictKey0, metadata0) in metadata {
                try metadataContainer.encode(metadata0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct ConfigureAgentInputHeadersMiddleware: Middleware {
    public let id: String = "ConfigureAgentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureAgentOutputError>
}

public struct ConfigureAgentInputQueryItemMiddleware: Middleware {
    public let id: String = "ConfigureAgentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ConfigureAgentInput>,
                  next: H) -> Swift.Result<OperationOutput<ConfigureAgentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ConfigureAgentInput>
    public typealias MOutput = OperationOutput<ConfigureAgentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ConfigureAgentOutputError>
}

/// <p>The structure representing the configureAgentRequest.</p>
public struct ConfigureAgentInput: Equatable {
    /// <p> A universally unique identifier (UUID) for a profiling instance. For example, if the
    ///          profiling instance is an Amazon EC2 instance, it is the instance ID. If it is an AWS
    ///          Fargate container, it is the container's task ID. </p>
    public let fleetInstanceId: String?
    /// <p> Metadata captured about the compute platform the agent is running on. It includes
    ///          information about sampling and reporting. The valid fields are:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>COMPUTE_PLATFORM</code> - The compute platform on which the agent is running
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AGENT_ID</code> - The ID for an agent instance.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AWS_REQUEST_ID</code> - The AWS request ID of a Lambda invocation.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>EXECUTION_ENVIRONMENT</code> - The execution environment a Lambda function is running on.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_FUNCTION_ARN</code> - The Amazon Resource Name (ARN) that is used to invoke a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_MEMORY_LIMIT_IN_MB</code> - The memory allocated to a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_REMAINING_TIME_IN_MILLISECONDS</code> - The time in milliseconds before execution of a Lambda function times out.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_TIME_GAP_BETWEEN_INVOKES_IN_MILLISECONDS</code> - The time in milliseconds between two invocations of a Lambda function.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LAMBDA_PREVIOUS_EXECUTION_TIME_IN_MILLISECONDS</code> - The time in milliseconds for the previous Lambda invocation.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let metadata: [String:String]?
    /// <p>
    ///          The name of the profiling group for which the configured agent is collecting profiling data.
    ///       </p>
    public let profilingGroupName: String?

    public init (
        fleetInstanceId: String? = nil,
        metadata: [String:String]? = nil,
        profilingGroupName: String? = nil
    )
    {
        self.fleetInstanceId = fleetInstanceId
        self.metadata = metadata
        self.profilingGroupName = profilingGroupName
    }
}

struct ConfigureAgentInputBody: Equatable {
    public let fleetInstanceId: String?
    public let metadata: [String:String]?
}

extension ConfigureAgentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fleetInstanceId
        case metadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fleetInstanceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fleetInstanceId)
        fleetInstanceId = fleetInstanceIdDecoded
        let metadataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metadata)
        var metadataDecoded0: [String:String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [String:String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension ConfigureAgentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ConfigureAgentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ConfigureAgentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ConfigureAgentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigureAgentOutputResponse(configuration: \(String(describing: configuration)))"}
}

extension ConfigureAgentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: AgentConfiguration = try responseDecoder.decode(responseBody: unwrappedData)
                self.configuration = output
            } else {
                self.configuration = nil
            }
        } else {
            self.configuration = nil
        }
    }
}

/// <p>The structure representing the configureAgentResponse.</p>
public struct ConfigureAgentOutputResponse: Equatable {
    /// <p>
    ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentConfiguration.html">
    ///                <code>AgentConfiguration</code>
    ///             </a>
    ///          object that specifies if an agent profiles or not and for how long to return profiling data.
    ///       </p>
    public let configuration: AgentConfiguration?

    public init (
        configuration: AgentConfiguration? = nil
    )
    {
        self.configuration = configuration
    }
}

struct ConfigureAgentOutputResponseBody: Equatable {
    public let configuration: AgentConfiguration?
}

extension ConfigureAgentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(AgentConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested operation would cause a conflict with the current state
///         of a service resource associated with the request. Resolve the conflict
///         before retrying this request.
///       </p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateProfilingGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateProfilingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfilingGroupOutputError>
}

extension CreateProfilingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfilingGroupInput(agentOrchestrationConfig: \(String(describing: agentOrchestrationConfig)), clientToken: \(String(describing: clientToken)), computePlatform: \(String(describing: computePlatform)), profilingGroupName: \(String(describing: profilingGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateProfilingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let computePlatform = computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let profilingGroupName = profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProfilingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfilingGroupOutputError>
}

public struct CreateProfilingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProfilingGroupInput>
    public typealias MOutput = OperationOutput<CreateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProfilingGroupOutputError>
}

/// <p>The structure representing the createProfiliingGroupRequest.</p>
public struct CreateProfilingGroupInput: Equatable {
    /// <p>
    ///          Specifies whether profiling is enabled or disabled for the created profiling group.
    ///       </p>
    public let agentOrchestrationConfig: AgentOrchestrationConfig?
    /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
    ///          accidental creation of duplicate profiling groups if there are failures and retries. </p>
    public var clientToken: String?
    /// <p>
    ///          The compute platform of the profiling group. Use <code>AWSLambda</code> if your application
    ///          runs on AWS Lambda. Use <code>Default</code> if your application runs on a compute platform that
    ///          is not AWS Lambda, such an Amazon EC2 instance, an on-premises server, or a different platform.
    ///          If not specified, <code>Default</code> is used.
    ///       </p>
    public let computePlatform: ComputePlatform?
    /// <p>The name of the profiling group to create.</p>
    public let profilingGroupName: String?
    /// <p>
    ///          A list of tags to add to the created profiling group.
    ///       </p>
    public let tags: [String:String]?

    public init (
        agentOrchestrationConfig: AgentOrchestrationConfig? = nil,
        clientToken: String? = nil,
        computePlatform: ComputePlatform? = nil,
        profilingGroupName: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.clientToken = clientToken
        self.computePlatform = computePlatform
        self.profilingGroupName = profilingGroupName
        self.tags = tags
    }
}

struct CreateProfilingGroupInputBody: Equatable {
    public let profilingGroupName: String?
    public let computePlatform: ComputePlatform?
    public let agentOrchestrationConfig: AgentOrchestrationConfig?
    public let tags: [String:String]?
}

extension CreateProfilingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentOrchestrationConfig
        case computePlatform
        case profilingGroupName
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfilingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfilingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfilingGroupOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfilingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProfilingGroupOutputResponse(profilingGroup: \(String(describing: profilingGroup)))"}
}

extension CreateProfilingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ProfilingGroupDescription = try responseDecoder.decode(responseBody: unwrappedData)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the createProfilingGroupResponse.</p>
public struct CreateProfilingGroupOutputResponse: Equatable {
    /// <p> The returned <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> object that contains information
    ///          about the created profiling group. </p>
    public let profilingGroup: ProfilingGroupDescription?

    public init (
        profilingGroup: ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct CreateProfilingGroupOutputResponseBody: Equatable {
    public let profilingGroup: ProfilingGroupDescription?
}

extension CreateProfilingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profilingGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

extension DeleteProfilingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfilingGroupInput(profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension DeleteProfilingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProfilingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfilingGroupInput>
    public typealias MOutput = OperationOutput<DeleteProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfilingGroupOutputError>
}

public struct DeleteProfilingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProfilingGroupInput>
    public typealias MOutput = OperationOutput<DeleteProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProfilingGroupOutputError>
}

/// <p>The structure representing the deleteProfilingGroupRequest.</p>
public struct DeleteProfilingGroupInput: Equatable {
    /// <p>The name of the profiling group to delete.</p>
    public let profilingGroupName: String?

    public init (
        profilingGroupName: String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DeleteProfilingGroupInputBody: Equatable {
}

extension DeleteProfilingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProfilingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfilingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfilingGroupOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfilingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProfilingGroupOutputResponse()"}
}

extension DeleteProfilingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the deleteProfilingGroupResponse.</p>
public struct DeleteProfilingGroupOutputResponse: Equatable {

    public init() {}
}

struct DeleteProfilingGroupOutputResponseBody: Equatable {
}

extension DeleteProfilingGroupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProfilingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProfilingGroupInput(profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension DescribeProfilingGroupInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProfilingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProfilingGroupInput>
    public typealias MOutput = OperationOutput<DescribeProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProfilingGroupOutputError>
}

public struct DescribeProfilingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProfilingGroupInput>
    public typealias MOutput = OperationOutput<DescribeProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProfilingGroupOutputError>
}

/// <p>The structure representing the describeProfilingGroupRequest.</p>
public struct DescribeProfilingGroupInput: Equatable {
    /// <p>
    ///          The name of the profiling group to get information about.
    ///       </p>
    public let profilingGroupName: String?

    public init (
        profilingGroupName: String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct DescribeProfilingGroupInputBody: Equatable {
}

extension DescribeProfilingGroupInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProfilingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProfilingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProfilingGroupOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProfilingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProfilingGroupOutputResponse(profilingGroup: \(String(describing: profilingGroup)))"}
}

extension DescribeProfilingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ProfilingGroupDescription = try responseDecoder.decode(responseBody: unwrappedData)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the describeProfilingGroupResponse.</p>
public struct DescribeProfilingGroupOutputResponse: Equatable {
    /// <p>
    ///          The returned <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          object that contains information about the requested profiling group.
    ///       </p>
    public let profilingGroup: ProfilingGroupDescription?

    public init (
        profilingGroup: ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct DescribeProfilingGroupOutputResponseBody: Equatable {
    public let profilingGroup: ProfilingGroupDescription?
}

extension DescribeProfilingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profilingGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

public enum EventPublisher {
    /// Notifications for Anomaly Detection
    case anomalyDetection
    case sdkUnknown(String)
}

extension EventPublisher : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventPublisher] {
        return [
            .anomalyDetection,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .anomalyDetection: return "AnomalyDetection"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventPublisher(rawValue: rawValue) ?? EventPublisher.sdkUnknown(rawValue)
    }
}

public enum FeedbackType {
    /// Profiler recommendation flagged as not useful.
    case negative
    /// Profiler recommendation flagged as useful.
    case positive
    case sdkUnknown(String)
}

extension FeedbackType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeedbackType] {
        return [
            .negative,
            .positive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .negative: return "Negative"
        case .positive: return "Positive"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeedbackType(rawValue: rawValue) ?? FeedbackType.sdkUnknown(rawValue)
    }
}

extension FindingsReportSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case totalNumberOfFindings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let profileEndTime = profileEndTime {
            try encodeContainer.encode(profileEndTime.timeIntervalSince1970, forKey: .profileEndTime)
        }
        if let profileStartTime = profileStartTime {
            try encodeContainer.encode(profileStartTime.timeIntervalSince1970, forKey: .profileStartTime)
        }
        if let profilingGroupName = profilingGroupName {
            try encodeContainer.encode(profilingGroupName, forKey: .profilingGroupName)
        }
        if let totalNumberOfFindings = totalNumberOfFindings {
            try encodeContainer.encode(totalNumberOfFindings, forKey: .totalNumberOfFindings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let totalNumberOfFindingsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalNumberOfFindings)
        totalNumberOfFindings = totalNumberOfFindingsDecoded
    }
}

extension FindingsReportSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingsReportSummary(id: \(String(describing: id)), profileEndTime: \(String(describing: profileEndTime)), profileStartTime: \(String(describing: profileStartTime)), profilingGroupName: \(String(describing: profilingGroupName)), totalNumberOfFindings: \(String(describing: totalNumberOfFindings)))"}
}

/// <p>
///             Information about potential recommendations that might be created from the
///             analysis of profiling data.
///         </p>
public struct FindingsReportSummary: Equatable {
    /// <p>The universally unique identifier (UUID) of the recommendation report.</p>
    public let id: String?
    /// <p>
    ///             The end time of the period during which the metric is flagged as anomalous.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let profileEndTime: Date?
    /// <p>The start time of the profile the analysis data is about.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let profileStartTime: Date?
    /// <p>The name of the profiling group that is associated with the analysis data.</p>
    public let profilingGroupName: String?
    /// <p>The total number of different recommendations that were found by the analysis.</p>
    public let totalNumberOfFindings: Int?

    public init (
        id: String? = nil,
        profileEndTime: Date? = nil,
        profileStartTime: Date? = nil,
        profilingGroupName: String? = nil,
        totalNumberOfFindings: Int? = nil
    )
    {
        self.id = id
        self.profileEndTime = profileEndTime
        self.profileStartTime = profileStartTime
        self.profilingGroupName = profilingGroupName
        self.totalNumberOfFindings = totalNumberOfFindings
    }
}

extension FrameMetric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for threadstates0 in threadStates {
                try threadStatesContainer.encode(threadstates0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension FrameMetric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FrameMetric(frameName: \(String(describing: frameName)), threadStates: \(String(describing: threadStates)), type: \(String(describing: type)))"}
}

/// <p>
///          The frame name, metric type, and thread states. These are used
///          to derive the value of the metric for the frame.</p>
public struct FrameMetric: Equatable {
    /// <p> Name of the method common across the multiple occurrences of a frame in an application
    ///          profile.</p>
    public let frameName: String?
    /// <p>List of application runtime thread states used to get the counts for a frame a derive a metric value.</p>
    public let threadStates: [String]?
    /// <p> A type of aggregation that specifies how a metric for a frame is analyzed. The
    ///          supported value <code>AggregatedRelativeTotalTime</code> is an aggregation of the metric
    ///          value for one frame that is calculated across the occurrences of all frames in a profile. </p>
    public let type: MetricType?

    public init (
        frameName: String? = nil,
        threadStates: [String]? = nil,
        type: MetricType? = nil
    )
    {
        self.frameName = frameName
        self.threadStates = threadStates
        self.type = type
    }
}

extension FrameMetricDatum: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frameMetric
        case values
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameMetric = frameMetric {
            try encodeContainer.encode(frameMetric, forKey: .frameMetric)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for framemetricvalues0 in values {
                try valuesContainer.encode(framemetricvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameMetricDecoded = try containerValues.decodeIfPresent(FrameMetric.self, forKey: .frameMetric)
        frameMetric = frameMetricDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Double?].self, forKey: .values)
        var valuesDecoded0:[Double]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Double]()
            for double0 in valuesContainer {
                if let double0 = double0 {
                    valuesDecoded0?.append(double0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension FrameMetricDatum: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FrameMetricDatum(frameMetric: \(String(describing: frameMetric)), values: \(String(describing: values)))"}
}

/// <p>
///          Information about a frame metric and its values.
///       </p>
public struct FrameMetricDatum: Equatable {
    /// <p>
    ///          The frame name, metric type, and thread states. These are used
    ///          to derive the value of the metric for the frame.</p>
    public let frameMetric: FrameMetric?
    /// <p>
    ///          A list of values that are associated with a frame metric.
    ///       </p>
    public let values: [Double]?

    public init (
        frameMetric: FrameMetric? = nil,
        values: [Double]? = nil
    )
    {
        self.frameMetric = frameMetric
        self.values = values
    }
}

extension GetFindingsReportAccountSummaryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsReportAccountSummaryInput(dailyReportsOnly: \(String(describing: dailyReportsOnly)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetFindingsReportAccountSummaryInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFindingsReportAccountSummaryInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingsReportAccountSummaryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsReportAccountSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsReportAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsReportAccountSummaryInput>
    public typealias MOutput = OperationOutput<GetFindingsReportAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsReportAccountSummaryOutputError>
}

public struct GetFindingsReportAccountSummaryInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingsReportAccountSummaryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingsReportAccountSummaryInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingsReportAccountSummaryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dailyReportsOnly = input.operationInput.dailyReportsOnly {
            let dailyReportsOnlyQueryItem = URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: String(dailyReportsOnly).urlPercentEncoding())
            input.builder.withQueryItem(dailyReportsOnlyQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingsReportAccountSummaryInput>
    public typealias MOutput = OperationOutput<GetFindingsReportAccountSummaryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingsReportAccountSummaryOutputError>
}

/// <p>The structure representing the GetFindingsReportAccountSummaryRequest.</p>
public struct GetFindingsReportAccountSummaryInput: Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
    ///             to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
    ///             analysis data is returned from smaller time windows (for example, one hour).</p>
    public let dailyReportsOnly: Bool?
    /// <p>The maximum number of results returned by <code> GetFindingsReportAccountSummary</code> in paginated output.
    ///             When this parameter is used, <code>GetFindingsReportAccountSummary</code> only returns <code>maxResults</code>
    ///             results in a single page along with a <code>nextToken</code> response element. The remaining results of the initial
    ///             request can be seen by sending another <code>GetFindingsReportAccountSummary</code> request with the returned
    ///             <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>GetFindingsReportAccountSummary</code>
    ///          request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
    ///          Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        dailyReportsOnly: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetFindingsReportAccountSummaryInputBody: Equatable {
}

extension GetFindingsReportAccountSummaryInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFindingsReportAccountSummaryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsReportAccountSummaryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingsReportAccountSummaryOutputError: Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsReportAccountSummaryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingsReportAccountSummaryOutputResponse(nextToken: \(String(describing: nextToken)), reportSummaries: \(String(describing: reportSummaries)))"}
}

extension GetFindingsReportAccountSummaryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingsReportAccountSummaryOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.reportSummaries = output.reportSummaries
        } else {
            self.nextToken = nil
            self.reportSummaries = nil
        }
    }
}

/// <p>The structure representing the GetFindingsReportAccountSummaryResponse.</p>
public struct GetFindingsReportAccountSummaryOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>GetFindingsReportAccountSummary</code> request.
    ///          When the results of a <code>GetFindingsReportAccountSummary</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return.</p>
    public let nextToken: String?
    /// <p>The return list of
    ///             <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_FindingsReportSummary.html">
    ///                <code>FindingsReportSummary</code>
    ///             </a>
    ///             objects taht contain summaries of analysis results for all profiling groups in your AWS account.</p>
    public let reportSummaries: [FindingsReportSummary]?

    public init (
        nextToken: String? = nil,
        reportSummaries: [FindingsReportSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.reportSummaries = reportSummaries
    }
}

struct GetFindingsReportAccountSummaryOutputResponseBody: Equatable {
    public let reportSummaries: [FindingsReportSummary]?
    public let nextToken: String?
}

extension GetFindingsReportAccountSummaryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case reportSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reportSummariesContainer = try containerValues.decodeIfPresent([FindingsReportSummary?].self, forKey: .reportSummaries)
        var reportSummariesDecoded0:[FindingsReportSummary]? = nil
        if let reportSummariesContainer = reportSummariesContainer {
            reportSummariesDecoded0 = [FindingsReportSummary]()
            for structure0 in reportSummariesContainer {
                if let structure0 = structure0 {
                    reportSummariesDecoded0?.append(structure0)
                }
            }
        }
        reportSummaries = reportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetNotificationConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNotificationConfigurationInput(profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension GetNotificationConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetNotificationConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetNotificationConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<GetNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNotificationConfigurationOutputError>
}

public struct GetNotificationConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetNotificationConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetNotificationConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetNotificationConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetNotificationConfigurationInput>
    public typealias MOutput = OperationOutput<GetNotificationConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetNotificationConfigurationOutputError>
}

/// <p>The structure representing the GetNotificationConfigurationRequest.</p>
public struct GetNotificationConfigurationInput: Equatable {
    /// <p>The name of the profiling group we want to get the notification configuration for.</p>
    public let profilingGroupName: String?

    public init (
        profilingGroupName: String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetNotificationConfigurationInputBody: Equatable {
}

extension GetNotificationConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetNotificationConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNotificationConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNotificationConfigurationOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNotificationConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetNotificationConfigurationOutputResponse(notificationConfiguration: \(String(describing: notificationConfiguration)))"}
}

extension GetNotificationConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the GetNotificationConfigurationResponse.</p>
public struct GetNotificationConfigurationOutputResponse: Equatable {
    /// <p>The current notification configuration for this profiling group.</p>
    public let notificationConfiguration: NotificationConfiguration?

    public init (
        notificationConfiguration: NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct GetNotificationConfigurationOutputResponseBody: Equatable {
    public let notificationConfiguration: NotificationConfiguration?
}

extension GetNotificationConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension GetPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

/// <p>
///             The structure representing the <code>getPolicyRequest</code>.
///         </p>
public struct GetPolicyInput: Equatable {
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: String?

    public init (
        profilingGroupName: String? = nil
    )
    {
        self.profilingGroupName = profilingGroupName
    }
}

struct GetPolicyInputBody: Equatable {
}

extension GetPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>getPolicyResponse</code>.</p>
public struct GetPolicyOutputResponse: Equatable {
    /// <p>The JSON-formatted resource-based policy attached to the <code>ProfilingGroup</code>.</p>
    public let policy: String?
    /// <p>A unique identifier for the current revision of the returned policy.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileInput(accept: \(String(describing: accept)), endTime: \(String(describing: endTime)), maxDepth: \(String(describing: maxDepth)), period: \(String(describing: period)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)))"}
}

extension GetProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let accept = input.operationInput.accept {
            input.builder.withHeader(name: "Accept", value: String(accept))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileInput>
    public typealias MOutput = OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileOutputError>
}

public struct GetProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxDepth = input.operationInput.maxDepth {
            let maxDepthQueryItem = URLQueryItem(name: "maxDepth".urlPercentEncoding(), value: String(maxDepth).urlPercentEncoding())
            input.builder.withQueryItem(maxDepthQueryItem)
        }
        if let period = input.operationInput.period {
            let periodQueryItem = URLQueryItem(name: "period".urlPercentEncoding(), value: String(period).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProfileInput>
    public typealias MOutput = OperationOutput<GetProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProfileOutputError>
}

/// <p>The structure representing the getProfileRequest.</p>
public struct GetProfileInput: Equatable {
    /// <p>
    ///          The format of the returned profiling data. The format maps to the
    ///          <code>Accept</code> and <code>Content-Type</code> headers of the
    ///          HTTP request. You can specify one of the following:
    ///         or the default .
    ///       </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>application/json</code> — standard JSON format
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
    ///                see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let accept: String?
    /// <p>
    ///          The end time of the requested profile. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    ///          <p>
    ///          If you specify <code>endTime</code>, then you must also specify <code>period</code>
    ///          or <code>startTime</code>, but not both.
    ///       </p>
    public let endTime: Date?
    /// <p>
    ///          The maximum depth of the stacks in the code that is represented in
    ///          the aggregated profile. For example, if CodeGuru Profiler finds a method <code>A</code>,
    ///          which calls method <code>B</code>, which calls method <code>C</code>, which
    ///          calls method <code>D</code>, then the depth is 4. If the <code>maxDepth</code> is
    ///          set to 2, then the aggregated profile contains representations of methods <code>A</code>
    ///          and <code>B</code>.
    ///       </p>
    public let maxDepth: Int?
    /// <p>
    ///          Used with <code>startTime</code> or <code>endTime</code> to specify
    ///          the time range for the returned aggregated profile. Specify using
    ///          the ISO 8601 format. For example, <code>P1DT1H1M1S</code>.
    ///       </p>
    ///
    ///          <p>
    ///          To get the latest aggregated profile, specify only <code>period</code>.
    ///       </p>
    public let period: String?
    /// <p>The name of the profiling group to get.</p>
    public let profilingGroupName: String?
    /// <p>The start time of the profile to get. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    ///
    ///          <p>
    ///          If you specify <code>startTime</code>, then you must also specify <code>period</code>
    ///          or <code>endTime</code>, but not both.
    ///       </p>
    public let startTime: Date?

    public init (
        accept: String? = nil,
        endTime: Date? = nil,
        maxDepth: Int? = nil,
        period: String? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.accept = accept
        self.endTime = endTime
        self.maxDepth = maxDepth
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetProfileInputBody: Equatable {
}

extension GetProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProfileOutputResponse(contentEncoding: \(String(describing: contentEncoding)), contentType: \(String(describing: contentType)), profile: \(String(describing: profile)))"}
}

extension GetProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let contentEncodingHeaderValue = httpResponse.headers.value(for: "Content-Encoding") {
            self.contentEncoding = contentEncodingHeaderValue
        } else {
            self.contentEncoding = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.profile = unwrappedData
        } else {
            self.profile = nil
        }
    }
}

/// <p>The structure representing the getProfileResponse.</p>
public struct GetProfileOutputResponse: Equatable {
    /// <p>The content encoding of the profile.</p>
    public let contentEncoding: String?
    /// <p>The content type of the profile in the payload. It is
    ///         either <code>application/json</code> or the default
    ///         <code>application/x-amzn-ion</code>.</p>
    public let contentType: String?
    /// <p>Information about the profile.</p>
    public let profile: Data?

    public init (
        contentEncoding: String? = nil,
        contentType: String? = nil,
        profile: Data? = nil
    )
    {
        self.contentEncoding = contentEncoding
        self.contentType = contentType
        self.profile = profile
    }
}

struct GetProfileOutputResponseBody: Equatable {
    public let profile: Data?
}

extension GetProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension GetRecommendationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationsInput(endTime: \(String(describing: endTime)), locale: \(String(describing: locale)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)))"}
}

extension GetRecommendationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRecommendationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecommendationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationsOutputError>
}

public struct GetRecommendationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecommendationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommendationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommendationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let locale = input.operationInput.locale {
            let localeQueryItem = URLQueryItem(name: "locale".urlPercentEncoding(), value: String(locale).urlPercentEncoding())
            input.builder.withQueryItem(localeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommendationsInput>
    public typealias MOutput = OperationOutput<GetRecommendationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommendationsOutputError>
}

/// <p>The structure representing the GetRecommendationsRequest.</p>
public struct GetRecommendationsInput: Equatable {
    /// <p>
    ///             The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let endTime: Date?
    /// <p>
    ///             The language used to provide analysis. Specify using a string that is one
    ///             of the following <code>BCP 47</code> language codes.
    ///         </p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                     <code>de-DE</code> - German, Germany
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>en-GB</code> - English, United Kingdom
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>en-US</code> - English, United States
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>es-ES</code> - Spanish, Spain
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>fr-FR</code> - French, France
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>it-IT</code> - Italian, Italy
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ja-JP</code> - Japanese, Japan
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>ko-KR</code> - Korean, Republic of Korea
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>pt-BR</code> - Portugese, Brazil
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>zh-CN</code> - Chinese, China
    ///                 </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                     <code>zh-TW</code> - Chinese, Taiwan
    ///                 </p>
    ///             </li>
    ///          </ul>
    public let locale: String?
    /// <p>
    ///             The name of the profiling group to get analysis data about.
    ///         </p>
    public let profilingGroupName: String?
    /// <p>
    ///             The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        locale: String? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.locale = locale
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct GetRecommendationsInputBody: Equatable {
}

extension GetRecommendationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRecommendationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommendationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommendationsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommendationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommendationsOutputResponse(anomalies: \(String(describing: anomalies)), profileEndTime: \(String(describing: profileEndTime)), profileStartTime: \(String(describing: profileStartTime)), profilingGroupName: \(String(describing: profilingGroupName)), recommendations: \(String(describing: recommendations)))"}
}

extension GetRecommendationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRecommendationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalies = output.anomalies
            self.profileEndTime = output.profileEndTime
            self.profileStartTime = output.profileStartTime
            self.profilingGroupName = output.profilingGroupName
            self.recommendations = output.recommendations
        } else {
            self.anomalies = nil
            self.profileEndTime = nil
            self.profileStartTime = nil
            self.profilingGroupName = nil
            self.recommendations = nil
        }
    }
}

/// <p>The structure representing the GetRecommendationsResponse.</p>
public struct GetRecommendationsOutputResponse: Equatable {
    /// <p>
    ///             The list of anomalies that the analysis has found for this profile.
    ///         </p>
    public let anomalies: [Anomaly]?
    /// <p>
    ///             The end time of the profile the analysis data is about. This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let profileEndTime: Date?
    /// <p>
    ///             The start time of the profile the analysis data is about. This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let profileStartTime: Date?
    /// <p>The name of the profiling group the analysis data is about.</p>
    public let profilingGroupName: String?
    /// <p>The list of recommendations that the analysis found for this profile.</p>
    public let recommendations: [Recommendation]?

    public init (
        anomalies: [Anomaly]? = nil,
        profileEndTime: Date? = nil,
        profileStartTime: Date? = nil,
        profilingGroupName: String? = nil,
        recommendations: [Recommendation]? = nil
    )
    {
        self.anomalies = anomalies
        self.profileEndTime = profileEndTime
        self.profileStartTime = profileStartTime
        self.profilingGroupName = profilingGroupName
        self.recommendations = recommendations
    }
}

struct GetRecommendationsOutputResponseBody: Equatable {
    public let profilingGroupName: String?
    public let profileStartTime: Date?
    public let profileEndTime: Date?
    public let recommendations: [Recommendation]?
    public let anomalies: [Anomaly]?
}

extension GetRecommendationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalies
        case profileEndTime
        case profileStartTime
        case profilingGroupName
        case recommendations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .profilingGroupName)
        profilingGroupName = profilingGroupNameDecoded
        let profileStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .profileStartTime)
        profileStartTime = profileStartTimeDecoded
        let profileEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .profileEndTime)
        profileEndTime = profileEndTimeDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([Recommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[Recommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [Recommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let anomaliesContainer = try containerValues.decodeIfPresent([Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an internal error and is unable to complete the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListFindingsReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsReportsInput(dailyReportsOnly: \(String(describing: dailyReportsOnly)), endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)))"}
}

extension ListFindingsReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFindingsReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsReportsInput>
    public typealias MOutput = OperationOutput<ListFindingsReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsReportsOutputError>
}

public struct ListFindingsReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let dailyReportsOnly = input.operationInput.dailyReportsOnly {
            let dailyReportsOnlyQueryItem = URLQueryItem(name: "dailyReportsOnly".urlPercentEncoding(), value: String(dailyReportsOnly).urlPercentEncoding())
            input.builder.withQueryItem(dailyReportsOnlyQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsReportsInput>
    public typealias MOutput = OperationOutput<ListFindingsReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsReportsOutputError>
}

/// <p>The structure representing the ListFindingsReportsRequest.</p>
public struct ListFindingsReportsInput: Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to only return reports from daily profiles. If set
    ///         to <code>True</code>, only analysis data from daily profiles is returned. If set to <code>False</code>,
    ///         analysis data is returned from smaller time windows (for example, one hour).</p>
    public let dailyReportsOnly: Bool?
    /// <p>
    ///             The end time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let endTime: Date?
    /// <p>The maximum number of report results returned by <code>ListFindingsReports</code>
    ///          in paginated output. When this parameter is used, <code>ListFindingsReports</code> only returns
    ///          <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListFindingsReports</code> request with the returned
    ///          <code>nextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated <code>ListFindingsReportsRequest</code>
    ///          request where <code>maxResults</code> was used and the results exceeded the value of that parameter.
    ///          Pagination continues from the end of the previous results that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///       the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>The name of the profiling group from which to search for analysis data.</p>
    public let profilingGroupName: String?
    /// <p>
    ///             The start time of the profile to get analysis data about. You must specify <code>startTime</code> and <code>endTime</code>.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.
    ///         </p>
    public let startTime: Date?

    public init (
        dailyReportsOnly: Bool? = nil,
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.dailyReportsOnly = dailyReportsOnly
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListFindingsReportsInputBody: Equatable {
}

extension ListFindingsReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFindingsReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsReportsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsReportsOutputResponse(findingsReportSummaries: \(String(describing: findingsReportSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFindingsReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findingsReportSummaries = output.findingsReportSummaries
            self.nextToken = output.nextToken
        } else {
            self.findingsReportSummaries = nil
            self.nextToken = nil
        }
    }
}

/// <p>The structure representing the ListFindingsReportsResponse.</p>
public struct ListFindingsReportsOutputResponse: Equatable {
    /// <p>The list of analysis results summaries.</p>
    public let findingsReportSummaries: [FindingsReportSummary]?
    /// <p>The <code>nextToken</code> value to include in a future <code>ListFindingsReports</code> request.
    ///          When the results of a <code>ListFindingsReports</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return.</p>
    public let nextToken: String?

    public init (
        findingsReportSummaries: [FindingsReportSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.findingsReportSummaries = findingsReportSummaries
        self.nextToken = nextToken
    }
}

struct ListFindingsReportsOutputResponseBody: Equatable {
    public let findingsReportSummaries: [FindingsReportSummary]?
    public let nextToken: String?
}

extension ListFindingsReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingsReportSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsReportSummariesContainer = try containerValues.decodeIfPresent([FindingsReportSummary?].self, forKey: .findingsReportSummaries)
        var findingsReportSummariesDecoded0:[FindingsReportSummary]? = nil
        if let findingsReportSummariesContainer = findingsReportSummariesContainer {
            findingsReportSummariesDecoded0 = [FindingsReportSummary]()
            for structure0 in findingsReportSummariesContainer {
                if let structure0 = structure0 {
                    findingsReportSummariesDecoded0?.append(structure0)
                }
            }
        }
        findingsReportSummaries = findingsReportSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfileTimesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileTimesInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), orderBy: \(String(describing: orderBy)), period: \(String(describing: period)), profilingGroupName: \(String(describing: profilingGroupName)), startTime: \(String(describing: startTime)))"}
}

extension ListProfileTimesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProfileTimesInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfileTimesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileTimesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileTimesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileTimesInput>
    public typealias MOutput = OperationOutput<ListProfileTimesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileTimesOutputError>
}

public struct ListProfileTimesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfileTimesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfileTimesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfileTimesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let period = input.operationInput.period {
            let periodQueryItem = URLQueryItem(name: "period".urlPercentEncoding(), value: String(period.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(periodQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let orderBy = input.operationInput.orderBy {
            let orderByQueryItem = URLQueryItem(name: "orderBy".urlPercentEncoding(), value: String(orderBy.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(orderByQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "startTime".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "endTime".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfileTimesInput>
    public typealias MOutput = OperationOutput<ListProfileTimesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfileTimesOutputError>
}

/// <p>The structure representing the listProfileTimesRequest.</p>
public struct ListProfileTimesInput: Equatable {
    /// <p>The end time of the time range from which to list the profiles.</p>
    public let endTime: Date?
    /// <p>The maximum number of profile time results returned by <code>ListProfileTimes</code>
    ///          in paginated output. When this parameter is used, <code>ListProfileTimes</code> only returns
    ///          <code>maxResults</code> results in a single page with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListProfileTimes</code> request with the returned
    ///          <code>nextToken</code> value.
    ///       </p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListProfileTimes</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?
    /// <p>The order (ascending or descending by start time of the profile) to
    ///         use when listing profiles. Defaults to <code>TIMESTAMP_DESCENDING</code>.
    ///       </p>
    public let orderBy: OrderBy?
    /// <p>
    ///          The aggregation period. This specifies the period during which an aggregation profile
    ///          collects posted agent profiles for a profiling group. There are 3 valid values.
    ///       </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>P1D</code> — 1 day
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT1H</code> — 1 hour
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PT5M</code> — 5 minutes
    ///             </p>
    ///             </li>
    ///          </ul>
    public let period: AggregationPeriod?
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: String?
    /// <p>The start time of the time range from which to list the profiles.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        orderBy: OrderBy? = nil,
        period: AggregationPeriod? = nil,
        profilingGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
        self.period = period
        self.profilingGroupName = profilingGroupName
        self.startTime = startTime
    }
}

struct ListProfileTimesInputBody: Equatable {
}

extension ListProfileTimesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProfileTimesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfileTimesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfileTimesOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfileTimesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfileTimesOutputResponse(nextToken: \(String(describing: nextToken)), profileTimes: \(String(describing: profileTimes)))"}
}

extension ListProfileTimesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfileTimesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.profileTimes = output.profileTimes
        } else {
            self.nextToken = nil
            self.profileTimes = nil
        }
    }
}

/// <p>The structure representing the listProfileTimesResponse.</p>
public struct ListProfileTimesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListProfileTimes</code> request.
    ///          When the results of a <code>ListProfileTimes</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: String?
    /// <p>The list of start times of the available profiles for the aggregation
    ///         period in the specified time range.
    ///       </p>
    public let profileTimes: [ProfileTime]?

    public init (
        nextToken: String? = nil,
        profileTimes: [ProfileTime]? = nil
    )
    {
        self.nextToken = nextToken
        self.profileTimes = profileTimes
    }
}

struct ListProfileTimesOutputResponseBody: Equatable {
    public let profileTimes: [ProfileTime]?
    public let nextToken: String?
}

extension ListProfileTimesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case profileTimes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileTimesContainer = try containerValues.decodeIfPresent([ProfileTime?].self, forKey: .profileTimes)
        var profileTimesDecoded0:[ProfileTime]? = nil
        if let profileTimesContainer = profileTimesContainer {
            profileTimesDecoded0 = [ProfileTime]()
            for structure0 in profileTimesContainer {
                if let structure0 = structure0 {
                    profileTimesDecoded0?.append(structure0)
                }
            }
        }
        profileTimes = profileTimesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProfilingGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfilingGroupsInput(includeDescription: \(String(describing: includeDescription)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProfilingGroupsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProfilingGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProfilingGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfilingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfilingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfilingGroupsInput>
    public typealias MOutput = OperationOutput<ListProfilingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfilingGroupsOutputError>
}

public struct ListProfilingGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProfilingGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProfilingGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProfilingGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let includeDescription = input.operationInput.includeDescription {
            let includeDescriptionQueryItem = URLQueryItem(name: "includeDescription".urlPercentEncoding(), value: String(includeDescription).urlPercentEncoding())
            input.builder.withQueryItem(includeDescriptionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProfilingGroupsInput>
    public typealias MOutput = OperationOutput<ListProfilingGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProfilingGroupsOutputError>
}

/// <p>The structure representing the listProfilingGroupsRequest.</p>
public struct ListProfilingGroupsInput: Equatable {
    /// <p>A <code>Boolean</code> value indicating whether to include a description. If <code>true</code>,
    ///       then a list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> objects
    ///       that contain detailed information about profiling groups is returned. If <code>false</code>, then
    ///       a list of profiling group names is returned.</p>
    public let includeDescription: Bool?
    /// <p>The maximum number of profiling groups results returned by <code>ListProfilingGroups</code>
    ///          in paginated output. When this parameter is used, <code>ListProfilingGroups</code> only returns
    ///          <code>maxResults</code> results in a single page along with a <code>nextToken</code> response
    ///          element. The remaining results of the initial request
    ///          can be seen by sending another <code>ListProfilingGroups</code> request with the returned
    ///          <code>nextToken</code> value.
    ///       </p>
    public let maxResults: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///          <code>ListProfilingGroups</code> request where <code>maxResults</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous results
    ///          that returned the <code>nextToken</code> value.
    ///       </p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is only used to retrieve
    ///          the next items in a list and not for other programmatic purposes.</p>
    ///          </note>
    public let nextToken: String?

    public init (
        includeDescription: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.includeDescription = includeDescription
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProfilingGroupsInputBody: Equatable {
}

extension ListProfilingGroupsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProfilingGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProfilingGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProfilingGroupsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProfilingGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProfilingGroupsOutputResponse(nextToken: \(String(describing: nextToken)), profilingGroupNames: \(String(describing: profilingGroupNames)), profilingGroups: \(String(describing: profilingGroups)))"}
}

extension ListProfilingGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProfilingGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.profilingGroupNames = output.profilingGroupNames
            self.profilingGroups = output.profilingGroups
        } else {
            self.nextToken = nil
            self.profilingGroupNames = nil
            self.profilingGroups = nil
        }
    }
}

/// <p>The structure representing the listProfilingGroupsResponse.</p>
public struct ListProfilingGroupsOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListProfilingGroups</code> request.
    ///          When the results of a <code>ListProfilingGroups</code> request exceed <code>maxResults</code>, this
    ///          value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more
    ///          results to return. </p>
    public let nextToken: String?
    /// <p>
    ///          A returned list of profiling group names. A list of the names is returned only if
    ///          <code>includeDescription</code> is <code>false</code>, otherwise a list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a> objects
    ///          is returned.
    ///       </p>
    public let profilingGroupNames: [String]?
    /// <p>
    ///          A returned list
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          objects. A list of
    ///          <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          objects is returned only if <code>includeDescription</code> is <code>true</code>, otherwise a list of profiling group names is returned.
    ///       </p>
    public let profilingGroups: [ProfilingGroupDescription]?

    public init (
        nextToken: String? = nil,
        profilingGroupNames: [String]? = nil,
        profilingGroups: [ProfilingGroupDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.profilingGroupNames = profilingGroupNames
        self.profilingGroups = profilingGroups
    }
}

struct ListProfilingGroupsOutputResponseBody: Equatable {
    public let profilingGroupNames: [String]?
    public let profilingGroups: [ProfilingGroupDescription]?
    public let nextToken: String?
}

extension ListProfilingGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case profilingGroupNames
        case profilingGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .profilingGroupNames)
        var profilingGroupNamesDecoded0:[String]? = nil
        if let profilingGroupNamesContainer = profilingGroupNamesContainer {
            profilingGroupNamesDecoded0 = [String]()
            for string0 in profilingGroupNamesContainer {
                if let string0 = string0 {
                    profilingGroupNamesDecoded0?.append(string0)
                }
            }
        }
        profilingGroupNames = profilingGroupNamesDecoded0
        let profilingGroupsContainer = try containerValues.decodeIfPresent([ProfilingGroupDescription?].self, forKey: .profilingGroups)
        var profilingGroupsDecoded0:[ProfilingGroupDescription]? = nil
        if let profilingGroupsContainer = profilingGroupsContainer {
            profilingGroupsDecoded0 = [ProfilingGroupDescription]()
            for structure0 in profilingGroupsContainer {
                if let structure0 = structure0 {
                    profilingGroupsDecoded0?.append(structure0)
                }
            }
        }
        profilingGroups = profilingGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that contains the tags to return.
    ///       </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    ///          The list of tags assigned to the specified resource. This is the list of tags
    ///          returned in the response.
    ///       </p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Match: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frameAddress
        case targetFramesIndex
        case thresholdBreachValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameAddress = frameAddress {
            try encodeContainer.encode(frameAddress, forKey: .frameAddress)
        }
        if let targetFramesIndex = targetFramesIndex {
            try encodeContainer.encode(targetFramesIndex, forKey: .targetFramesIndex)
        }
        if let thresholdBreachValue = thresholdBreachValue {
            try encodeContainer.encode(thresholdBreachValue, forKey: .thresholdBreachValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetFramesIndexDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .targetFramesIndex)
        targetFramesIndex = targetFramesIndexDecoded
        let frameAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameAddress)
        frameAddress = frameAddressDecoded
        let thresholdBreachValueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .thresholdBreachValue)
        thresholdBreachValue = thresholdBreachValueDecoded
    }
}

extension Match: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Match(frameAddress: \(String(describing: frameAddress)), targetFramesIndex: \(String(describing: targetFramesIndex)), thresholdBreachValue: \(String(describing: thresholdBreachValue)))"}
}

/// <p>The part of a profile that contains a recommendation found during analysis.</p>
public struct Match: Equatable {
    /// <p>The location in the profiling graph that contains a recommendation found during analysis.</p>
    public let frameAddress: String?
    /// <p>The target frame that triggered a match.</p>
    public let targetFramesIndex: Int?
    /// <p>The value in the profile data that exceeded the recommendation threshold.</p>
    public let thresholdBreachValue: Double?

    public init (
        frameAddress: String? = nil,
        targetFramesIndex: Int? = nil,
        thresholdBreachValue: Double? = nil
    )
    {
        self.frameAddress = frameAddress
        self.targetFramesIndex = targetFramesIndex
        self.thresholdBreachValue = thresholdBreachValue
    }
}

public enum MetadataField {
    /// Unique identifier for the agent instance.
    case agentId
    /// AWS requestId of the Lambda invocation.
    case awsRequestId
    /// Compute platform on which agent is running.
    case computePlatform
    /// Execution environment on which Lambda function is running.
    case executionEnvironment
    /// Function ARN that's used to invoke the Lambda function.
    case lambdaFunctionArn
    /// Memory allocated for the Lambda function.
    case lambdaMemoryLimitInMb
    /// Time in milliseconds for the previous Lambda invocation.
    case lambdaPreviousExecutionTimeInMilliseconds
    /// Time in milliseconds left before the execution times out.
    case lambdaRemainingTimeInMilliseconds
    /// Time in milliseconds between two invocations of the Lambda function.
    case lambdaTimeGapBetweenInvokesInMilliseconds
    case sdkUnknown(String)
}

extension MetadataField : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetadataField] {
        return [
            .agentId,
            .awsRequestId,
            .computePlatform,
            .executionEnvironment,
            .lambdaFunctionArn,
            .lambdaMemoryLimitInMb,
            .lambdaPreviousExecutionTimeInMilliseconds,
            .lambdaRemainingTimeInMilliseconds,
            .lambdaTimeGapBetweenInvokesInMilliseconds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agentId: return "AgentId"
        case .awsRequestId: return "AwsRequestId"
        case .computePlatform: return "ComputePlatform"
        case .executionEnvironment: return "ExecutionEnvironment"
        case .lambdaFunctionArn: return "LambdaFunctionArn"
        case .lambdaMemoryLimitInMb: return "LambdaMemoryLimitInMB"
        case .lambdaPreviousExecutionTimeInMilliseconds: return "LambdaPreviousExecutionTimeInMilliseconds"
        case .lambdaRemainingTimeInMilliseconds: return "LambdaRemainingTimeInMilliseconds"
        case .lambdaTimeGapBetweenInvokesInMilliseconds: return "LambdaTimeGapBetweenInvokesInMilliseconds"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetadataField(rawValue: rawValue) ?? MetadataField.sdkUnknown(rawValue)
    }
}

extension Metric: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frameName
        case threadStates
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frameName = frameName {
            try encodeContainer.encode(frameName, forKey: .frameName)
        }
        if let threadStates = threadStates {
            var threadStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threadStates)
            for strings0 in threadStates {
                try threadStatesContainer.encode(strings0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameName)
        frameName = frameNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MetricType.self, forKey: .type)
        type = typeDecoded
        let threadStatesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .threadStates)
        var threadStatesDecoded0:[String]? = nil
        if let threadStatesContainer = threadStatesContainer {
            threadStatesDecoded0 = [String]()
            for string0 in threadStatesContainer {
                if let string0 = string0 {
                    threadStatesDecoded0?.append(string0)
                }
            }
        }
        threadStates = threadStatesDecoded0
    }
}

extension Metric: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Metric(frameName: \(String(describing: frameName)), threadStates: \(String(describing: threadStates)), type: \(String(describing: type)))"}
}

/// <p>
///             Details about the metric that the analysis used when it detected the anomaly.
///             The metric what is analyzed to create recommendations. It includes the name of the
///             frame that was analyzed and the type and thread states used to derive the metric
///             value for that frame.
///         </p>
public struct Metric: Equatable {
    /// <p>
    ///             The name of the method that appears as a frame in any stack in a profile.
    ///         </p>
    public let frameName: String?
    /// <p>
    ///             The list of application runtime thread states that is used to calculate the
    ///             metric value for the frame.
    ///         </p>
    public let threadStates: [String]?
    /// <p>
    ///             A type that specifies how a metric for a frame is analyzed.
    ///             The supported value <code>AggregatedRelativeTotalTime</code> is an
    ///             aggregation of the metric value for one frame that is calculated across the
    ///             occurences of all frames in a profile.</p>
    public let type: MetricType?

    public init (
        frameName: String? = nil,
        threadStates: [String]? = nil,
        type: MetricType? = nil
    )
    {
        self.frameName = frameName
        self.threadStates = threadStates
        self.type = type
    }
}

public enum MetricType {
    /// Metric value aggregated for all instances of a frame name in a profile relative to the root frame.
    case aggregatedrelativetotaltime
    case sdkUnknown(String)
}

extension MetricType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MetricType] {
        return [
            .aggregatedrelativetotaltime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aggregatedrelativetotaltime: return "AggregatedRelativeTotalTime"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MetricType(rawValue: rawValue) ?? MetricType.sdkUnknown(rawValue)
    }
}

extension NotificationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channels
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .channels)
            for channels0 in channels {
                try channelsContainer.encode(channels0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent(Set<Channel>.self, forKey: .channels)
        var channelsDecoded0:Set<Channel>? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = Set<Channel>()
            for structure0 in channelsContainer {
                channelsDecoded0?.insert(structure0)
            }
        }
        channels = channelsDecoded0
    }
}

extension NotificationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotificationConfiguration(channels: \(String(describing: channels)))"}
}

/// <p>The configuration for notifications stored for each profiling group. This includes up to
///          to two channels and a list of event publishers associated with each channel.</p>
public struct NotificationConfiguration: Equatable {
    /// <p>List of up to two channels to be used for sending notifications for events detected from
    ///          the application profile.</p>
    public let channels: Set<Channel>?

    public init (
        channels: Set<Channel>? = nil
    )
    {
        self.channels = channels
    }
}

public enum OrderBy {
    /// Order by timestamp in ascending order.
    case timestampAscending
    /// Order by timestamp in descending order.
    case timestampDescending
    case sdkUnknown(String)
}

extension OrderBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderBy] {
        return [
            .timestampAscending,
            .timestampDescending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .timestampAscending: return "TimestampAscending"
        case .timestampDescending: return "TimestampDescending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
    }
}

extension Pattern: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case countersToAggregate
        case description
        case id
        case name
        case resolutionSteps
        case targetFrames
        case thresholdPercent
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countersToAggregate = countersToAggregate {
            var countersToAggregateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .countersToAggregate)
            for strings0 in countersToAggregate {
                try countersToAggregateContainer.encode(strings0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resolutionSteps = resolutionSteps {
            try encodeContainer.encode(resolutionSteps, forKey: .resolutionSteps)
        }
        if let targetFrames = targetFrames {
            var targetFramesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetFrames)
            for targetframes0 in targetFrames {
                var targetframes0Container = targetFramesContainer.nestedUnkeyedContainer()
                for targetframe1 in targetframes0 {
                    try targetframes0Container.encode(targetframe1)
                }
            }
        }
        if thresholdPercent != 0.0 {
            try encodeContainer.encode(thresholdPercent, forKey: .thresholdPercent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let resolutionStepsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolutionSteps)
        resolutionSteps = resolutionStepsDecoded
        let targetFramesContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .targetFrames)
        var targetFramesDecoded0:[[String]]? = nil
        if let targetFramesContainer = targetFramesContainer {
            targetFramesDecoded0 = [[String]]()
            for list0 in targetFramesContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    targetFramesDecoded0?.append(list0Decoded0)
                }
            }
        }
        targetFrames = targetFramesDecoded0
        let thresholdPercentDecoded = try containerValues.decode(Double.self, forKey: .thresholdPercent)
        thresholdPercent = thresholdPercentDecoded
        let countersToAggregateContainer = try containerValues.decodeIfPresent([String?].self, forKey: .countersToAggregate)
        var countersToAggregateDecoded0:[String]? = nil
        if let countersToAggregateContainer = countersToAggregateContainer {
            countersToAggregateDecoded0 = [String]()
            for string0 in countersToAggregateContainer {
                if let string0 = string0 {
                    countersToAggregateDecoded0?.append(string0)
                }
            }
        }
        countersToAggregate = countersToAggregateDecoded0
    }
}

extension Pattern: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Pattern(countersToAggregate: \(String(describing: countersToAggregate)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), resolutionSteps: \(String(describing: resolutionSteps)), targetFrames: \(String(describing: targetFrames)), thresholdPercent: \(String(describing: thresholdPercent)))"}
}

/// <p>
///             A set of rules used to make a recommendation during an analysis.
///         </p>
public struct Pattern: Equatable {
    /// <p>
    ///             A list of the different counters used to determine if there is a match.
    ///         </p>
    public let countersToAggregate: [String]?
    /// <p>The description of the recommendation. This explains a potential
    ///             inefficiency in a profiled application.</p>
    public let description: String?
    /// <p>The universally unique identifier (UUID) of this pattern.</p>
    public let id: String?
    /// <p>The name for this pattern.</p>
    public let name: String?
    /// <p>
    ///             A string that contains the steps recommended to address the potential inefficiency.
    ///         </p>
    public let resolutionSteps: String?
    /// <p>A list of frame names that were searched during the analysis that generated
    ///             a recommendation.</p>
    public let targetFrames: [[String]]?
    /// <p>
    ///             The percentage of time an application spends in one method that triggers
    ///             a recommendation. The percentage of time is the same as the percentage of
    ///             the total gathered sample counts during analysis.
    ///         </p>
    public let thresholdPercent: Double

    public init (
        countersToAggregate: [String]? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        resolutionSteps: String? = nil,
        targetFrames: [[String]]? = nil,
        thresholdPercent: Double = 0.0
    )
    {
        self.countersToAggregate = countersToAggregate
        self.description = description
        self.id = id
        self.name = name
        self.resolutionSteps = resolutionSteps
        self.targetFrames = targetFrames
        self.thresholdPercent = thresholdPercent
    }
}

public struct PostAgentProfileInputBodyMiddleware: Middleware {
    public let id: String = "PostAgentProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let agentProfile = input.operationInput.agentProfile {
            let data = agentProfile
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostAgentProfileOutputError>
}

extension PostAgentProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostAgentProfileInput(agentProfile: \(String(describing: agentProfile)), contentType: \(String(describing: contentType)), profileToken: \(String(describing: profileToken)), profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension PostAgentProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentProfile
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentProfile = agentProfile {
            try encodeContainer.encode(agentProfile.base64EncodedString(), forKey: .agentProfile)
        }
    }
}

public struct PostAgentProfileInputHeadersMiddleware: Middleware {
    public let id: String = "PostAgentProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostAgentProfileOutputError>
}

public struct PostAgentProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "PostAgentProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PostAgentProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<PostAgentProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let profileToken = input.operationInput.profileToken {
            let profileTokenQueryItem = URLQueryItem(name: "profileToken".urlPercentEncoding(), value: String(profileToken).urlPercentEncoding())
            input.builder.withQueryItem(profileTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PostAgentProfileInput>
    public typealias MOutput = OperationOutput<PostAgentProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PostAgentProfileOutputError>
}

/// <p>The structure representing the postAgentProfileRequest.</p>
public struct PostAgentProfileInput: Equatable {
    /// <p>
    ///          The submitted profiling data.
    ///       </p>
    public let agentProfile: Data?
    /// <p>
    ///          The format of the submitted profiling data. The format maps to the
    ///          <code>Accept</code> and <code>Content-Type</code> headers of the
    ///          HTTP request. You can specify one of the following:
    ///          or the default .
    ///       </p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>application/json</code> — standard JSON format
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>application/x-amzn-ion</code> — the Amazon Ion data format. For more information,
    ///                see <a href="http://amzn.github.io/ion-docs/">Amazon Ion</a>.
    ///             </p>
    ///             </li>
    ///          </ul>
    public let contentType: String?
    /// <p> Amazon CodeGuru Profiler uses this universally unique identifier (UUID) to prevent the
    ///          accidental submission of duplicate profiling data if there are failures and retries. </p>
    public var profileToken: String?
    /// <p>
    ///          The name of the profiling group with the aggregated profile that receives the
    ///          submitted profiling data.
    ///       </p>
    public let profilingGroupName: String?

    public init (
        agentProfile: Data? = nil,
        contentType: String? = nil,
        profileToken: String? = nil,
        profilingGroupName: String? = nil
    )
    {
        self.agentProfile = agentProfile
        self.contentType = contentType
        self.profileToken = profileToken
        self.profilingGroupName = profilingGroupName
    }
}

struct PostAgentProfileInputBody: Equatable {
    public let agentProfile: Data?
}

extension PostAgentProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentProfile
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentProfileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .agentProfile)
        agentProfile = agentProfileDecoded
    }
}

extension PostAgentProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostAgentProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PostAgentProfileOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostAgentProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PostAgentProfileOutputResponse()"}
}

extension PostAgentProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the postAgentProfileResponse.</p>
public struct PostAgentProfileOutputResponse: Equatable {

    public init() {}
}

struct PostAgentProfileOutputResponseBody: Equatable {
}

extension PostAgentProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ProfileTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case start
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let start = start {
            try encodeContainer.encode(start.timeIntervalSince1970, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .start)
        start = startDecoded
    }
}

extension ProfileTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProfileTime(start: \(String(describing: start)))"}
}

/// <p>
///          Contains the start time of a profile.
///       </p>
public struct ProfileTime: Equatable {
    /// <p>The start time of a profile. It is specified using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let start: Date?

    public init (
        start: Date? = nil
    )
    {
        self.start = start
    }
}

extension ProfilingGroupDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentOrchestrationConfig
        case arn
        case computePlatform
        case createdAt
        case name
        case profilingStatus
        case tags
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let computePlatform = computePlatform {
            try encodeContainer.encode(computePlatform.rawValue, forKey: .computePlatform)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let profilingStatus = profilingStatus {
            try encodeContainer.encode(profilingStatus, forKey: .profilingStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let profilingStatusDecoded = try containerValues.decodeIfPresent(ProfilingStatus.self, forKey: .profilingStatus)
        profilingStatus = profilingStatusDecoded
        let computePlatformDecoded = try containerValues.decodeIfPresent(ComputePlatform.self, forKey: .computePlatform)
        computePlatform = computePlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ProfilingGroupDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProfilingGroupDescription(agentOrchestrationConfig: \(String(describing: agentOrchestrationConfig)), arn: \(String(describing: arn)), computePlatform: \(String(describing: computePlatform)), createdAt: \(String(describing: createdAt)), name: \(String(describing: name)), profilingStatus: \(String(describing: profilingStatus)), tags: \(String(describing: tags)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>
///          Contains information about a profiling group.
///       </p>
public struct ProfilingGroupDescription: Equatable {
    /// <p>
    ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AgentOrchestrationConfig.html">
    ///                <code>AgentOrchestrationConfig</code>
    ///             </a>
    ///          object that indicates if the profiling group is enabled for profiled or not.
    ///       </p>
    public let agentOrchestrationConfig: AgentOrchestrationConfig?
    /// <p>The Amazon Resource Name (ARN) identifying the profiling group resource.</p>
    public let arn: String?
    /// <p>
    ///          The compute platform of the profiling group. If it is set to <code>AWSLambda</code>, then
    ///          the profiled application runs on AWS Lambda. If it is set to <code>Default</code>, then the
    ///          profiled application runs on a compute platform that is not AWS Lambda, such an Amazon EC2 instance,
    ///          an on-premises server, or a different platform. The default is <code>Default</code>.
    ///       </p>
    public let computePlatform: ComputePlatform?
    /// <p>The time when the profiling group was created. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let createdAt: Date?
    /// <p>The name of the profiling group.</p>
    public let name: String?
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingStatus.html">
    ///                <code>ProfilingStatus</code>
    ///             </a> object
    ///          that includes information about the last time a profile agent pinged back,
    ///          the last time a profile was received, and the aggregation period and start time for the
    ///          most recent aggregated profile.
    ///       </p>
    public let profilingStatus: ProfilingStatus?
    /// <p>
    ///          A list of the tags that belong to this profiling group.
    ///       </p>
    public let tags: [String:String]?
    /// <p>
    ///          The date and time when the profiling group was last updated. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let updatedAt: Date?

    public init (
        agentOrchestrationConfig: AgentOrchestrationConfig? = nil,
        arn: String? = nil,
        computePlatform: ComputePlatform? = nil,
        createdAt: Date? = nil,
        name: String? = nil,
        profilingStatus: ProfilingStatus? = nil,
        tags: [String:String]? = nil,
        updatedAt: Date? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.arn = arn
        self.computePlatform = computePlatform
        self.createdAt = createdAt
        self.name = name
        self.profilingStatus = profilingStatus
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

extension ProfilingStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestAgentOrchestratedAt
        case latestAgentProfileReportedAt
        case latestAggregatedProfile
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestAgentOrchestratedAt = latestAgentOrchestratedAt {
            try encodeContainer.encode(latestAgentOrchestratedAt.timeIntervalSince1970, forKey: .latestAgentOrchestratedAt)
        }
        if let latestAgentProfileReportedAt = latestAgentProfileReportedAt {
            try encodeContainer.encode(latestAgentProfileReportedAt.timeIntervalSince1970, forKey: .latestAgentProfileReportedAt)
        }
        if let latestAggregatedProfile = latestAggregatedProfile {
            try encodeContainer.encode(latestAggregatedProfile, forKey: .latestAggregatedProfile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestAgentProfileReportedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestAgentProfileReportedAt)
        latestAgentProfileReportedAt = latestAgentProfileReportedAtDecoded
        let latestAggregatedProfileDecoded = try containerValues.decodeIfPresent(AggregatedProfileTime.self, forKey: .latestAggregatedProfile)
        latestAggregatedProfile = latestAggregatedProfileDecoded
        let latestAgentOrchestratedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .latestAgentOrchestratedAt)
        latestAgentOrchestratedAt = latestAgentOrchestratedAtDecoded
    }
}

extension ProfilingStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProfilingStatus(latestAgentOrchestratedAt: \(String(describing: latestAgentOrchestratedAt)), latestAgentProfileReportedAt: \(String(describing: latestAgentProfileReportedAt)), latestAggregatedProfile: \(String(describing: latestAggregatedProfile)))"}
}

/// <p>
///          Profiling status includes information about the last time a profile agent pinged back,
///          the last time a profile was received, and the aggregation period and start time for the
///          most recent aggregated profile.
///       </p>
public struct ProfilingStatus: Equatable {
    /// <p>The date and time when the profiling agent most recently pinged back. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let latestAgentOrchestratedAt: Date?
    /// <p>The date and time when the most recent profile was received. Specify using
    ///          the ISO 8601 format. For example,
    ///          2020-06-01T13:15:02.001Z  represents 1 millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let latestAgentProfileReportedAt: Date?
    /// <p>
    ///          An <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AggregatedProfileTime.html">
    ///                <code>AggregatedProfileTime</code>
    ///             </a>
    ///          object that contains the aggregation period and start time for an aggregated profile.
    ///       </p>
    public let latestAggregatedProfile: AggregatedProfileTime?

    public init (
        latestAgentOrchestratedAt: Date? = nil,
        latestAgentProfileReportedAt: Date? = nil,
        latestAggregatedProfile: AggregatedProfileTime? = nil
    )
    {
        self.latestAgentOrchestratedAt = latestAgentOrchestratedAt
        self.latestAgentProfileReportedAt = latestAgentProfileReportedAt
        self.latestAggregatedProfile = latestAggregatedProfile
    }
}

public struct PutPermissionInputBodyMiddleware: Middleware {
    public let id: String = "PutPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

extension PutPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionInput(actionGroup: \(String(describing: actionGroup)), principals: \(String(describing: principals)), profilingGroupName: \(String(describing: profilingGroupName)), revisionId: \(String(describing: revisionId)))"}
}

extension PutPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case principals
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principals = principals {
            var principalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .principals)
            for principals0 in principals {
                try principalsContainer.encode(principals0)
            }
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct PutPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "PutPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

public struct PutPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

/// <p>The structure representing the <code>putPermissionRequest</code>.</p>
public struct PutPermissionInput: Equatable {
    /// <p>
    ///             Specifies an action group that contains permissions to add to
    ///             a profiling group resource. One action group is supported, <code>agentPermissions</code>, which
    ///             grants permission to perform actions required by the profiling agent, <code>ConfigureAgent</code>
    ///             and <code>PostAgentProfile</code> permissions.
    ///         </p>
    public let actionGroup: ActionGroup?
    /// <p>
    ///             A list ARNs for the roles and users you want to grant access to the profiling group.
    ///             Wildcards are not are supported in the ARNs.
    ///         </p>
    public let principals: [String]?
    /// <p>The name of the profiling group to grant access to.</p>
    public let profilingGroupName: String?
    /// <p>
    ///             A universally unique identifier (UUID) for the revision of the policy you
    ///             are adding to the profiling group. Do not specify
    ///             this when you add permissions to a profiling group for the first time. If a policy already exists on the
    ///             profiling group, you must specify the <code>revisionId</code>.
    ///         </p>
    public let revisionId: String?

    public init (
        actionGroup: ActionGroup? = nil,
        principals: [String]? = nil,
        profilingGroupName: String? = nil,
        revisionId: String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.principals = principals
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct PutPermissionInputBody: Equatable {
    public let principals: [String]?
    public let revisionId: String?
}

extension PutPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case principals
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .principals)
        var principalsDecoded0:[String]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [String]()
            for string0 in principalsContainer {
                if let string0 = string0 {
                    principalsDecoded0?.append(string0)
                }
            }
        }
        principals = principalsDecoded0
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PutPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension PutPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutPermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>putPermissionResponse</code>.</p>
public struct PutPermissionOutputResponse: Equatable {
    /// <p>
    ///             The JSON-formatted resource-based policy on the profiling group that includes the
    ///             added permissions.
    ///         </p>
    public let policy: String?
    /// <p> A universally unique identifier (UUID) for the revision of the resource-based policy
    ///             that includes the added permissions. The JSON-formatted policy is in the
    ///                 <code>policy</code> element of the response. </p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct PutPermissionOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension PutPermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension Recommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allMatchesCount
        case allMatchesSum
        case endTime
        case pattern
        case startTime
        case topMatches
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allMatchesCount = allMatchesCount {
            try encodeContainer.encode(allMatchesCount, forKey: .allMatchesCount)
        }
        if let allMatchesSum = allMatchesSum {
            try encodeContainer.encode(allMatchesSum, forKey: .allMatchesSum)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let topMatches = topMatches {
            var topMatchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topMatches)
            for matches0 in topMatches {
                try topMatchesContainer.encode(matches0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allMatchesCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allMatchesCount)
        allMatchesCount = allMatchesCountDecoded
        let allMatchesSumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .allMatchesSum)
        allMatchesSum = allMatchesSumDecoded
        let patternDecoded = try containerValues.decodeIfPresent(Pattern.self, forKey: .pattern)
        pattern = patternDecoded
        let topMatchesContainer = try containerValues.decodeIfPresent([Match?].self, forKey: .topMatches)
        var topMatchesDecoded0:[Match]? = nil
        if let topMatchesContainer = topMatchesContainer {
            topMatchesDecoded0 = [Match]()
            for structure0 in topMatchesContainer {
                if let structure0 = structure0 {
                    topMatchesDecoded0?.append(structure0)
                }
            }
        }
        topMatches = topMatchesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension Recommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Recommendation(allMatchesCount: \(String(describing: allMatchesCount)), allMatchesSum: \(String(describing: allMatchesSum)), endTime: \(String(describing: endTime)), pattern: \(String(describing: pattern)), startTime: \(String(describing: startTime)), topMatches: \(String(describing: topMatches)))"}
}

/// <p>A potential improvement that was found from analyzing the profiling data.</p>
public struct Recommendation: Equatable {
    /// <p>How many different places in the profile graph triggered a match.</p>
    public let allMatchesCount: Int?
    /// <p>How much of the total sample count is potentially affected.</p>
    public let allMatchesSum: Double?
    /// <p>End time of the profile that was used by this analysis.
    ///             This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let endTime: Date?
    /// <p>The pattern that analysis recognized in the profile to make this recommendation.</p>
    public let pattern: Pattern?
    /// <p>The start time of the profile that was used by this analysis.
    ///         This is specified
    ///             using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///             millisecond past June 1, 2020 1:15:02 PM UTC.</p>
    public let startTime: Date?
    /// <p>List of the matches with most impact. </p>
    public let topMatches: [Match]?

    public init (
        allMatchesCount: Int? = nil,
        allMatchesSum: Double? = nil,
        endTime: Date? = nil,
        pattern: Pattern? = nil,
        startTime: Date? = nil,
        topMatches: [Match]? = nil
    )
    {
        self.allMatchesCount = allMatchesCount
        self.allMatchesSum = allMatchesSum
        self.endTime = endTime
        self.pattern = pattern
        self.startTime = startTime
        self.topMatches = topMatches
    }
}

extension RemoveNotificationChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveNotificationChannelInput(channelId: \(String(describing: channelId)), profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension RemoveNotificationChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveNotificationChannelInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveNotificationChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveNotificationChannelOutputError>
}

public struct RemoveNotificationChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveNotificationChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveNotificationChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveNotificationChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveNotificationChannelInput>
    public typealias MOutput = OperationOutput<RemoveNotificationChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveNotificationChannelOutputError>
}

/// <p>The structure representing the RemoveNotificationChannelRequest.</p>
public struct RemoveNotificationChannelInput: Equatable {
    /// <p>The id of the channel that we want to stop receiving notifications.</p>
    public let channelId: String?
    /// <p>The name of the profiling group we want to change notification configuration for.</p>
    public let profilingGroupName: String?

    public init (
        channelId: String? = nil,
        profilingGroupName: String? = nil
    )
    {
        self.channelId = channelId
        self.profilingGroupName = profilingGroupName
    }
}

struct RemoveNotificationChannelInputBody: Equatable {
}

extension RemoveNotificationChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveNotificationChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveNotificationChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveNotificationChannelOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveNotificationChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveNotificationChannelOutputResponse(notificationConfiguration: \(String(describing: notificationConfiguration)))"}
}

extension RemoveNotificationChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveNotificationChannelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

/// <p>The structure representing the RemoveNotificationChannelResponse.</p>
public struct RemoveNotificationChannelOutputResponse: Equatable {
    /// <p>The new notification configuration for this profiling group.</p>
    public let notificationConfiguration: NotificationConfiguration?

    public init (
        notificationConfiguration: NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct RemoveNotificationChannelOutputResponseBody: Equatable {
    public let notificationConfiguration: NotificationConfiguration?
}

extension RemoveNotificationChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case notificationConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension RemovePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionInput(actionGroup: \(String(describing: actionGroup)), profilingGroupName: \(String(describing: profilingGroupName)), revisionId: \(String(describing: revisionId)))"}
}

extension RemovePermissionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemovePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "revisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

/// <p>
///
///             The structure representing the <code>removePermissionRequest</code>.</p>
public struct RemovePermissionInput: Equatable {
    /// <p>
    ///             Specifies an action group that contains the permissions to remove from
    ///             a profiling group's resource-based policy. One action group is supported, <code>agentPermissions</code>, which
    ///             grants <code>ConfigureAgent</code> and <code>PostAgentProfile</code> permissions.
    ///         </p>
    public let actionGroup: ActionGroup?
    /// <p>The name of the profiling group.</p>
    public let profilingGroupName: String?
    /// <p>
    ///             A universally unique identifier (UUID) for the revision of the resource-based policy from which
    ///             you want to remove permissions.
    ///         </p>
    public let revisionId: String?

    public init (
        actionGroup: ActionGroup? = nil,
        profilingGroupName: String? = nil,
        revisionId: String? = nil
    )
    {
        self.actionGroup = actionGroup
        self.profilingGroupName = profilingGroupName
        self.revisionId = revisionId
    }
}

struct RemovePermissionInputBody: Equatable {
}

extension RemovePermissionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemovePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension RemovePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemovePermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

/// <p>The structure representing the <code>removePermissionResponse</code>.</p>
public struct RemovePermissionOutputResponse: Equatable {
    /// <p>
    ///             The JSON-formatted resource-based policy on the profiling group after
    ///             the specified permissions were removed.
    ///         </p>
    public let policy: String?
    /// <p> A universally unique identifier (UUID) for the revision of the resource-based policy
    ///             after the specified permissions were removed. The updated JSON-formatted policy is in the
    ///                 <code>policy</code> element of the response. </p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct RemovePermissionOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension RemovePermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case revisionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded your service quota. To perform the requested action,
///         remove some of the relevant resources, or use <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html">Service Quotas</a> to request a
///         service quota increase.
///       </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct SubmitFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

extension SubmitFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubmitFeedbackInput(anomalyInstanceId: \(String(describing: anomalyInstanceId)), comment: \(String(describing: comment)), profilingGroupName: \(String(describing: profilingGroupName)), type: \(String(describing: type)))"}
}

extension SubmitFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct SubmitFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

public struct SubmitFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "SubmitFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubmitFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<SubmitFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubmitFeedbackInput>
    public typealias MOutput = OperationOutput<SubmitFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubmitFeedbackOutputError>
}

/// <p>The structure representing the SubmitFeedbackRequest.</p>
public struct SubmitFeedbackInput: Equatable {
    /// <p>The universally unique identifier (UUID) of the
    ///             <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_AnomalyInstance.html">
    ///                <code>AnomalyInstance</code>
    ///             </a> object
    ///             that is included in the analysis data.</p>
    public let anomalyInstanceId: String?
    /// <p>Optional feedback about this anomaly.</p>
    public let comment: String?
    /// <p>The name of the profiling group that is associated with the analysis data.</p>
    public let profilingGroupName: String?
    /// <p>
    ///             The feedback tpye. Thee are two valid values, <code>Positive</code> and <code>Negative</code>.
    ///         </p>
    public let type: FeedbackType?

    public init (
        anomalyInstanceId: String? = nil,
        comment: String? = nil,
        profilingGroupName: String? = nil,
        type: FeedbackType? = nil
    )
    {
        self.anomalyInstanceId = anomalyInstanceId
        self.comment = comment
        self.profilingGroupName = profilingGroupName
        self.type = type
    }
}

struct SubmitFeedbackInputBody: Equatable {
    public let type: FeedbackType?
    public let comment: String?
}

extension SubmitFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FeedbackType.self, forKey: .type)
        type = typeDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension SubmitFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubmitFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubmitFeedbackOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubmitFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubmitFeedbackOutputResponse()"}
}

extension SubmitFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The structure representing the SubmitFeedbackResponse.</p>
public struct SubmitFeedbackOutputResponse: Equatable {

    public init() {}
}

struct SubmitFeedbackOutputResponseBody: Equatable {
}

extension SubmitFeedbackOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that the tags are added to.
    ///       </p>
    public let resourceArn: String?
    /// <p>
    ///          The list of tags that are added to the specified resource.
    ///       </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TimestampStructure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let value = value {
            try encodeContainer.encode(value.timeIntervalSince1970, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .value)
        value = valueDecoded
    }
}

extension TimestampStructure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampStructure(value: \(String(describing: value)))"}
}

/// <p>
///          A data type that contains a <code>Timestamp</code> object. This is specified
///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
///          millisecond past June 1, 2020 1:15:02 PM UTC.
///       </p>
public struct TimestampStructure: Equatable {
    /// <p>
    ///          A <code>Timestamp</code>. This is specified
    ///          using the ISO 8601 format. For example, 2020-06-01T13:15:02.001Z represents 1
    ///          millisecond past June 1, 2020 1:15:02 PM UTC.
    ///       </p>
    public let value: Date?

    public init (
        value: Date? = nil
    )
    {
        self.value = value
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///          The Amazon Resource Name (ARN) of the resource that contains the tags to remove.
    ///       </p>
    public let resourceArn: String?
    /// <p>
    ///          A list of tag keys. Existing tags of resources with keys in this list are removed from
    ///          the specified resource.
    ///       </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateProfilingGroupInputBodyMiddleware: Middleware {
    public let id: String = "UpdateProfilingGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfilingGroupOutputError>
}

extension UpdateProfilingGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfilingGroupInput(agentOrchestrationConfig: \(String(describing: agentOrchestrationConfig)), profilingGroupName: \(String(describing: profilingGroupName)))"}
}

extension UpdateProfilingGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentOrchestrationConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentOrchestrationConfig = agentOrchestrationConfig {
            try encodeContainer.encode(agentOrchestrationConfig, forKey: .agentOrchestrationConfig)
        }
    }
}

public struct UpdateProfilingGroupInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateProfilingGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfilingGroupOutputError>
}

public struct UpdateProfilingGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateProfilingGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateProfilingGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateProfilingGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateProfilingGroupInput>
    public typealias MOutput = OperationOutput<UpdateProfilingGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateProfilingGroupOutputError>
}

/// <p>The structure representing the updateProfilingGroupRequest.</p>
public struct UpdateProfilingGroupInput: Equatable {
    /// <p>
    ///          Specifies whether profiling is enabled or disabled for a profiling group.
    ///       </p>
    public let agentOrchestrationConfig: AgentOrchestrationConfig?
    /// <p>The name of the profiling group to update.</p>
    public let profilingGroupName: String?

    public init (
        agentOrchestrationConfig: AgentOrchestrationConfig? = nil,
        profilingGroupName: String? = nil
    )
    {
        self.agentOrchestrationConfig = agentOrchestrationConfig
        self.profilingGroupName = profilingGroupName
    }
}

struct UpdateProfilingGroupInputBody: Equatable {
    public let agentOrchestrationConfig: AgentOrchestrationConfig?
}

extension UpdateProfilingGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentOrchestrationConfig
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentOrchestrationConfigDecoded = try containerValues.decodeIfPresent(AgentOrchestrationConfig.self, forKey: .agentOrchestrationConfig)
        agentOrchestrationConfig = agentOrchestrationConfigDecoded
    }
}

extension UpdateProfilingGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfilingGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfilingGroupOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfilingGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateProfilingGroupOutputResponse(profilingGroup: \(String(describing: profilingGroup)))"}
}

extension UpdateProfilingGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ProfilingGroupDescription = try responseDecoder.decode(responseBody: unwrappedData)
                self.profilingGroup = output
            } else {
                self.profilingGroup = nil
            }
        } else {
            self.profilingGroup = nil
        }
    }
}

/// <p>The structure representing the updateProfilingGroupResponse.</p>
public struct UpdateProfilingGroupOutputResponse: Equatable {
    /// <p>
    ///          A <a href="https://docs.aws.amazon.com/codeguru/latest/profiler-api/API_ProfilingGroupDescription.html">
    ///                <code>ProfilingGroupDescription</code>
    ///             </a>
    ///          that contains information about the returned updated profiling group.
    ///       </p>
    public let profilingGroup: ProfilingGroupDescription?

    public init (
        profilingGroup: ProfilingGroupDescription? = nil
    )
    {
        self.profilingGroup = profilingGroup
    }
}

struct UpdateProfilingGroupOutputResponseBody: Equatable {
    public let profilingGroup: ProfilingGroupDescription?
}

extension UpdateProfilingGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case profilingGroup
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilingGroupDecoded = try containerValues.decodeIfPresent(ProfilingGroupDescription.self, forKey: .profilingGroup)
        profilingGroup = profilingGroupDecoded
    }
}

extension UserFeedback: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FeedbackType.self, forKey: .type)
        type = typeDecoded
    }
}

extension UserFeedback: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UserFeedback(type: \(String(describing: type)))"}
}

/// <p>Feedback that can be submitted for each instance of an anomaly by the user.
///             Feedback is be used for improvements in generating recommendations for the application.</p>
public struct UserFeedback: Equatable {
    /// <p>Optional <code>Positive</code> or <code>Negative</code> feedback submitted by
    ///             the user about whether the recommendation is useful or not.</p>
    public let type: FeedbackType?

    public init (
        type: FeedbackType? = nil
    )
    {
        self.type = type
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
